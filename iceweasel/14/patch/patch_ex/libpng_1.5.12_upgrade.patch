diff -urN a/media/libpng/CHANGES b/media/libpng/CHANGES
--- a/media/libpng/CHANGES	2012-07-11 03:33:19 +0800
+++ b/media/libpng/CHANGES	2012-07-13 12:40:56 +0800
@@ -1,3820 +1,3906 @@
-#if 0
-CHANGES - changes for libpng
-
-Version 0.2
-  added reader into png.h
-  fixed small problems in stub file
-
-Version 0.3
-  added pull reader
-  split up pngwrite.c to several files
-  added pnglib.txt
-  added example.c
-  cleaned up writer, adding a few new transformations
-  fixed some bugs in writer
-  interfaced with zlib 0.5
-  added K&R support
-  added check for 64 KB blocks for 16-bit machines
-
-Version 0.4
-  cleaned up code and commented code
-  simplified time handling into png_time
-  created png_color_16 and png_color_8 to handle color needs
-  cleaned up color type defines
-  fixed various bugs
-  made various names more consistent
-  interfaced with zlib 0.71
-  cleaned up zTXt reader and writer (using zlib's Reset functions)
-  split transformations into pngrtran.c and pngwtran.c
-
-Version 0.5
-  interfaced with zlib 0.8
-  fixed many reading and writing bugs
-  saved using 3 spaces instead of tabs
-
-Version 0.6
-  added png_large_malloc() and png_large_free()
-  added png_size_t
-  cleaned up some compiler warnings
-  added png_start_read_image()
-
-Version 0.7
-  cleaned up lots of bugs
-  finished dithering and other stuff
-  added test program
-  changed name from pnglib to libpng
-
-Version 0.71 [June, 1995]
-  changed pngtest.png for zlib 0.93
-  fixed error in libpng.txt and example.c
-
-Version 0.8
-  cleaned up some bugs
-  added png_set_filler()
-  split up pngstub.c into pngmem.c, pngio.c, and pngerror.c
-  added #define's to remove unwanted code
-  moved png_info_init() to png.c
-  added old_size into png_realloc()
-  added functions to manually set filtering and compression info
-  changed compression parameters based on image type
-  optimized filter selection code
-  added version info
-  changed external functions passing floats to doubles (k&r problems?)
-  put all the configurable stuff in pngconf.h
-  enabled png_set_shift to work with paletted images on read
-  added png_read_update_info() - updates info structure with transformations
-
-Version 0.81 [August, 1995]
-  incorporated Tim Wegner's medium model code (thanks, Tim)
-
-Version 0.82 [September, 1995]
-  [unspecified changes]
-
-Version 0.85 [December, 1995]
-  added more medium model code (almost everything's a far)
-  added i/o, error, and memory callback functions
-  fixed some bugs (16-bit, 4-bit interlaced, etc.)
-  added first run progressive reader (barely tested)
-
-Version 0.86 [January, 1996]
-  fixed bugs
-  improved documentation
-
-Version 0.87 [January, 1996]
-  fixed medium model bugs
-  fixed other bugs introduced in 0.85 and 0.86
-  added some minor documentation
-
-Version 0.88 [January, 1996]
-  fixed progressive bugs
-  replaced tabs with spaces
-  cleaned up documentation
-  added callbacks for read/write and warning/error functions
-
-Version 0.89 [July, 1996]
-  Added new initialization API to make libpng work better with shared libs
-    we now have png_create_read_struct(), png_create_write_struct(),
-    png_create_info_struct(), png_destroy_read_struct(), and
-    png_destroy_write_struct() instead of the separate calls to
-    malloc and png_read_init(), png_info_init(), and png_write_init()
-  Changed warning/error callback functions to fix bug - this means you
-    should use the new initialization API if you were using the old
-    png_set_message_fn() calls, and that the old API no longer exists
-    so that people are aware that they need to change their code
-  Changed filter selection API to allow selection of multiple filters
-    since it didn't work in previous versions of libpng anyways
-  Optimized filter selection code
-  Fixed png_set_background() to allow using an arbitrary RGB color for
-    paletted images
-  Fixed gamma and background correction for paletted images, so
-    png_correct_palette is not needed unless you are correcting an
-    external palette (you will need to #define PNG_CORRECT_PALETTE_SUPPORTED
-    in pngconf.h) - if nobody uses this, it may disappear in the future.
-  Fixed bug with Borland 64K memory allocation (Alexander Lehmann)
-  Fixed bug in interlace handling (Smarasderagd, I think)
-  Added more error checking for writing and image to reduce invalid files
-  Separated read and write functions so that they won't both be linked
-    into a binary when only reading or writing functionality is used
-  New pngtest image also has interlacing and zTXt
-  Updated documentation to reflect new API
-
-Version 0.90 [January, 1997]
-  Made CRC errors/warnings on critical and ancillary chunks configurable
-  libpng will use the zlib CRC routines by (compile-time) default
-  Changed DOS small/medium model memory support - needs zlib 1.04 (Tim Wegner)
-  Added external C++ wrapper statements to png.h (Gilles Dauphin)
-  Allow PNG file to be read when some or all of file signature has already
-    been read from the beginning of the stream.  ****This affects the size
-    of info_struct and invalidates all programs that use a shared libpng****
-  Fixed png_filler() declarations
-  Fixed? background color conversions
-  Fixed order of error function pointers to match documentation
-  Current chunk name is now available in png_struct to reduce the number
-    of nearly identical error messages (will simplify multi-lingual
-    support when available)
-  Try to get ready for unknown-chunk callback functions:
-    - previously read critical chunks are flagged, so the chunk handling
-      routines can determine if the chunk is in the right place
-    - all chunk handling routines have the same prototypes, so we will
-      be able to handle all chunks via a callback mechanism
-  Try to fix Linux "setjmp" buffer size problems
-  Removed png_large_malloc, png_large_free, and png_realloc functions.
-
-Version 0.95 [March, 1997]
-  Fixed bug in pngwutil.c allocating "up_row" twice and "avg_row" never
-  Fixed bug in PNG file signature compares when start != 0
-  Changed parameter type of png_set_filler(...filler...) from png_byte
-    to png_uint_32
-  Added test for MACOS to ensure that both math.h and fp.h are not #included
-  Added macros for libpng to be compiled as a Windows DLL (Andreas Kupries)
-  Added "packswap" transformation, which changes the endianness of
-    packed-pixel bytes (Kevin Bracey)
-  Added "strip_alpha" transformation, which removes the alpha channel of
-    input images without using it (not necessarily a good idea)
-  Added "swap_alpha" transformation, which puts the alpha channel in front
-    of the color bytes instead of after
-  Removed all implicit variable tests which assume NULL == 0 (I think)
-  Changed several variables to "png_size_t" to show 16/32-bit limitations
-  Added new pCAL chunk read/write support
-  Added experimental filter selection weighting (Greg Roelofs)
-  Removed old png_set_rgbx() and png_set_xrgb() functions that have been
-     obsolete for about 2 years now (use png_set_filler() instead)
-  Added macros to read 16- and 32-bit ints directly from buffer, to be
-    used only on those systems that support it (namely PowerPC and 680x0)
-    With some testing, this may become the default for MACOS/PPC systems.
-  Only calculate CRC on data if we are going to use it
-  Added macros for zTXt compression type PNG_zTXt_COMPRESSION_???
-  Added macros for simple libpng debugging output selectable at compile time
-  Removed PNG_READ_END_MODE in progressive reader (Smarasderagd)
-  More description of info_struct in libpng.txt and png.h
-  More instructions in example.c
-  More chunk types tested in pngtest.c
-  Renamed pngrcb.c to pngset.c, and all png_read_<chunk> functions to be
-    png_set_<chunk>.  We now have corresponding png_get_<chunk>
-    functions in pngget.c to get information in info_ptr.  This isolates
-    the application from the internal organization of png_info_struct
-    (good for shared library implementations).
-
-Version 0.96 [May, 1997]
-  Fixed serious bug with < 8bpp images introduced in 0.95
-  Fixed 256-color transparency bug (Greg Roelofs)
-  Fixed up documentation (Greg Roelofs, Laszlo Nyul)
-  Fixed "error" in pngconf.h for Linux setjmp() behavior
-  Fixed DOS medium model support (Tim Wegner)
-  Fixed png_check_keyword() for case with error in static string text
-  Added read of CRC after IEND chunk for embedded PNGs (Laszlo Nyul)
-  Added typecasts to quiet compiler errors
-  Added more debugging info
-
-Version 0.97 [January, 1998]
-  Removed PNG_USE_OWN_CRC capability
-  Relocated png_set_crc_action from pngrutil.c to pngrtran.c
-  Fixed typecasts of "new_key", etc. (Andreas Dilger)
-  Added RFC 1152 [sic] date support
-  Fixed bug in gamma handling of 4-bit grayscale
-  Added 2-bit grayscale gamma handling (Glenn R-P)
-  Added more typecasts. 65536L becomes (png_uint_32)65536L, etc. (Glenn R-P)
-  Minor corrections in libpng.txt
-  Added simple sRGB support (Glenn R-P)
-  Easier conditional compiling, e.g.,
-    define PNG_READ/WRITE_NOT_FULLY_SUPPORTED;
-    all configurable options can be selected from command-line instead
-    of having to edit pngconf.h (Glenn R-P)
-  Fixed memory leak in pngwrite.c (free info_ptr->text) (Glenn R-P)
-  Added more conditions for png_do_background, to avoid changing
-    black pixels to background when a background is supplied and
-    no pixels are transparent
-  Repaired PNG_NO_STDIO behavior
-  Tested NODIV support and made it default behavior (Greg Roelofs)
-  Added "-m" option and PNGTEST_DEBUG_MEMORY to pngtest (John Bowler)
-  Regularized version numbering scheme and bumped shared-library major
-    version number to 2 to avoid problems with libpng 0.89 apps
-    (Greg Roelofs)
-
-Version 0.98 [January, 1998]
-  Cleaned up some typos in libpng.txt and in code documentation
-  Fixed memory leaks in pCAL chunk processing (Glenn R-P and John Bowler)
-  Cosmetic change "display_gamma" to "screen_gamma" in pngrtran.c
-  Changed recommendation about file_gamma for PC images to .51 from .45,
-    in example.c and libpng.txt, added comments to distinguish between
-    screen_gamma, viewing_gamma, and display_gamma.
-  Changed all references to RFC1152 to read RFC1123 and changed the
-    PNG_TIME_RFC1152_SUPPORTED macro to PNG_TIME_RFC1123_SUPPORTED
-  Added png_invert_alpha capability (Glenn R-P -- suggestion by Jon Vincent)
-  Changed srgb_intent from png_byte to int to avoid compiler bugs
-
-Version 0.99 [January 30, 1998]
-  Free info_ptr->text instead of end_info_ptr->text in pngread.c (John Bowler)
-  Fixed a longstanding "packswap" bug in pngtrans.c
-  Fixed some inconsistencies in pngconf.h that prevented compiling with
-    PNG_READ_GAMMA_SUPPORTED and PNG_READ_hIST_SUPPORTED undefined
-  Fixed some typos and made other minor rearrangement of libpng.txt (Andreas)
-  Changed recommendation about file_gamma for PC images to .50 from .51 in
-    example.c and libpng.txt, and changed file_gamma for sRGB images to .45
-  Added a number of functions to access information from the png structure
-    png_get_image_height(), etc. (Glenn R-P, suggestion by Brad Pettit)
-  Added TARGET_MACOS similar to zlib-1.0.8
-  Define PNG_ALWAYS_EXTERN when __MWERKS__ && WIN32 are defined
-  Added type casting to all png_malloc() function calls
-
-Version 0.99a [January 31, 1998]
-  Added type casts and parentheses to all returns that return a value.(Tim W.)
-
-Version 0.99b [February 4, 1998]
-  Added type cast png_uint_32 on malloc function calls where needed.
-  Changed type of num_hist from png_uint_32 to int (same as num_palette).
-  Added checks for rowbytes overflow, in case png_size_t is less than 32 bits.
-  Renamed makefile.elf to makefile.lnx.
-
-Version 0.99c [February 7, 1998]
-  More type casting.  Removed erroneous overflow test in pngmem.c.
-  Added png_buffered_memcpy() and png_buffered_memset(), apply them to rowbytes.
-  Added UNIX manual pages libpng.3 (incorporating libpng.txt) and  png.5.
-
-Version 0.99d [February 11, 1998]
-  Renamed "far_to_near()" "png_far_to_near()"
-  Revised libpng.3
-  Version 99c "buffered" operations didn't work as intended.  Replaced them
-    with png_memcpy_check() and png_memset_check().
-  Added many "if (png_ptr == NULL) return" to quell compiler warnings about
-    unused png_ptr, mostly in pngget.c and pngset.c.
-  Check for overlength tRNS chunk present when indexed-color PLTE is read.
-  Cleaned up spelling errors in libpng.3/libpng.txt
-  Corrected a problem with png_get_tRNS() which returned undefined trans array
-
-Version 0.99e [February 28, 1998]
-  Corrected png_get_tRNS() again.
-  Add parentheses for easier reading of pngget.c, fixed "||" should be "&&".
-  Touched up example.c to make more of it compileable, although the entire
-    file still can't be compiled (Willem van Schaik)
-  Fixed a bug in png_do_shift() (Bryan Tsai)
-  Added a space in png.h prototype for png_write_chunk_start()
-  Replaced pngtest.png with one created with zlib 1.1.1
-  Changed pngtest to report PASS even when file size is different (Jean-loup G.)
-  Corrected some logic errors in png_do_invert_alpha() (Chris Patterson)
-
-Version 0.99f [March 5, 1998]
-  Corrected a bug in pngpread() introduced in version 99c (Kevin Bracey)
-  Moved makefiles into a "scripts" directory, and added INSTALL instruction file
-  Added makefile.os2 and pngos2.def (A. Zabolotny) and makefile.s2x (W. Sebok)
-  Added pointers to "note on libpng versions" in makefile.lnx and README
-  Added row callback feature when reading and writing nonprogressive rows
-    and added a test of this feature in pngtest.c
-  Added user transform callbacks, with test of the feature in pngtest.c
-
-Version 0.99g [March 6, 1998, morning]
-  Minor changes to pngtest.c to suppress compiler warnings.
-  Removed "beta" language from documentation.
-
-Version 0.99h [March 6, 1998, evening]
-  Minor changes to previous minor changes to pngtest.c
-  Changed PNG_READ_NOT_FULLY_SUPPORTED to PNG_READ_TRANSFORMS_NOT_SUPPORTED
-    and added PNG_PROGRESSIVE_READ_NOT_SUPPORTED macro
-  Added user transform capability
-
-Version 1.00 [March 7, 1998]
-  Changed several typedefs in pngrutil.c
-  Added makefile.wat (Pawel Mrochen), updated makefile.tc3 (Willem van Schaik)
-  Replaced "while(1)" with "for(;;)"
-  Added PNGARG() to prototypes in pngtest.c and removed some prototypes
-  Updated some of the makefiles (Tom Lane)
-  Changed some typedefs (s_start, etc.) in pngrutil.c
-  Fixed dimensions of "short_months" array in pngwrite.c
-  Replaced ansi2knr.c with the one from jpeg-v6
-
-Version 1.0.0 [March 8, 1998]
-  Changed name from 1.00 to 1.0.0 (Adam Costello)
-  Added smakefile.ppc (with SCOPTIONS.ppc) for Amiga PPC (Andreas Kleinert)
-
-Version 1.0.0a [March 9, 1998]
-  Fixed three bugs in pngrtran.c to make gamma+background handling consistent
-    (Greg Roelofs)
-  Changed format of the PNG_LIBPNG_VER integer to xyyzz instead of xyz
-    for major, minor, and bugfix releases.  This is 10001. (Adam Costello,
-    Tom Lane)
-  Make months range from 1-12 in png_convert_to_rfc1123
-
-Version 1.0.0b [March 13, 1998]
-  Quieted compiler complaints about two empty "for" loops in pngrutil.c
-  Minor changes to makefile.s2x
-  Removed #ifdef/#endif around a png_free() in pngread.c
-
-Version 1.0.1 [March 14, 1998]
-  Changed makefile.s2x to reduce security risk of using a relative pathname
-  Fixed some typos in the documentation (Greg).
-  Fixed a problem with value of "channels" returned by png_read_update_info()
-
-Version 1.0.1a [April 21, 1998]
-  Optimized Paeth calculations by replacing abs() function calls with intrinsics
-  plus other loop optimizations. Improves avg decoding speed by about 20%.
-  Commented out i386istic "align" compiler flags in makefile.lnx.
-  Reduced the default warning level in some makefiles, to make them consistent.
-  Removed references to IJG and JPEG in the ansi2knr.c copyright statement.
-  Fixed a bug in png_do_strip_filler with XXRRGGBB => RRGGBB transformation.
-  Added grayscale and 16-bit capability to png_do_read_filler().
-  Fixed a bug in pngset.c, introduced in version 0.99c, that sets rowbytes
-    too large when writing an image with bit_depth < 8 (Bob Dellaca).
-  Corrected some bugs in the experimental weighted filtering heuristics.
-  Moved a misplaced pngrutil code block that truncates tRNS if it has more
-    than num_palette entries -- test was done before num_palette was defined.
-  Fixed a png_convert_to_rfc1123() bug that converts day 31 to 0 (Steve Eddins).
-  Changed compiler flags in makefile.wat for better optimization
-    (Pawel Mrochen).
-
-Version 1.0.1b [May 2, 1998]
-  Relocated png_do_gray_to_rgb() within png_do_read_transformations() (Greg).
-  Relocated the png_composite macros from pngrtran.c to png.h (Greg).
-  Added makefile.sco (contributed by Mike Hopkirk).
-  Fixed two bugs (missing definitions of "istop") introduced in libpng-1.0.1a.
-  Fixed a bug in pngrtran.c that would set channels=5 under some circumstances.
-  More work on the Paeth-filtering, achieving imperceptible speedup
-    (A Kleinert).
-  More work on loop optimization which may help when compiled with C++
-    compilers.
-  Added warnings when people try to use transforms they've defined out.
-  Collapsed 4 "i" and "c" loops into single "i" loops in pngrtran and pngwtran.
-  Revised paragraph about png_set_expand() in libpng.txt and libpng.3 (Greg)
-
-Version 1.0.1c [May 11, 1998]
-  Fixed a bug in pngrtran.c (introduced in libpng-1.0.1a) where the masks for
-    filler bytes should have been 0xff instead of 0xf.
-  Added max_pixel_depth=32 in pngrutil.c when using FILLER with palette images.
-  Moved PNG_WRITE_WEIGHTED_FILTER_SUPPORTED and PNG_WRITE_FLUSH_SUPPORTED
-    out of the PNG_WRITE_TRANSFORMS_NOT_SUPPORTED block of pngconf.h
-  Added "PNG_NO_WRITE_TRANSFORMS" etc., as alternatives for *_NOT_SUPPORTED,
-    for consistency, in pngconf.h
-  Added individual "ifndef PNG_NO_[CAPABILITY]" in pngconf.h to make it easier
-    to remove unwanted capabilities via the compile line
-  Made some corrections to grammar (which, it's) in documentation (Greg).
-  Corrected example.c, use of row_pointers in png_write_image().
-
-Version 1.0.1d [May 24, 1998]
-  Corrected several statements that used side effects illegally in pngrutil.c
-    and pngtrans.c, that were introduced in version 1.0.1b
-  Revised png_read_rows() to avoid repeated if-testing for NULL (A Kleinert)
-  More corrections to example.c, use of row_pointers in png_write_image()
-    and png_read_rows().
-  Added pngdll.mak and pngdef.pas to scripts directory, contributed by
-    Bob Dellaca, to make a png32bd.dll with Borland C++ 4.5
-  Fixed error in example.c with png_set_text: num_text is 3, not 2 (Guido V.)
-  Changed several loops from count-down to count-up, for consistency.
-
-Version 1.0.1e [June 6, 1998]
-  Revised libpng.txt and libpng.3 description of png_set_read|write_fn(), and
-    added warnings when people try to set png_read_fn and png_write_fn in
-    the same structure.
-  Added a test such that png_do_gamma will be done when num_trans==0
-    for truecolor images that have defined a background.  This corrects an
-    error that was introduced in libpng-0.90 that can cause gamma processing
-    to be skipped.
-  Added tests in png.h to include "trans" and "trans_values" in structures
-    when PNG_READ_BACKGROUND_SUPPORTED or PNG_READ_EXPAND_SUPPORTED is defined.
-  Add png_free(png_ptr->time_buffer) in png_destroy_read_struct()
-  Moved png_convert_to_rfc_1123() from pngwrite.c to png.c
-  Added capability for user-provided malloc_fn() and free_fn() functions,
-    and revised pngtest.c to demonstrate their use, replacing the
-    PNGTEST_DEBUG_MEM feature.
-  Added makefile.w32, for Microsoft C++ 4.0 and later (Tim Wegner).
-
-Version 1.0.2 [June 14, 1998]
-  Fixed two bugs in makefile.bor .
-
-Version 1.0.2a [December 30, 1998]
-  Replaced and extended code that was removed from png_set_filler() in 1.0.1a.
-  Fixed a bug in png_do_filler() that made it fail to write filler bytes in
-    the left-most pixel of each row (Kevin Bracey).
-  Changed "static pngcharp tIME_string" to "static char tIME_string[30]"
-    in pngtest.c (Duncan Simpson).
-  Fixed a bug in pngtest.c that caused pngtest to try to write a tIME chunk
-    even when no tIME chunk was present in the source file.
-  Fixed a problem in pngrutil.c: gray_to_rgb didn't always work with 16-bit.
-  Fixed a problem in png_read_push_finish_row(), which would not skip some
-    passes that it should skip, for images that are less than 3 pixels high.
-  Interchanged the order of calls to png_do_swap() and png_do_shift()
-    in pngwtran.c (John Cromer).
-  Added #ifdef PNG_DEBUG/#endif surrounding use of PNG_DEBUG in png.h .
-  Changed "bad adaptive filter type" from error to warning in pngrutil.c .
-  Fixed a documentation error about default filtering with 8-bit indexed-color.
-  Separated the PNG_NO_STDIO macro into PNG_NO_STDIO and PNG_NO_CONSOLE_IO
-    (L. Peter Deutsch).
-  Added png_set_rgb_to_gray() and png_get_rgb_to_gray_status() functions.
-  Added png_get_copyright() and png_get_header_version() functions.
-  Revised comments on png_set_progressive_read_fn() in libpng.txt and example.c
-  Added information about debugging in libpng.txt and libpng.3 .
-  Changed "ln -sf" to "ln -s -f" in makefile.s2x, makefile.lnx, and
-    makefile.sco.
-  Removed lines after Dynamic Dependencies" in makefile.aco .
-  Revised makefile.dec to make a shared library (Jeremie Petit).
-  Removed trailing blanks from all files.
-
-Version 1.0.2a [January 6, 1999]
-  Removed misplaced #endif and #ifdef PNG_NO_EXTERN near the end of png.h
-  Added "if" tests to silence complaints about unused png_ptr in png.h and png.c
-  Changed "check_if_png" function in example.c to return true (nonzero) if PNG.
-  Changed libpng.txt to demonstrate png_sig_cmp() instead of png_check_sig()
-    which is obsolete.
-
-Version 1.0.3 [January 14, 1999]
-  Added makefile.hux, for Hewlett Packard HPUX 10.20 and 11.00 (Jim Rice)
-  Added a statement of Y2K compliance in png.h, libpng.3, and Y2KINFO.
-
-Version 1.0.3a [August 12, 1999]
-  Added check for PNG_READ_INTERLACE_SUPPORTED in pngread.c; issue a warning
-     if an attempt is made to read an interlaced image when it's not supported.
-  Added check if png_ptr->trans is defined before freeing it in pngread.c
-  Modified the Y2K statement to include versions back to version 0.71
-  Fixed a bug in the check for valid IHDR bit_depth/color_types in pngrutil.c
-  Modified makefile.wat (added -zp8 flag, ".symbolic", changed some comments)
-  Replaced leading blanks with tab characters in makefile.hux
-  Changed "dworkin.wustl.edu" to "ccrc.wustl.edu" in various documents.
-  Changed (float)red and (float)green to (double)red, (double)green
-     in png_set_rgb_to_gray() to avoid "promotion" problems in AIX.
-  Fixed a bug in pngconf.h that omitted <stdio.h> when PNG_DEBUG==0 (K Bracey).
-  Reformatted libpng.3 and libpngpf.3 with proper fonts (script by J. vanZandt).
-  Updated documentation to refer to the PNG-1.2 specification.
-  Removed ansi2knr.c and left pointers to the latest source for ansi2knr.c
-    in makefile.knr, INSTALL, and README (L. Peter Deutsch)
-  Fixed bugs in calculation of the length of rowbytes when adding alpha
-    channels to 16-bit images, in pngrtran.c (Chris Nokleberg)
-  Added function png_set_user_transform_info() to store user_transform_ptr,
-    user_depth, and user_channels into the png_struct, and a function
-    png_get_user_transform_ptr() to retrieve the pointer (Chris Nokleberg)
-  Added function png_set_empty_plte_permitted() to make libpng useable
-    in MNG applications.
-  Corrected the typedef for png_free_ptr in png.h (Jesse Jones).
-  Correct gamma with srgb is 45455 instead of 45000 in pngrutil.c, to be
-    consistent with PNG-1.2, and allow variance of 500 before complaining.
-  Added assembler code contributed by Intel in file pngvcrd.c and modified
-    makefile.w32 to use it (Nirav Chhatrapati, INTEL Corporation,
-    Gilles Vollant)
-  Changed "ln -s -f" to "ln -f -s" in the makefiles to make Solaris happy.
-  Added some aliases for png_set_expand() in pngrtran.c, namely
-    png_set_expand_PLTE(), png_set_expand_depth(), and png_set_expand_tRNS()
-    (Greg Roelofs, in "PNG: The Definitive Guide").
-  Added makefile.beo for BEOS on X86, contributed by Sander Stok.
-
-Version 1.0.3b [August 26, 1999]
-  Replaced 2147483647L several places with PNG_MAX_UINT macro, defined in png.h
-  Changed leading blanks to tabs in all makefiles.
-  Define PNG_USE_PNGVCRD in makefile.w32, to get MMX assembler code.
-  Made alternate versions of  png_set_expand() in pngrtran.c, namely
-    png_set_gray_1_2_4_to_8, png_set_palette_to_rgb, and png_set_tRNS_to_alpha
-    (Greg Roelofs, in "PNG: The Definitive Guide").  Deleted the 1.0.3a aliases.
-  Relocated start of 'extern "C"' block in png.h so it doesn't include pngconf.h
-  Revised calculation of num_blocks in pngmem.c to avoid a potentially
-    negative shift distance, whose results are undefined in the C language.
-  Added a check in pngset.c to prevent writing multiple tIME chunks.
-  Added a check in pngwrite.c to detect invalid small window_bits sizes.
-
-Version 1.0.3d [September 4, 1999]
-  Fixed type casting of igamma in pngrutil.c
-  Added new png_expand functions to scripts/pngdef.pas and pngos2.def
-  Added a demo read_user_transform_fn that examines the row filters in pngtest.c
-
-Version 1.0.4 [September 24, 1999]
-  Define PNG_ALWAYS_EXTERN in pngconf.h if __STDC__ is defined
-  Delete #define PNG_INTERNAL and include "png.h" from pngasmrd.h
-  Made several minor corrections to pngtest.c
-  Renamed the makefiles with longer but more user friendly extensions.
-  Copied the PNG copyright and license to a separate LICENSE file.
-  Revised documentation, png.h, and example.c to remove reference to
-    "viewing_gamma" which no longer appears in the PNG specification.
-  Revised pngvcrd.c to use MMX code for interlacing only on the final pass.
-  Updated pngvcrd.c to use the faster C filter algorithms from libpng-1.0.1a
-  Split makefile.win32vc into two versions, makefile.vcawin32 (uses MMX
-    assembler code) and makefile.vcwin32 (doesn't).
-  Added a CPU timing report to pngtest.c (enabled by defining PNGTEST_TIMING)
-  Added a copy of pngnow.png to the distribution.
-
-Version 1.0.4a [September 25, 1999]
-  Increase max_pixel_depth in pngrutil.c if a user transform needs it.
-  Changed several division operations to right-shifts in pngvcrd.c
-
-Version 1.0.4b [September 30, 1999]
-  Added parentheses in line 3732 of pngvcrd.c
-  Added a comment in makefile.linux warning about buggy -O3 in pgcc 2.95.1
-
-Version 1.0.4c [October 1, 1999]
-  Added a "png_check_version" function in png.c and pngtest.c that will generate
-    a helpful compiler error if an old png.h is found in the search path.
-  Changed type of png_user_transform_depth|channels from int to png_byte.
-
-Version 1.0.4d [October 6, 1999]
-  Changed 0.45 to 0.45455 in png_set_sRGB()
-  Removed unused PLTE entries from pngnow.png
-  Re-enabled some parts of pngvcrd.c (png_combine_row) that work properly.
-
-Version 1.0.4e [October 10, 1999]
-  Fixed sign error in pngvcrd.c (Greg Roelofs)
-  Replaced some instances of memcpy with simple assignments in pngvcrd (GR-P)
-
-Version 1.0.4f [October 15, 1999]
-  Surrounded example.c code with #if 0 .. #endif to prevent people from
-    inadvertently trying to compile it.
-  Changed png_get_header_version() from a function to a macro in png.h
-  Added type casting mostly in pngrtran.c and pngwtran.c
-  Removed some pointless "ptr = NULL" in pngmem.c
-  Added a "contrib" directory containing the source code from Greg's book.
-
-Version 1.0.5 [October 15, 1999]
-  Minor editing of the INSTALL and README files.
-
-Version 1.0.5a [October 23, 1999]
-  Added contrib/pngsuite and contrib/pngminus (Willem van Schaik)
-  Fixed a typo in the png_set_sRGB() function call in example.c (Jan Nijtmans)
-  Further optimization and bugfix of pngvcrd.c
-  Revised pngset.c so that it does not allocate or free memory in the user's
-    text_ptr structure.  Instead, it makes its own copy.
-  Created separate write_end_info_struct in pngtest.c for a more severe test.
-  Added code in pngwrite.c to free info_ptr->text[i].key to stop a memory leak.
-
-Version 1.0.5b [November 23, 1999]
-  Moved PNG_FLAG_HAVE_CHUNK_HEADER, PNG_FLAG_BACKGROUND_IS_GRAY and
-    PNG_FLAG_WROTE_tIME from flags to mode.
-  Added png_write_info_before_PLTE() function.
-  Fixed some typecasting in contrib/gregbook/*.c
-  Updated scripts/makevms.com and added makevms.com to contrib/gregbook
-    and contrib/pngminus (Martin Zinser)
-
-Version 1.0.5c [November 26, 1999]
-  Moved png_get_header_version from png.h to png.c, to accommodate ansi2knr.
-  Removed all global arrays (according to PNG_NO_GLOBAL_ARRAYS macro), to
-    accommodate making DLL's: Moved usr_png_ver from global variable to function
-    png_get_header_ver() in png.c.  Moved png_sig to png_sig_bytes in png.c and
-    eliminated use of png_sig in pngwutil.c.  Moved the various png_CHNK arrays
-    into pngtypes.h.  Eliminated use of global png_pass arrays.  Declared the
-    png_CHNK and png_pass arrays to be "const".  Made the global arrays
-    available to applications (although none are used in libpng itself) when
-    PNG_NO_GLOBAL_ARRAYS is not defined or when PNG_GLOBAL_ARRAYS is defined.
-  Removed some extraneous "-I" from contrib/pngminus/makefile.std
-  Changed the PNG_sRGB_INTENT macros in png.h to be consistent with PNG-1.2.
-  Change PNG_SRGB_INTENT to PNG_sRGB_INTENT in libpng.txt and libpng.3
-
-Version 1.0.5d [November 29, 1999]
-  Add type cast (png_const_charp) two places in png.c
-  Eliminated pngtypes.h; use macros instead to declare PNG_CHNK arrays.
-  Renamed "PNG_GLOBAL_ARRAYS" to "PNG_USE_GLOBAL_ARRAYS" and made available
-    to applications a macro "PNG_USE_LOCAL_ARRAYS".
-  comment out (with #ifdef) all the new declarations when
-    PNG_USE_GLOBAL_ARRAYS is defined.
-  Added PNG_EXPORT_VAR macro to accommodate making DLL's.
-
-Version 1.0.5e [November 30, 1999]
-  Added iCCP, iTXt, and sPLT support; added "lang" member to the png_text
-    structure; refactored the inflate/deflate support to make adding new chunks
-    with trailing compressed parts easier in the future, and added new functions
-    png_free_iCCP, png_free_pCAL, png_free_sPLT, png_free_text, png_get_iCCP,
-    png_get_spalettes, png_set_iCCP, png_set_spalettes (Eric S. Raymond).
-  NOTE: Applications that write text chunks MUST define png_text->lang
-    before calling png_set_text(). It must be set to NULL if you want to
-    write tEXt or zTXt chunks.  If you want your application to be able to
-    run with older versions of libpng, use
-
-      #ifdef PNG_iTXt_SUPPORTED
-         png_text[i].lang = NULL;
-      #endif
-
-  Changed png_get_oFFs() and png_set_oFFs() to use signed rather than unsigned
-    offsets (Eric S. Raymond).
-  Combined PNG_READ_cHNK_SUPPORTED and PNG_WRITE_cHNK_SUPPORTED macros into
-    PNG_cHNK_SUPPORTED and combined the three types of PNG_text_SUPPORTED
-    macros, leaving the separate macros also available.
-  Removed comments on #endifs at the end of many short, non-nested #if-blocks.
-
-Version 1.0.5f [December 6, 1999]
-  Changed makefile.solaris to issue a warning about potential problems when
-    the ucb "ld" is in the path ahead of the ccs "ld".
-  Removed "- [date]" from the "synopsis" line in libpng.3 and libpngpf.3.
-  Added sCAL chunk support (Eric S. Raymond).
-
-Version 1.0.5g [December 7, 1999]
-  Fixed "png_free_spallettes" typo in png.h
-  Added code to handle new chunks in pngpread.c
-  Moved PNG_CHNK string macro definitions outside of PNG_NO_EXTERN block
-  Added "translated_key" to png_text structure and png_write_iTXt().
-  Added code in pngwrite.c to work around a newly discovered zlib bug.
-
-Version 1.0.5h [December 10, 1999]
-  NOTE: regarding the note for version 1.0.5e, the following must also
-    be included in your code:
-        png_text[i].translated_key = NULL;
-  Unknown chunk handling is now supported.
-  Option to eliminate all floating point support was added.  Some new
-    fixed-point functions such as png_set_gAMA_fixed() were added.
-  Expanded tabs and removed trailing blanks in source files.
-
-Version 1.0.5i [December 13, 1999]
-  Added some type casts to silence compiler warnings.
-  Renamed "png_free_spalette" to "png_free_spalettes" for consistency.
-  Removed leading blanks from a #define in pngvcrd.c
-  Added some parameters to the new png_set_keep_unknown_chunks() function.
-  Added a test for up->location != 0 in the first instance of writing
-    unknown chunks in pngwrite.c
-  Changed "num" to "i" in png_free_spalettes() and png_free_unknowns() to
-    prevent recursion.
-  Added png_free_hIST() function.
-  Various patches to fix bugs in the sCAL and integer cHRM processing,
-    and to add some convenience macros for use with sCAL.
-
-Version 1.0.5j [December 21, 1999]
-  Changed "unit" parameter of png_write_sCAL from png_byte to int, to work
-    around buggy compilers.
-  Added new type "png_fixed_point" for integers that hold float*100000 values
-  Restored backward compatibility of tEXt/zTXt chunk processing:
-    Restored the first four members of png_text to the same order as v.1.0.5d.
-    Added members "lang_key" and "itxt_length" to png_text struct.  Set
-    text_length=0 when "text" contains iTXt data.  Use the "compression"
-    member to distinguish among tEXt/zTXt/iTXt types.  Added
-    PNG_ITXT_COMPRESSION_NONE (1) and PNG_ITXT_COMPRESSION_zTXt(2) macros.
-    The "Note" above, about backward incompatibility of libpng-1.0.5e, no
-    longer applies.
-  Fixed png_read|write_iTXt() to read|write parameters in the right order,
-    and to write the iTXt chunk after IDAT if it appears in the end_ptr.
-  Added pnggccrd.c, version of pngvcrd.c Intel assembler for gcc (Greg Roelofs)
-  Reversed the order of trying to write floating-point and fixed-point gAMA.
-
-Version 1.0.5k [December 27, 1999]
-  Added many parentheses, e.g., "if (a && b & c)" becomes "if (a && (b & c))"
-  Added png_handle_as_unknown() function (Glenn)
-  Added png_free_chunk_list() function and chunk_list and num_chunk_list members
-    of png_ptr.
-  Eliminated erroneous warnings about multiple sPLT chunks and sPLT-after-PLTE.
-  Fixed a libpng-1.0.5h bug in pngrutil.c that was issuing erroneous warnings
-    about ignoring incorrect gAMA with sRGB (gAMA was in fact not ignored)
-  Added png_free_tRNS(); png_set_tRNS() now malloc's its own trans array (ESR).
-  Define png_get_int_32 when oFFs chunk is supported as well as when pCAL is.
-  Changed type of proflen from png_int_32 to png_uint_32 in png_get_iCCP().
-
-Version 1.0.5l [January 1, 2000]
-  Added functions png_set_read_user_chunk_fn() and png_get_user_chunk_ptr()
-    for setting a callback function to handle unknown chunks and for
-    retrieving the associated user pointer (Glenn).
-
-Version 1.0.5m [January 7, 2000]
-  Added high-level functions png_read_png(), png_write_png(), png_free_pixels().
-
-Version 1.0.5n [January 9, 2000]
-  Added png_free_PLTE() function, and modified png_set_PLTE() to malloc its
-    own memory for info_ptr->palette.  This makes it safe for the calling
-    application to free its copy of the palette any time after it calls
-    png_set_PLTE().
-
-Version 1.0.5o [January 20, 2000]
-  Cosmetic changes only (removed some trailing blanks and TABs)
-
-Version 1.0.5p [January 31, 2000]
-  Renamed pngdll.mak to makefile.bd32
-  Cosmetic changes in pngtest.c
-
-Version 1.0.5q [February 5, 2000]
-  Relocated the makefile.solaris warning about PATH problems.
-  Fixed pngvcrd.c bug by pushing/popping registers in mmxsupport (Bruce Oberg)
-  Revised makefile.gcmmx
-  Added PNG_SETJMP_SUPPORTED, PNG_SETJMP_NOT_SUPPORTED, and PNG_ABORT() macros
-
-Version 1.0.5r [February 7, 2000]
-  Removed superfluous prototype for png_get_itxt from png.h
-  Fixed a bug in pngrtran.c that improperly expanded the background color.
-  Return *num_text=0 from png_get_text() when appropriate, and fix documentation
-    of png_get_text() in libpng.txt/libpng.3.
-
-Version 1.0.5s [February 18, 2000]
-  Added "png_jmp_env()" macro to pngconf.h, to help people migrate to the
-    new error handler that's planned for the next libpng release, and changed
-    example.c, pngtest.c, and contrib programs to use this macro.
-  Revised some of the DLL-export macros in pngconf.h (Greg Roelofs)
-  Fixed a bug in png_read_png() that caused it to fail to expand some images
-    that it should have expanded.
-  Fixed some mistakes in the unused and undocumented INCH_CONVERSIONS functions
-    in pngget.c
-  Changed the allocation of palette, history, and trans arrays back to
-    the version 1.0.5 method (linking instead of copying) which restores
-    backward compatibility with version 1.0.5.  Added some remarks about
-    that in example.c.  Added "free_me" member to info_ptr and png_ptr
-    and added png_free_data() function.
-  Updated makefile.linux and makefile.gccmmx to make directories conditionally.
-  Made cosmetic changes to pngasmrd.h
-  Added png_set_rows() and png_get_rows(), for use with png_read|write_png().
-  Modified png_read_png() to allocate info_ptr->row_pointers only if it
-    hasn't already been allocated.
-
-Version 1.0.5t [March 4, 2000]
-  Changed png_jmp_env() migration aiding macro to png_jmpbuf().
-  Fixed "interlace" typo (should be "interlaced") in contrib/gregbook/read2-x.c
-  Fixed bug with use of PNG_BEFORE_IHDR bit in png_ptr->mode, introduced when
-    PNG_FLAG_HAVE_CHUNK_HEADER was moved into png_ptr->mode in version 1.0.5b
-  Files in contrib/gregbook were revised to use png_jmpbuf() and to select
-    a 24-bit visual if one is available, and to allow abbreviated options.
-  Files in contrib/pngminus were revised to use the png_jmpbuf() macro.
-  Removed spaces in makefile.linux and makefile.gcmmx, introduced in 1.0.5s
-
-Version 1.0.5u [March 5, 2000]
-  Simplified the code that detects old png.h in png.c and pngtest.c
-  Renamed png_spalette (_p, _pp) to png_sPLT_t (_tp, _tpp)
-  Increased precision of rgb_to_gray calculations from 8 to 15 bits and
-    added png_set_rgb_to_gray_fixed() function.
-  Added makefile.bc32 (32-bit Borland C++, C mode)
-
-Version 1.0.5v [March 11, 2000]
-  Added some parentheses to the png_jmpbuf macro definition.
-  Updated references to the zlib home page, which has moved to freesoftware.com.
-  Corrected bugs in documentation regarding png_read_row() and png_write_row().
-  Updated documentation of png_rgb_to_gray calculations in libpng.3/libpng.txt.
-  Renamed makefile.borland,turboc3 back to makefile.bor,tc3 as in version 1.0.3,
-    revised borland makefiles; added makefile.ibmvac3 and makefile.gcc (Cosmin)
-
-Version 1.0.6 [March 20, 2000]
-  Minor revisions of makefile.bor, libpng.txt, and gregbook/rpng2-win.c
-  Added makefile.sggcc (SGI IRIX with gcc)
-
-Version 1.0.6d [April 7, 2000]
-  Changed sprintf() to strcpy() in png_write_sCAL_s() to work without STDIO
-  Added data_length parameter to png_decompress_chunk() function
-  Revised documentation to remove reference to abandoned png_free_chnk functions
-  Fixed an error in png_rgb_to_gray_fixed()
-  Revised example.c, usage of png_destroy_write_struct().
-  Renamed makefile.ibmvac3 to makefile.ibmc, added libpng.icc IBM project file
-  Added a check for info_ptr->free_me&PNG_FREE_TEXT when freeing text in png.c
-  Simplify png_sig_bytes() function to remove use of non-ISO-C strdup().
-
-Version 1.0.6e [April 9, 2000]
-  Added png_data_freer() function.
-  In the code that checks for over-length tRNS chunks, added check of
-    info_ptr->num_trans as well as png_ptr->num_trans (Matthias Benckmann)
-  Minor revisions of libpng.txt/libpng.3.
-  Check for existing data and free it if the free_me flag is set, in png_set_*()
-    and png_handle_*().
-  Only define PNG_WEIGHTED_FILTERS_SUPPORTED when PNG_FLOATING_POINT_SUPPORTED
-    is defined.
-  Changed several instances of PNG_NO_CONSOLE_ID to PNG_NO_STDIO in pngrutil.c
-    and mentioned the purposes of the two macros in libpng.txt/libpng.3.
-
-Version 1.0.6f [April 14, 2000]
-  Revised png_set_iCCP() and png_set_rows() to avoid prematurely freeing data.
-  Add checks in png_set_text() for NULL members of the input text structure.
-  Revised libpng.txt/libpng.3.
-  Removed superfluous prototype for png_set_iTXt from png.h
-  Removed "else" from pngread.c, after png_error(), and changed "0" to "length".
-  Changed several png_errors about malformed ancillary chunks to png_warnings.
-
-Version 1.0.6g [April 24, 2000]
-  Added png_pass-* arrays to pnggccrd.c when PNG_USE_LOCAL_ARRAYS is defined.
-  Relocated paragraph about png_set_background() in libpng.3/libpng.txt
-    and other revisions (Matthias Benckmann)
-  Relocated info_ptr->free_me, png_ptr->free_me, and other info_ptr and
-    png_ptr members to restore binary compatibility with libpng-1.0.5
-    (breaks compatibility with libpng-1.0.6).
-
-Version 1.0.6h [April 24, 2000]
-  Changed shared library so-number pattern from 2.x.y.z to xy.z (this builds
-    libpng.so.10 & libpng.so.10.6h instead of libpng.so.2 & libpng.so.2.1.0.6h)
-    This is a temporary change for test purposes.
-
-Version 1.0.6i [May 2, 2000]
-  Rearranged some members at the end of png_info and png_struct, to put
-    unknown_chunks_num and free_me within the original size of the png_structs
-    and free_me, png_read_user_fn, and png_free_fn within the original png_info,
-    because some old applications allocate the structs directly instead of
-    using png_create_*().
-  Added documentation of user memory functions in libpng.txt/libpng.3
-  Modified png_read_png so that it will use user_allocated row_pointers
-    if present, unless free_me directs that it be freed, and added description
-    of the use of png_set_rows() and png_get_rows() in libpng.txt/libpng.3.
-  Added PNG_LEGACY_SUPPORTED macro, and #ifdef out all new (since version
-    1.00) members of png_struct and png_info, to regain binary compatibility
-    when you define this macro.  Capabilities lost in this event
-    are user transforms (new in version 1.0.0),the user transform pointer
-    (new in version 1.0.2), rgb_to_gray (new in 1.0.5), iCCP, sCAL, sPLT,
-    the high-level interface, and unknown chunks support (all new in 1.0.6).
-    This was necessary because of old applications that allocate the structs
-    directly as authors were instructed to do in libpng-0.88 and earlier,
-    instead of using png_create_*().
-  Added modes PNG_CREATED_READ_STRUCT and PNG_CREATED_WRITE_STRUCT which
-    can be used to detect codes that directly allocate the structs, and
-    code to check these modes in png_read_init() and png_write_init() and
-    generate a libpng error if the modes aren't set and PNG_LEGACY_SUPPORTED
-    was not defined.
-  Added makefile.intel and updated makefile.watcom (Pawel Mrochen)
-
-Version 1.0.6j [May 3, 2000]
-  Overloaded png_read_init() and png_write_init() with macros that convert
-    calls to png_read_init_2() or png_write_init_2() that check the version
-    and structure sizes.
-
-Version 1.0.7beta11 [May 7, 2000]
-  Removed the new PNG_CREATED_READ_STRUCT and PNG_CREATED_WRITE_STRUCT modes
-    which are no longer used.
-  Eliminated the three new members of png_text when PNG_LEGACY_SUPPORTED is
-    defined or when neither PNG_READ_iTXt_SUPPORTED nor PNG_WRITE_iTXT_SUPPORTED
-    is defined.
-  Made PNG_NO_READ|WRITE_iTXt the default setting, to avoid memory
-    overrun when old applications fill the info_ptr->text structure directly.
-  Added PNGAPI macro, and added it to the definitions of all exported functions.
-  Relocated version macro definitions ahead of the includes of zlib.h and
-    pngconf.h in png.h.
-
-Version 1.0.7beta12 [May 12, 2000]
-  Revised pngset.c to avoid a problem with expanding the png_debug macro.
-  Deleted some extraneous defines from pngconf.h
-  Made PNG_NO_CONSOLE_IO the default condition when PNG_BUILD_DLL is defined.
-  Use MSC _RPTn debugging instead of fprintf if _MSC_VER is defined.
-  Added png_access_version_number() function.
-  Check for mask&PNG_FREE_CHNK (for TEXT, SCAL, PCAL) in png_free_data().
-  Expanded libpng.3/libpng.txt information about png_data_freer().
-
-Version 1.0.7beta14 [May 17, 2000] (beta13 was not published)
-  Changed pnggccrd.c and pngvcrd.c to handle bad adaptive filter types as
-    warnings instead of errors, as pngrutil.c does.
-  Set the PNG_INFO_IDAT valid flag in png_set_rows() so png_write_png()
-    will actually write IDATs.
-  Made the default PNG_USE_LOCAL_ARRAYS depend on PNG_DLL instead of WIN32.
-  Make png_free_data() ignore its final parameter except when freeing data
-    that can have multiple instances (text, sPLT, unknowns).
-  Fixed a new bug in png_set_rows().
-  Removed info_ptr->valid tests from png_free_data(), as in version 1.0.5.
-  Added png_set_invalid() function.
-  Fixed incorrect illustrations of png_destroy_write_struct() in example.c.
-
-Version 1.0.7beta15 [May 30, 2000]
-  Revised the deliberately erroneous Linux setjmp code in pngconf.h to produce
-    fewer error messages.
-  Rearranged checks for Z_OK to check the most likely path first in pngpread.c
-    and pngwutil.c.
-  Added checks in pngtest.c for png_create_*() returning NULL, and mentioned
-    in libpng.txt/libpng.3 the need for applications to check this.
-  Changed names of png_default_*() functions in pngtest to pngtest_*().
-  Changed return type of png_get_x|y_offset_*() from png_uint_32 to png_int_32.
-  Fixed some bugs in the unused PNG_INCH_CONVERSIONS functions in pngget.c
-  Set each pointer to NULL after freeing it in png_free_data().
-  Worked around a problem in pngconf.h; AIX's strings.h defines an "index"
-    macro that conflicts with libpng's png_color_16.index. (Dimitri
-    Papadapoulos)
-  Added "msvc" directory with MSVC++ project files (Simon-Pierre Cadieux).
-
-Version 1.0.7beta16 [June 4, 2000]
-  Revised the workaround of AIX string.h "index" bug.
-  Added a check for overlength PLTE chunk in pngrutil.c.
-  Added PNG_NO_POINTER_INDEXING macro to use array-indexing instead of pointer
-    indexing in pngrutil.c and pngwutil.c to accommodate a buggy compiler.
-  Added a warning in png_decompress_chunk() when it runs out of data, e.g.
-    when it tries to read an erroneous PhotoShop iCCP chunk.
-  Added PNG_USE_DLL macro.
-  Revised the copyright/disclaimer/license notice.
-  Added contrib/msvctest directory
-
-Version 1.0.7rc1 [June 9, 2000]
-  Corrected the definition of PNG_TRANSFORM_INVERT_ALPHA  (0x0400 not 0x0200)
-  Added contrib/visupng directory (Willem van Schaik)
-
-Version 1.0.7beta18 [June 23, 2000]
-  Revised PNGAPI definition, and pngvcrd.c to work with __GCC__
-    and do not redefine PNGAPI if it is passed in via a compiler directive.
-  Revised visupng/PngFile.c to remove returns from within the Try block.
-  Removed leading underscores from "_PNG_H" and "_PNG_SAVE_BSD_SOURCE" macros.
-  Updated contrib/visupng/cexcept.h to version 1.0.0.
-  Fixed bugs in pngwrite.c and pngwutil.c that prevented writing iCCP chunks.
-
-Version 1.0.7rc2 [June 28, 2000]
-  Updated license to include disclaimers required by UCITA.
-  Fixed "DJBPP" typo in pnggccrd.c introduced in beta18.
-
-Version 1.0.7 [July 1, 2000]
-  Revised the definition of "trans_values" in libpng.3/libpng.txt
-
-Version 1.0.8beta1 [July 8, 2000]
-  Added png_free(png_ptr, key) two places in pngpread.c to stop memory leaks.
-  Changed PNG_NO_STDIO to PNG_NO_CONSOLE_IO, several places in pngrutil.c and
-     pngwutil.c.
-  Changed PNG_EXPORT_VAR to use PNG_IMPEXP, in pngconf.h.
-  Removed unused "#include <assert.h>" from png.c
-  Added WindowsCE support.
-  Revised pnggccrd.c to work with gcc-2.95.2 and in the Cygwin environment.
-
-Version 1.0.8beta2 [July 10, 2000]
-  Added project files to the wince directory and made further revisions
-     of pngtest.c, pngrio.c, and pngwio.c in support of WindowsCE.
-
-Version 1.0.8beta3 [July 11, 2000]
-  Only set the PNG_FLAG_FREE_TRNS or PNG_FREE_TRNS flag in png_handle_tRNS()
-     for indexed-color input files to avoid potential double-freeing trans array
-     under some unusual conditions; problem was introduced in version 1.0.6f.
-  Further revisions to pngtest.c and files in the wince subdirectory.
-
-Version 1.0.8beta4 [July 14, 2000]
-  Added the files pngbar.png and pngbar.jpg to the distribution.
-  Added makefile.cygwin, and cygwin support in pngconf.h
-  Added PNG_NO_ZALLOC_ZERO macro (makes png_zalloc skip zeroing memory)
-
-Version 1.0.8rc1 [July 16, 2000]
-  Revised png_debug() macros and statements to eliminate compiler warnings.
-
-Version 1.0.8 [July 24, 2000]
-  Added png_flush() in pngwrite.c, after png_write_IEND().
-  Updated makefile.hpux to build a shared library.
-
-Version 1.0.9beta1 [November 10, 2000]
-  Fixed typo in scripts/makefile.hpux
-  Updated makevms.com in scripts and contrib/* and contrib/* (Martin Zinser)
-  Fixed seqence-point bug in contrib/pngminus/png2pnm (Martin Zinser)
-  Changed "cdrom.com" in documentation to "libpng.org"
-  Revised pnggccrd.c to get it all working, and updated makefile.gcmmx (Greg).
-  Changed type of "params" from voidp to png_voidp in png_read|write_png().
-  Make sure PNGAPI and PNG_IMPEXP are defined in pngconf.h.
-  Revised the 3 instances of WRITEFILE in pngtest.c.
-  Relocated "msvc" and "wince" project subdirectories into "dll" subdirectory.
-  Updated png.rc in dll/msvc project
-  Revised makefile.dec to define and use LIBPATH and INCPATH
-  Increased size of global png_libpng_ver[] array from 12 to 18 chars.
-  Made global png_libpng_ver[], png_sig[] and png_pass_*[] arrays const.
-  Removed duplicate png_crc_finish() from png_handle_bKGD() function.
-  Added a warning when application calls png_read_update_info() multiple times.
-  Revised makefile.cygwin
-  Fixed bugs in iCCP support in pngrutil.c and pngwutil.c.
-  Replaced png_set_empty_plte_permitted() with png_permit_mng_features().
-
-Version 1.0.9beta2 [November 19, 2000]
-  Renamed the "dll" subdirectory "projects".
-  Added borland project files to "projects" subdirectory.
-  Set VS_FF_PRERELEASE and VS_FF_PATCHED flags in msvc/png.rc when appropriate.
-  Add error message in png_set_compression_buffer_size() when malloc fails.
-
-Version 1.0.9beta3 [November 23, 2000]
-  Revised PNG_LIBPNG_BUILD_TYPE macro in png.h, used in the msvc project.
-  Removed the png_flush() in pngwrite.c that crashes some applications
-    that don't set png_output_flush_fn.
-  Added makefile.macosx and makefile.aix to scripts directory.
-
-Version 1.0.9beta4 [December 1, 2000]
-  Change png_chunk_warning to png_warning in png_check_keyword().
-  Increased the first part of msg buffer from 16 to 18 in png_chunk_error().
-
-Version 1.0.9beta5 [December 15, 2000]
-  Added support for filter method 64 (for PNG datastreams embedded in MNG).
-
-Version 1.0.9beta6 [December 18, 2000]
-  Revised png_set_filter() to accept filter method 64 when appropriate.
-  Added new PNG_HAVE_PNG_SIGNATURE bit to png_ptr->mode and use it to
-    help prevent applications from using MNG features in PNG datastreams.
-  Added png_permit_mng_features() function.
-  Revised libpng.3/libpng.txt.  Changed "filter type" to "filter method".
-
-Version 1.0.9rc1 [December 23, 2000]
-  Revised test for PNG_HAVE_PNG_SIGNATURE in pngrutil.c
-  Fixed error handling of unknown compression type in png_decompress_chunk().
-  In pngconf.h, define __cdecl when _MSC_VER is defined.
-
-Version 1.0.9beta7 [December 28, 2000]
-  Changed PNG_TEXT_COMPRESSION_zTXt to PNG_COMPRESSION_TYPE_BASE several places.
-  Revised memory management in png_set_hIST and png_handle_hIST in a backward
-    compatible manner.  PLTE and tRNS were revised similarly.
-  Revised the iCCP chunk reader to ignore trailing garbage.
-
-Version 1.0.9beta8 [January 12, 2001]
-  Moved pngasmrd.h into pngconf.h.
-  Improved handling of out-of-spec garbage iCCP chunks generated by PhotoShop.
-
-Version 1.0.9beta9 [January 15, 2001]
-  Added png_set_invalid, png_permit_mng_features, and png_mmx_supported to
-    wince and msvc project module definition files.
-  Minor revision of makefile.cygwin.
-  Fixed bug with progressive reading of narrow interlaced images in pngpread.c
-
-Version 1.0.9beta10 [January 16, 2001]
-  Do not typedef png_FILE_p in pngconf.h when PNG_NO_STDIO is defined.
-  Fixed "png_mmx_supported" typo in project definition files.
-
-Version 1.0.9beta11 [January 19, 2001]
-  Updated makefile.sgi to make shared library.
-  Removed png_mmx_support() function and disabled PNG_MNG_FEATURES_SUPPORTED
-    by default, for the benefit of DLL forward compatibility.  These will
-    be re-enabled in version 1.2.0.
-
-Version 1.0.9rc2 [January 22, 2001]
-  Revised cygwin support.
-
-Version 1.0.9 [January 31, 2001]
-  Added check of cygwin's ALL_STATIC in pngconf.h
-  Added "-nommx" parameter to contrib/gregbook/rpng2-win and rpng2-x demos.
-
-Version 1.0.10beta1 [March 14, 2001]
-  Revised makefile.dec, makefile.sgi, and makefile.sggcc; added makefile.hpgcc.
-  Reformatted libpng.3 to eliminate bad line breaks.
-  Added checks for _mmx_supported in the read_filter_row function of pnggccrd.c
-  Added prototype for png_mmx_support() near the top of pnggccrd.c
-  Moved some error checking from png_handle_IHDR to png_set_IHDR.
-  Added PNG_NO_READ_SUPPORTED and PNG_NO_WRITE_SUPPORTED macros.
-  Revised png_mmx_support() function in pnggccrd.c
-  Restored version 1.0.8 PNG_WRITE_EMPTY_PLTE_SUPPORTED behavior in pngwutil.c
-  Fixed memory leak in contrib/visupng/PngFile.c
-  Fixed bugs in png_combine_row() in pnggccrd.c and pngvcrd.c (C version)
-  Added warnings when retrieving or setting gamma=0.
-  Increased the first part of msg buffer from 16 to 18 in png_chunk_warning().
-
-Version 1.0.10rc1 [March 23, 2001]
-  Changed all instances of memcpy, strcpy, and strlen to png_memcpy, png_strcpy,
-    and png_strlen.
-  Revised png_mmx_supported() function in pnggccrd.c to return proper value.
-  Fixed bug in progressive reading (pngpread.c) with small images (height < 8).
-
-Version 1.0.10 [March 30, 2001]
-  Deleted extraneous space (introduced in 1.0.9) from line 42 of makefile.cygwin
-  Added beos project files (Chris Herborth)
-
-Version 1.0.11beta1 [April 3, 2001]
-  Added type casts on several png_malloc() calls (Dimitri Papadapoulos).
-  Removed a no-longer needed AIX work-around from pngconf.h
-  Changed several "//" single-line comments to C-style in pnggccrd.c
-
-Version 1.0.11beta2 [April 11, 2001]
-  Removed PNGAPI from several functions whose prototypes did not have PNGAPI.
-  Updated scripts/pngos2.def
-
-Version 1.0.11beta3 [April 14, 2001]
-  Added checking the results of many instances of png_malloc() for NULL
-
-Version 1.0.11beta4 [April 20, 2001]
-  Undid the changes from version 1.0.11beta3.  Added a check for NULL return
-    from user's malloc_fn().
-  Removed some useless type casts of the NULL pointer.
-  Added makefile.netbsd
-
-Version 1.0.11 [April 27, 2001]
-  Revised makefile.netbsd
-
-Version 1.0.12beta1 [May 14, 2001]
-  Test for Windows platform in pngconf.h when including malloc.h (Emmanuel Blot)
-  Updated makefile.cygwin and handling of Cygwin's ALL_STATIC in pngconf.h
-  Added some never-to-be-executed code in pnggccrd.c to quiet compiler warnings.
-  Eliminated the png_error about apps using png_read|write_init().  Instead,
-    libpng will reallocate the png_struct and info_struct if they are too small.
-    This retains future binary compatibility for old applications written for
-    libpng-0.88 and earlier.
-
-Version 1.2.0beta1 [May 6, 2001]
-  Bumped DLLNUM to 2.
-  Re-enabled PNG_MNG_FEATURES_SUPPORTED and enabled PNG_ASSEMBLER_CODE_SUPPORTED
-    by default.
-  Added runtime selection of MMX features.
-  Added png_set_strip_error_numbers function and related macros.
-
-Version 1.2.0beta2 [May 7, 2001]
-  Finished merging 1.2.0beta1 with version 1.0.11
-  Added a check for attempts to read or write PLTE in grayscale PNG datastreams.
-
-Version 1.2.0beta3 [May 17, 2001]
-  Enabled user memory function by default.
-  Modified png_create_struct so it passes user mem_ptr to user memory allocator.
-  Increased png_mng_features flag from png_byte to png_uint_32.
-  Bumped shared-library (so-number) and dll-number to 3.
-
-Version 1.2.0beta4 [June 23, 2001]
-  Check for missing profile length field in iCCP chunk and free chunk_data
-     in case of truncated iCCP chunk.
-  Bumped shared-library number to 3 in makefile.sgi and makefile.sggcc
-  Bumped dll-number from 2 to 3 in makefile.cygwin
-  Revised contrib/gregbook/rpng*-x.c to avoid a memory leak and to exit cleanly
-     if user attempts to run it on an 8-bit display.
-  Updated contrib/gregbook
-  Use png_malloc instead of png_zalloc to allocate palette in pngset.c
-  Updated makefile.ibmc
-  Added some typecasts to eliminate gcc 3.0 warnings.  Changed prototypes
-     of png_write_oFFS width and height from png_uint_32 to png_int_32.
-  Updated example.c
-  Revised prototypes for png_debug_malloc and png_debug_free in pngtest.c
-
-Version 1.2.0beta5 [August 8, 2001]
-  Revised contrib/gregbook
-  Revised makefile.gcmmx
-  Revised pnggccrd.c to conditionally compile some thread-unsafe code only
-     when PNG_THREAD_UNSAFE_OK is defined.
-  Added tests to prevent pngwutil.c from writing a bKGD or tRNS chunk with
-     value exceeding 2^bit_depth-1
-  Revised makefile.sgi and makefile.sggcc
-  Replaced calls to fprintf(stderr,...) with png_warning() in pnggccrd.c
-  Removed restriction that do_invert_mono only operate on 1-bit opaque files
-
-Version 1.2.0 [September 1, 2001]
-  Changed a png_warning() to png_debug() in pnggccrd.c
-  Fixed contrib/gregbook/rpng-x.c, rpng2-x.c to avoid crash with XFreeGC().
-
-Version 1.2.1beta1 [October 19, 2001]
-  Revised makefile.std in contrib/pngminus
-  Include background_1 in png_struct regardless of gamma support.
-  Revised makefile.netbsd and makefile.macosx, added makefile.darwin.
-  Revised example.c to provide more details about using row_callback().
-
-Version 1.2.1beta2 [October 25, 2001]
-  Added type cast to each NULL appearing in a function call, except for
-    WINCE functions.
-  Added makefile.so9.
-
-Version 1.2.1beta3 [October 27, 2001]
-  Removed type casts from all NULLs.
-  Simplified png_create_struct_2().
-
-Version 1.2.1beta4 [November 7, 2001]
-  Revised png_create_info_struct() and png_creat_struct_2().
-  Added error message if png_write_info() was omitted.
-  Type cast NULLs appearing in function calls when _NO_PROTO or
-    PNG_TYPECAST_NULL is defined.
-
-Version 1.2.1rc1 [November 24, 2001]
-  Type cast NULLs appearing in function calls except when PNG_NO_TYPECAST_NULL
-    is defined.
-  Changed typecast of "size" argument to png_size_t in pngmem.c calls to
-    the user malloc_fn, to agree with the prototype in png.h
-  Added a pop/push operation to pnggccrd.c, to preserve Eflag (Maxim Sobolev)
-  Updated makefile.sgi to recognize LIBPATH and INCPATH.
-  Updated various makefiles so "make clean" does not remove previous major
-    version of the shared library.
-
-Version 1.2.1rc2 [December 4, 2001]
-  Always allocate 256-entry internal palette, hist, and trans arrays, to
-    avoid out-of-bounds memory reference caused by invalid PNG datastreams.
-  Added a check for prefix_length > data_length in iCCP chunk handler.
-
-Version 1.2.1 [December 7, 2001]
-  None.
-
-Version 1.2.2beta1 [February 22, 2002]
-  Fixed a bug with reading the length of iCCP profiles (Larry Reeves).
-  Revised makefile.linux, makefile.gcmmx, and makefile.sgi to generate
-    libpng.a, libpng12.so (not libpng.so.3), and libpng12/png.h
-  Revised makefile.darwin to remove "-undefined suppress" option.
-  Added checks for gamma and chromaticity values over 21474.83, which exceed
-    the limit for PNG unsigned 32-bit integers when encoded.
-  Revised calls to png_create_read_struct() and png_create_write_struct()
-    for simpler debugging.
-  Revised png_zalloc() so zlib handles errors (uses PNG_FLAG_MALLOC_NULL_MEM_OK)
-
-Version 1.2.2beta2 [February 23, 2002]
-  Check chunk_length and idat_size for invalid (over PNG_MAX_UINT) lengths.
-  Check for invalid image dimensions in png_get_IHDR.
-  Added missing "fi;" in the install target of the SGI makefiles.
-  Added install-static to all makefiles that make shared libraries.
-  Always do gamma compensation when image is partially transparent.
-
-Version 1.2.2beta3 [March 7, 2002]
-  Compute background.gray and background_1.gray even when color_type is RGB
-    in case image gets reduced to gray later.
-  Modified shared-library makefiles to install pkgconfig/libpngNN.pc.
-  Export (with PNGAPI) png_zalloc, png_zfree, and png_handle_as_unknown
-  Removed unused png_write_destroy_info prototype from png.h
-  Eliminated incorrect use of width_mmx from pnggccrd.c in pixel_bytes == 8 case
-  Added install-shared target to all makefiles that make shared libraries.
-  Stopped a double free of palette, hist, and trans when not using free_me.
-  Added makefile.32sunu for Sun Ultra 32 and makefile.64sunu for Sun Ultra 64.
-
-Version 1.2.2beta4 [March 8, 2002]
-  Compute background.gray and background_1.gray even when color_type is RGB
-    in case image gets reduced to gray later (Jason Summers).
-  Relocated a misplaced /bin/rm in the "install-shared" makefile targets
-  Added PNG_1_0_X macro which can be used to build a 1.0.x-compatible library.
-
-Version 1.2.2beta5 [March 26, 2002]
-  Added missing PNGAPI to several function definitions.
-  Check for invalid bit_depth or color_type in png_get_IHDR(), and
-    check for missing PLTE or IHDR in png_push_read_chunk() (Matthias Clasen).
-  Revised iTXt support to accept NULL for lang and lang_key.
-  Compute gamma for color components of background even when color_type is gray.
-  Changed "()" to "{}" in scripts/libpng.pc.in.
-  Revised makefiles to put png.h and pngconf.h only in $prefix/include/libpngNN
-  Revised makefiles to make symlink to libpng.so.NN in addition to libpngNN.so
-
-Version 1.2.2beta6 [March 31, 2002]
-
-Version 1.0.13beta1 [March 31, 2002]
-  Prevent png_zalloc() from trying to memset memory that it failed to acquire.
-  Add typecasts of PNG_MAX_UINT in pngset_cHRM_fixed() (Matt Holgate).
-  Ensure that the right function (user or default) is used to free the
-    png_struct after an error in png_create_read_struct_2().
-
-Version 1.2.2rc1 [April 7, 2002]
-
-Version 1.0.13rc1 [April 7, 2002]
-  Save the ebx register in pnggccrd.c (Sami Farin)
-  Add "mem_ptr = png_ptr->mem_ptr" in png_destroy_write_struct() (Paul Gardner).
-  Updated makefiles to put headers in include/libpng and remove old include/*.h.
-
-Version 1.2.2 [April 15, 2002]
-
-Version 1.0.13 [April 15, 2002]
-  Revised description of png_set_filter() in libpng.3/libpng.txt.
-  Revised makefile.netbsd and added makefile.neNNbsd and makefile.freebsd
-
-Version 1.0.13patch01 [April 17, 2002]
-
-Version 1.2.2patch01 [April 17, 2002]
-  Changed ${PNGMAJ}.${PNGVER} bug to ${PNGVER} in makefile.sgi and
-    makefile.sggcc
-  Fixed VER -> PNGVER typo in makefile.macosx and added install-static to
-    install
-  Added install: target to makefile.32sunu and makefile.64sunu
-
-Version 1.0.13patch03 [April 18, 2002]
-
-Version 1.2.2patch03 [April 18, 2002]
-  Revised 15 makefiles to link libpng.a to libpngNN.a and the include libpng
-  subdirectory to libpngNN subdirectory without the full pathname.
-  Moved generation of libpng.pc from "install" to "all" in 15 makefiles.
-
-Version 1.2.3rc1 [April 28, 2002]
-  Added install-man target to 15 makefiles (Dimitri Papadopolous-Orfanos).
-  Added $(DESTDIR) feature to 24 makefiles (Tim Mooney)
-  Fixed bug with $prefix, should be $(prefix) in makefile.hpux.
-  Updated cygwin-specific portion of pngconf.h and revised makefile.cygwin
-  Added a link from libpngNN.pc to libpng.pc in 15 makefiles.
-  Added links from include/libpngNN/*.h to include/*.h in 24 makefiles.
-  Revised makefile.darwin to make relative links without full pathname.
-  Added setjmp() at the end of png_create_*_struct_2() in case user forgets
-    to put one in their application.
-  Restored png_zalloc() and png_zfree() prototypes to version 1.2.1 and
-    removed them from module definition files.
-
-Version 1.2.3rc2 [May 1, 2002]
-  Fixed bug in reporting number of channels in pngget.c and pngset.c,
-    that was introduced in version 1.2.2beta5.
-  Exported png_zalloc(), png_zfree(), png_default_read(), png_default_write(),
-    png_default_flush(), and png_push_fill_buffer() and included them in
-    module definition files.
-  Added "libpng.pc" dependency to the "install-shared" target in 15 makefiles.
-
-Version 1.2.3rc3 [May 1, 2002]
-  Revised prototype for png_default_flush()
-  Remove old libpng.pc and libpngNN.pc before installing new ones.
-
-Version 1.2.3rc4 [May 2, 2002]
-  Typos in *.def files (png_default_read|write -> png_default_read|write_data)
-  In makefiles, changed rm libpng.NN.pc to rm libpngNN.pc
-  Added libpng-config and libpngNN-config and modified makefiles to install
-    them.
-  Changed $(MANPATH) to $(DESTDIR)$(MANPATH) in makefiles
-  Added "Win32 DLL VB" configuration to projects/msvc/libpng.dsp
-
-Version 1.2.3rc5 [May 11, 2002]
-  Changed "error" and "message" in prototypes to "error_message" and
-    "warning_message" to avoid namespace conflict.
-  Revised 15 makefiles to build libpng-config from libpng-config-*.in
-  Once more restored png_zalloc and png_zfree to regular nonexported form.
-  Restored png_default_read|write_data, png_default_flush, png_read_fill_buffer
-    to nonexported form, but with PNGAPI, and removed them from module def
-    files.
-
-Version 1.2.3rc6 [May 14, 2002]
-  Removed "PNGAPI" from png_zalloc() and png_zfree() in png.c
-  Changed "Gz" to "Gd" in projects/msvc/libpng.dsp and zlib.dsp.
-  Removed leftover libpng-config "sed" script from four makefiles.
-  Revised libpng-config creating script in 16 makefiles.
-
-Version 1.2.3 [May 22, 2002]
-  Revised libpng-config target in makefile.cygwin.
-  Removed description of png_set_mem_fn() from documentation.
-  Revised makefile.freebsd.
-  Minor cosmetic changes to 15 makefiles, e.g., $(DI) = $(DESTDIR)/$(INCDIR).
-  Revised projects/msvc/README.txt
-  Changed -lpng to -lpngNN in LDFLAGS in several makefiles.
-
-Version 1.2.4beta1 [May 24, 2002]
-  Added libpng.pc and libpng-config to "all:" target in 16 makefiles.
-  Fixed bug in 16 makefiles: $(DESTDIR)/$(LIBPATH) to $(DESTDIR)$(LIBPATH)
-  Added missing "\" before closing double quote in makefile.gcmmx.
-  Plugged various memory leaks; added png_malloc_warn() and png_set_text_2()
-    functions.
-
-Version 1.2.4beta2 [June 25, 2002]
-  Plugged memory leak of png_ptr->current_text (Matt Holgate).
-  Check for buffer overflow before reading CRC in pngpread.c (Warwick Allison)
-  Added -soname to the loader flags in makefile.dec, makefile.sgi, and
-    makefile.sggcc.
-  Added "test-installed" target to makefile.linux, makefile.gcmmx,
-    makefile.sgi, and makefile.sggcc.
-
-Version 1.2.4beta3 [June 28, 2002]
-  Plugged memory leak of row_buf in pngtest.c when there is a png_error().
-  Detect buffer overflow in pngpread.c when IDAT is corrupted with extra data.
-  Added "test-installed" target to makefile.32sunu, makefile.64sunu,
-    makefile.beos, makefile.darwin, makefile.dec, makefile.macosx,
-    makefile.solaris, makefile.hpux, makefile.hpgcc, and makefile.so9.
-
-Version 1.2.4rc1 and 1.0.14rc1 [July 2, 2002]
-  Added "test-installed" target to makefile.cygwin and makefile.sco.
-  Revised pnggccrd.c to be able to back out version 1.0.x via PNG_1_0_X macro.
-
-Version 1.2.4 and 1.0.14 [July 8, 2002]
-  Changed png_warning() to png_error() when width is too large to process.
-
-Version 1.2.4patch01 [July 20, 2002]
-  Revised makefile.cygwin to use DLL number 12 instead of 13.
-
-Version 1.2.5beta1 [August 6, 2002]
-  Added code to contrib/gregbook/readpng2.c to ignore unused chunks.
-  Replaced toucan.png in contrib/gregbook (it has been corrupt since 1.0.11)
-  Removed some stray *.o files from contrib/gregbook.
-  Changed png_error() to png_warning() about "Too much data" in pngpread.c
-    and about "Extra compressed data" in pngrutil.c.
-  Prevent png_ptr->pass from exceeding 7 in png_push_finish_row().
-  Updated makefile.hpgcc
-  Updated png.c and pnggccrd.c handling of return from png_mmx_support()
-
-Version 1.2.5beta2 [August 15, 2002]
-  Only issue png_warning() about "Too much data" in pngpread.c when avail_in
-    is nonzero.
-  Updated makefiles to install a separate libpng.so.3 with its own rpath.
-
-Version 1.2.5rc1 and 1.0.15rc1 [August 24, 2002]
-  Revised makefiles to not remove previous minor versions of shared libraries.
-
-Version 1.2.5rc2 and 1.0.15rc2 [September 16, 2002]
-  Revised 13 makefiles to remove "-lz" and "-L$(ZLIBLIB)", etc., from shared
-    library loader directive.
-  Added missing "$OBJSDLL" line to makefile.gcmmx.
-  Added missing "; fi" to makefile.32sunu.
-
-Version 1.2.5rc3 and 1.0.15rc3 [September 18, 2002]
-  Revised libpng-config script.
-
-Version 1.2.5 and 1.0.15 [October 3, 2002]
-  Revised makefile.macosx, makefile.darwin, makefile.hpgcc, and makefile.hpux,
-    and makefile.aix.
-  Relocated two misplaced PNGAPI lines in pngtest.c
-
-Version 1.2.6beta1 [October 22, 2002]
-  Commented out warning about uninitialized mmx_support in pnggccrd.c.
-  Changed "IBMCPP__" flag to "__IBMCPP__" in pngconf.h.
-  Relocated two more misplaced PNGAPI lines in pngtest.c
-  Fixed memory overrun bug in png_do_read_filler() with 16-bit datastreams,
-    introduced in version 1.0.2.
-  Revised makefile.macosx, makefile.dec, makefile.aix, and makefile.32sunu.
-
-Version 1.2.6beta2 [November 1, 2002]
-  Added libpng-config "--ldopts" output.
-  Added "AR=ar" and "ARFLAGS=rc" and changed "ar rc" to "$(AR) $(ARFLAGS)"
-    in makefiles.
-
-Version 1.2.6beta3 [July 18, 2004]
-  Reverted makefile changes from version 1.2.6beta2 and some of the changes
-    from version 1.2.6beta1; these will be postponed until version 1.2.7.
-    Version 1.2.6 is going to be a simple bugfix release.
-  Changed the one instance of "ln -sf" to "ln -f -s" in each Sun makefile.
-  Fixed potential overrun in pngerror.c by using strncpy instead of memcpy.
-  Added "#!/bin/sh" at the top of configure, for recognition of the
-    'x' flag under Cygwin (Cosmin).
-  Optimized vacuous tests that silence compiler warnings, in png.c (Cosmin).
-  Added support for PNG_USER_CONFIG, in pngconf.h (Cosmin).
-  Fixed the special memory handler for Borland C under DOS, in pngmem.c
-    (Cosmin).
-  Removed some spurious assignments in pngrutil.c (Cosmin).
-  Replaced 65536 with 65536L, and 0xffff with 0xffffL, to silence warnings
-    on 16-bit platforms (Cosmin).
-  Enclosed shift op expressions in parentheses, to silence warnings (Cosmin).
-  Used proper type png_fixed_point, to avoid problems on 16-bit platforms,
-    in png_handle_sRGB() (Cosmin).
-  Added compression_type to png_struct, and optimized the window size
-    inside the deflate stream (Cosmin).
-  Fixed definition of isnonalpha(), in pngerror.c and pngrutil.c (Cosmin).
-  Fixed handling of unknown chunks that come after IDAT (Cosmin).
-  Allowed png_error() and png_warning() to work even if png_ptr == NULL
-    (Cosmin).
-  Replaced row_info->rowbytes with row_bytes in png_write_find_filter()
-    (Cosmin).
-  Fixed definition of PNG_LIBPNG_VER_DLLNUM (Simon-Pierre).
-  Used PNG_LIBPNG_VER and PNG_LIBPNG_VER_STRING instead of the hardcoded
-    values in png.c (Simon-Pierre, Cosmin).
-  Initialized png_libpng_ver[] with PNG_LIBPNG_VER_STRING (Simon-Pierre).
-  Replaced PNG_LIBPNG_VER_MAJOR with PNG_LIBPNG_VER_DLLNUM in png.rc
-    (Simon-Pierre).
-  Moved the definition of PNG_HEADER_VERSION_STRING near the definitions
-    of the other PNG_LIBPNG_VER_... symbols in png.h (Cosmin).
-  Relocated #ifndef PNGAPI guards in pngconf.h (Simon-Pierre, Cosmin).
-  Updated scripts/makefile.vc(a)win32 (Cosmin).
-  Updated the MSVC project (Simon-Pierre, Cosmin).
-  Updated the Borland C++ Builder project (Cosmin).
-  Avoided access to asm_flags in pngvcrd.c, if PNG_1_0_X is defined (Cosmin).
-  Commented out warning about uninitialized mmx_support in pngvcrd.c (Cosmin).
-  Removed scripts/makefile.bd32 and scripts/pngdef.pas (Cosmin).
-  Added extra guard around inclusion of Turbo C memory headers, in pngconf.h
-    (Cosmin).
-  Renamed projects/msvc/ to projects/visualc6/, and projects/borland/ to
-    projects/cbuilder5/ (Cosmin).
-  Moved projects/visualc6/png32ms.def to scripts/pngw32.def,
-    and projects/visualc6/png.rc to scripts/pngw32.rc (Cosmin).
-  Added projects/visualc6/pngtest.dsp; removed contrib/msvctest/ (Cosmin).
-  Changed line endings to DOS style in cbuilder5 and visualc6 files, even
-    in the tar.* distributions (Cosmin).
-  Updated contrib/visupng/VisualPng.dsp (Cosmin).
-  Updated contrib/visupng/cexcept.h to version 2.0.0 (Cosmin).
-  Added a separate distribution with "configure" and supporting files (Junichi).
-
-Version 1.2.6beta4 [July 28, 2004]
-  Added user ability to change png_size_t via a PNG_SIZE_T macro.
-  Added png_sizeof() and png_convert_size() functions.
-  Added PNG_SIZE_MAX (maximum value of a png_size_t variable.
-  Added check in png_malloc_default() for (size_t)size != (png_uint_32)size
-    which would indicate an overflow.
-  Changed sPLT failure action from png_error to png_warning and abandon chunk.
-  Changed sCAL and iCCP failures from png_error to png_warning and abandon.
-  Added png_get_uint_31(png_ptr, buf) function.
-  Added PNG_UINT_32_MAX macro.
-  Renamed PNG_MAX_UINT to PNG_UINT_31_MAX.
-  Made png_zalloc() issue a png_warning and return NULL on potential
-    overflow.
-  Turn on PNG_NO_ZALLOC_ZERO by default in version 1.2.x
-  Revised "clobber list" in pnggccrd.c so it will compile under gcc-3.4.
-  Revised Borland portion of png_malloc() to return NULL or issue
-    png_error() according to setting of PNG_FLAG_MALLOC_NULL_MEM_OK.
-  Added PNG_NO_SEQUENTIAL_READ_SUPPORTED macro to conditionally remove
-    sequential read support.
-  Added some "#if PNG_WRITE_SUPPORTED" blocks.
-  Added #ifdef to remove some redundancy in png_malloc_default().
-  Use png_malloc instead of png_zalloc to allocate the pallete.
-
-Version 1.0.16rc1 and 1.2.6rc1 [August 4, 2004]
-  Fixed buffer overflow vulnerability in png_handle_tRNS()
-  Fixed integer arithmetic overflow vulnerability in png_read_png().
-  Fixed some harmless bugs in png_handle_sBIT, etc, that would cause
-    duplicate chunk types to go undetected.
-  Fixed some timestamps in the -config version
-  Rearranged order of processing of color types in png_handle_tRNS().
-  Added ROWBYTES macro to calculate rowbytes without integer overflow.
-  Updated makefile.darwin and removed makefile.macosx from scripts directory.
-  Imposed default one million column, one-million row limits on the image
-    dimensions, and added png_set_user_limits() function to override them.
-  Revised use of PNG_SET_USER_LIMITS_SUPPORTED macro.
-  Fixed wrong cast of returns from png_get_user_width|height_max().
-  Changed some "keep the compiler happy" from empty statements to returns,
-  Revised libpng.txt to remove 1.2.x stuff from the 1.0.x distribution
-
-Version 1.0.16rc2 and 1.2.6rc2 [August 7, 2004]
-  Revised makefile.darwin and makefile.solaris.  Removed makefile.macosx.
-  Revised pngtest's png_debug_malloc() to use png_malloc() instead of
-    png_malloc_default() which is not supposed to be exported.
-  Fixed off-by-one error in one of the conversions to PNG_ROWBYTES() in
-    pngpread.c.  Bug was introduced in 1.2.6rc1.
-  Fixed bug in RGB to RGBX transformation introduced in 1.2.6rc1.
-  Fixed old bug in RGB to Gray transformation.
-  Fixed problem with 64-bit compilers by casting arguments to abs()
-    to png_int_32.
-  Changed "ln -sf" to "ln -f -s" in three makefiles (solaris, sco, so9).
-  Changed "HANDLE_CHUNK_*" to "PNG_HANDLE_CHUNK_*" (Cosmin)
-  Added "-@/bin/rm -f $(DL)/$(LIBNAME).so.$(PNGMAJ)" to 15 *NIX makefiles.
-  Added code to update the row_info->colortype in png_do_read_filler() (MSB).
-
-Version 1.0.16rc3 and 1.2.6rc3 [August 9, 2004]
-  Eliminated use of "abs()" in testing cHRM and gAMA values, to avoid
-    trouble with some 64-bit compilers.  Created PNG_OUT_OF_RANGE() macro.
-  Revised documentation of png_set_keep_unknown_chunks().
-  Check handle_as_unknown status in pngpread.c, as in pngread.c previously.
-  Moved  "PNG_HANDLE_CHUNK_*" macros out of PNG_INTERNAL section of png.h
-  Added "rim" definitions for CONST4 and CONST6 in pnggccrd.c
-
-Version 1.0.16rc4 and 1.2.6rc4 [August 10, 2004]
-  Fixed mistake in pngtest.c introduced in 1.2.6rc2 (declaration of
-    "pinfo" was out of place).
-
-Version 1.0.16rc5 and 1.2.6rc5 [August 10, 2004]
-  Moved  "PNG_HANDLE_CHUNK_*" macros out of PNG_ASSEMBLER_CODE_SUPPORTED
-     section of png.h where they were inadvertently placed in version rc3.
-
-Version 1.2.6 and 1.0.16 [August 15, 2004]
-  Revised pngtest so memory allocation testing is only done when PNG_DEBUG==1.
-
-Version 1.2.7beta1 [August 26, 2004]
-  Removed unused pngasmrd.h file.
-  Removed references to uu.net for archived files.  Added references to
-    PNG Spec (second edition) and the PNG ISO/IEC Standard.
-  Added "test-dd" target in 15 makefiles, to run pngtest in DESTDIR.
-  Fixed bug with "optimized window size" in the IDAT datastream, that
-    causes libpng to write PNG files with incorrect zlib header bytes.
-
-Version 1.2.7beta2 [August 28, 2004]
-  Fixed bug with sCAL chunk and big-endian machines (David Munro).
-  Undid new code added in 1.2.6rc2 to update the color_type in
-    png_set_filler().
-  Added png_set_add_alpha() that updates color type.
-
-Version 1.0.17rc1 and 1.2.7rc1 [September 4, 2004]
-  Revised png_set_strip_filler() to not remove alpha if color_type has alpha.
-
-Version 1.2.7 and 1.0.17 [September 12, 2004]
-  Added makefile.hp64
-  Changed projects/msvc/png32ms.def to scripts/png32ms.def in makefile.cygwin
-
-Version 1.2.8beta1 [November 1, 2004]
-  Fixed bug in png_text_compress() that would fail to complete a large block.
-  Fixed bug, introduced in libpng-1.2.7, that overruns a buffer during
-    strip alpha operation in png_do_strip_filler().
-  Added PNG_1_2_X definition in pngconf.h
-  Use #ifdef to comment out png_info_init in png.c and png_read_init in
-    pngread.c (as of 1.3.0)
-
-Version 1.2.8beta2 [November 2, 2004]
-  Reduce color_type to a nonalpha type after strip alpha operation in
-    png_do_strip_filler().
-
-Version 1.2.8beta3 [November 3, 2004]
-  Revised definitions of PNG_MAX_UINT_32, PNG_MAX_SIZE, and PNG_MAXSUM
-
-Version 1.2.8beta4 [November 12, 2004]
-  Fixed (again) definition of PNG_LIBPNG_VER_DLLNUM in png.h (Cosmin).
-  Added PNG_LIBPNG_BUILD_PRIVATE in png.h (Cosmin).
-  Set png_ptr->zstream.data_type to Z_BINARY, to avoid unnecessary detection
-    of data type in deflate (Cosmin).
-  Deprecated but continue to support SPECIALBUILD and PRIVATEBUILD in favor of
-    PNG_LIBPNG_BUILD_SPECIAL_STRING and PNG_LIBPNG_BUILD_PRIVATE_STRING.
-
-Version 1.2.8beta5 [November 20, 2004]
-  Use png_ptr->flags instead of png_ptr->transformations to pass
-    PNG_STRIP_ALPHA info to png_do_strip_filler(), to preserve ABI
-    compatibility.
-  Revised handling of SPECIALBUILD, PRIVATEBUILD,
-    PNG_LIBPNG_BUILD_SPECIAL_STRING and PNG_LIBPNG_BUILD_PRIVATE_STRING.
-
-Version 1.2.8rc1 [November 24, 2004]
-  Moved handling of BUILD macros from pngconf.h to png.h
-  Added definition of PNG_LIBPNG_BASE_TYPE in png.h, inadvertently
-    omitted from beta5.
-  Revised scripts/pngw32.rc
-  Despammed mailing addresses by masking "@" with "at".
-  Inadvertently installed a supposedly faster test version of pngrutil.c
-
-Version 1.2.8rc2 [November 26, 2004]
-  Added two missing "\" in png.h
-  Change tests in pngread.c and pngpread.c to
-    if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
-       png_do_read_transformations(png_ptr);
-
-Version 1.2.8rc3 [November 28, 2004]
-  Reverted pngrutil.c to version libpng-1.2.8beta5.
-  Added scripts/makefile.elf with supporting code in pngconf.h for symbol
-    versioning (John Bowler).
-
-Version 1.2.8rc4 [November 29, 2004]
-  Added projects/visualc7 (Simon-pierre).
-
-Version 1.2.8rc5 [November 29, 2004]
-  Fixed new typo in scripts/pngw32.rc
-
-Version 1.2.8 [December 3, 2004]
-  Removed projects/visualc7, added projects/visualc71.
-
-Version 1.2.9beta1 [February 21, 2006]
-  Initialized some structure members in pngwutil.c to avoid gcc-4.0.0 complaints
-  Revised man page and libpng.txt to make it clear that one should not call
-    png_read_end or png_write_end after png_read_png or png_write_png.
-  Updated references to png-mng-implement mailing list.
-  Fixed an incorrect typecast in pngrutil.c
-  Added PNG_NO_READ_SUPPORTED conditional for making a write-only library.
-  Added PNG_NO_WRITE_INTERLACING_SUPPORTED conditional.
-  Optimized alpha-inversion loops in pngwtran.c
-  Moved test for nonzero gamma outside of png_build_gamma_table() in pngrtran.c
-  Make sure num_trans is <= 256 before copying data in png_set_tRNS().
-  Make sure num_palette is <= 256 before copying data in png_set_PLTE().
-  Interchanged order of write_swap_alpha and write_invert_alpha transforms.
-  Added parentheses in the definition of PNG_LIBPNG_BUILD_TYPE (Cosmin).
-  Optimized zlib window flag (CINFO) in contrib/pngsuite/*.png (Cosmin).
-  Updated scripts/makefile.bc32 for Borland C++ 5.6 (Cosmin).
-  Exported png_get_uint_32, png_save_uint_32, png_get_uint_16, png_save_uint_16,
-    png_get_int_32, png_save_int_32, png_get_uint_31 (Cosmin).
-  Added type cast (png_byte) in png_write_sCAL() (Cosmin).
-  Fixed scripts/makefile.cygwin (Christian Biesinger, Cosmin).
-  Default iTXt support was inadvertently enabled.
-
-Version 1.2.9beta2 [February 21, 2006]
-  Check for png_rgb_to_gray and png_gray_to_rgb read transformations before
-    checking for png_read_dither in pngrtran.c
-  Revised checking of chromaticity limits to accommodate extended RGB
-    colorspace (John Denker).
-  Changed line endings in some of the project files to CRLF, even in the
-    "Unix" tar distributions (Cosmin).
-  Made png_get_int_32 and png_save_int_32 always available (Cosmin).
-  Updated scripts/pngos2.def, scripts/pngw32.def and projects/wince/png32ce.def
-    with the newly exported functions.
-  Eliminated distributions without the "configure" script.
-  Updated INSTALL instructions.
-
-Version 1.2.9beta3 [February 24, 2006]
-  Fixed CRCRLF line endings in contrib/visupng/VisualPng.dsp
-  Made libpng.pc respect EXEC_PREFIX (D. P. Kreil, J. Bowler)
-  Removed reference to pngasmrd.h from Makefile.am
-  Renamed CHANGES to ChangeLog.
-  Renamed LICENSE to COPYING.
-  Renamed ANNOUNCE to NEWS.
-  Created AUTHORS file.
-
-Version 1.2.9beta4 [March 3, 2006]
-  Changed definition of PKGCONFIG from $prefix/lib to $libdir in configure.ac
-  Reverted to filenames LICENSE and ANNOUNCE; removed AUTHORS and COPYING.
-  Removed newline from the end of some error and warning messages.
-  Removed test for sqrt() from configure.ac and configure.
-  Made swap tables in pngtrans.c PNG_CONST (Carlo Bramix).
-  Disabled default iTXt support that was inadvertently enabled in
-    libpng-1.2.9beta1.
-  Added "OS2" to list of systems that don't need underscores, in pnggccrd.c
-  Removed libpng version and date from *.c files.
-
-Version 1.2.9beta5 [March 4, 2006]
-  Removed trailing blanks from source files.
-  Put version and date of latest change in each source file, and changed
-    copyright year accordingly.
-  More cleanup of configure.ac, Makefile.am, and associated scripts.
-  Restored scripts/makefile.elf which was inadvertently deleted.
-
-Version 1.2.9beta6 [March 6, 2006]
-  Fixed typo (RELEASE) in configuration files.
-
-Version 1.2.9beta7 [March 7, 2006]
-  Removed libpng.vers and libpng.sym from libpng12_la_SOURCES in Makefile.am
-  Fixed inconsistent #ifdef's around png_sig_bytes() and png_set_sCAL_s()
-    in png.h.
-  Updated makefile.elf as suggested by debian.
-  Made cosmetic changes to some makefiles, adding LN_SF and other macros.
-  Made some makefiles accept "exec_prefix".
-
-Version 1.2.9beta8 [March 9, 2006]
-  Fixed some "#if defined (..." which should be "#if defined(..."
-    Bug introduced in libpng-1.2.8.
-  Fixed inconsistency in definition of png_default_read_data()
-  Restored blank that was lost from makefile.sggcc "clean" target in beta7.
-  Revised calculation of "current" and "major" for irix in ltmain.sh
-  Changed "mkdir" to "MKDIR_P" in some makefiles.
-  Separated PNG_EXPAND and PNG_EXPAND_tRNS.
-  Added png_set_expand_gray_1_2_4_to_8() and deprecated
-    png_set_gray_1_2_4_to_8() which also expands tRNS to alpha.
-
-Version 1.2.9beta9 [March 10, 2006]
-  Include "config.h" in pngconf.h when available.
-  Added some checks for NULL png_ptr or NULL info_ptr (timeless)
-
-Version 1.2.9beta10 [March 20, 2006]
-  Removed extra CR from contrib/visualpng/VisualPng.dsw (Cosmin)
-  Made pnggccrd.c PIC-compliant (Christian Aichinger).
-  Added makefile.mingw (Wolfgang Glas).
-  Revised pngconf.h MMX checking.
-
-Version 1.2.9beta11 [March 22, 2006]
-  Fixed out-of-order declaration in pngwrite.c that was introduced in beta9
-  Simplified some makefiles by using LIBSO, LIBSOMAJ, and LIBSOVER macros.
-
-Version 1.2.9rc1 [March 31, 2006]
-  Defined PNG_USER_PRIVATEBUILD when including "pngusr.h" (Cosmin).
-  Removed nonsensical assertion check from pngtest.c (Cosmin).
-
-Version 1.2.9 [April 14, 2006]
-  Revised makefile.beos and added "none" selector in ltmain.sh
-
-Version 1.2.10beta1 [April 15, 2006]
-  Renamed "config.h" to "png_conf.h" and revised Makefile.am to add
-    -DPNG_BUILDING_LIBPNG to compile directive, and modified pngconf.h
-    to include png_conf.h only when PNG_BUILDING_LIBPNG is defined.
-
-Version 1.2.10beta2 [April 15, 2006]
-  Manually updated Makefile.in and configure.  Changed png_conf.h.in
-    back to config.h.
-
-Version 1.2.10beta3 [April 15, 2006]
-  Change png_conf.h back to config.h in pngconf.h.
-
-Version 1.2.10beta4 [April 16, 2006]
-  Change PNG_BUILDING_LIBPNG to PNG_CONFIGURE_LIBPNG in config/Makefile*.
-
-Version 1.2.10beta5 [April 16, 2006]
-  Added a configure check for compiling assembler code in pnggccrd.c
-
-Version 1.2.10beta6 [April 17, 2006]
-  Revised the configure check for pnggccrd.c
-  Moved -DPNG_CONFIGURE_LIBPNG into @LIBPNG_DEFINES@
-  Added @LIBPNG_DEFINES@ to arguments when building libpng.sym
-
-Version 1.2.10beta7 [April 18, 2006]
-  Change "exec_prefix=$prefix" to "exec_prefix=$(prefix)" in makefiles.
-
-Version 1.2.10rc1 [April 19, 2006]
-  Ensure pngconf.h doesn't define both PNG_USE_PNGGCCRD and PNG_USE_PNGVCRD
-  Fixed "LN_FS" typo in makefile.sco and makefile.solaris.
-
-Version 1.2.10rc2 [April 20, 2006]
-  Added a backslash between -DPNG_CONFIGURE_LIBPNG and -DPNG_NO_ASSEMBLER_CODE
-   in configure.ac and configure
-  Made the configure warning about versioned symbols less arrogant.
-
-Version 1.2.10rc3 [April 21, 2006]
-  Added a note in libpng.txt that png_set_sig_bytes(8) can be used when
-    writing an embedded PNG without the 8-byte signature.
-  Revised makefiles and configure to avoid making links to libpng.so.*
-
-Version 1.2.10 [April 23, 2006]
-  Reverted configure to "rc2" state.
-
-Version 1.2.11beta1 [May 31, 2006]
-  scripts/libpng.pc.in contained "configure" style version info and would
-    not work with makefiles.
-  The shared-library makefiles were linking to libpng.so.0 instead of
-    libpng.so.3 compatibility as the library.
-
-Version 1.2.11beta2 [June 2, 2006]
-  Increased sprintf buffer from 50 to 52 chars in pngrutil.c to avoid
-    buffer overflow.
-  Fixed bug in example.c (png_set_palette_rgb -> png_set_palette_to_rgb)
-
-Version 1.2.11beta3 [June 5, 2006]
-  Prepended "#! /bin/sh" to ltmail.sh and contrib/pngminus/*.sh (Cosmin).
-  Removed the accidental leftover Makefile.in~ (Cosmin).
-  Avoided potential buffer overflow and optimized buffer in
-    png_write_sCAL(), png_write_sCAL_s() (Cosmin).
-  Removed the include directories and libraries from CFLAGS and LDFLAGS
-    in scripts/makefile.gcc (Nelson A. de Oliveira, Cosmin).
-
-Version 1.2.11beta4 [June 6, 2006]
-  Allow zero-length IDAT chunks after the entire zlib datastream, but not
-    after another intervening chunk type.
-
-Version 1.0.19rc1, 1.2.11rc1 [June 13, 2006]
-  Deleted extraneous square brackets from [config.h] in configure.ac
-
-Version 1.0.19rc2, 1.2.11rc2 [June 14, 2006]
-  Added prototypes for PNG_INCH_CONVERSIONS functions to png.h
-  Revised INSTALL and autogen.sh
-  Fixed typo in several makefiles (-W1 should be -Wl)
-  Added typedef for png_int_32 and png_uint_32 on 64-bit systems.
-
-Version 1.0.19rc3, 1.2.11rc3 [June 15, 2006]
-  Removed the new typedefs for 64-bit systems (delay until version 1.4.0)
-  Added one zero element to png_gamma_shift[] array in pngrtran.c to avoid
-    reading out of bounds.
-
-Version 1.0.19rc4, 1.2.11rc4 [June 15, 2006]
-  Really removed the new typedefs for 64-bit systems.
-
-Version 1.0.19rc5, 1.2.11rc5 [June 22, 2006]
-  Removed png_sig_bytes entry from scripts/pngw32.def
-
-Version 1.0.19, 1.2.11 [June 26, 2006]
-  None.
-
-Version 1.0.20, 1.2.12 [June 27, 2006]
-  Really increased sprintf buffer from 50 to 52 chars in pngrutil.c to avoid
-    buffer overflow.
-
-Version 1.2.13beta1 [October 2, 2006]
-  Removed AC_FUNC_MALLOC from configure.ac
-  Work around Intel-Mac compiler bug by setting PNG_NO_MMX_CODE in pngconf.h
-  Change "logical" to "bitwise" throughout documentation.
-  Detect and fix attempt to write wrong iCCP profile length (CVE-2006-7244)
-
-Version 1.0.21, 1.2.13 [November 14, 2006]
-  Fix potential buffer overflow in sPLT chunk handler.
-  Fix Makefile.am to not try to link to noexistent files.
-  Check all exported functions for NULL png_ptr.
-
-Version 1.2.14beta1 [November 17, 2006]
-  Relocated three misplaced tests for NULL png_ptr.
-  Built Makefile.in with automake-1.9.6 instead of 1.9.2.
-  Build configure with autoconf-2.60 instead of 2.59
-
-Version 1.2.14beta2 [November 17, 2006]
-  Added some typecasts in png_zalloc().
-
-Version 1.2.14rc1 [November 20, 2006]
-  Changed "strtod" to "png_strtod" in pngrutil.c
-
-Version 1.0.22, 1.2.14    [November 27, 2006]
-  Added missing "$(srcdir)" in Makefile.am and Makefile.in
-
-Version 1.2.15beta1 [December 3, 2006]
-  Generated configure with autoconf-2.61 instead of 2.60
-  Revised configure.ac to update libpng.pc and libpng-config.
-
-Version 1.2.15beta2 [December 3, 2006]
-  Always export MMX asm functions, just stubs if not building pnggccrd.c
-
-Version 1.2.15beta3 [December 4, 2006]
-  Add "png_bytep" typecast to profile while calculating length in pngwutil.c
-
-Version 1.2.15beta4 [December 7, 2006]
-  Added scripts/CMakeLists.txt
-  Changed PNG_NO_ASSEMBLER_CODE to PNG_NO_MMX_CODE in scripts, like 1.4.0beta
-
-Version 1.2.15beta5 [December 7, 2006]
-  Changed some instances of PNG_ASSEMBLER_* to PNG_MMX_* in pnggccrd.c
-  Revised scripts/CMakeLists.txt
-
-Version 1.2.15beta6 [December 13, 2006]
-  Revised scripts/CMakeLists.txt and configure.ac
-
-Version 1.2.15rc1 [December 18, 2006]
-  Revised scripts/CMakeLists.txt
-
-Version 1.2.15rc2 [December 21, 2006]
-  Added conditional #undef jmpbuf in pngtest.c to undo #define in AIX headers.
-  Added scripts/makefile.nommx
-
-Version 1.2.15rc3 [December 25, 2006]
-  Fixed shared library numbering error that was introduced in 1.2.15beta6.
-
-Version 1.2.15rc4 [December 27, 2006]
-  Fixed handling of rgb_to_gray when png_ptr->color.gray isn't set.
-
-Version 1.2.15rc5 [December 31, 2006]
-  Revised handling of rgb_to_gray.
-
-Version 1.2.15 [January 5, 2007]
-  Added some (unsigned long) typecasts in pngtest.c to avoid printing errors.
-
-Version 1.2.16beta1 [January 6, 2007]
-  Fix bugs in makefile.nommx
-
-Version 1.2.16beta2 [January 16, 2007]
-  Revised scripts/CMakeLists.txt
-
-Version 1.2.16 [January 31, 2007]
-  No changes.
-
-Version 1.2.17beta1 [March 6, 2007]
-  Revised scripts/CMakeLists.txt to install both shared and static libraries.
-  Deleted a redundant line from pngset.c.
-
-Version 1.2.17beta2 [April 26, 2007]
-  Relocated misplaced test for png_ptr == NULL in pngpread.c
-  Change "==" to "&" for testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN
-    flags.
-  Changed remaining instances of PNG_ASSEMBLER_* to PNG_MMX_*
-  Added pngerror() when write_IHDR fails in deflateInit2().
-  Added "const" to some array declarations.
-  Mention examples of libpng usage in the libpng*.txt and libpng.3 documents.
-
-Version 1.2.17rc1 [May 4, 2007]
-  No changes.
-
-Version 1.2.17rc2 [May 8, 2007]
-  Moved several PNG_HAVE_* macros out of PNG_INTERNAL because applications
-    calling set_unknown_chunk_location() need them.
-  Changed transformation flag from PNG_EXPAND_tRNS to PNG_EXPAND in
-    png_set_expand_gray_1_2_4_to_8().
-  Added png_ptr->unknown_chunk to hold working unknown chunk data, so it
-    can be free'ed in case of error.  Revised unknown chunk handling in
-    pngrutil.c and pngpread.c to use this structure.
-
-Version 1.2.17rc3 [May 8, 2007]
-  Revised symbol-handling in configure script.
-
-Version 1.2.17rc4 [May 10, 2007]
-  Revised unknown chunk handling to avoid storing unknown critical chunks.
-
-Version 1.0.25 [May 15, 2007]
-Version 1.2.17 [May 15, 2007]
-  Added "png_ptr->num_trans=0" before error return in png_handle_tRNS,
-    to eliminate a vulnerability (CVE-2007-2445, CERT VU#684664)
-
-Version 1.0.26 [May 15, 2007]
-Version 1.2.18 [May 15, 2007]
-  Reverted the libpng-1.2.17rc3 change to symbol-handling in configure script
-
-Version 1.2.19beta1 [May 18, 2007]
-  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
-    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
-  Changed some handling of unused parameters, to avoid compiler warnings.
-    "if (unused == NULL) return;" becomes "unused = unused".
-
-Version 1.2.19beta2 [May 18, 2007]
-  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)
-
-Version 1.2.19beta3 [May 19, 2007]
-  Add some "png_byte" typecasts in png_check_keyword() and write new_key
-  instead of key in zTXt chunk (Kevin Ryde).
-
-Version 1.2.19beta4 [May 21, 2007]
-  Add png_snprintf() function and use it in place of sprint() for improved
-    defense against buffer overflows.
-
-Version 1.2.19beta5 [May 21, 2007]
-  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
-  Changed handling of more unused parameters, to avoid compiler warnings.
-  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.
-
-Version 1.2.19beta6 [May 22, 2007]
-  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
-  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf
-
-Version 1.2.19beta7 [May 22, 2007]
-  Squelched png_squelch_warnings() in pnggccrd.c and added
-    an #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
-    the warnings that png_squelch_warnings was squelching.
-
-Version 1.2.19beta8 [May 22, 2007]
-  Removed __MMX__ from test in pngconf.h.
-
-Version 1.2.19beta9 [May 23, 2007]
-  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
-  Revised png_squelch_warnings() so it might work.
-  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.
-
-Version 1.2.19beta10 [May 24, 2007]
-  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.
-
-Version 1.4.0beta1 [April 20, 2006]
-  Enabled iTXt support (changes png_struct, thus requires so-number change).
-  Cleaned up PNG_ASSEMBLER_CODE_SUPPORTED vs PNG_MMX_CODE_SUPPORTED
-  Eliminated PNG_1_0_X and PNG_1_2_X macros.
-  Removed deprecated functions png_read_init, png_write_init, png_info_init,
-    png_permit_empty_plte, png_set_gray_1_2_4_to_8, png_check_sig, and
-    removed the deprecated macro PNG_MAX_UINT.
-  Moved "PNG_INTERNAL" parts of png.h and pngconf.h into pngintrn.h
-  Removed many WIN32_WCE #ifdefs (Cosmin).
-  Reduced dependency on C-runtime library when on Windows (Simon-Pierre)
-  Replaced sprintf() with png_sprintf() (Simon-Pierre)
-
-Version 1.4.0beta2 [April 20, 2006]
-  Revised makefiles and configure to avoid making links to libpng.so.*
-  Moved some leftover MMX-related defines from pngconf.h to pngintrn.h
-  Updated scripts/pngos2.def, pngw32.def, and projects/wince/png32ce.def
-
-Version 1.4.0beta3 [May 10, 2006]
-  Updated scripts/pngw32.def to comment out MMX functions.
-  Added PNG_NO_GET_INT_32 and PNG_NO_SAVE_INT_32 macros.
-  Scripts/libpng.pc.in contained "configure" style version info and would
-    not work with makefiles.
-  Revised pngconf.h and added pngconf.h.in, so makefiles and configure can
-    pass defines to libpng and applications.
-
-Version 1.4.0beta4 [May 11, 2006]
-  Revised configure.ac, Makefile.am, and many of the makefiles to write
-    their defines in pngconf.h.
-
-Version 1.4.0beta5 [May 15, 2006]
-  Added a missing semicolon in Makefile.am and Makefile.in
-  Deleted extraneous square brackets from configure.ac
-
-Version 1.4.0beta6 [June 2, 2006]
-  Increased sprintf buffer from 50 to 52 chars in pngrutil.c to avoid
-    buffer overflow.
-  Changed sonum from 0 to 1.
-  Removed unused prototype for png_check_sig() from png.h
-
-Version 1.4.0beta7 [June 16, 2006]
-  Exported png_write_sig (Cosmin).
-  Optimized buffer in png_handle_cHRM() (Cosmin).
-  Set pHYs = 2835 x 2835 pixels per meter, and added
-    sCAL = 0.352778e-3 x 0.352778e-3 meters, in pngtest.png (Cosmin).
-  Added png_set_benign_errors(), png_benign_error(), png_chunk_benign_error().
-  Added typedef for png_int_32 and png_uint_32 on 64-bit systems.
-  Added "(unsigned long)" typecast on png_uint_32 variables in printf lists.
-
-Version 1.4.0beta8 [June 22, 2006]
-  Added demonstration of user chunk support in pngtest.c, to support the
-    public sTER chunk and a private vpAg chunk.
-
-Version 1.4.0beta9 [July 3, 2006]
-  Removed ordinals from scripts/pngw32.def and removed png_info_int and
-    png_set_gray_1_2_4_to_8 entries.
-  Inline call of png_get_uint_32() in png_get_uint_31().
-  Use png_get_uint_31() to get vpAg width and height in pngtest.c
-  Removed WINCE and Netware projects.
-  Removed standalone Y2KINFO file.
-
-Version 1.4.0beta10 [July 12, 2006]
-  Eliminated automatic copy of pngconf.h to pngconf.h.in from configure and
-    some makefiles, because it was not working reliably.  Instead, distribute
-    pngconf.h.in along with pngconf.h and cause configure and some of the
-    makefiles to update pngconf.h from pngconf.h.in.
-  Added pngconf.h to DEPENDENCIES in Makefile.am
-
-Version 1.4.0beta11 [August 19, 2006]
-  Removed AC_FUNC_MALLOC from configure.ac.
-  Added a warning when writing iCCP profile with mismatched profile length.
-  Patched pnggccrd.c to assemble on x86_64 platforms.
-  Moved chunk header reading into a separate function png_read_chunk_header()
-    in pngrutil.c.  The chunk header (len+sig) is now serialized in a single
-    operation (Cosmin).
-  Implemented support for I/O states. Added png_ptr member io_state, and
-    functions png_get_io_chunk_name() and png_get_io_state() in pngget.c
-    (Cosmin).
-  Added png_get_io_chunk_name and png_get_io_state to scripts/*.def (Cosmin).
-  Renamed scripts/pngw32.* to scripts/pngwin.* (Cosmin).
-  Removed the include directories and libraries from CFLAGS and LDFLAGS
-    in scripts/makefile.gcc (Cosmin).
-  Used png_save_uint_32() to set vpAg width and height in pngtest.c (Cosmin).
-  Cast to proper type when getting/setting vpAg units in pngtest.c (Cosmin).
-  Added pngintrn.h to the Visual C++ projects (Cosmin).
-  Removed scripts/list (Cosmin).
-  Updated copyright year in scripts/pngwin.def (Cosmin).
-  Removed PNG_TYPECAST_NULL and used standard NULL consistently (Cosmin).
-  Disallowed the user to redefine png_size_t, and enforced a consistent use
-    of png_size_t across libpng (Cosmin).
-  Changed the type of png_ptr->rowbytes, PNG_ROWBYTES() and friends
-    to png_size_t (Cosmin).
-  Removed png_convert_size() and replaced png_sizeof with sizeof (Cosmin).
-  Removed some unnecessary type casts (Cosmin).
-  Changed prototype of png_get_compression_buffer_size() and
-    png_set_compression_buffer_size() to work with png_size_t instead of
-    png_uint_32 (Cosmin).
-  Removed png_memcpy_check() and png_memset_check() (Cosmin).
-  Fixed a typo (png_byte --> png_bytep) in libpng.3 and libpng.txt (Cosmin).
-  Clarified that png_zalloc() does not clear the allocated memory,
-    and png_zalloc() and png_zfree() cannot be PNGAPI (Cosmin).
-  Renamed png_mem_size_t to png_alloc_size_t, fixed its definition in
-    pngconf.h, and used it in all memory allocation functions (Cosmin).
-  Renamed pngintrn.h to pngpriv.h, added a comment at the top of the file
-    mentioning that the symbols declared in that file are private, and
-    updated the scripts and the Visual C++ projects accordingly (Cosmin).
-  Removed circular references between pngconf.h and pngconf.h.in in
-    scripts/makefile.vc*win32 (Cosmin).
-  Removing trailing '.' from the warning and error messages (Cosmin).
-  Added pngdefs.h that is built by makefile or configure, instead of
-    pngconf.h.in (Glenn).
-  Detect and fix attempt to write wrong iCCP profile length.
-
-Version 1.4.0beta12 [October 19, 2006]
-  Changed "logical" to "bitwise" in the documentation.
-  Work around Intel-Mac compiler bug by setting PNG_NO_MMX_CODE in pngconf.h
-  Add a typecast to stifle compiler warning in pngrutil.c
-
-Version 1.4.0beta13 [November 10, 2006]
-  Fix potential buffer overflow in sPLT chunk handler.
-  Fix Makefile.am to not try to link to noexistent files.
-
-Version 1.4.0beta14 [November 15, 2006]
-  Check all exported functions for NULL png_ptr.
-
-Version 1.4.0beta15 [November 17, 2006]
-  Relocated two misplaced tests for NULL png_ptr.
-  Built Makefile.in with automake-1.9.6 instead of 1.9.2.
-  Build configure with autoconf-2.60 instead of 2.59
-  Add "install: all" in Makefile.am so "configure; make install" will work.
-
-Version 1.4.0beta16 [November 17, 2006]
-  Added a typecast in png_zalloc().
-
-Version 1.4.0beta17 [December 4, 2006]
-  Changed "new_key[79] = '\0';" to "(*new_key)[79] = '\0';" in pngwutil.c
-  Add "png_bytep" typecast to profile while calculating length in pngwutil.c
-
-Version 1.4.0beta18 [December 7, 2006]
-  Added scripts/CMakeLists.txt
-
-Version 1.4.0beta19 [May 16, 2007]
-  Revised scripts/CMakeLists.txt
-  Rebuilt configure and Makefile.in with newer tools.
-  Added conditional #undef jmpbuf in pngtest.c to undo #define in AIX headers.
-  Added scripts/makefile.nommx
-
-Version 1.4.0beta20 [July 9, 2008]
-  Moved several PNG_HAVE_* macros from pngpriv.h to png.h because applications
-    calling set_unknown_chunk_location() need them.
-  Moved several macro definitions from pngpriv.h to pngconf.h
-  Merge with changes to the 1.2.X branch, as of 1.2.30beta04.
-  Deleted all use of the MMX assembler code and Intel-licensed optimizations.
-  Revised makefile.mingw
-
-Version 1.4.0beta21 [July 21, 2008]
-  Moved local array "chunkdata" from pngrutil.c to the png_struct, so
-    it will be freed by png_read_destroy() in case of a read error (Kurt
-    Christensen).
-
-Version 1.4.0beta22 [July 21, 2008]
-  Change "purpose" and "buffer" to png_ptr->chunkdata to avoid memory leaking.
-
-Version 1.4.0beta23 [July 22, 2008]
-  Change "chunkdata = NULL" to "png_ptr->chunkdata = NULL" several places in
-    png_decompress_chunk().
-
-Version 1.4.0beta24 [July 25, 2008]
-  Change all remaining "chunkdata" to "png_ptr->chunkdata" in
-    png_decompress_chunk(), and remove "chunkdata" from parameter list.
-  Put a call to png_check_chunk_name() in png_read_chunk_header().
-  Revised png_check_chunk_name() to reject a name with a lowercase 3rd byte.
-  Removed two calls to png_check_chunk_name() occuring later in the process.
-  Define PNG_NO_ERROR_NUMBERS by default in pngconf.h
-
-Version 1.4.0beta25 [July 30, 2008]
-  Added a call to png_check_chunk_name() in pngpread.c
-  Reverted png_check_chunk_name() to accept a name with a lowercase 3rd byte.
-  Added png_push_have_buffer() function to pngpread.c
-  Eliminated PNG_BIG_ENDIAN_SUPPORTED and associated png_get_* macros.
-  Made inline expansion of png_get_*() optional with PNG_USE_READ_MACROS.
-  Eliminated all PNG_USELESS_TESTS and PNG_CORRECT_PALETTE_SUPPORTED code.
-  Synced contrib directory and configure files with libpng-1.2.30beta06.
-  Eliminated no-longer-used pngdefs.h (but it's still built in the makefiles)
-  Relocated a misplaced "#endif /* PNG_NO_WRITE_FILTER */" in pngwutil.c
-
-Version 1.4.0beta26 [August 4, 2008]
-  Removed png_push_have_buffer() function in pngpread.c.  It increased the
-    compiled library size slightly.
-  Changed "-Wall" to "-W -Wall" in the CFLAGS in all makefiles (Cosmin Truta)
-  Declared png_ptr "volatile" in pngread.c and pngwrite.c to avoid warnings.
-  Updated contrib/visupng/cexcept.h to version 2.0.1
-  Added PNG_LITERAL_CHARACTER macros for #, [, and ].
-
-Version 1.4.0beta27 [August 5, 2008]
-  Revised usage of PNG_LITERAL_SHARP in pngerror.c.
-  Moved newline character from individual png_debug messages into the
-    png_debug macros.
-  Allow user to #define their own png_debug, png_debug1, and png_debug2.
-
-Version 1.4.0beta28 [August 5, 2008]
-  Revised usage of PNG_LITERAL_SHARP in pngerror.c.
-  Added PNG_STRING_NEWLINE macro
-
-Version 1.4.0beta29 [August 9, 2008]
-  Revised usage of PNG_STRING_NEWLINE to work on non-ISO compilers.
-  Added PNG_STRING_COPYRIGHT macro.
-  Added non-ISO versions of png_debug macros.
-
-Version 1.4.0beta30 [August 14, 2008]
-  Added premultiplied alpha feature (Volker Wiendl).
-
-Version 1.4.0beta31 [August 18, 2008]
-  Moved png_set_premultiply_alpha from pngtrans.c to pngrtran.c
-  Removed extra crc check at the end of png_handle_cHRM().  Bug introduced
-    in libpng-1.4.0beta20.
-
-Version 1.4.0beta32 [August 19, 2008]
-  Added PNG_WRITE_FLUSH_SUPPORTED block around new png_flush() call.
-  Revised PNG_NO_STDIO version of png_write_flush()
-
-Version 1.4.0beta33 [August 20, 2008]
-  Added png_get|set_chunk_cache_max() to limit the total number of sPLT,
-    text, and unknown chunks that can be stored.
-
-Version 1.4.0beta34 [September 6, 2008]
-  Shortened tIME_string to 29 bytes in pngtest.c
-  Fixed off-by-one error introduced in png_push_read_zTXt() function in
-    libpng-1.2.30beta04/pngpread.c (Harald van Dijk)
-
-Version 1.4.0beta35 [October 6, 2008]
-  Changed "trans_values" to "trans_color".
-  Changed so-number from 0 to 14.  Some OS do not like 0.
-  Revised makefile.darwin to fix shared library numbering.
-  Change png_set_gray_1_2_4_to_8() to png_set_expand_gray_1_2_4_to_8()
-    in example.c (debian bug report)
-
-Version 1.4.0beta36 [October 25, 2008]
-  Sync with tEXt vulnerability fix in libpng-1.2.33rc02.
-
-Version 1.4.0beta37 [November 13, 2008]
-  Added png_check_cHRM in png.c and moved checking from pngget.c, pngrutil.c,
-    and pngwrite.c
-
-Version 1.4.0beta38 [November 22, 2008]
-  Added check for zero-area RGB cHRM triangle in png_check_cHRM() and
-    png_check_cHRM_fixed().
-
-Version 1.4.0beta39 [November 23, 2008]
-  Revised png_warning() to write its message on standard output by default
-    when warning_fn is NULL.
-
-Version 1.4.0beta40 [November 24, 2008]
-  Eliminated png_check_cHRM().  Instead, always use png_check_cHRM_fixed().
-  In png_check_cHRM_fixed(), ensure white_y is > 0, and removed redundant
-    check for all-zero coordinates that is detected by the triangle check.
-
-Version 1.4.0beta41 [November 26, 2008]
-  Fixed string vs pointer-to-string error in png_check_keyword().
-  Rearranged test expressions in png_check_cHRM_fixed() to avoid internal
-    overflows.
-  Added PNG_NO_CHECK_cHRM conditional.
-
-Version 1.4.0beta42, 43 [December 1, 2008]
-  Merge png_debug with version 1.2.34beta04.
-
-Version 1.4.0beta44 [December 6, 2008]
-  Removed redundant check for key==NULL before calling png_check_keyword()
-    to ensure that new_key gets initialized and removed extra warning
-    (Merge with version 1.2.34beta05 -- Arvan Pritchard).
-
-Version 1.4.0beta45 [December 9, 2008]
-  In png_write_png(), respect the placement of the filler bytes in an earlier
-    call to png_set_filler() (Jim Barry).
-
-Version 1.4.0beta46 [December 10, 2008]
-  Undid previous change and added PNG_TRANSFORM_STRIP_FILLER_BEFORE and
-    PNG_TRANSFORM_STRIP_FILLER_AFTER conditionals and deprecated
-    PNG_TRANSFORM_STRIP_FILLER (Jim Barry).
-
-Version 1.4.0beta47 [December 15, 2008]
-  Support for dithering was disabled by default, because it has never
-    been well tested and doesn't work very well.  The code has not
-    been removed, however, and can be enabled by building libpng with
-    PNG_READ_DITHER_SUPPORTED defined.
-
-Version 1.4.0beta48 [February 14, 2009]
-  Added new exported function png_calloc().
-  Combined several instances of png_malloc(); png_memset() into png_calloc().
-  Removed prototype for png_freeptr() that was added in libpng-1.4.0beta24
-    but was never defined.
-
-Version 1.4.0beta49 [February 28, 2009]
-  Added png_fileno() macro to pngconf.h, used in pngwio.c
-  Corrected order of #ifdef's in png_debug definition in png.h
-  Fixed bug introduced in libpng-1.4.0beta48 with the memset arguments
-    for pcal_params.
-  Fixed order of #ifdef directives in the png_debug defines in png.h
-    (bug introduced in libpng-1.2.34/1.4.0beta29).
-  Revised comments in png_set_read_fn() and png_set_write_fn().
-
-Version 1.4.0beta50 [March 18, 2009]
-  Use png_calloc() instead of png_malloc() to allocate big_row_buf when
-    reading an interlaced file, to avoid a possible UMR.
-  Undid revision of PNG_NO_STDIO version of png_write_flush().  Users
-    having trouble with fflush() can build with PNG_NO_WRITE_FLUSH defined
-    or supply their own flush_fn() replacement.
-  Revised libpng*.txt and png.h documentation about use of png_write_flush()
-    and png_set_write_fn().
-  Removed fflush() from pngtest.c.
-  Added "#define PNG_NO_WRITE_FLUSH" to contrib/pngminim/encoder/pngusr.h
-
-Version 1.4.0beta51 [March 21, 2009]
-  Removed new png_fileno() macro from pngconf.h .
-
-Version 1.4.0beta52 [March 27, 2009]
-  Relocated png_do_chop() ahead of building gamma tables in pngrtran.c
-    This avoids building 16-bit gamma tables unnecessarily.
-  Removed fflush() from pngtest.c.
-  Added "#define PNG_NO_WRITE_FLUSH" to contrib/pngminim/encoder/pngusr.h
-  Added a section on differences between 1.0.x and 1.2.x to libpng.3/libpng.txt
-
-Version 1.4.0beta53 [April 1, 2009]
-  Removed some remaining MMX macros from pngpriv.h
-  Fixed potential memory leak of "new_name" in png_write_iCCP() (Ralph Giles)
-
-Version 1.4.0beta54 [April 13, 2009]
-  Added "ifndef PNG_SKIP_SETJMP_CHECK" block in pngconf.h to allow
-    application code writers to bypass the check for multiple inclusion
-    of setjmp.h when they know that it is safe to ignore the situation.
-  Eliminated internal use of setjmp() in pngread.c and pngwrite.c
-  Reordered ancillary chunks in pngtest.png to be the same as what
-    pngtest now produces, and made some cosmetic changes to pngtest output.
-  Eliminated deprecated png_read_init_3() and png_write_init_3() functions.
-
-Version 1.4.0beta55 [April 15, 2009]
-  Simplified error handling in pngread.c and pngwrite.c by putting
-    the new png_read_cleanup() and png_write_cleanup() functions inline.
-
-Version 1.4.0beta56 [April 25, 2009]
-  Renamed "user_chunk_data" to "my_user_chunk_data" in pngtest.c to suppress
-    "shadowed declaration" warning from gcc-4.3.3.
-  Renamed "gamma" to "png_gamma" in pngset.c to avoid "shadowed declaration"
-    warning about a global "gamma" variable in math.h on some platforms.
-
-Version 1.4.0beta57 [May 2, 2009]
-  Removed prototype for png_freeptr() that was added in libpng-1.4.0beta24
-    but was never defined (again).
-  Rebuilt configure scripts with autoconf-2.63 instead of 2.62
-  Removed pngprefs.h and MMX from makefiles
-
-Version 1.4.0beta58 [May 14, 2009]
-  Changed pngw32.def to pngwin.def in makefile.mingw (typo was introduced
-    in beta57).
-  Clarified usage of sig_bit versus sig_bit_p in example.c (Vincent Torri)
-
-Version 1.4.0beta59 [May 15, 2009]
-  Reformated sources in libpng style (3-space intentation, comment format)
-  Fixed typo in libpng docs (PNG_FILTER_AVE should be PNG_FILTER_AVG)
-  Added sections about the git repository and our coding style to the
-    documentation
-  Relocated misplaced #endif in pngwrite.c, sCAL chunk handler.
-
-Version 1.4.0beta60 [May 19, 2009]
-  Conditionally compile png_read_finish_row() which is not used by
-    progressive readers.
-  Added contrib/pngminim/preader to demonstrate building minimal progressive
-    decoder, based on contrib/gregbook with embedded libpng and zlib.
-
-Version 1.4.0beta61 [May 20, 2009]
-  In contrib/pngminim/*, renamed "makefile.std" to "makefile", since there
-    is only one makefile in those directories, and revised the README files
-    accordingly.
-  More reformatting of comments, mostly to capitalize sentences.
-
-Version 1.4.0beta62 [June 2, 2009]
-  Added "#define PNG_NO_WRITE_SWAP" to contrib/pngminim/encoder/pngusr.h
-    and "define PNG_NO_READ_SWAP" to decoder/pngusr.h and preader/pngusr.h
-  Reformatted several remaining "else statement" into two lines.
-  Added a section to the libpng documentation about using png_get_io_ptr()
-    in configure scripts to detect the presence of libpng.
-
-Version 1.4.0beta63 [June 15, 2009]
-  Revised libpng*.txt and libpng.3 to mention calling png_set_IHDR()
-    multiple times and to specify the sample order in the tRNS chunk,
-    because the ISO PNG specification has a typo in the tRNS table.
-  Changed several PNG_UNKNOWN_CHUNK_SUPPORTED to
-    PNG_HANDLE_AS_UNKNOWN_SUPPORTED, to make the png_set_keep mechanism
-    available for ignoring known chunks even when not saving unknown chunks.
-  Adopted preference for consistent use of "#ifdef" and "#ifndef" versus
-    "#if defined()" and "if !defined()" where possible.
-
-Version 1.4.0beta64 [June 24, 2009]
-  Eliminated PNG_LEGACY_SUPPORTED code.
-  Moved the various unknown chunk macro definitions outside of the
-     PNG_READ|WRITE_ANCILLARY_CHUNK_SUPPORTED blocks.
-
-Version 1.4.0beta65 [June 26, 2009]
-  Added a reference to the libpng license in each file.
-
-Version 1.4.0beta66 [June 27, 2009]
-  Refer to the libpng license instead of the libpng license in each file.
-
-Version 1.4.0beta67 [July 6, 2009]
-  Relocated INVERT_ALPHA within png_read_png() and png_write_png().
-  Added high-level API transform PNG_TRANSFORM_GRAY_TO_RGB.
-  Added an "xcode" project to the projects directory (Alam Arias).
-
-Version 1.4.0beta68 [July 19, 2009]
-  Avoid some tests in filter selection in pngwutil.c
-
-Version 1.4.0beta69 [July 25, 2009]
-  Simplified the new filter-selection test.  This runs faster in the
-    common "PNG_ALL_FILTERS" and PNG_FILTER_NONE cases.
-  Removed extraneous declaration from the new call to png_read_gray_to_rgb()
-    (bug introduced in libpng-1.4.0beta67).
-  Fixed up xcode project (Alam Arias)
-  Added a prototype for png_64bit_product() in png.c
-
-Version 1.4.0beta70 [July 27, 2009]
-  Avoid a possible NULL dereference in debug build, in png_set_text_2().
-    (bug introduced in libpng-0.95, discovered by Evan Rouault)
-
-Version 1.4.0beta71 [July 29, 2009]
-  Rebuilt configure scripts with autoconf-2.64.
-
-Version 1.4.0beta72 [August 1, 2009]
-  Replaced *.tar.lzma with *.tar.xz in distribution.  Get the xz codec
-    from <http://tukaani.org/xz>.
-
-Version 1.4.0beta73 [August 1, 2009]
-  Reject attempt to write iCCP chunk with negative embedded profile length
-    (JD Chen) (CVE-2009-5063).
-
-Version 1.4.0beta74 [August 8, 2009]
-  Changed png_ptr and info_ptr member "trans" to "trans_alpha".
-
-Version 1.4.0beta75 [August 21, 2009]
-  Removed an extra png_debug() recently added to png_write_find_filter().
-  Fixed incorrect #ifdef in pngset.c regarding unknown chunk support.
-
-Version 1.4.0beta76 [August 22, 2009]
-  Moved an incorrectly located test in png_read_row() in pngread.c
-
-Version 1.4.0beta77 [August 27, 2009]
-  Removed lpXYZ.tar.bz2 (with CRLF), KNOWNBUG, libpng-x.y.z-KNOWNBUG.txt,
-    and the "noconfig" files from the distribution.
-  Moved CMakeLists.txt from scripts into the main libpng directory.
-  Various bugfixes and improvements to CMakeLists.txt (Philip Lowman)
-
-Version 1.4.0beta78 [August 31, 2009]
-  Converted all PNG_NO_* tests to PNG_*_SUPPORTED everywhere except pngconf.h
-  Eliminated PNG_NO_FREE_ME and PNG_FREE_ME_SUPPORTED macros.
-  Use png_malloc plus a loop instead of png_calloc() to initialize
-    row_pointers in png_read_png().
-
-Version 1.4.0beta79 [September 1, 2009]
-  Eliminated PNG_GLOBAL_ARRAYS and PNG_LOCAL_ARRAYS; always use local arrays.
-  Eliminated PNG_CALLOC_SUPPORTED macro and always provide png_calloc().
-
-Version 1.4.0beta80 [September 17, 2009]
-  Removed scripts/libpng.icc
-  Changed typecast of filler from png_byte to png_uint_16 in png_set_filler().
-    (Dennis Gustafsson)
-  Fixed typo introduced in beta78 in pngtest.c ("#if def " should be "#ifdef ")
-
-Version 1.4.0beta81 [September 23, 2009]
-  Eliminated unused PNG_FLAG_FREE_* defines from pngpriv.h
-  Expanded TAB characters in pngrtran.c
-  Removed PNG_CONST from all "PNG_CONST PNG_CHNK" declarations to avoid
-    compiler complaints about doubly declaring things "const".
-  Changed all "#if [!]defined(X)" to "if[n]def X" where possible.
-  Eliminated unused png_ptr->row_buf_size
-
-Version 1.4.0beta82 [September 25, 2009]
-  Moved redundant IHDR checking into new png_check_IHDR() in png.c
-    and report all errors found in the IHDR data.
-  Eliminated useless call to png_check_cHRM() from pngset.c
-
-Version 1.4.0beta83 [September 25, 2009]
-  Revised png_check_IHDR() to eliminate bogus complaint about filter_type.
-
-Version 1.4.0beta84 [September 30, 2009]
-  Fixed some inconsistent indentation in pngconf.h
-  Revised png_check_IHDR() to add a test for width variable less than 32-bit.
-
-Version 1.4.0beta85 [October 1, 2009]
-  Revised png_check_IHDR() again, to check info_ptr members instead of
-    the contents of the returned parameters.
-
-Version 1.4.0beta86 [October 9, 2009]
-  Updated the "xcode" project (Alam Arias).
-  Eliminated a shadowed declaration of "pp" in png_handle_sPLT().
-
-Version 1.4.0rc01 [October 19, 2009]
-  Trivial cosmetic changes.
-
-Version 1.4.0beta87 [October 30, 2009]
-  Moved version 1.4.0 back into beta.
-
-Version 1.4.0beta88 [October 30, 2009]
-  Revised libpng*.txt section about differences between 1.2.x and 1.4.0
-    because most of the new features have now been ported back to 1.2.41
-
-Version 1.4.0beta89 [November 1, 2009]
-  More bugfixes and improvements to CMakeLists.txt (Philip Lowman)
-  Removed a harmless extra png_set_invert_alpha() from pngwrite.c
-  Apply png_user_chunk_cache_max within png_decompress_chunk().
-  Merged libpng-1.2.41.txt with libpng-1.4.0.txt where appropriate.
-
-Version 1.4.0beta90 [November 2, 2009]
-  Removed all remaining WIN32_WCE #ifdefs except those involving the
-    time.h "tm" structure
-
-Version 1.4.0beta91 [November 3, 2009]
-  Updated scripts/pngw32.def and projects/wince/png32ce.def
-  Copied projects/wince/png32ce.def to the scripts directory.
-  Added scripts/makefile.wce
-  Patched ltmain.sh for wince support.
-  Added PNG_CONVERT_tIME_SUPPORTED macro.
-
-Version 1.4.0beta92 [November 4, 2009]
-  Make inclusion of time.h in pngconf.h depend on PNG_CONVERT_tIME_SUPPORTED
-  Make #define PNG_CONVERT_tIME_SUPPORTED depend on PNG_WRITE_tIME_SUPPORTED
-  Revised libpng*.txt to describe differences from 1.2.40 to 1.4.0 (instead
-    of differences from 1.2.41 to 1.4.0)
-
-Version 1.4.0beta93 [November 7, 2009]
-  Added PNG_DEPSTRUCT, PNG_DEPRECATED, PNG_USE_RESULT, PNG_NORETURN, and
-    PNG_ALLOCATED macros to detect deprecated direct access to the
-    png_struct or info_struct members and other deprecated usage in
-    applications (John Bowler).
-  Updated scripts/makefile* to add "-DPNG_CONFIGURE_LIBPNG" to CFLAGS,
-    to prevent warnings about direct access to png structs by libpng
-    functions while building libpng.  They need to be tested, especially
-    those using compilers other than gcc.
-  Updated projects/visualc6 and visualc71 with "/d PNG_CONFIGURE_LIBPNG".
-    They should work but still need to be updated to remove
-    references to pnggccrd.c or pngvcrd.c and ASM building.
-  Added README.txt to the beos, cbuilder5, netware, and xcode projects warning
-    that they need to be updated, to remove references to pnggccrd.c and
-    pngvcrd.c and to depend on pngpriv.h
-  Removed three direct references to read_info_ptr members in pngtest.c
-    that were detected by the new PNG_DEPSTRUCT macro.
-  Moved the png_debug macro definitions and the png_read_destroy(),
-    png_write_destroy() and png_far_to_near() prototypes from png.h
-    to pngpriv.h (John Bowler)
-  Moved the synopsis lines for png_read_destroy(), png_write_destroy()
-    png_debug(), png_debug1(), and png_debug2() from libpng.3 to libpngpf.3.
-
-Version 1.4.0beta94 [November 9, 2009]
-  Removed the obsolete, unused pnggccrd.c and pngvcrd.c files.
-  Updated CMakeLists.txt to add "-DPNG_CONFIGURE_LIBPNG" to the definitions.
-  Removed dependency of pngtest.o on pngpriv.h in the makefiles.
-  Only #define PNG_DEPSTRUCT, etc. in pngconf.h if not already defined.
-
-Version 1.4.0beta95 [November 10, 2009]
-  Changed png_check_sig() to !png_sig_cmp() in contrib programs.
-  Added -DPNG_CONFIGURE_LIBPNG to contrib/pngminm/*/makefile
-  Changed png_check_sig() to !png_sig_cmp() in contrib programs.
-  Corrected the png_get_IHDR() call in contrib/gregbook/readpng2.c
-  Changed pngminim/*/gather.sh to stop trying to remove pnggccrd.c and pngvcrd.c
-  Added dependency on pngpriv.h in contrib/pngminim/*/makefile
-
-Version 1.4.0beta96 [November 12, 2009]
-  Renamed scripts/makefile.wce to scripts/makefile.cegcc
-  Revised Makefile.am to use libpng.sys while building libpng.so
-    so that only PNG_EXPORT functions are exported.
-  Removed the deprecated png_check_sig() function/macro.
-  Removed recently removed function names from scripts/*.def
-  Revised pngtest.png to put chunks in the same order written by pngtest
-    (evidently the same change made in libpng-1.0beta54 was lost).
-  Added PNG_PRIVATE macro definition in pngconf.h for possible future use.
-
-Version 1.4.0beta97 [November 13, 2009]
-  Restored pngtest.png to the libpng-1.4.0beta7 version.
-  Removed projects/beos and netware.txt; no one seems to be supporting them.
-  Revised Makefile.in
-
-Version 1.4.0beta98 [November 13, 2009]
-  Added the "xcode" project to zip distributions,
-  Fixed a typo in scripts/pngwin.def introduced in beta97.
-
-Version 1.4.0beta99 [November 14, 2009]
-  Moved libpng-config.in and libpng.pc-configure.in out of the scripts
-    directory, to libpng-config.in and libpng-pc.in, respectively, and
-    modified Makefile.am and configure.ac accordingly.  Now "configure"
-    needs nothing from the "scripts" directory.
-  Avoid redefining PNG_CONST in pngconf.h
-
-Version 1.4.0beta100 [November 14, 2009]
-  Removed ASM builds from projects/visualc6 and projects/visualc71
-  Removed scripts/makefile.nommx and makefile.vcawin32
-  Revised CMakeLists.txt to account for new location of libpng-config.in
-    and libpng-pc.in
-  Updated INSTALL to reflect removal and relocation of files.
-
-Version 1.4.0beta101 [November 14, 2009]
-  Restored the binary files (*.jpg, *.png, some project files) that were
-    accidentally deleted from the zip and 7z distributions when the xcode
-    project was added.
-
-Version 1.4.0beta102 [November 18, 2009]
-  Added libpng-config.in and libpng-pc.in to the zip and 7z distributions.
-  Fixed a typo in projects/visualc6/pngtest.dsp, introduced in beta100.
-  Moved descriptions of makefiles and other scripts out of INSTALL into
-    scripts/README.txt
-  Updated the copyright year in scripts/pngwin.rc from 2006 to 2009.
-
-Version 1.4.0beta103 [November 21, 2009]
-  Removed obsolete comments about ASM from projects/visualc71/README_zlib.txt
-  Align row_buf on 16-byte boundary in memory.
-  Restored the PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED guard around the call
-    to png_flush() after png_write_IEND().  See 1.4.0beta32, 1.4.0beta50
-    changes above and 1.2.30, 1.2.30rc01 and rc03 in 1.2.41 CHANGES.  Someone
-    needs this feature.
-  Make the 'png_jmpbuf' macro expand to a call that records the correct
-    longjmp function as well as returning a pointer to the setjmp
-    jmp_buf buffer, and marked direct access to jmpbuf 'deprecated'.
-    (John Bowler)
-
-Version 1.4.0beta104 [November 22, 2009]
-  Removed png_longjmp_ptr from scripts/*.def and libpng.3
-  Rebuilt configure scripts with autoconf-2.65
-
-Version 1.4.0beta105 [November 25, 2009]
-  Use fast integer PNG_DIVIDE_BY_255() or PNG_DIVIDE_BY_65535()
-    to accomplish alpha premultiplication when
-    PNG_READ_COMPOSITE_NODIV_SUPPORTED is defined.
-  Changed "/255" to "/255.0" in background calculations to make it clear
-    that the 255 is used as a double.
-
-Version 1.4.0beta106 [November 27, 2009]
-  Removed premultiplied alpha feature.
-
-Version 1.4.0beta107 [December 4, 2009]
-  Updated README
-  Added "#define PNG_NO_PEDANTIC_WARNINGS" in the libpng source files.
-  Removed "-DPNG_CONFIGURE_LIBPNG" from the makefiles and projects.
-  Revised scripts/makefile.netbsd, makefile.openbsd, and makefile.sco
-    to put png.h and pngconf.h in $prefix/include, like the other scripts,
-    instead of in $prefix/include/libpng.  Also revised makefile.sco
-    to put them in $prefix/include/libpng15 instead of in
-    $prefix/include/libpng/libpng15.
-
-Version 1.4.0beta108 [December 11, 2009]
-  Removed leftover "-DPNG_CONFIGURE_LIBPNG" from contrib/pngminim/*/makefile
-  Relocated png_do_chop() to its original position in pngrtran.c; the
-    change in version 1.2.41beta08 caused transparency to be handled wrong
-    in some 16-bit datastreams (Yusaku Sugai).
-
-Version 1.4.0beta109 [December 13, 2009]
-  Added "bit_depth" parameter to the private png_build_gamma_table() function.
-  Pass bit_depth=8 to png_build_gamma_table() when bit_depth is 16 but the
-    PNG_16_TO_8 transform has been set, to avoid unnecessary build of 16-bit
-    tables.
-
-Version 1.4.0rc02 [December 20, 2009]
-  Declared png_cleanup_needed "volatile" in pngread.c and pngwrite.c
-
-Version 1.4.0rc03 [December 22, 2009]
-  Renamed libpng-pc.in back to libpng.pc.in and revised CMakeLists.txt
-    (revising the change in 1.4.0beta99)
-
-Version 1.4.0rc04 [December 25, 2009]
-  Swapped PNG_UNKNOWN_CHUNKS_SUPPORTED and PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-    in pngset.c to be consistent with other changes in version 1.2.38.
-
-Version 1.4.0rc05 [December 25, 2009]
-  Changed "libpng-pc.in" to "libpng.pc.in" in configure.ac, configure, and
-    Makefile.in to be consistent with changes in libpng-1.4.0rc03
-
-Version 1.4.0rc06 [December 29, 2009]
-  Reverted the gamma_table changes from libpng-1.4.0beta109.
-  Fixed some indentation errors.
-
-Version 1.4.0rc07 [January 1, 2010]
-  Revised libpng*.txt and libpng.3 about 1.2.x->1.4.x differences.
-  Use png_calloc() instead of png_malloc(); png_memset() in pngrutil.c
-  Update copyright year to 2010.
-
-Version 1.4.0rc08 [January 2, 2010]
-  Avoid deprecated references to png_ptr-io_ptr and png_ptr->error_ptr
-    in pngtest.c
-
-Version 1.4.0 [January 3, 2010]
-  No changes.
-
-Version 1.4.1beta01 [January 8, 2010]
-  Updated CMakeLists.txt for consistent indentation and to avoid an
-    unclosed if-statement warning (Philip Lowman).
-  Revised Makefile.am and Makefile.in to remove references to Y2KINFO,
-    KNOWNBUG, and libpng.la (Robert Schwebel).
-  Revised the makefiles to install the same files and symbolic
-    links as configure, except for libpng.la and libpng14.la.
-  Make png_set|get_compression_buffer_size() available even when
-    PNG_WRITE_SUPPORTED is not enabled.
-  Revised Makefile.am and Makefile.in to simplify their maintenance.
-  Revised scripts/makefile.linux to install a link to libpng14.so.14.1
-
-Version 1.4.1beta02 [January 9, 2010]
-  Revised the rest of the makefiles to install a link to libpng14.so.14.1
-
-Version 1.4.1beta03 [January 10, 2010]
-  Removed png_set_premultiply_alpha() from scripts/*.def
-
-Version 1.4.1rc01 [January 16, 2010]
-  No changes.
-
-Version 1.4.1beta04 [January 23, 2010]
-  Revised png_decompress_chunk() to improve speed and memory usage when
-    decoding large chunks.
-  Added png_set|get_chunk_malloc_max() functions.
-
-Version 1.4.1beta05 [January 26, 2010]
-  Relocated "int k" declaration in pngtest.c to minimize its scope.
-
-Version 1.4.1beta06 [January 28, 2010]
-  Revised png_decompress_chunk() to use a two-pass method suggested by
-    John Bowler.
-
-Version 1.4.1beta07 [February 6, 2010]
-  Folded some long lines in the source files.
-  Added defineable PNG_USER_CHUNK_CACHE_MAX, PNG_USER_CHUNK_MALLOC_MAX,
-    and a PNG_USER_LIMITS_SUPPORTED flag.
-  Eliminated use of png_ptr->irowbytes and reused the slot in png_ptr as
-    png_ptr->png_user_chunk_malloc_max.
-  Revised png_push_save_buffer() to do fewer but larger png_malloc() calls.
-
-Version 1.4.1beta08 [February 6, 2010]
-  Minor cleanup and updating of dates and copyright year.
-
-Version 1.5.0beta01 [February 7, 2010]
-  Moved declaration of png_struct into private pngstruct.h and png_info
-    into pnginfo.h
-
-Version 1.4.1beta09 and 1.5.0beta02 [February 7, 2010]
-  Reverted to original png_push_save_buffer() code.
-
-Version 1.4.1beta10 and 1.5.0beta03 [February 8, 2010]
-  Return allocated "old_buffer" in png_push_save_buffer() before
-    calling png_error(), to avoid a potential memory leak.
-  Updated configure script to use SO number 15.
-
-Version 1.5.0beta04 [February 9, 2010]
-  Removed malformed "incomplete struct declaration" of png_info from png.h
-
-Version 1.5.0beta05 [February 12, 2010]
-  Removed PNG_DEPSTRUCT markup in pngstruct.h and pnginfo.h, and undid the
-    linewrapping that it entailed.
-  Revised comments in pngstruct.h and pnginfo.h and added pointers to
-    the libpng license.
-  Changed PNG_INTERNAL to PNG_EXPOSE_INTERNAL_STRUCTURES
-  Removed the cbuilder5 project, which has not been updated to 1.4.0.
-
-Version 1.4.1beta12 and 1.5.0beta06 [February 14, 2010]
-  Fixed type declaration of png_get_chunk_malloc_max() in pngget.c (Daisuke
-    Nishikawa)
-
-Version 1.5.0beta07 [omitted]
-
-Version 1.5.0beta08 [February 19, 2010]
-  Changed #ifdef PNG_NO_STDIO_SUPPORTED to #ifdef PNG_NO_CONSOLE_IO_SUPPORTED
-    wherever png_snprintf() is used to construct error and warning messages.
-  Noted in scripts/makefile.mingw that it expects to be run under MSYS.
-  Removed obsolete unused MMX-querying support from contrib/gregbook
-  Added exported png_longjmp() function.
-  Removed the AIX redefinition of jmpbuf in png.h
-  Added -D_ALLSOURCE in configure.ac, makefile.aix, and CMakeLists.txt
-    when building on AIX.
-
-Version 1.5.0beta09 [February 19, 2010]
-  Removed -D_ALLSOURCE from configure.ac, makefile.aix, and CMakeLists.txt.
-  Changed the name of png_ptr->jmpbuf to png_ptr->png_jmpbuf in pngstruct.h
-
-Version 1.5.0beta10 [February 25, 2010]
-  Removed unused gzio.c from contrib/pngminim gather and makefile scripts
-  Removed replacement error handlers from contrib/gregbook.  Because of
-    the new png_longjmp() function they are no longer needed.
-
-Version 1.5.0beta11 [March 6, 2010]
-  Removed checking for already-included setjmp.h from pngconf.h
-  Fixed inconsistent indentations and made numerous cosmetic changes.
-  Revised the "SEE ALSO" style of libpng.3, libpngpf.3, and png.5
-
-Version 1.5.0beta12 [March 9, 2010]
-  Moved "#include png.h" inside pngpriv.h and removed "#include png.h" from
-    the source files, along with "#define PNG_EXPOSE_INTERNAL_STRUCTURES"
-    and "#define PNG_NO_PEDANTIC_WARNINGS" (John Bowler).
-  Created new pngdebug.h and moved debug definitions there.
-
-Version 1.5.0beta13 [March 10, 2010]
-  Protect pngstruct.h, pnginfo.h, and pngdebug.h from being included twice.
-  Revise the "#ifdef" blocks in png_inflate() so it will compile when neither
-    PNG_USER_CHUNK_MALLOC_MAX nor PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
-    is defined.
-  Removed unused png_measure_compressed_chunk() from pngpriv.h and libpngpf.3
-  Moved the 'config.h' support from pngconf.h to pngpriv.h
-  Removed PNGAPI from the png_longjmp_ptr typedef.
-  Eliminated dependence of pngtest.c on the private pngdebug.h file.
-  Make all png_debug macros into *unterminated* statements or
-    expressions (i.e. a trailing ';' must always be added) and correct
-    the format statements in various png_debug messages.
-
-Version 1.5.0beta14 [March 14, 2010]
-  Removed direct access to png_ptr->io_ptr from the Windows code in pngtest.c
-  Revised Makefile.am to account for recent additions and replacements.
-  Corrected CE and OS/2 DEF files (scripts/png*def) for symbols removed and
-    added ordinal numbers to the Windows DEF file and corrected the duplicated
-    ordinal numbers on CE symbols that are commented out.
-  Added back in export symbols that can be present in the Windows build but
-    are disabled by default.
-  PNG_EXPORT changed to include an 'ordinal' field for DEF file generation.
-    PNG_CALLBACK added to make callback definitions uniform.  PNGAPI split
-    into PNGCAPI (base C form), PNGAPI (exports) and PNGCBAPI (callbacks),
-    and appropriate changes made to all files.  Cygwin builds re-hinged to
-    allow procedure call standard changes and to remove the need for the DEF
-    file (fixes build on Cygwin).
-  Enabled 'attribute' warnings that are relevant to library APIs and callbacks.
-  Changed rules for generation of the various symbol files and added a new
-    rule for a DEF file (which is also added to the distribution).
-  Updated the symbol file generation to stop it adding spurious spaces
-    to EOL (coming from preprocessor macro expansion).  Added a facility
-    to join tokens in the output and rewrite *.dfn to use this.
-  Eliminated scripts/*.def in favor of libpng.def; updated projects/visualc71
-    and removed scripts/makefile.cygwin.
-  Made PNG_BUILD_DLL safe: it can be set whenever a DLL is being built.
-  Removed the include of sys/types.h - apparently unnecessary now on the
-    platforms on which it happened (all but Mac OS and RISC OS).
-  Moved the Mac OS test into pngpriv.h (the only place it is used.)
-
-Version 1.5.0beta15 [March 17, 2010]
-  Added symbols.chk target to Makefile.am to validate the symbols in png.h
-    against the new DEF file scripts/symbols.def.
-  Changed the default DEF file back to pngwin.def.
-  Removed makefile.mingw.
-  Eliminated PNG_NO_EXTERN and PNG_ALL_EXTERN
-
-Version 1.5.0beta16 [April 1, 2010]
-  Make png_text_struct independent of PNG_iTXt_SUPPORTED, so that
-    fields are initialized in all configurations.  The READ/WRITE
-    macros (PNG_(READ|WRITE)_iTXt_SUPPORTED) still function as
-    before to disable code to actually read or write iTXt chunks
-    and iTXt_SUPPORTED can be used to detect presence of either
-    read or write support (but it is probably better to check for
-    the one actually required - read or write.)
-  Combined multiple png_warning() calls for a single error.
-  Restored the macro definition of png_check_sig().
-
-Version 1.5.0beta17 [April 17, 2010]
-  Added some "(long)" typecasts to printf calls in png_handle_cHRM().
-  Documented the fact that png_set_dither() was disabled since libpng-1.4.0.
-  Reenabled png_set_dither() but renamed it to png_set_quantize() to reflect
-    more accurately what it actually does.  At the same time, renamed
-    the PNG_DITHER_[RED,GREEN_BLUE]_BITS macros to
-    PNG_QUANTIZE_[RED,GREEN,BLUE]_BITS.
-  Added some "(long)" typecasts to printf calls in png_handle_cHRM().
-  Freeze build-time only configuration in the build.
-    In all prior versions of libpng most configuration options
-    controlled by compiler #defines had to be repeated by the
-    application code that used libpng.  This patch changes this
-    so that compilation options that can only be changed at build
-    time are frozen in the build.  Options that are compiler
-    dependent (and those that are system dependent) are evaluated
-    each time - pngconf.h holds these.  Options that can be changed
-    per-file in the application are in png.h.  Frozen options are
-    in the new installed header file pnglibconf.h (John Bowler)
-  Removed the xcode project because it has not been updated to work
-    with libpng-1.5.0.
-  Removed the ability to include optional pngusr.h
-
-Version 1.5.0beta18 [April 17, 2010]
-  Restored the ability to include optional pngusr.h
-  Moved replacements for png_error() and png_warning() from the
-    contrib/pngminim project to pngerror.c, for use when warnings or
-    errors are disabled via PNG_NO_WARN or PNG_NO_ERROR_TEXT, to avoid
-    storing unneeded error/warning text.
-  Updated contrib/pngminim project to work with the new pnglibconf.h
-  Added some PNG_NO_* defines to contrib/pngminim/*/pngusr.h to save space.
-
-Version 1.5.0beta19 [April 24, 2010]
-  Added PNG_{READ,WRITE}_INT_FUNCTIONS_SUPPORTED.  This allows the functions
-    to read and write ints to be disabled independently of PNG_USE_READ_MACROS,
-    which allows libpng to be built with the functions even though the default
-    is to use the macros - this allows applications to choose at app build
-    time whether or not to use macros (previously impossible because the
-    functions weren't in the default build.)
-  Changed Windows calling convention back to __cdecl for API functions.
-    For Windows/x86 platforms only:
-      __stdcall is no longer needed for Visual Basic, so libpng-1.5.0 uses
-      __cdecl throughout (both API functions and callbacks) on Windows/x86
-      platforms.
-  Replaced visualc6 and visualc71 projects with new vstudio project
-  Relaxed the overly-restrictive permissions of some files.
-
-Version 1.5.0beta20 [April 24, 2010]
-  Relaxed more overly-restrictive permissions of some files.
-
-Version 1.5.0beta21 [April 27, 2010]
-  Removed some unwanted binary bytes and changed CRLF to NEWLINE in the new
-    vstudio project files, and some trivial editing of some files in the
-    scripts directory.
-  Set PNG_NO_READ_BGR, PNG_NO_IO_STATE, and PNG_NO_TIME_RFC1123 in
-    contrib/pngminim/decoder/pngusr.h to make a smaller decoder application.
-
-Version 1.5.0beta22 [April 28, 2010]
-  Fixed dependencies of GET_INT_32 - it does not require READ_INT_FUNCTIONS
-    because it has a macro equivalent.
-  Improved the options.awk script; added an "everything off" option.
-  Revised contrib/pngminim to use the "everything off" option in pngusr.dfa.
-
-Version 1.5.0beta23 [April 29, 2010]
-  Corrected PNG_REMOVED macro to take five arguments.
-    The macro was documented with two arguments (name,ordinal), however
-    the symbol checking .dfn files assumed five arguments.  The five
-    argument form seems more useful so it is changed to that.
-  Corrected PNG_UNKNOWN_CHUNKS_SUPPORTED to PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-    in gregbook/readpng2.c
-  Corrected protection of png_get_user_transform_ptr. The API declaration in
-    png.h is removed if both READ and WRITE USER_TRANSFORM are turned off
-    but was left defined in pngtrans.c
-  Added logunsupported=1 to cause pnglibconf.h to document disabled options.
-    This makes the installed pnglibconf.h more readable but causes no
-    other change.  The intention is that users of libpng will find it
-    easier to understand if an API they need is missing.
-  Include png_reset_zstream() in png.c only when PNG_READ_SUPPORTED is defined.
-  Removed dummy_inflate.c from contrib/pngminim/encoder
-  Removed contrib/pngminim/*/gather.sh; gathering is now done in the makefile.
-
-Version 1.5.0beta24 [May 7, 2010]
-  Use bitwise "&" instead of arithmetic mod in pngrutil.c calculation of the
-    offset of the png_ptr->rowbuf pointer into png_ptr->big_row_buf.
-  Added more blank lines for readability.
-
-Version 1.5.0beta25 [June 18, 2010]
-  In pngpread.c: png_push_have_row() add check for new_row > height
-  Removed the now-redundant check for out-of-bounds new_row from example.c
-
-Version 1.5.0beta26 [June 18, 2010]
-  In pngpread.c: png_push_process_row() add check for too many rows.
-
-Version 1.5.0beta27 [June 18, 2010]
-  Removed the check added in beta25 as it is now redundant.
-
-Version 1.5.0beta28 [June 20, 2010]
-  Rewrote png_process_IDAT_data to consistently treat extra data as warnings
-    and handle end conditions more cleanly.
-  Removed the new (beta26) check in png_push_process_row().
-
-Version 1.5.0beta29 [June 21, 2010]
-  Revised scripts/options.awk to work on Sunos (but still doesn't work)
-  Added comment to options.awk and contrib/pngminim/*/makefile to try nawk.
-
-Version 1.5.0beta30 [June 22, 2010]
-  Stop memory leak when reading a malformed sCAL chunk.
-
-Version 1.5.0beta31 [June 26, 2010]
-  Revised pngpread.c patch of beta28 to avoid an endless loop.
-  Removed some trailing blanks.
-
-Version 1.5.0beta32 [June 26, 2010]
-  Removed leftover scripts/options.patch and scripts/options.rej
-
-Version 1.5.0beta33 [July 6, 3010]
-  Made FIXED and FLOATING options consistent in the APIs they enable and
-    disable.  Corrected scripts/options.awk to handle both command line
-    options and options specified in the .dfa files.
-  Changed char *msg to PNG_CONST char *msg in pngrutil.c
-  Make png_set_sRGB_gAMA_and_cHRM set values using either the fixed or
-    floating point APIs, but not both.
-  Reversed patch to remove error handler when the jmp_buf is stored in the
-    main program structure, not the png_struct.
-    The error handler is needed because the default handler in libpng will
-    always use the jmp_buf in the library control structure; this is never
-    set.  The gregbook code is a useful example because, even though it
-    uses setjmp/longjmp, it shows how error handling can be implemented
-    using control mechanisms not directly supported by libpng.  The
-    technique will work correctly with mechanisms such as Microsoft
-    Structure Exceptions or C++ exceptions (compiler willing - note that gcc
-    does not by default support interworking of C and C++ error handling.)
-  Reverted changes to call png_longjmp in contrib/gregbook where it is not
-    appropriate.  If mainprog->jmpbuf is used by setjmp, then png_longjmp
-    cannot be used.
-  Changed "extern PNG_EXPORT" to "PNG_EXPORT" in png.h (Jan Nijtmans)
-  Changed "extern" to "PNG_EXTERN" in pngpriv.h (except for the 'extern "C" {')
-
-Version 1.5.0beta34 [July 12, 2010]
-  Put #ifndef PNG_EXTERN, #endif around the define PNG_EXTERN in pngpriv.h
-
-Version 1.5.0beta35 [July 24, 2010]
-  Removed some newly-added TAB characters.
-  Added -DNO_PNG_SNPRINTF to CFLAGS in scripts/makefile.dj2
-  Moved the definition of png_snprintf() outside of the enclosing
-    #ifdef blocks in pngconf.h
-
-Version 1.5.0beta36 [July 29, 2010]
-  Patches by John Bowler:
-  Fixed point APIs are now supported throughout (no missing APIs).
-  Internal fixed point arithmetic support exists for all internal floating
-    point operations.
-  sCAL validates the floating point strings it is passed.
-  Safe, albeit rudimentary, Watcom support is provided by PNG_API_RULE==2
-  Two new APIs exist to get the number of passes without turning on the
-    PNG_INTERLACE transform and to get the number of rows in the current
-    pass.
-  A new test program, pngvalid.c, validates the gamma code.
-  Errors in the 16-bit gamma correction (overflows) have been corrected.
-  cHRM chunk testing is done consistently (previously the floating point
-    API bypassed it, because the test really didn't work on FP, now the test
-    is performed on the actual values to be stored in the PNG file so it
-    works in the FP case too.)
-  Most floating point APIs now simply call the fixed point APIs after
-    converting the values to the fixed point form used in the PNG file.
-  The standard headers no longer include zlib.h, which is currently only
-    required for pngstruct.h and can therefore be internal.
-  Revised png_get_int_32 to undo the PNG two's complement representation of
-    negative numbers.
-
-Version 1.5.0beta37 [July 30, 2010]
-  Added a typecast in png_get_int_32() in png.h and pngrutil.h to avoid
-    a compiler warning.
-  Replaced oFFs 0,0 with oFFs -10,20 in pngtest.png
-
-Version 1.5.0beta38 [July 31, 2010]
-  Implemented remaining "_fixed" functions.
-  Corrected a number of recently introduced warnings mostly resulting from
-    safe but uncast assignments to shorter integers.  Also added a zlib
-    VStudio release library project because the latest zlib Official Windows
-    build does not include such a thing.
-  Revised png_get_int_16() to be similar to png_get_int_32().
-  Restored projects/visualc71.
-
-Version 1.5.0beta39 [August 2, 2010]
-  VisualC/GCC warning fixes, VisualC build fixes
-  The changes include support for function attributes in VC in addition to
-    those already present in GCC - necessary because without these some
-    warnings are unavoidable.  Fixes include signed/unsigned fixes in
-    pngvalid and checks with gcc -Wall -Wextra -Wunused.
-  VC requires function attributes on function definitions as well as
-    declarations, PNG_FUNCTION has been added to enable this and the
-    relevant function definitions changed.
-
-Version 1.5.0beta40 [August 6, 2010]
-  Correct use of _WINDOWS_ in pngconf.h
-  Removed png_mem_ #defines; they are no longer used.
-  Added the sRGB chunk to pngtest.png
-
-Version 1.5.0beta41 [August 11, 2010]
-  Added the cHRM chunk to pngtest.png
-  Don't try to use version-script with cygwin/mingw.
-  Revised contrib/gregbook to work under cygwin/mingw.
-
-Version 1.5.0beta42 [August 18, 2010]
-  Add .dll.a to the list of extensions to be symlinked by Makefile.am (Yaakov)
-  Made all API functions that have const arguments and constant string
-    literal pointers declare them (John Bowler).
-
-Version 1.5.0beta43 [August 20, 2010]
-  Removed spurious tabs, shorten long lines (no source change)
-    Also added scripts/chkfmt to validate the format of all the files that can
-    reasonably be validated (it is suggested to run "make distclean" before
-    checking, because some machine generated files have long lines.)
-  Reformatted the CHANGES file to be more consistent throughout.
-  Made changes to address various issues identified by GCC, mostly
-    signed/unsigned and shortening problems on assignment but also a few
-    difficult to optimize (for GCC) loops.
-  Fixed non-GCC fixed point builds.  In png.c a declaration was misplaced
-    in an earlier update.  Fixed to declare the auto variables at the head.
-  Use cexcept.h in pngvalid.c.
-
-Version 1.5.0beta44 [August 24, 2010]
-  Updated CMakeLists.txt to use CMAKE_INSTALL_LIBDIR variable; useful for
-    installing libpng in /usr/lib64 (Funda Wang).
-  Revised CMakeLists.txt to put the man pages in share/man/man* not man/man*
-  Revised CMakeLists.txt to make symlinks instead of copies when installing.
-  Changed PNG_LIB_NAME from pngNN to libpngNN in CMakeLists.txt (Philip Lowman)
-  Implemented memory checks within pngvalid
-  Reformatted/rearranged pngvalid.c to assist use of progressive reader.
-  Check interlaced images in pngvalid
-  Clarified pngusr.h comments in pnglibconf.dfa
-  Simplified the pngvalid error-handling code now that cexcept.h is in place.
-  Implemented progressive reader in pngvalid.c for standard tests
-  Implemented progressive read in pngvalid.c gamma tests
-  Turn on progressive reader in pngvalid.c by default and tidy code.
-
-Version 1.5.0beta45 [August 26, 2010]
-  Added an explicit make step to projects/vstudio for pnglibconf.h
-    Also corrected zlib.vcxproj into which Visual Studio had introduced
-    what it calls an "authoring error".  The change to make pnglibconf.h
-    simply copies the file; in the future it may actually generate the
-    file from scripts/pnglibconf.dfa as the other build systems do.
-  Changed pngvalid to work when floating point APIs are disabled
-  Renamed the prebuilt scripts/pnglibconf.h to scripts/pnglibconf.h.prebuilt
-  Supply default values for PNG_USER_PRIVATEBUILD and PNG_USER_DLLFNAME_POSTFIX
-    in pngpriv.h in case the user neglected to define them in their pngusr.h
-
-Version 1.5.0beta46 [August 28, 2010]
-  Added new private header files to libpng_sources in CMakeLists.txt
-  Added PNG_READ_16BIT, PNG_WRITE_16BIT, and PNG_16BIT options.
-  Added reference to scripts/pnglibconf.h.prebuilt in the visualc71 project.
-
-Version 1.5.0beta47 [September 11, 2010]
-  Fixed a number of problems with 64-bit compilation reported by Visual
-    Studio 2010 (John Bowler).
-
-Version 1.5.0beta48 [October 4, 2010]
-  Updated CMakeLists.txt (Philip Lowman).
-  Revised autogen.sh to recognize and use $AUTOCONF, $AUTOMAKE, $AUTOHEADER,
-    $AUTOPOINT, $ACLOCAL and $LIBTOOLIZE
-  Fixed problem with symbols creation in Makefile.am which was assuming that
-    all versions of ccp write to standard output by default (Martin Banky). The
-    bug was introduced in libpng-1.2.9beta5.
-  Removed unused mkinstalldirs.
-
-Version 1.5.0beta49 [October 8, 2010]
-  Undid Makefile.am revision of 1.5.0beta48.
-
-Version 1.5.0beta50 [October 14, 2010]
-  Revised Makefile.in to account for mkinstalldirs being removed.
-  Added some "(unsigned long)" typecasts in printf statements in pngvalid.c.
-  Suppressed a compiler warning in png_handle_sPLT().
-  Check for out-of-range text compression mode in png_set_text().
-
-Version 1.5.0beta51 [October 15, 2010]
-  Changed embedded dates to "(PENDING RELEASE) in beta releases (and future
-    rc releases) to minimize the difference between releases.
-
-Version 1.5.0beta52 [October 16, 2010]
-  Restored some of the embedded dates (in png.h, png.c, documentation, etc.)
-
-Version 1.5.0beta53 [October 18, 2010]
-  Updated INSTALL to mention using "make maintainer-clean" and to remove
-    obsolete statement about a custom ltmain.sh
-  Disabled "color-tests" by default in Makefile.am so it will work with
-    automake versions earlier than 1.11.1
-  Use document name "libpng-manual.txt" instead of "libpng-<version>.txt"
-    to simplify version differences.
-  Removed obsolete remarks about setjmp handling from INSTALL.
-  Revised and renamed the typedef in png.h and png.c that was designed
-    to catch library and header mismatch.
-
-Version 1.5.0beta54 [November 10, 2010]
-  Require 48 bytes, not 64 bytes, for big_row_buf in overflow checks.
-  Used a consistent structure for the pngget.c functions.
-
-Version 1.5.0beta55 [November 21, 2010]
-  Revised png_get_uint_32, png_get_int_32, png_get_uint_16 (Cosmin)
-  Moved reading of file signature into png_read_sig (Cosmin)
-  Fixed atomicity of chunk header serialization (Cosmin)
-  Added test for io_state in pngtest.c (Cosmin)
-  Added "#!/bin/sh" at the top of contrib/pngminim/*/gather.sh scripts.
-  Changes to remove gcc warnings (John Bowler)
-    Certain optional gcc warning flags resulted in warnings in libpng code.
-    With these changes only -Wconversion and -Wcast-qual cannot be turned on.
-    Changes are trivial rearrangements of code.  -Wconversion is not possible
-    for pngrutil.c (because of the widespread use of += et al on variables
-    smaller than (int) or (unsigned int)) and -Wcast-qual is not possible
-    with pngwio.c and pngwutil.c because the 'write' callback and zlib
-    compression both fail to declare their input buffers with 'const'.
-
-Version 1.5.0beta56 [December 7, 2010]
-  Added the private PNG_UNUSED() macro definition in pngpriv.h.
-  Added some commentary about PNG_EXPORT in png.h and pngconf.h
-  Revised PNG_EXPORT() macro and added PNG_EXPORTA() macro, with the
-    objective of simplifying and improving the cosmetic appearance of png.h.
-  Fixed some incorrect "=" macro names in pnglibconf.dfa
-  Included documentation of changes in 1.5.0 from 1.4.x in libpng-manual.txt
-
-Version 1.5.0beta57 [December 9, 2010]
-  Documented the pngvalid gamma error summary with additional comments and
-    print statements.
-  Improved missing symbol handling in checksym.awk; symbols missing in both
-    the old and new files can now be optionally ignored, treated as errors
-    or warnings.
-  Removed references to pngvcrd.c and pnggccrd.c from the vstudio project.
-  Updated "libpng14" to "libpng15" in the visualc71 project.
-  Enabled the strip16 tests in pngvalid.`
-  Don't display test results (except PASS/FAIL) when running "make test".
-    Instead put them in pngtest-log.txt
-  Added "--with-zprefix=<string>" to configure.ac
-  Updated the prebuilt configuration files to autoconf version 2.68
-
-Version 1.5.0beta58 [December 19, 2010]
-  Fixed interlace image handling and add test cases (John Bowler)
-  Fixed the clean rule in Makefile.am to remove pngtest-log.txt
-  Made minor changes to work around warnings in gcc 3.4
-
-Version 1.5.0rc01 [December 27, 2010]
-  No changes.
-
-Version 1.5.0rc02 [December 27, 2010]
-  Eliminated references to the scripts/*.def files in project/visualc71.
-
-Version 1.5.0rc03 [December 28, 2010]
-  Eliminated scripts/*.def and revised Makefile.am accordingly
-
-Version 1.5.0rc04 [December 29, 2010]
-  Fixed bug in background transformation handling in pngrtran.c (it was
-    looking for the flag in png_ptr->transformations instead of in
-    png_ptr->flags) (David Raymond).
-
-Version 1.5.0rc05 [December 31, 2010]
-  Fixed typo in a comment in CMakeLists.txt (libpng14 => libpng15) (Cosmin)
-
-Version 1.5.0rc06 [January 4, 2011]
-  Changed the new configure option "zprefix=string" to "zlib-prefix=string"
-
-Version 1.5.0rc07 [January 4, 2011]
-  Updated copyright year.
-
-Version 1.5.0 [January 6, 2011]
-  No changes.
-
-version 1.5.1beta01 [January 8, 2011]
-  Added description of png_set_crc_action() to the manual.
-  Added a note in the manual that the type of the iCCP profile was changed
-    from png_charpp to png_bytepp in png_get_iCCP().  This change happened
-    in version 1.5.0beta36 but is not noted in the CHANGES.  Similarly,
-    it was changed from png_charpp to png_const_bytepp in png_set_iCCP().
-  Ensure that png_rgb_to_gray ignores palette mapped images, if libpng
-    internally happens to call it with one, and fixed a failure to handle
-    palette mapped images correctly.  This fixes CVE-2690.
-
-Version 1.5.1beta02 [January 14, 2011]
-  Fixed a bug in handling of interlaced images (bero at arklinux.org).
-  Updated CMakeLists.txt (Clifford Yapp)
-
-Version 1.5.1beta03 [January 14, 2011]
-  Fixed typecasting of some png_debug() statements (Cosmin)
-
-Version 1.5.1beta04 [January 16, 2011]
-  Updated documentation of png_set|get_tRNS() (Thomas Klausner).
-  Mentioned in the documentation that applications must #include "zlib.h"
-    if they need access to anything in zlib.h, and that a number of
-    macros such as png_memset() are no longer accessible by applications.
-  Corrected pngvalid gamma test "sample" function to access all of the color
-    samples of each pixel, instead of sampling the red channel three times.
-  Prefixed variable names index, div, exp, gamma with "png_" to avoid "shadow"
-    warnings, and (mistakenly) changed png_exp() to exp().
-
-Version 1.5.1beta05 [January 16, 2011]
-  Changed variable names png_index, png_div, png_exp, and png_gamma to
-    char_index, divisor, exp_b10, and gamma_val, respectively, and
-    changed exp() back to png_exp().
-
-Version 1.5.1beta06 [January 20, 2011]
-  Prevent png_push_crc_skip() from hanging while reading an unknown chunk
-    or an over-large compressed zTXt chunk with the progressive reader.
-  Eliminated more GCC "shadow" warnings.
-  Revised png_fixed() in png.c to avoid compiler warning about reaching the
-    end without returning anything.
-
-Version 1.5.1beta07 [January 22, 2011]
-  In the manual, describe the png_get_IHDR() arguments in the correct order.
-  Added const_png_structp and const_png_infop types, and used them in
-    prototypes for most png_get_*() functions.
-
-Version 1.5.1beta08 [January 23, 2011]
-  Added png_get_io_chunk_type() and deprecated png_get_io_chunk_name()
-  Added synopses for the IO_STATE functions and other missing synopses
-    to the manual. Removed the synopses from libpngpf.3 because they
-    were out of date and no longer useful.  Better information can be
-    obtained by reading the prototypes and comments in pngpriv.h
-  Attempted to fix cpp on Solaris with S. Studio 12 cc, fix build
-    Added a make macro DFNCPP that is a CPP that will accept the tokens in
-    a .dfn file and adds configure stuff to test for such a CPP.  ./configure
-    should fail if one is not available.
-  Corrected const_png_ in png.h to png_const_ to avoid polluting the namespace.
-  Added png_get_current_row_number and png_get_current_pass_number for the
-    benefit of the user transform callback.
-  Added png_process_data_pause and png_process_data_skip for the benefit of
-    progressive readers that need to stop data processing or want to optimize
-    skipping of unread data (e.g., if the reader marks a chunk to be skipped.)
-
-Version 1.5.1beta09 [January 24, 2011]
-  Enhanced pngvalid, corrected an error in gray_to_rgb, corrected doc error.
-    pngvalid contains tests of transforms, which tests are currently disabled
-    because they are incompletely tested.  gray_to_rgb was failing to expand
-    the bit depth for smaller bit depth images; this seems to be a long
-    standing error and resulted, apparently, in invalid output
-    (CVE-2011-0408, CERT VU#643140).  The documentation did not accurately
-    describe what libpng really does when converting RGB to gray.
-
-Version 1.5.1beta10 [January 27, 2010]
-  Fixed incorrect examples of callback prototypes in the manual, that were
-    introduced in libpng-1.0.0.
-  In addition the order of the png_get_uint macros with respect to the
-    relevant function definitions has been reversed.  This helps the
-    preprocessing of the symbol files be more robust.  Furthermore, the
-    symbol file preprocessing now uses -DPNG_NO_USE_READ_MACROS even when
-    the library may actually be built with PNG_USE_READ_MACROS; this stops
-    the read macros interfering with the symbol file format.
-  Made the manual, synopses, and function prototypes use the function
-    argument names file_gamma, int_file_gamma, and srgb_intent consistently.
-
-Version 1.5.1beta11 [January 28, 2011]
-  Changed PNG_UNUSED from "param=param;" to "{if(param){}}".
-  Corrected local variable type in new API png_process_data_skip()
-    The type was self-evidently incorrect but only causes problems on 64-bit
-    architectures.
-  Added transform tests to pngvalid and simplified the arguments.
-
-Version 1.5.1rc01 [January 29, 2011]
-  No changes.
-
-Version 1.5.1rc02 [January 31, 2011]
-  Added a request in the manual that applications do not use "png_" or
-    "PNG_" to begin any of their own symbols.
-  Changed PNG_UNUSED to "(void)param;" and updated the commentary in pngpriv.h
-
-Version 1.5.1 [February 3, 2011]
-  No changes.
-
-Version 1.5.2beta01 [February 13, 2011]
-  More -Wshadow fixes for older gcc compilers.  Older gcc versions apparently
-    check formal parameters names in function declarations (as well as
-    definitions) to see if they match a name in the global namespace.
-  Revised PNG_EXPORTA macro to not use an empty parameter, to accommodate the
-    old VisualC++ preprocessor.
-  Turned on interlace handling in png_read_png().
-  Fixed gcc pendantic warnings.
-  Handle longjmp in Cygwin.
-  Fixed png_get_current_row_number() in the interlaced case.
-  Cleaned up ALPHA flags and transformations.
-  Implemented expansion to 16 bits.
-
-Version 1.5.2beta02 [February 19, 2011]
-  Fixed mistake in the descriptions of user read_transform and write_transform
-    function prototypes in the manual.  The row_info struct is png_row_infop.
-  Reverted png_get_current_row_number() to previous (1.5.2beta01) behavior.
-  Corrected png_get_current_row_number documentation
-  Fixed the read/write row callback documentation.
-    This documents the current behavior, where the callback is called after
-    every row with information pertaining to the next row.
-
-Version 1.5.2beta03 [March 3, 2011]
-  Fixed scripts/makefile.vcwin32
-  Updated contrib/pngsuite/README to add the word "modify".
-  Define PNG_ALLOCATED to blank when _MSC_VER<1300.
-
-Version 1.5.2rc01 [March 19, 2011]
-  Define remaining attributes to blank when MSC_VER<1300.
-  ifdef out mask arrays in pngread.c when interlacing is not supported.
-
-Version 1.5.2rc02 [March 22, 2011]
-  Added a hint to try CPP=/bin/cpp if "cpp -E" fails in scripts/pnglibconf.mak
-    and in contrib/pngminim/*/makefile, eg., on SunOS 5.10, and removed "strip"
-    from the makefiles.
-  Fixed a bug (present since libpng-1.0.7) that makes png_handle_sPLT() fail
-    to compile when PNG_NO_POINTER_INDEXING is defined (Chubanov Kirill)
-
-Version 1.5.2rc03 [March 24, 2011]
-  Don't include standard header files in png.h while building the symbol table,
-    to avoid cpp failure on SunOS (introduced PNG_BUILDING_SYMBOL_TABLE macro).
-
-Version 1.5.2 [March 31, 2011]
-  No changes.
-
-Version 1.5.3beta01 [April 1, 2011]
-  Re-initialize the zlib compressor before compressing non-IDAT chunks.
-  Added API functions (png_set_text_compression_level() and four others) to
-    set parameters for zlib compression of non-IDAT chunks.
-
-Version 1.5.3beta02 [April 3, 2011]
-  Updated scripts/symbols.def with new API functions.
-  Only compile the new zlib re-initializing code when text or iCCP is
-    supported, using PNG_WRITE_COMPRESSED_TEXT_SUPPORTED macro.
-  Improved the optimization of the zlib CMF byte (see libpng-1.2.6beta03).
-  Optimize the zlib CMF byte in non-IDAT compressed chunks
-
-Version 1.5.3beta03 [April 16, 2011]
-  Fixed gcc -ansi -pedantic compile. A strict ANSI system does not have
-    snprintf, and the "__STRICT_ANSI__" detects that condition more reliably
-    than __STDC__ (John Bowler).
-  Removed the PNG_PTR_NORETURN attribute because it too dangerous. It tells
-    the compiler that a user supplied callback (the error handler) does not
-    return, yet there is no guarantee in practice that the application code
-    will correctly implement the error handler because the compiler only
-    issues a warning if there is a mistake (John Bowler).
-  Removed the no-longer-used PNG_DEPSTRUCT macro.
-  Updated the zlib version to 1.2.5 in the VStudio project.
-  Fixed 64-bit builds where png_uint_32 is smaller than png_size_t in
-    pngwutil.c (John Bowler).
-  Fixed bug with stripping the filler or alpha channel when writing, that
-    was introduced in libpng-1.5.2beta01 (bug report by Andrew Church).
-
-Version 1.5.3beta04 [April 27, 2011]
-  Updated pngtest.png with the new zlib CMF optimization.
-  Cleaned up conditional compilation code and of background/gamma handling
-    Internal changes only except a new option to avoid compiling the
-    png_build_grayscale_palette API (which is not used at all internally.)
-    The main change is to move the transform tests (READ_TRANSFORMS,
-    WRITE_TRANSFORMS) up one level to the caller of the APIs.  This avoids
-    calls to spurious functions if all transforms are disabled and slightly
-    simplifies those functions.  Pngvalid modified to handle this.
-    A minor change is to stop the strip_16 and expand_16 interfaces from
-    disabling each other; this allows the future alpha premultiplication
-    code to use 16-bit intermediate values while still producing 8-bit output.
-    png_do_background and png_do_gamma have been simplified to take a single
-    pointer to the png_struct rather than pointers to every item required
-    from the png_struct. This makes no practical difference to the internal
-    code.
-  A serious bug in the pngvalid internal routine 'standard_display_init' has
-    been fixed - this failed to initialize the red channel and accidentally
-    initialized the alpha channel twice.
-  Changed png_struct jmp_buf member name from png_jmpbuf to tmp_jmpbuf to
-    avoid a possible clash with the png_jmpbuf macro on some platforms.
-
-Version 1.5.3beta05 [May 6, 2011]
-  Added the "_POSIX_SOURCE" feature test macro to ensure libpng sees the
-    correct API. _POSIX_SOURCE is defined in pngpriv.h, pngtest.c and
-    pngvalid.c to ensure that POSIX conformant systems disable non-POSIX APIs.
-  Removed png_snprintf and added formatted warning messages.  This change adds
-    internal APIs to allow png_warning messages to have parameters without
-    requiring the host OS to implement snprintf.  As a side effect the
-    dependency of the tIME-supporting RFC1132 code on stdio is removed and
-    PNG_NO_WARNINGS does actually work now.
-  Pass "" instead of '\0' to png_default_error() in png_err().  This mistake
-    was introduced in libpng-1.2.20beta01.  This fixes CVE-2011-2691.
-  Added PNG_WRITE_OPTIMIZE_CMF_SUPPORTED macro to make the zlib "CMF" byte
-    optimization configureable.
-  IDAT compression failed if preceded by a compressed text chunk (bug
-    introduced in libpng-1.5.3beta01-02).  This was because the attempt to
-    reset the zlib stream in png_write_IDAT happened after the first IDAT
-    chunk had been deflated - much too late.  In this change internal
-    functions were added to claim/release the z_stream and, hopefully, make
-    the code more robust.  Also deflateEnd checking is added - previously
-    libpng would ignore an error at the end of the stream.
-
-Version 1.5.3beta06 [May 8, 2011]
-  Removed the -D_ALL_SOURCE from definitions for AIX in CMakeLists.txt
-  Implemented premultiplied alpha support: png_set_alpha_mode API
-
-Version 1.5.3beta07 [May 11, 2011]
-  Added expand_16 support to the high level interface.
-  Added named value and 'flag' gamma support to png_set_gamma.  Made a minor
-    change from the previous (unreleased) ABI/API to hide the exact value used
-    for Macs - it's not a good idea to embed this in the ABI!
-  Moved macro definitions for PNG_HAVE_IHDR, PNG_HAVE_PLTE, and PNG_AFTER_IDAT
-    from pngpriv.h to png.h because they must be visible to applications
-    that call png_set_unknown_chunks().
-  Check for up->location !PNG_AFTER_IDAT when writing unknown chunks
-    before IDAT.
-
-Version 1.5.3beta08 [May 16, 2011]
-  Improved "pngvalid --speed" to exclude more of pngvalid from the time.
-  Documented png_set_alpha_mode(), other changes in libpng.3/libpng-manual.txt
-  The cHRM chunk now sets the defaults for png_set_rgb_to_gray() (when negative
-    parameters are supplied by the caller), while in the absence of cHRM
-    sRGB/Rec 709 values are still used.  This introduced a divide-by-zero
-    bug in png_handle_cHRM().
-  The bKGD chunk no longer overwrites the background value set by
-    png_set_background(), allowing the latter to be used before the file
-    header is read. It never performed any useful function to override
-    the default anyway.
-  Added memory overwrite and palette image checks to pngvalid.c
-    Previously palette image code was poorly checked. Since the transformation
-    code has a special palette path in most cases this was a severe weakness.
-  Minor cleanup and some extra checking in pngrutil.c and pngrtran.c. When
-    expanding an indexed image, always expand to RGBA if transparency is
-    present.
-
-Version 1.5.3beta09 [May 17, 2011]
-  Reversed earlier 1.5.3 change of transformation order; move png_expand_16
-    back where it was.  The change doesn't work because it requires 16-bit
-    gamma tables when the code only generates 8-bit ones.  This fails
-    silently; the libpng code just doesn't do any gamma correction.  Moving
-    the tests back leaves the old, inaccurate, 8-bit gamma calculations, but
-    these are clearly better than none!
-
-Version 1.5.3beta10 [May 20, 2011]
-
-  png_set_background() and png_expand_16() did not work together correctly.
-    This problem is present in 1.5.2; if png_set_background is called with
-    need_expand false and the matching 16 bit color libpng erroneously just
-    treats it as an 8-bit color because of where png_do_expand_16 is in the
-    transform list.  This simple fix reduces the supplied colour to 8-bits,
-    so it gets smashed, but this is better than the current behavior.
-  Added tests for expand16, more fixes for palette image tests to pngvalid.
-    Corrects the code for palette image tests and disables attempts to
-    validate palette colors.
-
-Version 1.5.3rc01 [June 3, 2011]
-  No changes.
-
-Version 1.5.3rc02 [June 8, 2011]
-  Fixed uninitialized memory read in png_format_buffer() (Bug report by
-    Frank Busse, CVE-2011-2501, related to CVE-2004-0421).
-
-Version 1.5.3beta11 [June 11, 2011]
-  Fixed png_handle_sCAL which is broken in 1.5. This fixes CVE 2011-2692.
-  Added sCAL to pngtest.png
-  Revised documentation about png_set_user_limits() to say that it also affects
-    png writing.
-  Revised handling of png_set_user_limits() so that it can increase the
-    limit beyond the PNG_USER_WIDTH|HEIGHT_MAX; previously it could only
-    reduce it.
-  Make the 16-to-8 scaling accurate. Dividing by 256 with no rounding is
-    wrong (high by one) 25% of the time. Dividing by 257 with rounding is
-    wrong in 128 out of 65536 cases. Getting the right answer all the time
-    without division is easy.
-  Added "_SUPPORTED" to the PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION macro.
-  Added projects/owatcom, an IDE project for OpenWatcom to replace
-    scripts/makefile.watcom.  This project works with OpenWatcom 1.9. The
-    IDE autogenerates appropriate makefiles (libpng.mk) for batch processing.
-    The project is configurable, unlike the Visual Studio project, so long
-    as the developer has an awk.
-  Changed png_set_gAMA to limit the gamma value range so that the inverse
-    of the stored value cannot overflow the fixed point representation,
-    and changed other things OpenWatcom warns about.
-  Revised pngvalid.c to test PNG_ALPHA_MODE_SUPPORTED correctly. This allows
-    pngvalid to build when ALPHA_MODE is not supported, which is required if
-    it is to build on libpng 1.4.
-  Removed string/memory macros that are no longer used and are not
-    necessarily fully supportable, particularly png_strncpy and png_snprintf.
-  Added log option to pngvalid.c and attempted to improve gamma messages.
-
-Version 1.5.3 [omitted]
-  People found the presence of a beta release following an rc release
-    to be confusing; therefore we bump the version to libpng-1.5.4beta01
-    and there will be no libpng-1.5.3 release.
-
-Version 1.5.4beta01 [June 14, 2011]
-  Made it possible to undefine PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-    to get the same (inaccurate) output as libpng-1.5.2 and earlier.
-  Moved definitions of PNG_HAVE_IHDR, PNG_AFTER_IDAT, and PNG_HAVE_PLTE
-    outside of an unknown-chunk block in png.h because they are also
-    needed for other uses.
-
-Version 1.5.4beta02 [June 14, 2011]
-  Fixed and clarified LEGACY 16-to-8 scaling code.
-  Added png_set_chop_16() API, to match inaccurate results from previous
-    libpng versions.
-  Removed the ACCURATE and LEGACY options (they are no longer useable)
-  Use the old scaling method for background if png_set_chop_16() was
-    called.
-  Made png_set_chop_16() API removeable by disabling PNG_CHOP_16_TO_8_SUPPORTED
-
-Version 1.5.4beta03 [June 15, 2011]
-  Fixed a problem in png_do_expand_palette() exposed by optimization in
-    1.5.3beta06
-  Also removed a spurious and confusing "trans" member ("trans") from png_info.
-  The palette expand optimization prevented expansion to an intermediate RGBA
-    form if tRNS was present but alpha was marked to be stripped; this exposed
-    a check for tRNS in png_do_expand_palette() which is inconsistent with the
-    code elsewhere in libpng.
-  Correction to the expand_16 code; removed extra instance of
-    png_set_scale_16_to_8 from pngpriv.h
-
-Version 1.5.4beta04 [June 16, 2011]
-  Added a missing "#ifdef PNG_READ_BACKGROUND_SUPPORTED/#endif" in pngrtran.c
-  Added PNG_TRANSFORM_CHOP_16 to the high-level read transforms.
-  Made PNG_READ_16_TO_8_ACCURATE_SCALE configurable again.  If this is
-    not enabled, png_set_strip_16() and png_do_scale_16_to_8() aren't built.
-  Revised contrib/visupng, gregbook, and pngminim to demonstrate chop_16_to_8
-
-Version 1.5.4beta05 [June 16, 2011]
-  Renamed png_set_strip_16() to png_set_scale_16() and renamed
-    png_set_chop_16() to png_set_strip(16) in an attempt to minimize the
-    behavior changes between libpng14 and libpng15.
-
-Version 1.5.4beta06 [June 18, 2011]
-  Fixed new bug that was causing both strip_16 and scale_16 to be applied.
-
-Version 1.5.4beta07 [June 19, 2011]
-  Fixed pngvalid, simplified macros, added checking for 0 in sCAL.
-    The ACCURATE scale macro is no longer defined in 1.5 - call the
-    png_scale_16_to_8 API.  Made sure that PNG_READ_16_TO_8 is still defined
-    if the png_strip_16_to_8 API is present.  png_check_fp_number now
-    maintains some state so that positive, negative and zero values are
-    identified.  sCAL uses these to be strictly spec conformant.
-
-Version 1.5.4beta08 [June 23, 2011]
-  Fixed pngvalid if ACCURATE_SCALE is defined.
-  Updated scripts/pnglibconf.h.prebuilt.
-
-Version 1.5.4rc01 [June 30, 2011]
-  Define PNG_ALLOCATED to "restrict" only if MSC_VER >= 1400.
-
-Version 1.5.4 [July 7, 2011]
-  No changes.
-
-Version 1.5.5beta01 [July 13, 2011]
-  Fixed some typos and made other minor changes in the manual.
-  Updated contrib/pngminus/makefile.std (Samuli Souminen)
-
-Version 1.5.5beta02 [July 14, 2011]
-  Revised Makefile.am and Makefile.in to look in the right directory for
-    pnglibconf.h.prebuilt
-
-Version 1.5.5beta03 [July 27, 2011]
-  Enabled compilation with g++ compiler.  This compiler does not recognize
-    the file extension, so it always compiles with C++ rules.  Made minor
-    changes to pngrutil.c to cast results where C++ expects it but C does not.
-  Minor editing of libpng.3 and libpng-manual.txt.
-
-Version 1.5.5beta04 [July 29, 2011]
-  Revised CMakeLists.txt (Clifford Yapp)
-  Updated commentary about the png_rgb_to_gray() default coefficients
-    in the manual and in pngrtran.c
-
-Version 1.5.5beta05 [August 17, 2011]
-  Prevent unexpected API exports from non-libpng DLLs on Windows.  The "_DLL"
-    is removed from the test of whether a DLL is being built (this erroneously
-    caused the libpng APIs to be marked as DLL exports in static builds under
-    Microsoft Visual Studio).  Almost all of the libpng building configuration
-    is moved from pngconf.h to pngpriv.h, but PNG_DLL_EXPORT remains in
-    pngconf.h, though, so that it is colocated with the import definition (it
-    is no longer used anywhere in the installed headers).  The VStudio project
-    definitions have been cleaned up: "_USRDLL" has been removed from the
-    static library builds (this was incorrect), and PNG_USE_DLL has been added
-    to pngvalid to test the functionality (pngtest does not supply it,
-    deliberately).  The spurious "_EXPORTS" has been removed from the
-    libpng build (all these errors were a result of copy/paste between project
-    configurations.)
-  Added new types and internal functions for CIE RGB end point handling to
-    pngpriv.h (functions yet to be implemented).
-
-Version 1.5.5beta06 [August 26, 2011]
-  Ensure the CMAKE_LIBRARY_OUTPUT_DIRECTORY is set in CMakeLists.txt
-    (Clifford Yap)
-  Fixes to rgb_to_gray and cHRM XYZ APIs (John Bowler):
-    The rgb_to_gray code had errors when combined with gamma correction.
-    Some pixels were treated as true grey when they weren't and such pixels
-    and true grey ones were not gamma corrected (the original value of the
-    red component was used instead).  APIs to get and set cHRM using color
-    space end points have been added and the rgb_to_gray code that defaults
-    based on cHRM, and the divide-by-zero bug in png_handle_cHRM (CERT
-    VU#477046, CVE-2011-3328, introduced in 1.5.4) have been corrected.
-  A considerable number of tests has been added to pngvalid for the
-    rgb_to_gray transform.
-  Arithmetic errors in rgb_to_gray whereby the calculated gray value was
-    truncated to the bit depth rather than rounded have been fixed except in
-    the 8-bit non-gamma-corrected case (where consistency seems more important
-    than correctness.)  The code still has considerable inaccuracies in the
-    8-bit case because 8-bit linear arithmetic is used.
-
-Version 1.5.5beta07 [September 7, 2011]
-  Added "$(ARCH)" option to makefile.darwin
-  Added SunOS support to configure.ac and Makefile.am
-  Changed png_chunk_benign_error() to png_warning() in png.c, in
-    png_XYZ_from_xy_checked().
-
-Version 1.5.5beta08 [September 10, 2011]
-  Fixed 64-bit compilation errors (gcc). The errors fixed relate
-    to conditions where types that are 32 bits in the GCC 32-bit
-    world (uLong and png_size_t) become 64 bits in the 64-bit
-    world.  This produces potential truncation errors which the
-    compiler correctly flags.
-  Relocated new HAVE_SOLARIS_LD definition in configure.ac
-  Constant changes for 64-bit compatibility (removal of L suffixes). The
-    16-bit cases still use "L" as we don't have a 16-bit test system.
-
-Version 1.5.5rc01 [September 15, 2011]
-  Removed "L" suffixes in pngpriv.h
-
-Version 1.5.5 [September 22, 2011]
-  No changes.
-
-Version 1.5.6beta01 [September 22, 2011]
-  Fixed some 64-bit type conversion warnings in pngrtran.c
-  Moved row_info from png_struct to a local variable.
-  The various interlace mask arrays have been made into arrays of
-    bytes and made PNG_CONST and static (previously some arrays were
-    marked PNG_CONST and some weren't).
-  Additional checks have been added to the transform code to validate the
-    pixel depths after the transforms on both read and write.
-  Removed some redundant code from pngwrite.c, in png_destroy_write_struct().
-  Changed chunk reading/writing code to use png_uint_32 instead of png_byte[4].
-    This removes the need to allocate temporary strings for chunk names on
-    the stack in the read/write code.  Unknown chunk handling still uses the
-    string form because this is exposed in the API.
-
-Version 1.5.6beta02 [September 26, 2011]
-  Added a note in the manual the png_read_update_info() must be called only
-    once with a particular info_ptr.
-  Fixed a typo in the definition of the new PNG_STRING_FROM_CHUNK(s,c) macro.
-
-Version 1.5.6beta03 [September 28, 2011]
-  Revised test-pngtest.sh to report FAIL when pngtest fails.
-  Added "--strict" option to pngtest, to report FAIL when the failure is
-    only because the resulting valid files are different.
-  Revised CMakeLists.txt to work with mingw and removed some material from
-    CMakeLists.txt that is no longer useful in libpng-1.5.
-
-Version 1.5.6beta04 [October 5, 2011]
-  Fixed typo in Makefile.in and Makefile.am ("-M Wl" should be "-M -Wl")."
-
-Version 1.5.6beta05 [October 12, 2011]
-  Speed up png_combine_row() for interlaced images. This reduces the generality
-    of the code, allowing it to be optimized for Adam7 interlace.  The masks
-    passed to png_combine_row() are now generated internally, avoiding
-    some code duplication and localizing the interlace handling somewhat.
-  Align png_struct::row_buf - previously it was always unaligned, caused by
-    a bug in the code that attempted to align it; the code needs to subtract
-    one from the pointer to take account of the filter byte prepended to
-    each row.
-  Optimized png_combine_row() when rows are aligned. This gains a small
-    percentage for 16-bit and 32-bit pixels in the typical case where the
-    output row buffers are appropriately aligned. The optimization was not
-    previously possible because the png_struct buffer was always misaligned.
-  Fixed bug in png_write_chunk_header() debug print, introduced in 1.5.6beta01.
-
-Version 1.5.6beta06 [October 17, 2011]
-  Removed two redundant tests for unitialized row.
-  Fixed a relatively harmless memory overwrite in compressed text writing
-    with a 1 byte zlib buffer.
-  Add ability to call png_read_update_info multiple times to pngvalid.c.
-  Fixes for multiple calls to png_read_update_info. These fixes attend to
-    most of the errors revealed in pngvalid, however doing the gamma work
-    twice results in inaccuracies that can't be easily fixed.  There is now
-    a warning in the code if this is going to happen.
-  Turned on multiple png_read_update_info in pngvalid transform tests.
-  Prevent libpng from overwriting unused bits at the end of the image when
-    it is not byte aligned, while reading. Prior to libpng-1.5.6 libpng would
-    overwrite the partial byte at the end of each row if the row width was not
-    an exact multiple of 8 bits and the image is not interlaced.
-
-Version 1.5.6beta07 [October 21, 2011]
-  Made png_ptr->prev_row an aligned pointer into png_ptr->big_prev_row
-    (Mans Rullgard).
-
-Version 1.5.6rc01 [October 26, 2011]
-  Changed misleading "Missing PLTE before cHRM" warning to "Out of place cHRM"
-
-Version 1.5.6rc02 [October 27, 2011]
-  Added LSR() macro to defend against buggy compilers that evaluate non-taken
-    code branches and complain about out-of-range shifts.
-
-Version 1.5.6rc03 [October 28, 2011]
-  Renamed the LSR() macro to PNG_LSR() and added PNG_LSL() macro.
-  Fixed compiler warnings with Intel and MSYS compilers. The logical shift
-    fix for Microsoft Visual C is required by other compilers, so this
-    enables that fix for all compilers when using compile-time constants.
-    Under MSYS 'byte' is a name declared in a system header file, so we
-    changed the name of a local variable to avoid the warnings that result.
-  Added #define PNG_ALIGN_TYPE PNG_ALIGN_NONE to contrib/pngminim/*/pngusr.h
-
-Version 1.5.6 [November 3, 2011]
-  No changes.
-
-Version 1.5.7beta01 [November 4, 2011]
-  Added support for ARM processor (Mans Rullgard)
-  Fixed bug in pngvalid on early allocation failure; fixed type cast in
-    pngmem.c; pngvalid would attempt to call png_error() if the allocation
-    of a png_struct or png_info failed. This would probably have led to a
-    crash.  The pngmem.c implementation of png_malloc() included a cast
-    to png_size_t which would fail on large allocations on 16-bit systems.
-  Fix for the preprocessor of the Intel C compiler. The preprocessor
-    splits adjacent @ signs with a space; this changes the concatentation
-    token from @-@-@ to PNG_JOIN; that should work with all compiler
-    preprocessors.
-  Paeth filter speed improvements from work by Siarhei Siamashka. This
-    changes the 'Paeth' reconstruction function to improve the GCC code
-    generation on x86. The changes are only part of the suggested ones;
-    just the changes that definitely improve speed and remain simple.
-    The changes also slightly increase the clarity of the code.
-
-Version 1.5.7beta02 [November 11, 2011]
-  Check compression_type parameter in png_get_iCCP and remove spurious
-    casts. The compression_type parameter is always assigned to, so must
-    be non-NULL. The cast of the profile length potentially truncated the
-    value unnecessarily on a 16-bit int system, so the cast of the (byte)
-    compression type to (int) is specified by ANSI-C anyway.
-  Fixed FP division by zero in pngvalid.c; the 'test_pixel' code left
-    the sBIT fields in the test pixel as 0, which resulted in a floating
-    point division by zero which was irrelevant but causes systems where
-    FP exceptions cause a crash. Added code to pngvalid to turn on FP
-    exceptions if the appropriate glibc support is there to ensure this is
-    tested in the future.
-  Updated scripts/pnglibconf.mak and scripts/makefile.std to handle the
-    new PNG_JOIN macro.
-  Added versioning to pnglibconf.h comments.
-  Simplified read/write API initial version; basic read/write tested on
-    a variety of images, limited documentation (in the header file.)
-  Installed more accurate linear to sRGB conversion tables. The slightly
-    modified tables reduce the number of 16-bit values that
-    convert to an off-by-one 8-bit value.  The "makesRGB.c" code that was used
-    to generate the tables is now in a contrib/sRGBtables sub-directory.
-
-Version 1.5.7beta03 [November 17, 2011]
-  Removed PNG_CONST from the sRGB table declarations in pngpriv.h and png.c
-  Added run-time detection of NEON support.
-  Added contrib/libtests; includes simplified API test and timing test and
-    a color conversion utility for rapid checking of failed 'pngstest' results.
-  Multiple transform bug fixes plus a work-round for double gamma correction.
-    libpng does not support more than one transform that requires linear data
-    at once - if this is tried typically the results is double gamma
-    correction. Since the simplified APIs can need rgb to gray combined with
-    a compose operation it is necessary to do one of these outside the main
-    libpng transform code. This check-in also contains fixes to various bugs
-    in the simplified APIs themselves and to some bugs in compose and rgb to
-    gray (on palette) itself.
-  Fixes for C++ compilation using g++ When libpng source is compiled
-    using g++. The compiler imposes C++ rules on the C source; thus it
-    is desireable to make the source work with either C or C++ rules
-    without throwing away useful error information.  This change adds
-    png_voidcast to allow C semantic (void*) cases or the corresponding
-    C++ static_cast operation, as appropriate.
-  Added --noexecstack to assembler file compilation. GCC does not set
-    this on assembler compilation, even though it does on C compilation.
-    This creates security issues if assembler code is enabled; the
-    work-around is to set it by default in the flags for $(CCAS)
-  Work around compilers that don't support declaration of const data. Some
-    compilers fault 'extern const' data declarations (because the data is
-    not initialized); this turns on const-ness only for compilers where
-    this is known to work.
-
-Version 1.5.7beta04 [November 17, 2011]
-  Since the gcc driver does not recognize the --noexecstack flag, we must
-    use the -Wa prefix to have it passed through to the assembler.
-    Also removed a duplicate setting of this flag.
-  Added files that were omitted from the libpng-1.5.7beta03 zip distribution.
-
-Version 1.5.7beta05 [November 25, 2011]
-  Removed "zTXt" from warning in generic chunk decompression function.
-  Validate time settings passed to pngset() and png_convert_to_rfc1123()
-    (Frank Busse).
-  Added MINGW support to CMakeLists.txt
-  Reject invalid compression flag or method when reading the iTXt chunk.
-  Backed out 'simplified' API changes. The API seems too complex and there
-    is a lack of consensus or enthusiasm for the proposals.  The API also
-    reveals significant bugs inside libpng (double gamma correction and the
-    known bug of being unable to retrieve a corrected palette). It seems
-    better to wait until the bugs, at least, are corrected.
-  Moved pngvalid.c into contrib/libtests
-  Rebuilt Makefile.in, configure, etc., with autoconf-2.68
-
-Version 1.5.7rc01 [December 1, 2011]
-  Replaced an "#if" with "#ifdef" in pngrtran.c
-  Revised #if PNG_DO_BC block in png.c (use #ifdef and add #else)
-
-Version 1.5.7rc02 [December 5, 2011]
-  Revised project files and contrib/pngvalid/pngvalid.c to account for
-    the relocation of pngvalid into contrib/libtests.
-  Revised pngconf.h to use " __declspec(restrict)" only when MSC_VER >= 1400,
-    as in libpng-1.5.4.
-  Put CRLF line endings in the owatcom project files.
-
-Version 1.5.7rc03 [December 7, 2011]
-  Updated CMakeLists.txt to account for the relocation of pngvalid.c
-
-Version 1.5.7 [December 15, 2011]
-  Minor fixes to pngvalid.c for gcc 4.6.2 compatibility to remove warnings
-    reported by earlier versions.
-
-Version 1.5.8beta01 [January 15, 2011]
-  Removed '#include config.h"' from contrib/libtests/pngvalid.c.  It's not
-    needed and causes trouble for VPATH building.
-  Moved AC_MSG_CHECKING([if libraries can be versioned]) later to the proper
-    location in configure.ac (Gilles Espinasse).
-  Fix bug in pngerror.c: some long warnings were being improperly truncated
-    (CVE-2011-3464, bug introduced in libpng-1.5.3beta05).
-
-Version 1.5.8rc01 [January 21, 2012]
-  No changes.
-
-Version 1.5.8rc02 [January 25, 2012]
-  Fixed Min/GW uninstall to remove libpng.dll.a
-  Conditionalize the install rules for MINGW and CYGWIN in CMakeLists.txt
-
-Version 1.5.8 [February 1, 2012]
-  No changes.
-
-Version 1.5.9beta01 [February 3, 2012]
-  Rebuilt configure scripts in the tar distributions.
-
-Version 1.5.9beta02 [February 16, 2012]
-  Removed two unused definitions from scripts/pnglibconf.h.prebuilt
-  Removed some unused arrays (with #ifdef) from png_read_push_finish_row().
-  Removed tests for no-longer-used *_EMPTY_PLTE_SUPPORTED from pngstruct.h
-
-Version 1.5.9rc01 [February 17, 2012]
-  Fixed CVE-2011-3026 buffer overrun bug.  Deal more correctly with the test
-    on iCCP chunk length. Also removed spurious casts that may hide problems
-    on 16-bit systems.
-
-Version 1.5.9 [February 18, 2012]
-  No changes.
-
-Send comments/corrections/commendations to png-mng-implement at lists.sf.net
-(subscription required; visit
-https://lists.sourceforge.net/lists/listinfo/png-mng-implement
-to subscribe)
-or to glennrp at users.sourceforge.net
-
-Glenn R-P
-#endif
+#if 0
+CHANGES - changes for libpng
+
+Version 0.2
+  added reader into png.h
+  fixed small problems in stub file
+
+Version 0.3
+  added pull reader
+  split up pngwrite.c to several files
+  added pnglib.txt
+  added example.c
+  cleaned up writer, adding a few new transformations
+  fixed some bugs in writer
+  interfaced with zlib 0.5
+  added K&R support
+  added check for 64 KB blocks for 16-bit machines
+
+Version 0.4
+  cleaned up code and commented code
+  simplified time handling into png_time
+  created png_color_16 and png_color_8 to handle color needs
+  cleaned up color type defines
+  fixed various bugs
+  made various names more consistent
+  interfaced with zlib 0.71
+  cleaned up zTXt reader and writer (using zlib's Reset functions)
+  split transformations into pngrtran.c and pngwtran.c
+
+Version 0.5
+  interfaced with zlib 0.8
+  fixed many reading and writing bugs
+  saved using 3 spaces instead of tabs
+
+Version 0.6
+  added png_large_malloc() and png_large_free()
+  added png_size_t
+  cleaned up some compiler warnings
+  added png_start_read_image()
+
+Version 0.7
+  cleaned up lots of bugs
+  finished dithering and other stuff
+  added test program
+  changed name from pnglib to libpng
+
+Version 0.71 [June, 1995]
+  changed pngtest.png for zlib 0.93
+  fixed error in libpng.txt and example.c
+
+Version 0.8
+  cleaned up some bugs
+  added png_set_filler()
+  split up pngstub.c into pngmem.c, pngio.c, and pngerror.c
+  added #define's to remove unwanted code
+  moved png_info_init() to png.c
+  added old_size into png_realloc()
+  added functions to manually set filtering and compression info
+  changed compression parameters based on image type
+  optimized filter selection code
+  added version info
+  changed external functions passing floats to doubles (k&r problems?)
+  put all the configurable stuff in pngconf.h
+  enabled png_set_shift to work with paletted images on read
+  added png_read_update_info() - updates info structure with transformations
+
+Version 0.81 [August, 1995]
+  incorporated Tim Wegner's medium model code (thanks, Tim)
+
+Version 0.82 [September, 1995]
+  [unspecified changes]
+
+Version 0.85 [December, 1995]
+  added more medium model code (almost everything's a far)
+  added i/o, error, and memory callback functions
+  fixed some bugs (16-bit, 4-bit interlaced, etc.)
+  added first run progressive reader (barely tested)
+
+Version 0.86 [January, 1996]
+  fixed bugs
+  improved documentation
+
+Version 0.87 [January, 1996]
+  fixed medium model bugs
+  fixed other bugs introduced in 0.85 and 0.86
+  added some minor documentation
+
+Version 0.88 [January, 1996]
+  fixed progressive bugs
+  replaced tabs with spaces
+  cleaned up documentation
+  added callbacks for read/write and warning/error functions
+
+Version 0.89 [July, 1996]
+  Added new initialization API to make libpng work better with shared libs
+    we now have png_create_read_struct(), png_create_write_struct(),
+    png_create_info_struct(), png_destroy_read_struct(), and
+    png_destroy_write_struct() instead of the separate calls to
+    malloc and png_read_init(), png_info_init(), and png_write_init()
+  Changed warning/error callback functions to fix bug - this means you
+    should use the new initialization API if you were using the old
+    png_set_message_fn() calls, and that the old API no longer exists
+    so that people are aware that they need to change their code
+  Changed filter selection API to allow selection of multiple filters
+    since it didn't work in previous versions of libpng anyways
+  Optimized filter selection code
+  Fixed png_set_background() to allow using an arbitrary RGB color for
+    paletted images
+  Fixed gamma and background correction for paletted images, so
+    png_correct_palette is not needed unless you are correcting an
+    external palette (you will need to #define PNG_CORRECT_PALETTE_SUPPORTED
+    in pngconf.h) - if nobody uses this, it may disappear in the future.
+  Fixed bug with Borland 64K memory allocation (Alexander Lehmann)
+  Fixed bug in interlace handling (Smarasderagd, I think)
+  Added more error checking for writing and image to reduce invalid files
+  Separated read and write functions so that they won't both be linked
+    into a binary when only reading or writing functionality is used
+  New pngtest image also has interlacing and zTXt
+  Updated documentation to reflect new API
+
+Version 0.90 [January, 1997]
+  Made CRC errors/warnings on critical and ancillary chunks configurable
+  libpng will use the zlib CRC routines by (compile-time) default
+  Changed DOS small/medium model memory support - needs zlib 1.04 (Tim Wegner)
+  Added external C++ wrapper statements to png.h (Gilles Dauphin)
+  Allow PNG file to be read when some or all of file signature has already
+    been read from the beginning of the stream.  ****This affects the size
+    of info_struct and invalidates all programs that use a shared libpng****
+  Fixed png_filler() declarations
+  Fixed? background color conversions
+  Fixed order of error function pointers to match documentation
+  Current chunk name is now available in png_struct to reduce the number
+    of nearly identical error messages (will simplify multi-lingual
+    support when available)
+  Try to get ready for unknown-chunk callback functions:
+    - previously read critical chunks are flagged, so the chunk handling
+      routines can determine if the chunk is in the right place
+    - all chunk handling routines have the same prototypes, so we will
+      be able to handle all chunks via a callback mechanism
+  Try to fix Linux "setjmp" buffer size problems
+  Removed png_large_malloc, png_large_free, and png_realloc functions.
+
+Version 0.95 [March, 1997]
+  Fixed bug in pngwutil.c allocating "up_row" twice and "avg_row" never
+  Fixed bug in PNG file signature compares when start != 0
+  Changed parameter type of png_set_filler(...filler...) from png_byte
+    to png_uint_32
+  Added test for MACOS to ensure that both math.h and fp.h are not #included
+  Added macros for libpng to be compiled as a Windows DLL (Andreas Kupries)
+  Added "packswap" transformation, which changes the endianness of
+    packed-pixel bytes (Kevin Bracey)
+  Added "strip_alpha" transformation, which removes the alpha channel of
+    input images without using it (not necessarily a good idea)
+  Added "swap_alpha" transformation, which puts the alpha channel in front
+    of the color bytes instead of after
+  Removed all implicit variable tests which assume NULL == 0 (I think)
+  Changed several variables to "png_size_t" to show 16/32-bit limitations
+  Added new pCAL chunk read/write support
+  Added experimental filter selection weighting (Greg Roelofs)
+  Removed old png_set_rgbx() and png_set_xrgb() functions that have been
+     obsolete for about 2 years now (use png_set_filler() instead)
+  Added macros to read 16- and 32-bit ints directly from buffer, to be
+    used only on those systems that support it (namely PowerPC and 680x0)
+    With some testing, this may become the default for MACOS/PPC systems.
+  Only calculate CRC on data if we are going to use it
+  Added macros for zTXt compression type PNG_zTXt_COMPRESSION_???
+  Added macros for simple libpng debugging output selectable at compile time
+  Removed PNG_READ_END_MODE in progressive reader (Smarasderagd)
+  More description of info_struct in libpng.txt and png.h
+  More instructions in example.c
+  More chunk types tested in pngtest.c
+  Renamed pngrcb.c to pngset.c, and all png_read_<chunk> functions to be
+    png_set_<chunk>.  We now have corresponding png_get_<chunk>
+    functions in pngget.c to get information in info_ptr.  This isolates
+    the application from the internal organization of png_info_struct
+    (good for shared library implementations).
+
+Version 0.96 [May, 1997]
+  Fixed serious bug with < 8bpp images introduced in 0.95
+  Fixed 256-color transparency bug (Greg Roelofs)
+  Fixed up documentation (Greg Roelofs, Laszlo Nyul)
+  Fixed "error" in pngconf.h for Linux setjmp() behavior
+  Fixed DOS medium model support (Tim Wegner)
+  Fixed png_check_keyword() for case with error in static string text
+  Added read of CRC after IEND chunk for embedded PNGs (Laszlo Nyul)
+  Added typecasts to quiet compiler errors
+  Added more debugging info
+
+Version 0.97 [January, 1998]
+  Removed PNG_USE_OWN_CRC capability
+  Relocated png_set_crc_action from pngrutil.c to pngrtran.c
+  Fixed typecasts of "new_key", etc. (Andreas Dilger)
+  Added RFC 1152 [sic] date support
+  Fixed bug in gamma handling of 4-bit grayscale
+  Added 2-bit grayscale gamma handling (Glenn R-P)
+  Added more typecasts. 65536L becomes (png_uint_32)65536L, etc. (Glenn R-P)
+  Minor corrections in libpng.txt
+  Added simple sRGB support (Glenn R-P)
+  Easier conditional compiling, e.g.,
+    define PNG_READ/WRITE_NOT_FULLY_SUPPORTED;
+    all configurable options can be selected from command-line instead
+    of having to edit pngconf.h (Glenn R-P)
+  Fixed memory leak in pngwrite.c (free info_ptr->text) (Glenn R-P)
+  Added more conditions for png_do_background, to avoid changing
+    black pixels to background when a background is supplied and
+    no pixels are transparent
+  Repaired PNG_NO_STDIO behavior
+  Tested NODIV support and made it default behavior (Greg Roelofs)
+  Added "-m" option and PNGTEST_DEBUG_MEMORY to pngtest (John Bowler)
+  Regularized version numbering scheme and bumped shared-library major
+    version number to 2 to avoid problems with libpng 0.89 apps
+    (Greg Roelofs)
+
+Version 0.98 [January, 1998]
+  Cleaned up some typos in libpng.txt and in code documentation
+  Fixed memory leaks in pCAL chunk processing (Glenn R-P and John Bowler)
+  Cosmetic change "display_gamma" to "screen_gamma" in pngrtran.c
+  Changed recommendation about file_gamma for PC images to .51 from .45,
+    in example.c and libpng.txt, added comments to distinguish between
+    screen_gamma, viewing_gamma, and display_gamma.
+  Changed all references to RFC1152 to read RFC1123 and changed the
+    PNG_TIME_RFC1152_SUPPORTED macro to PNG_TIME_RFC1123_SUPPORTED
+  Added png_invert_alpha capability (Glenn R-P -- suggestion by Jon Vincent)
+  Changed srgb_intent from png_byte to int to avoid compiler bugs
+
+Version 0.99 [January 30, 1998]
+  Free info_ptr->text instead of end_info_ptr->text in pngread.c (John Bowler)
+  Fixed a longstanding "packswap" bug in pngtrans.c
+  Fixed some inconsistencies in pngconf.h that prevented compiling with
+    PNG_READ_GAMMA_SUPPORTED and PNG_READ_hIST_SUPPORTED undefined
+  Fixed some typos and made other minor rearrangement of libpng.txt (Andreas)
+  Changed recommendation about file_gamma for PC images to .50 from .51 in
+    example.c and libpng.txt, and changed file_gamma for sRGB images to .45
+  Added a number of functions to access information from the png structure
+    png_get_image_height(), etc. (Glenn R-P, suggestion by Brad Pettit)
+  Added TARGET_MACOS similar to zlib-1.0.8
+  Define PNG_ALWAYS_EXTERN when __MWERKS__ && WIN32 are defined
+  Added type casting to all png_malloc() function calls
+
+Version 0.99a [January 31, 1998]
+  Added type casts and parentheses to all returns that return a value.(Tim W.)
+
+Version 0.99b [February 4, 1998]
+  Added type cast png_uint_32 on malloc function calls where needed.
+  Changed type of num_hist from png_uint_32 to int (same as num_palette).
+  Added checks for rowbytes overflow, in case png_size_t is less than 32 bits.
+  Renamed makefile.elf to makefile.lnx.
+
+Version 0.99c [February 7, 1998]
+  More type casting.  Removed erroneous overflow test in pngmem.c.
+  Added png_buffered_memcpy() and png_buffered_memset(), apply them to rowbytes.
+  Added UNIX manual pages libpng.3 (incorporating libpng.txt) and  png.5.
+
+Version 0.99d [February 11, 1998]
+  Renamed "far_to_near()" "png_far_to_near()"
+  Revised libpng.3
+  Version 99c "buffered" operations didn't work as intended.  Replaced them
+    with png_memcpy_check() and png_memset_check().
+  Added many "if (png_ptr == NULL) return" to quell compiler warnings about
+    unused png_ptr, mostly in pngget.c and pngset.c.
+  Check for overlength tRNS chunk present when indexed-color PLTE is read.
+  Cleaned up spelling errors in libpng.3/libpng.txt
+  Corrected a problem with png_get_tRNS() which returned undefined trans array
+
+Version 0.99e [February 28, 1998]
+  Corrected png_get_tRNS() again.
+  Add parentheses for easier reading of pngget.c, fixed "||" should be "&&".
+  Touched up example.c to make more of it compileable, although the entire
+    file still can't be compiled (Willem van Schaik)
+  Fixed a bug in png_do_shift() (Bryan Tsai)
+  Added a space in png.h prototype for png_write_chunk_start()
+  Replaced pngtest.png with one created with zlib 1.1.1
+  Changed pngtest to report PASS even when file size is different (Jean-loup G.)
+  Corrected some logic errors in png_do_invert_alpha() (Chris Patterson)
+
+Version 0.99f [March 5, 1998]
+  Corrected a bug in pngpread() introduced in version 99c (Kevin Bracey)
+  Moved makefiles into a "scripts" directory, and added INSTALL instruction file
+  Added makefile.os2 and pngos2.def (A. Zabolotny) and makefile.s2x (W. Sebok)
+  Added pointers to "note on libpng versions" in makefile.lnx and README
+  Added row callback feature when reading and writing nonprogressive rows
+    and added a test of this feature in pngtest.c
+  Added user transform callbacks, with test of the feature in pngtest.c
+
+Version 0.99g [March 6, 1998, morning]
+  Minor changes to pngtest.c to suppress compiler warnings.
+  Removed "beta" language from documentation.
+
+Version 0.99h [March 6, 1998, evening]
+  Minor changes to previous minor changes to pngtest.c
+  Changed PNG_READ_NOT_FULLY_SUPPORTED to PNG_READ_TRANSFORMS_NOT_SUPPORTED
+    and added PNG_PROGRESSIVE_READ_NOT_SUPPORTED macro
+  Added user transform capability
+
+Version 1.00 [March 7, 1998]
+  Changed several typedefs in pngrutil.c
+  Added makefile.wat (Pawel Mrochen), updated makefile.tc3 (Willem van Schaik)
+  Replaced "while(1)" with "for(;;)"
+  Added PNGARG() to prototypes in pngtest.c and removed some prototypes
+  Updated some of the makefiles (Tom Lane)
+  Changed some typedefs (s_start, etc.) in pngrutil.c
+  Fixed dimensions of "short_months" array in pngwrite.c
+  Replaced ansi2knr.c with the one from jpeg-v6
+
+Version 1.0.0 [March 8, 1998]
+  Changed name from 1.00 to 1.0.0 (Adam Costello)
+  Added smakefile.ppc (with SCOPTIONS.ppc) for Amiga PPC (Andreas Kleinert)
+
+Version 1.0.0a [March 9, 1998]
+  Fixed three bugs in pngrtran.c to make gamma+background handling consistent
+    (Greg Roelofs)
+  Changed format of the PNG_LIBPNG_VER integer to xyyzz instead of xyz
+    for major, minor, and bugfix releases.  This is 10001. (Adam Costello,
+    Tom Lane)
+  Make months range from 1-12 in png_convert_to_rfc1123
+
+Version 1.0.0b [March 13, 1998]
+  Quieted compiler complaints about two empty "for" loops in pngrutil.c
+  Minor changes to makefile.s2x
+  Removed #ifdef/#endif around a png_free() in pngread.c
+
+Version 1.0.1 [March 14, 1998]
+  Changed makefile.s2x to reduce security risk of using a relative pathname
+  Fixed some typos in the documentation (Greg).
+  Fixed a problem with value of "channels" returned by png_read_update_info()
+
+Version 1.0.1a [April 21, 1998]
+  Optimized Paeth calculations by replacing abs() function calls with intrinsics
+  plus other loop optimizations. Improves avg decoding speed by about 20%.
+  Commented out i386istic "align" compiler flags in makefile.lnx.
+  Reduced the default warning level in some makefiles, to make them consistent.
+  Removed references to IJG and JPEG in the ansi2knr.c copyright statement.
+  Fixed a bug in png_do_strip_filler with XXRRGGBB => RRGGBB transformation.
+  Added grayscale and 16-bit capability to png_do_read_filler().
+  Fixed a bug in pngset.c, introduced in version 0.99c, that sets rowbytes
+    too large when writing an image with bit_depth < 8 (Bob Dellaca).
+  Corrected some bugs in the experimental weighted filtering heuristics.
+  Moved a misplaced pngrutil code block that truncates tRNS if it has more
+    than num_palette entries -- test was done before num_palette was defined.
+  Fixed a png_convert_to_rfc1123() bug that converts day 31 to 0 (Steve Eddins).
+  Changed compiler flags in makefile.wat for better optimization
+    (Pawel Mrochen).
+
+Version 1.0.1b [May 2, 1998]
+  Relocated png_do_gray_to_rgb() within png_do_read_transformations() (Greg).
+  Relocated the png_composite macros from pngrtran.c to png.h (Greg).
+  Added makefile.sco (contributed by Mike Hopkirk).
+  Fixed two bugs (missing definitions of "istop") introduced in libpng-1.0.1a.
+  Fixed a bug in pngrtran.c that would set channels=5 under some circumstances.
+  More work on the Paeth-filtering, achieving imperceptible speedup
+    (A Kleinert).
+  More work on loop optimization which may help when compiled with C++
+    compilers.
+  Added warnings when people try to use transforms they've defined out.
+  Collapsed 4 "i" and "c" loops into single "i" loops in pngrtran and pngwtran.
+  Revised paragraph about png_set_expand() in libpng.txt and libpng.3 (Greg)
+
+Version 1.0.1c [May 11, 1998]
+  Fixed a bug in pngrtran.c (introduced in libpng-1.0.1a) where the masks for
+    filler bytes should have been 0xff instead of 0xf.
+  Added max_pixel_depth=32 in pngrutil.c when using FILLER with palette images.
+  Moved PNG_WRITE_WEIGHTED_FILTER_SUPPORTED and PNG_WRITE_FLUSH_SUPPORTED
+    out of the PNG_WRITE_TRANSFORMS_NOT_SUPPORTED block of pngconf.h
+  Added "PNG_NO_WRITE_TRANSFORMS" etc., as alternatives for *_NOT_SUPPORTED,
+    for consistency, in pngconf.h
+  Added individual "ifndef PNG_NO_[CAPABILITY]" in pngconf.h to make it easier
+    to remove unwanted capabilities via the compile line
+  Made some corrections to grammar (which, it's) in documentation (Greg).
+  Corrected example.c, use of row_pointers in png_write_image().
+
+Version 1.0.1d [May 24, 1998]
+  Corrected several statements that used side effects illegally in pngrutil.c
+    and pngtrans.c, that were introduced in version 1.0.1b
+  Revised png_read_rows() to avoid repeated if-testing for NULL (A Kleinert)
+  More corrections to example.c, use of row_pointers in png_write_image()
+    and png_read_rows().
+  Added pngdll.mak and pngdef.pas to scripts directory, contributed by
+    Bob Dellaca, to make a png32bd.dll with Borland C++ 4.5
+  Fixed error in example.c with png_set_text: num_text is 3, not 2 (Guido V.)
+  Changed several loops from count-down to count-up, for consistency.
+
+Version 1.0.1e [June 6, 1998]
+  Revised libpng.txt and libpng.3 description of png_set_read|write_fn(), and
+    added warnings when people try to set png_read_fn and png_write_fn in
+    the same structure.
+  Added a test such that png_do_gamma will be done when num_trans==0
+    for truecolor images that have defined a background.  This corrects an
+    error that was introduced in libpng-0.90 that can cause gamma processing
+    to be skipped.
+  Added tests in png.h to include "trans" and "trans_values" in structures
+    when PNG_READ_BACKGROUND_SUPPORTED or PNG_READ_EXPAND_SUPPORTED is defined.
+  Add png_free(png_ptr->time_buffer) in png_destroy_read_struct()
+  Moved png_convert_to_rfc_1123() from pngwrite.c to png.c
+  Added capability for user-provided malloc_fn() and free_fn() functions,
+    and revised pngtest.c to demonstrate their use, replacing the
+    PNGTEST_DEBUG_MEM feature.
+  Added makefile.w32, for Microsoft C++ 4.0 and later (Tim Wegner).
+
+Version 1.0.2 [June 14, 1998]
+  Fixed two bugs in makefile.bor .
+
+Version 1.0.2a [December 30, 1998]
+  Replaced and extended code that was removed from png_set_filler() in 1.0.1a.
+  Fixed a bug in png_do_filler() that made it fail to write filler bytes in
+    the left-most pixel of each row (Kevin Bracey).
+  Changed "static pngcharp tIME_string" to "static char tIME_string[30]"
+    in pngtest.c (Duncan Simpson).
+  Fixed a bug in pngtest.c that caused pngtest to try to write a tIME chunk
+    even when no tIME chunk was present in the source file.
+  Fixed a problem in pngrutil.c: gray_to_rgb didn't always work with 16-bit.
+  Fixed a problem in png_read_push_finish_row(), which would not skip some
+    passes that it should skip, for images that are less than 3 pixels high.
+  Interchanged the order of calls to png_do_swap() and png_do_shift()
+    in pngwtran.c (John Cromer).
+  Added #ifdef PNG_DEBUG/#endif surrounding use of PNG_DEBUG in png.h .
+  Changed "bad adaptive filter type" from error to warning in pngrutil.c .
+  Fixed a documentation error about default filtering with 8-bit indexed-color.
+  Separated the PNG_NO_STDIO macro into PNG_NO_STDIO and PNG_NO_CONSOLE_IO
+    (L. Peter Deutsch).
+  Added png_set_rgb_to_gray() and png_get_rgb_to_gray_status() functions.
+  Added png_get_copyright() and png_get_header_version() functions.
+  Revised comments on png_set_progressive_read_fn() in libpng.txt and example.c
+  Added information about debugging in libpng.txt and libpng.3 .
+  Changed "ln -sf" to "ln -s -f" in makefile.s2x, makefile.lnx, and
+    makefile.sco.
+  Removed lines after Dynamic Dependencies" in makefile.aco .
+  Revised makefile.dec to make a shared library (Jeremie Petit).
+  Removed trailing blanks from all files.
+
+Version 1.0.2a [January 6, 1999]
+  Removed misplaced #endif and #ifdef PNG_NO_EXTERN near the end of png.h
+  Added "if" tests to silence complaints about unused png_ptr in png.h and png.c
+  Changed "check_if_png" function in example.c to return true (nonzero) if PNG.
+  Changed libpng.txt to demonstrate png_sig_cmp() instead of png_check_sig()
+    which is obsolete.
+
+Version 1.0.3 [January 14, 1999]
+  Added makefile.hux, for Hewlett Packard HPUX 10.20 and 11.00 (Jim Rice)
+  Added a statement of Y2K compliance in png.h, libpng.3, and Y2KINFO.
+
+Version 1.0.3a [August 12, 1999]
+  Added check for PNG_READ_INTERLACE_SUPPORTED in pngread.c; issue a warning
+     if an attempt is made to read an interlaced image when it's not supported.
+  Added check if png_ptr->trans is defined before freeing it in pngread.c
+  Modified the Y2K statement to include versions back to version 0.71
+  Fixed a bug in the check for valid IHDR bit_depth/color_types in pngrutil.c
+  Modified makefile.wat (added -zp8 flag, ".symbolic", changed some comments)
+  Replaced leading blanks with tab characters in makefile.hux
+  Changed "dworkin.wustl.edu" to "ccrc.wustl.edu" in various documents.
+  Changed (float)red and (float)green to (double)red, (double)green
+     in png_set_rgb_to_gray() to avoid "promotion" problems in AIX.
+  Fixed a bug in pngconf.h that omitted <stdio.h> when PNG_DEBUG==0 (K Bracey).
+  Reformatted libpng.3 and libpngpf.3 with proper fonts (script by J. vanZandt).
+  Updated documentation to refer to the PNG-1.2 specification.
+  Removed ansi2knr.c and left pointers to the latest source for ansi2knr.c
+    in makefile.knr, INSTALL, and README (L. Peter Deutsch)
+  Fixed bugs in calculation of the length of rowbytes when adding alpha
+    channels to 16-bit images, in pngrtran.c (Chris Nokleberg)
+  Added function png_set_user_transform_info() to store user_transform_ptr,
+    user_depth, and user_channels into the png_struct, and a function
+    png_get_user_transform_ptr() to retrieve the pointer (Chris Nokleberg)
+  Added function png_set_empty_plte_permitted() to make libpng useable
+    in MNG applications.
+  Corrected the typedef for png_free_ptr in png.h (Jesse Jones).
+  Correct gamma with srgb is 45455 instead of 45000 in pngrutil.c, to be
+    consistent with PNG-1.2, and allow variance of 500 before complaining.
+  Added assembler code contributed by Intel in file pngvcrd.c and modified
+    makefile.w32 to use it (Nirav Chhatrapati, INTEL Corporation,
+    Gilles Vollant)
+  Changed "ln -s -f" to "ln -f -s" in the makefiles to make Solaris happy.
+  Added some aliases for png_set_expand() in pngrtran.c, namely
+    png_set_expand_PLTE(), png_set_expand_depth(), and png_set_expand_tRNS()
+    (Greg Roelofs, in "PNG: The Definitive Guide").
+  Added makefile.beo for BEOS on X86, contributed by Sander Stok.
+
+Version 1.0.3b [August 26, 1999]
+  Replaced 2147483647L several places with PNG_MAX_UINT macro, defined in png.h
+  Changed leading blanks to tabs in all makefiles.
+  Define PNG_USE_PNGVCRD in makefile.w32, to get MMX assembler code.
+  Made alternate versions of  png_set_expand() in pngrtran.c, namely
+    png_set_gray_1_2_4_to_8, png_set_palette_to_rgb, and png_set_tRNS_to_alpha
+    (Greg Roelofs, in "PNG: The Definitive Guide").  Deleted the 1.0.3a aliases.
+  Relocated start of 'extern "C"' block in png.h so it doesn't include pngconf.h
+  Revised calculation of num_blocks in pngmem.c to avoid a potentially
+    negative shift distance, whose results are undefined in the C language.
+  Added a check in pngset.c to prevent writing multiple tIME chunks.
+  Added a check in pngwrite.c to detect invalid small window_bits sizes.
+
+Version 1.0.3d [September 4, 1999]
+  Fixed type casting of igamma in pngrutil.c
+  Added new png_expand functions to scripts/pngdef.pas and pngos2.def
+  Added a demo read_user_transform_fn that examines the row filters in pngtest.c
+
+Version 1.0.4 [September 24, 1999]
+  Define PNG_ALWAYS_EXTERN in pngconf.h if __STDC__ is defined
+  Delete #define PNG_INTERNAL and include "png.h" from pngasmrd.h
+  Made several minor corrections to pngtest.c
+  Renamed the makefiles with longer but more user friendly extensions.
+  Copied the PNG copyright and license to a separate LICENSE file.
+  Revised documentation, png.h, and example.c to remove reference to
+    "viewing_gamma" which no longer appears in the PNG specification.
+  Revised pngvcrd.c to use MMX code for interlacing only on the final pass.
+  Updated pngvcrd.c to use the faster C filter algorithms from libpng-1.0.1a
+  Split makefile.win32vc into two versions, makefile.vcawin32 (uses MMX
+    assembler code) and makefile.vcwin32 (doesn't).
+  Added a CPU timing report to pngtest.c (enabled by defining PNGTEST_TIMING)
+  Added a copy of pngnow.png to the distribution.
+
+Version 1.0.4a [September 25, 1999]
+  Increase max_pixel_depth in pngrutil.c if a user transform needs it.
+  Changed several division operations to right-shifts in pngvcrd.c
+
+Version 1.0.4b [September 30, 1999]
+  Added parentheses in line 3732 of pngvcrd.c
+  Added a comment in makefile.linux warning about buggy -O3 in pgcc 2.95.1
+
+Version 1.0.4c [October 1, 1999]
+  Added a "png_check_version" function in png.c and pngtest.c that will generate
+    a helpful compiler error if an old png.h is found in the search path.
+  Changed type of png_user_transform_depth|channels from int to png_byte.
+
+Version 1.0.4d [October 6, 1999]
+  Changed 0.45 to 0.45455 in png_set_sRGB()
+  Removed unused PLTE entries from pngnow.png
+  Re-enabled some parts of pngvcrd.c (png_combine_row) that work properly.
+
+Version 1.0.4e [October 10, 1999]
+  Fixed sign error in pngvcrd.c (Greg Roelofs)
+  Replaced some instances of memcpy with simple assignments in pngvcrd (GR-P)
+
+Version 1.0.4f [October 15, 1999]
+  Surrounded example.c code with #if 0 .. #endif to prevent people from
+    inadvertently trying to compile it.
+  Changed png_get_header_version() from a function to a macro in png.h
+  Added type casting mostly in pngrtran.c and pngwtran.c
+  Removed some pointless "ptr = NULL" in pngmem.c
+  Added a "contrib" directory containing the source code from Greg's book.
+
+Version 1.0.5 [October 15, 1999]
+  Minor editing of the INSTALL and README files.
+
+Version 1.0.5a [October 23, 1999]
+  Added contrib/pngsuite and contrib/pngminus (Willem van Schaik)
+  Fixed a typo in the png_set_sRGB() function call in example.c (Jan Nijtmans)
+  Further optimization and bugfix of pngvcrd.c
+  Revised pngset.c so that it does not allocate or free memory in the user's
+    text_ptr structure.  Instead, it makes its own copy.
+  Created separate write_end_info_struct in pngtest.c for a more severe test.
+  Added code in pngwrite.c to free info_ptr->text[i].key to stop a memory leak.
+
+Version 1.0.5b [November 23, 1999]
+  Moved PNG_FLAG_HAVE_CHUNK_HEADER, PNG_FLAG_BACKGROUND_IS_GRAY and
+    PNG_FLAG_WROTE_tIME from flags to mode.
+  Added png_write_info_before_PLTE() function.
+  Fixed some typecasting in contrib/gregbook/*.c
+  Updated scripts/makevms.com and added makevms.com to contrib/gregbook
+    and contrib/pngminus (Martin Zinser)
+
+Version 1.0.5c [November 26, 1999]
+  Moved png_get_header_version from png.h to png.c, to accommodate ansi2knr.
+  Removed all global arrays (according to PNG_NO_GLOBAL_ARRAYS macro), to
+    accommodate making DLL's: Moved usr_png_ver from global variable to function
+    png_get_header_ver() in png.c.  Moved png_sig to png_sig_bytes in png.c and
+    eliminated use of png_sig in pngwutil.c.  Moved the various png_CHNK arrays
+    into pngtypes.h.  Eliminated use of global png_pass arrays.  Declared the
+    png_CHNK and png_pass arrays to be "const".  Made the global arrays
+    available to applications (although none are used in libpng itself) when
+    PNG_NO_GLOBAL_ARRAYS is not defined or when PNG_GLOBAL_ARRAYS is defined.
+  Removed some extraneous "-I" from contrib/pngminus/makefile.std
+  Changed the PNG_sRGB_INTENT macros in png.h to be consistent with PNG-1.2.
+  Change PNG_SRGB_INTENT to PNG_sRGB_INTENT in libpng.txt and libpng.3
+
+Version 1.0.5d [November 29, 1999]
+  Add type cast (png_const_charp) two places in png.c
+  Eliminated pngtypes.h; use macros instead to declare PNG_CHNK arrays.
+  Renamed "PNG_GLOBAL_ARRAYS" to "PNG_USE_GLOBAL_ARRAYS" and made available
+    to applications a macro "PNG_USE_LOCAL_ARRAYS".
+  comment out (with #ifdef) all the new declarations when
+    PNG_USE_GLOBAL_ARRAYS is defined.
+  Added PNG_EXPORT_VAR macro to accommodate making DLL's.
+
+Version 1.0.5e [November 30, 1999]
+  Added iCCP, iTXt, and sPLT support; added "lang" member to the png_text
+    structure; refactored the inflate/deflate support to make adding new chunks
+    with trailing compressed parts easier in the future, and added new functions
+    png_free_iCCP, png_free_pCAL, png_free_sPLT, png_free_text, png_get_iCCP,
+    png_get_spalettes, png_set_iCCP, png_set_spalettes (Eric S. Raymond).
+  NOTE: Applications that write text chunks MUST define png_text->lang
+    before calling png_set_text(). It must be set to NULL if you want to
+    write tEXt or zTXt chunks.  If you want your application to be able to
+    run with older versions of libpng, use
+
+      #ifdef PNG_iTXt_SUPPORTED
+         png_text[i].lang = NULL;
+      #endif
+
+  Changed png_get_oFFs() and png_set_oFFs() to use signed rather than unsigned
+    offsets (Eric S. Raymond).
+  Combined PNG_READ_cHNK_SUPPORTED and PNG_WRITE_cHNK_SUPPORTED macros into
+    PNG_cHNK_SUPPORTED and combined the three types of PNG_text_SUPPORTED
+    macros, leaving the separate macros also available.
+  Removed comments on #endifs at the end of many short, non-nested #if-blocks.
+
+Version 1.0.5f [December 6, 1999]
+  Changed makefile.solaris to issue a warning about potential problems when
+    the ucb "ld" is in the path ahead of the ccs "ld".
+  Removed "- [date]" from the "synopsis" line in libpng.3 and libpngpf.3.
+  Added sCAL chunk support (Eric S. Raymond).
+
+Version 1.0.5g [December 7, 1999]
+  Fixed "png_free_spallettes" typo in png.h
+  Added code to handle new chunks in pngpread.c
+  Moved PNG_CHNK string macro definitions outside of PNG_NO_EXTERN block
+  Added "translated_key" to png_text structure and png_write_iTXt().
+  Added code in pngwrite.c to work around a newly discovered zlib bug.
+
+Version 1.0.5h [December 10, 1999]
+  NOTE: regarding the note for version 1.0.5e, the following must also
+    be included in your code:
+        png_text[i].translated_key = NULL;
+  Unknown chunk handling is now supported.
+  Option to eliminate all floating point support was added.  Some new
+    fixed-point functions such as png_set_gAMA_fixed() were added.
+  Expanded tabs and removed trailing blanks in source files.
+
+Version 1.0.5i [December 13, 1999]
+  Added some type casts to silence compiler warnings.
+  Renamed "png_free_spalette" to "png_free_spalettes" for consistency.
+  Removed leading blanks from a #define in pngvcrd.c
+  Added some parameters to the new png_set_keep_unknown_chunks() function.
+  Added a test for up->location != 0 in the first instance of writing
+    unknown chunks in pngwrite.c
+  Changed "num" to "i" in png_free_spalettes() and png_free_unknowns() to
+    prevent recursion.
+  Added png_free_hIST() function.
+  Various patches to fix bugs in the sCAL and integer cHRM processing,
+    and to add some convenience macros for use with sCAL.
+
+Version 1.0.5j [December 21, 1999]
+  Changed "unit" parameter of png_write_sCAL from png_byte to int, to work
+    around buggy compilers.
+  Added new type "png_fixed_point" for integers that hold float*100000 values
+  Restored backward compatibility of tEXt/zTXt chunk processing:
+    Restored the first four members of png_text to the same order as v.1.0.5d.
+    Added members "lang_key" and "itxt_length" to png_text struct.  Set
+    text_length=0 when "text" contains iTXt data.  Use the "compression"
+    member to distinguish among tEXt/zTXt/iTXt types.  Added
+    PNG_ITXT_COMPRESSION_NONE (1) and PNG_ITXT_COMPRESSION_zTXt(2) macros.
+    The "Note" above, about backward incompatibility of libpng-1.0.5e, no
+    longer applies.
+  Fixed png_read|write_iTXt() to read|write parameters in the right order,
+    and to write the iTXt chunk after IDAT if it appears in the end_ptr.
+  Added pnggccrd.c, version of pngvcrd.c Intel assembler for gcc (Greg Roelofs)
+  Reversed the order of trying to write floating-point and fixed-point gAMA.
+
+Version 1.0.5k [December 27, 1999]
+  Added many parentheses, e.g., "if (a && b & c)" becomes "if (a && (b & c))"
+  Added png_handle_as_unknown() function (Glenn)
+  Added png_free_chunk_list() function and chunk_list and num_chunk_list members
+    of png_ptr.
+  Eliminated erroneous warnings about multiple sPLT chunks and sPLT-after-PLTE.
+  Fixed a libpng-1.0.5h bug in pngrutil.c that was issuing erroneous warnings
+    about ignoring incorrect gAMA with sRGB (gAMA was in fact not ignored)
+  Added png_free_tRNS(); png_set_tRNS() now malloc's its own trans array (ESR).
+  Define png_get_int_32 when oFFs chunk is supported as well as when pCAL is.
+  Changed type of proflen from png_int_32 to png_uint_32 in png_get_iCCP().
+
+Version 1.0.5l [January 1, 2000]
+  Added functions png_set_read_user_chunk_fn() and png_get_user_chunk_ptr()
+    for setting a callback function to handle unknown chunks and for
+    retrieving the associated user pointer (Glenn).
+
+Version 1.0.5m [January 7, 2000]
+  Added high-level functions png_read_png(), png_write_png(), png_free_pixels().
+
+Version 1.0.5n [January 9, 2000]
+  Added png_free_PLTE() function, and modified png_set_PLTE() to malloc its
+    own memory for info_ptr->palette.  This makes it safe for the calling
+    application to free its copy of the palette any time after it calls
+    png_set_PLTE().
+
+Version 1.0.5o [January 20, 2000]
+  Cosmetic changes only (removed some trailing blanks and TABs)
+
+Version 1.0.5p [January 31, 2000]
+  Renamed pngdll.mak to makefile.bd32
+  Cosmetic changes in pngtest.c
+
+Version 1.0.5q [February 5, 2000]
+  Relocated the makefile.solaris warning about PATH problems.
+  Fixed pngvcrd.c bug by pushing/popping registers in mmxsupport (Bruce Oberg)
+  Revised makefile.gcmmx
+  Added PNG_SETJMP_SUPPORTED, PNG_SETJMP_NOT_SUPPORTED, and PNG_ABORT() macros
+
+Version 1.0.5r [February 7, 2000]
+  Removed superfluous prototype for png_get_itxt from png.h
+  Fixed a bug in pngrtran.c that improperly expanded the background color.
+  Return *num_text=0 from png_get_text() when appropriate, and fix documentation
+    of png_get_text() in libpng.txt/libpng.3.
+
+Version 1.0.5s [February 18, 2000]
+  Added "png_jmp_env()" macro to pngconf.h, to help people migrate to the
+    new error handler that's planned for the next libpng release, and changed
+    example.c, pngtest.c, and contrib programs to use this macro.
+  Revised some of the DLL-export macros in pngconf.h (Greg Roelofs)
+  Fixed a bug in png_read_png() that caused it to fail to expand some images
+    that it should have expanded.
+  Fixed some mistakes in the unused and undocumented INCH_CONVERSIONS functions
+    in pngget.c
+  Changed the allocation of palette, history, and trans arrays back to
+    the version 1.0.5 method (linking instead of copying) which restores
+    backward compatibility with version 1.0.5.  Added some remarks about
+    that in example.c.  Added "free_me" member to info_ptr and png_ptr
+    and added png_free_data() function.
+  Updated makefile.linux and makefile.gccmmx to make directories conditionally.
+  Made cosmetic changes to pngasmrd.h
+  Added png_set_rows() and png_get_rows(), for use with png_read|write_png().
+  Modified png_read_png() to allocate info_ptr->row_pointers only if it
+    hasn't already been allocated.
+
+Version 1.0.5t [March 4, 2000]
+  Changed png_jmp_env() migration aiding macro to png_jmpbuf().
+  Fixed "interlace" typo (should be "interlaced") in contrib/gregbook/read2-x.c
+  Fixed bug with use of PNG_BEFORE_IHDR bit in png_ptr->mode, introduced when
+    PNG_FLAG_HAVE_CHUNK_HEADER was moved into png_ptr->mode in version 1.0.5b
+  Files in contrib/gregbook were revised to use png_jmpbuf() and to select
+    a 24-bit visual if one is available, and to allow abbreviated options.
+  Files in contrib/pngminus were revised to use the png_jmpbuf() macro.
+  Removed spaces in makefile.linux and makefile.gcmmx, introduced in 1.0.5s
+
+Version 1.0.5u [March 5, 2000]
+  Simplified the code that detects old png.h in png.c and pngtest.c
+  Renamed png_spalette (_p, _pp) to png_sPLT_t (_tp, _tpp)
+  Increased precision of rgb_to_gray calculations from 8 to 15 bits and
+    added png_set_rgb_to_gray_fixed() function.
+  Added makefile.bc32 (32-bit Borland C++, C mode)
+
+Version 1.0.5v [March 11, 2000]
+  Added some parentheses to the png_jmpbuf macro definition.
+  Updated references to the zlib home page, which has moved to freesoftware.com.
+  Corrected bugs in documentation regarding png_read_row() and png_write_row().
+  Updated documentation of png_rgb_to_gray calculations in libpng.3/libpng.txt.
+  Renamed makefile.borland,turboc3 back to makefile.bor,tc3 as in version 1.0.3,
+    revised borland makefiles; added makefile.ibmvac3 and makefile.gcc (Cosmin)
+
+Version 1.0.6 [March 20, 2000]
+  Minor revisions of makefile.bor, libpng.txt, and gregbook/rpng2-win.c
+  Added makefile.sggcc (SGI IRIX with gcc)
+
+Version 1.0.6d [April 7, 2000]
+  Changed sprintf() to strcpy() in png_write_sCAL_s() to work without STDIO
+  Added data_length parameter to png_decompress_chunk() function
+  Revised documentation to remove reference to abandoned png_free_chnk functions
+  Fixed an error in png_rgb_to_gray_fixed()
+  Revised example.c, usage of png_destroy_write_struct().
+  Renamed makefile.ibmvac3 to makefile.ibmc, added libpng.icc IBM project file
+  Added a check for info_ptr->free_me&PNG_FREE_TEXT when freeing text in png.c
+  Simplify png_sig_bytes() function to remove use of non-ISO-C strdup().
+
+Version 1.0.6e [April 9, 2000]
+  Added png_data_freer() function.
+  In the code that checks for over-length tRNS chunks, added check of
+    info_ptr->num_trans as well as png_ptr->num_trans (Matthias Benckmann)
+  Minor revisions of libpng.txt/libpng.3.
+  Check for existing data and free it if the free_me flag is set, in png_set_*()
+    and png_handle_*().
+  Only define PNG_WEIGHTED_FILTERS_SUPPORTED when PNG_FLOATING_POINT_SUPPORTED
+    is defined.
+  Changed several instances of PNG_NO_CONSOLE_ID to PNG_NO_STDIO in pngrutil.c
+    and mentioned the purposes of the two macros in libpng.txt/libpng.3.
+
+Version 1.0.6f [April 14, 2000]
+  Revised png_set_iCCP() and png_set_rows() to avoid prematurely freeing data.
+  Add checks in png_set_text() for NULL members of the input text structure.
+  Revised libpng.txt/libpng.3.
+  Removed superfluous prototype for png_set_iTXt from png.h
+  Removed "else" from pngread.c, after png_error(), and changed "0" to "length".
+  Changed several png_errors about malformed ancillary chunks to png_warnings.
+
+Version 1.0.6g [April 24, 2000]
+  Added png_pass-* arrays to pnggccrd.c when PNG_USE_LOCAL_ARRAYS is defined.
+  Relocated paragraph about png_set_background() in libpng.3/libpng.txt
+    and other revisions (Matthias Benckmann)
+  Relocated info_ptr->free_me, png_ptr->free_me, and other info_ptr and
+    png_ptr members to restore binary compatibility with libpng-1.0.5
+    (breaks compatibility with libpng-1.0.6).
+
+Version 1.0.6h [April 24, 2000]
+  Changed shared library so-number pattern from 2.x.y.z to xy.z (this builds
+    libpng.so.10 & libpng.so.10.6h instead of libpng.so.2 & libpng.so.2.1.0.6h)
+    This is a temporary change for test purposes.
+
+Version 1.0.6i [May 2, 2000]
+  Rearranged some members at the end of png_info and png_struct, to put
+    unknown_chunks_num and free_me within the original size of the png_structs
+    and free_me, png_read_user_fn, and png_free_fn within the original png_info,
+    because some old applications allocate the structs directly instead of
+    using png_create_*().
+  Added documentation of user memory functions in libpng.txt/libpng.3
+  Modified png_read_png so that it will use user_allocated row_pointers
+    if present, unless free_me directs that it be freed, and added description
+    of the use of png_set_rows() and png_get_rows() in libpng.txt/libpng.3.
+  Added PNG_LEGACY_SUPPORTED macro, and #ifdef out all new (since version
+    1.00) members of png_struct and png_info, to regain binary compatibility
+    when you define this macro.  Capabilities lost in this event
+    are user transforms (new in version 1.0.0),the user transform pointer
+    (new in version 1.0.2), rgb_to_gray (new in 1.0.5), iCCP, sCAL, sPLT,
+    the high-level interface, and unknown chunks support (all new in 1.0.6).
+    This was necessary because of old applications that allocate the structs
+    directly as authors were instructed to do in libpng-0.88 and earlier,
+    instead of using png_create_*().
+  Added modes PNG_CREATED_READ_STRUCT and PNG_CREATED_WRITE_STRUCT which
+    can be used to detect codes that directly allocate the structs, and
+    code to check these modes in png_read_init() and png_write_init() and
+    generate a libpng error if the modes aren't set and PNG_LEGACY_SUPPORTED
+    was not defined.
+  Added makefile.intel and updated makefile.watcom (Pawel Mrochen)
+
+Version 1.0.6j [May 3, 2000]
+  Overloaded png_read_init() and png_write_init() with macros that convert
+    calls to png_read_init_2() or png_write_init_2() that check the version
+    and structure sizes.
+
+Version 1.0.7beta11 [May 7, 2000]
+  Removed the new PNG_CREATED_READ_STRUCT and PNG_CREATED_WRITE_STRUCT modes
+    which are no longer used.
+  Eliminated the three new members of png_text when PNG_LEGACY_SUPPORTED is
+    defined or when neither PNG_READ_iTXt_SUPPORTED nor PNG_WRITE_iTXT_SUPPORTED
+    is defined.
+  Made PNG_NO_READ|WRITE_iTXt the default setting, to avoid memory
+    overrun when old applications fill the info_ptr->text structure directly.
+  Added PNGAPI macro, and added it to the definitions of all exported functions.
+  Relocated version macro definitions ahead of the includes of zlib.h and
+    pngconf.h in png.h.
+
+Version 1.0.7beta12 [May 12, 2000]
+  Revised pngset.c to avoid a problem with expanding the png_debug macro.
+  Deleted some extraneous defines from pngconf.h
+  Made PNG_NO_CONSOLE_IO the default condition when PNG_BUILD_DLL is defined.
+  Use MSC _RPTn debugging instead of fprintf if _MSC_VER is defined.
+  Added png_access_version_number() function.
+  Check for mask&PNG_FREE_CHNK (for TEXT, SCAL, PCAL) in png_free_data().
+  Expanded libpng.3/libpng.txt information about png_data_freer().
+
+Version 1.0.7beta14 [May 17, 2000] (beta13 was not published)
+  Changed pnggccrd.c and pngvcrd.c to handle bad adaptive filter types as
+    warnings instead of errors, as pngrutil.c does.
+  Set the PNG_INFO_IDAT valid flag in png_set_rows() so png_write_png()
+    will actually write IDATs.
+  Made the default PNG_USE_LOCAL_ARRAYS depend on PNG_DLL instead of WIN32.
+  Make png_free_data() ignore its final parameter except when freeing data
+    that can have multiple instances (text, sPLT, unknowns).
+  Fixed a new bug in png_set_rows().
+  Removed info_ptr->valid tests from png_free_data(), as in version 1.0.5.
+  Added png_set_invalid() function.
+  Fixed incorrect illustrations of png_destroy_write_struct() in example.c.
+
+Version 1.0.7beta15 [May 30, 2000]
+  Revised the deliberately erroneous Linux setjmp code in pngconf.h to produce
+    fewer error messages.
+  Rearranged checks for Z_OK to check the most likely path first in pngpread.c
+    and pngwutil.c.
+  Added checks in pngtest.c for png_create_*() returning NULL, and mentioned
+    in libpng.txt/libpng.3 the need for applications to check this.
+  Changed names of png_default_*() functions in pngtest to pngtest_*().
+  Changed return type of png_get_x|y_offset_*() from png_uint_32 to png_int_32.
+  Fixed some bugs in the unused PNG_INCH_CONVERSIONS functions in pngget.c
+  Set each pointer to NULL after freeing it in png_free_data().
+  Worked around a problem in pngconf.h; AIX's strings.h defines an "index"
+    macro that conflicts with libpng's png_color_16.index. (Dimitri
+    Papadapoulos)
+  Added "msvc" directory with MSVC++ project files (Simon-Pierre Cadieux).
+
+Version 1.0.7beta16 [June 4, 2000]
+  Revised the workaround of AIX string.h "index" bug.
+  Added a check for overlength PLTE chunk in pngrutil.c.
+  Added PNG_NO_POINTER_INDEXING macro to use array-indexing instead of pointer
+    indexing in pngrutil.c and pngwutil.c to accommodate a buggy compiler.
+  Added a warning in png_decompress_chunk() when it runs out of data, e.g.
+    when it tries to read an erroneous PhotoShop iCCP chunk.
+  Added PNG_USE_DLL macro.
+  Revised the copyright/disclaimer/license notice.
+  Added contrib/msvctest directory
+
+Version 1.0.7rc1 [June 9, 2000]
+  Corrected the definition of PNG_TRANSFORM_INVERT_ALPHA  (0x0400 not 0x0200)
+  Added contrib/visupng directory (Willem van Schaik)
+
+Version 1.0.7beta18 [June 23, 2000]
+  Revised PNGAPI definition, and pngvcrd.c to work with __GCC__
+    and do not redefine PNGAPI if it is passed in via a compiler directive.
+  Revised visupng/PngFile.c to remove returns from within the Try block.
+  Removed leading underscores from "_PNG_H" and "_PNG_SAVE_BSD_SOURCE" macros.
+  Updated contrib/visupng/cexcept.h to version 1.0.0.
+  Fixed bugs in pngwrite.c and pngwutil.c that prevented writing iCCP chunks.
+
+Version 1.0.7rc2 [June 28, 2000]
+  Updated license to include disclaimers required by UCITA.
+  Fixed "DJBPP" typo in pnggccrd.c introduced in beta18.
+
+Version 1.0.7 [July 1, 2000]
+  Revised the definition of "trans_values" in libpng.3/libpng.txt
+
+Version 1.0.8beta1 [July 8, 2000]
+  Added png_free(png_ptr, key) two places in pngpread.c to stop memory leaks.
+  Changed PNG_NO_STDIO to PNG_NO_CONSOLE_IO, several places in pngrutil.c and
+     pngwutil.c.
+  Changed PNG_EXPORT_VAR to use PNG_IMPEXP, in pngconf.h.
+  Removed unused "#include <assert.h>" from png.c
+  Added WindowsCE support.
+  Revised pnggccrd.c to work with gcc-2.95.2 and in the Cygwin environment.
+
+Version 1.0.8beta2 [July 10, 2000]
+  Added project files to the wince directory and made further revisions
+     of pngtest.c, pngrio.c, and pngwio.c in support of WindowsCE.
+
+Version 1.0.8beta3 [July 11, 2000]
+  Only set the PNG_FLAG_FREE_TRNS or PNG_FREE_TRNS flag in png_handle_tRNS()
+     for indexed-color input files to avoid potential double-freeing trans array
+     under some unusual conditions; problem was introduced in version 1.0.6f.
+  Further revisions to pngtest.c and files in the wince subdirectory.
+
+Version 1.0.8beta4 [July 14, 2000]
+  Added the files pngbar.png and pngbar.jpg to the distribution.
+  Added makefile.cygwin, and cygwin support in pngconf.h
+  Added PNG_NO_ZALLOC_ZERO macro (makes png_zalloc skip zeroing memory)
+
+Version 1.0.8rc1 [July 16, 2000]
+  Revised png_debug() macros and statements to eliminate compiler warnings.
+
+Version 1.0.8 [July 24, 2000]
+  Added png_flush() in pngwrite.c, after png_write_IEND().
+  Updated makefile.hpux to build a shared library.
+
+Version 1.0.9beta1 [November 10, 2000]
+  Fixed typo in scripts/makefile.hpux
+  Updated makevms.com in scripts and contrib/* and contrib/* (Martin Zinser)
+  Fixed seqence-point bug in contrib/pngminus/png2pnm (Martin Zinser)
+  Changed "cdrom.com" in documentation to "libpng.org"
+  Revised pnggccrd.c to get it all working, and updated makefile.gcmmx (Greg).
+  Changed type of "params" from voidp to png_voidp in png_read|write_png().
+  Make sure PNGAPI and PNG_IMPEXP are defined in pngconf.h.
+  Revised the 3 instances of WRITEFILE in pngtest.c.
+  Relocated "msvc" and "wince" project subdirectories into "dll" subdirectory.
+  Updated png.rc in dll/msvc project
+  Revised makefile.dec to define and use LIBPATH and INCPATH
+  Increased size of global png_libpng_ver[] array from 12 to 18 chars.
+  Made global png_libpng_ver[], png_sig[] and png_pass_*[] arrays const.
+  Removed duplicate png_crc_finish() from png_handle_bKGD() function.
+  Added a warning when application calls png_read_update_info() multiple times.
+  Revised makefile.cygwin
+  Fixed bugs in iCCP support in pngrutil.c and pngwutil.c.
+  Replaced png_set_empty_plte_permitted() with png_permit_mng_features().
+
+Version 1.0.9beta2 [November 19, 2000]
+  Renamed the "dll" subdirectory "projects".
+  Added borland project files to "projects" subdirectory.
+  Set VS_FF_PRERELEASE and VS_FF_PATCHED flags in msvc/png.rc when appropriate.
+  Add error message in png_set_compression_buffer_size() when malloc fails.
+
+Version 1.0.9beta3 [November 23, 2000]
+  Revised PNG_LIBPNG_BUILD_TYPE macro in png.h, used in the msvc project.
+  Removed the png_flush() in pngwrite.c that crashes some applications
+    that don't set png_output_flush_fn.
+  Added makefile.macosx and makefile.aix to scripts directory.
+
+Version 1.0.9beta4 [December 1, 2000]
+  Change png_chunk_warning to png_warning in png_check_keyword().
+  Increased the first part of msg buffer from 16 to 18 in png_chunk_error().
+
+Version 1.0.9beta5 [December 15, 2000]
+  Added support for filter method 64 (for PNG datastreams embedded in MNG).
+
+Version 1.0.9beta6 [December 18, 2000]
+  Revised png_set_filter() to accept filter method 64 when appropriate.
+  Added new PNG_HAVE_PNG_SIGNATURE bit to png_ptr->mode and use it to
+    help prevent applications from using MNG features in PNG datastreams.
+  Added png_permit_mng_features() function.
+  Revised libpng.3/libpng.txt.  Changed "filter type" to "filter method".
+
+Version 1.0.9rc1 [December 23, 2000]
+  Revised test for PNG_HAVE_PNG_SIGNATURE in pngrutil.c
+  Fixed error handling of unknown compression type in png_decompress_chunk().
+  In pngconf.h, define __cdecl when _MSC_VER is defined.
+
+Version 1.0.9beta7 [December 28, 2000]
+  Changed PNG_TEXT_COMPRESSION_zTXt to PNG_COMPRESSION_TYPE_BASE several places.
+  Revised memory management in png_set_hIST and png_handle_hIST in a backward
+    compatible manner.  PLTE and tRNS were revised similarly.
+  Revised the iCCP chunk reader to ignore trailing garbage.
+
+Version 1.0.9beta8 [January 12, 2001]
+  Moved pngasmrd.h into pngconf.h.
+  Improved handling of out-of-spec garbage iCCP chunks generated by PhotoShop.
+
+Version 1.0.9beta9 [January 15, 2001]
+  Added png_set_invalid, png_permit_mng_features, and png_mmx_supported to
+    wince and msvc project module definition files.
+  Minor revision of makefile.cygwin.
+  Fixed bug with progressive reading of narrow interlaced images in pngpread.c
+
+Version 1.0.9beta10 [January 16, 2001]
+  Do not typedef png_FILE_p in pngconf.h when PNG_NO_STDIO is defined.
+  Fixed "png_mmx_supported" typo in project definition files.
+
+Version 1.0.9beta11 [January 19, 2001]
+  Updated makefile.sgi to make shared library.
+  Removed png_mmx_support() function and disabled PNG_MNG_FEATURES_SUPPORTED
+    by default, for the benefit of DLL forward compatibility.  These will
+    be re-enabled in version 1.2.0.
+
+Version 1.0.9rc2 [January 22, 2001]
+  Revised cygwin support.
+
+Version 1.0.9 [January 31, 2001]
+  Added check of cygwin's ALL_STATIC in pngconf.h
+  Added "-nommx" parameter to contrib/gregbook/rpng2-win and rpng2-x demos.
+
+Version 1.0.10beta1 [March 14, 2001]
+  Revised makefile.dec, makefile.sgi, and makefile.sggcc; added makefile.hpgcc.
+  Reformatted libpng.3 to eliminate bad line breaks.
+  Added checks for _mmx_supported in the read_filter_row function of pnggccrd.c
+  Added prototype for png_mmx_support() near the top of pnggccrd.c
+  Moved some error checking from png_handle_IHDR to png_set_IHDR.
+  Added PNG_NO_READ_SUPPORTED and PNG_NO_WRITE_SUPPORTED macros.
+  Revised png_mmx_support() function in pnggccrd.c
+  Restored version 1.0.8 PNG_WRITE_EMPTY_PLTE_SUPPORTED behavior in pngwutil.c
+  Fixed memory leak in contrib/visupng/PngFile.c
+  Fixed bugs in png_combine_row() in pnggccrd.c and pngvcrd.c (C version)
+  Added warnings when retrieving or setting gamma=0.
+  Increased the first part of msg buffer from 16 to 18 in png_chunk_warning().
+
+Version 1.0.10rc1 [March 23, 2001]
+  Changed all instances of memcpy, strcpy, and strlen to png_memcpy, png_strcpy,
+    and png_strlen.
+  Revised png_mmx_supported() function in pnggccrd.c to return proper value.
+  Fixed bug in progressive reading (pngpread.c) with small images (height < 8).
+
+Version 1.0.10 [March 30, 2001]
+  Deleted extraneous space (introduced in 1.0.9) from line 42 of makefile.cygwin
+  Added beos project files (Chris Herborth)
+
+Version 1.0.11beta1 [April 3, 2001]
+  Added type casts on several png_malloc() calls (Dimitri Papadapoulos).
+  Removed a no-longer needed AIX work-around from pngconf.h
+  Changed several "//" single-line comments to C-style in pnggccrd.c
+
+Version 1.0.11beta2 [April 11, 2001]
+  Removed PNGAPI from several functions whose prototypes did not have PNGAPI.
+  Updated scripts/pngos2.def
+
+Version 1.0.11beta3 [April 14, 2001]
+  Added checking the results of many instances of png_malloc() for NULL
+
+Version 1.0.11beta4 [April 20, 2001]
+  Undid the changes from version 1.0.11beta3.  Added a check for NULL return
+    from user's malloc_fn().
+  Removed some useless type casts of the NULL pointer.
+  Added makefile.netbsd
+
+Version 1.0.11 [April 27, 2001]
+  Revised makefile.netbsd
+
+Version 1.0.12beta1 [May 14, 2001]
+  Test for Windows platform in pngconf.h when including malloc.h (Emmanuel Blot)
+  Updated makefile.cygwin and handling of Cygwin's ALL_STATIC in pngconf.h
+  Added some never-to-be-executed code in pnggccrd.c to quiet compiler warnings.
+  Eliminated the png_error about apps using png_read|write_init().  Instead,
+    libpng will reallocate the png_struct and info_struct if they are too small.
+    This retains future binary compatibility for old applications written for
+    libpng-0.88 and earlier.
+
+Version 1.2.0beta1 [May 6, 2001]
+  Bumped DLLNUM to 2.
+  Re-enabled PNG_MNG_FEATURES_SUPPORTED and enabled PNG_ASSEMBLER_CODE_SUPPORTED
+    by default.
+  Added runtime selection of MMX features.
+  Added png_set_strip_error_numbers function and related macros.
+
+Version 1.2.0beta2 [May 7, 2001]
+  Finished merging 1.2.0beta1 with version 1.0.11
+  Added a check for attempts to read or write PLTE in grayscale PNG datastreams.
+
+Version 1.2.0beta3 [May 17, 2001]
+  Enabled user memory function by default.
+  Modified png_create_struct so it passes user mem_ptr to user memory allocator.
+  Increased png_mng_features flag from png_byte to png_uint_32.
+  Bumped shared-library (so-number) and dll-number to 3.
+
+Version 1.2.0beta4 [June 23, 2001]
+  Check for missing profile length field in iCCP chunk and free chunk_data
+     in case of truncated iCCP chunk.
+  Bumped shared-library number to 3 in makefile.sgi and makefile.sggcc
+  Bumped dll-number from 2 to 3 in makefile.cygwin
+  Revised contrib/gregbook/rpng*-x.c to avoid a memory leak and to exit cleanly
+     if user attempts to run it on an 8-bit display.
+  Updated contrib/gregbook
+  Use png_malloc instead of png_zalloc to allocate palette in pngset.c
+  Updated makefile.ibmc
+  Added some typecasts to eliminate gcc 3.0 warnings.  Changed prototypes
+     of png_write_oFFS width and height from png_uint_32 to png_int_32.
+  Updated example.c
+  Revised prototypes for png_debug_malloc and png_debug_free in pngtest.c
+
+Version 1.2.0beta5 [August 8, 2001]
+  Revised contrib/gregbook
+  Revised makefile.gcmmx
+  Revised pnggccrd.c to conditionally compile some thread-unsafe code only
+     when PNG_THREAD_UNSAFE_OK is defined.
+  Added tests to prevent pngwutil.c from writing a bKGD or tRNS chunk with
+     value exceeding 2^bit_depth-1
+  Revised makefile.sgi and makefile.sggcc
+  Replaced calls to fprintf(stderr,...) with png_warning() in pnggccrd.c
+  Removed restriction that do_invert_mono only operate on 1-bit opaque files
+
+Version 1.2.0 [September 1, 2001]
+  Changed a png_warning() to png_debug() in pnggccrd.c
+  Fixed contrib/gregbook/rpng-x.c, rpng2-x.c to avoid crash with XFreeGC().
+
+Version 1.2.1beta1 [October 19, 2001]
+  Revised makefile.std in contrib/pngminus
+  Include background_1 in png_struct regardless of gamma support.
+  Revised makefile.netbsd and makefile.macosx, added makefile.darwin.
+  Revised example.c to provide more details about using row_callback().
+
+Version 1.2.1beta2 [October 25, 2001]
+  Added type cast to each NULL appearing in a function call, except for
+    WINCE functions.
+  Added makefile.so9.
+
+Version 1.2.1beta3 [October 27, 2001]
+  Removed type casts from all NULLs.
+  Simplified png_create_struct_2().
+
+Version 1.2.1beta4 [November 7, 2001]
+  Revised png_create_info_struct() and png_creat_struct_2().
+  Added error message if png_write_info() was omitted.
+  Type cast NULLs appearing in function calls when _NO_PROTO or
+    PNG_TYPECAST_NULL is defined.
+
+Version 1.2.1rc1 [November 24, 2001]
+  Type cast NULLs appearing in function calls except when PNG_NO_TYPECAST_NULL
+    is defined.
+  Changed typecast of "size" argument to png_size_t in pngmem.c calls to
+    the user malloc_fn, to agree with the prototype in png.h
+  Added a pop/push operation to pnggccrd.c, to preserve Eflag (Maxim Sobolev)
+  Updated makefile.sgi to recognize LIBPATH and INCPATH.
+  Updated various makefiles so "make clean" does not remove previous major
+    version of the shared library.
+
+Version 1.2.1rc2 [December 4, 2001]
+  Always allocate 256-entry internal palette, hist, and trans arrays, to
+    avoid out-of-bounds memory reference caused by invalid PNG datastreams.
+  Added a check for prefix_length > data_length in iCCP chunk handler.
+
+Version 1.2.1 [December 7, 2001]
+  None.
+
+Version 1.2.2beta1 [February 22, 2002]
+  Fixed a bug with reading the length of iCCP profiles (Larry Reeves).
+  Revised makefile.linux, makefile.gcmmx, and makefile.sgi to generate
+    libpng.a, libpng12.so (not libpng.so.3), and libpng12/png.h
+  Revised makefile.darwin to remove "-undefined suppress" option.
+  Added checks for gamma and chromaticity values over 21474.83, which exceed
+    the limit for PNG unsigned 32-bit integers when encoded.
+  Revised calls to png_create_read_struct() and png_create_write_struct()
+    for simpler debugging.
+  Revised png_zalloc() so zlib handles errors (uses PNG_FLAG_MALLOC_NULL_MEM_OK)
+
+Version 1.2.2beta2 [February 23, 2002]
+  Check chunk_length and idat_size for invalid (over PNG_MAX_UINT) lengths.
+  Check for invalid image dimensions in png_get_IHDR.
+  Added missing "fi;" in the install target of the SGI makefiles.
+  Added install-static to all makefiles that make shared libraries.
+  Always do gamma compensation when image is partially transparent.
+
+Version 1.2.2beta3 [March 7, 2002]
+  Compute background.gray and background_1.gray even when color_type is RGB
+    in case image gets reduced to gray later.
+  Modified shared-library makefiles to install pkgconfig/libpngNN.pc.
+  Export (with PNGAPI) png_zalloc, png_zfree, and png_handle_as_unknown
+  Removed unused png_write_destroy_info prototype from png.h
+  Eliminated incorrect use of width_mmx from pnggccrd.c in pixel_bytes == 8 case
+  Added install-shared target to all makefiles that make shared libraries.
+  Stopped a double free of palette, hist, and trans when not using free_me.
+  Added makefile.32sunu for Sun Ultra 32 and makefile.64sunu for Sun Ultra 64.
+
+Version 1.2.2beta4 [March 8, 2002]
+  Compute background.gray and background_1.gray even when color_type is RGB
+    in case image gets reduced to gray later (Jason Summers).
+  Relocated a misplaced /bin/rm in the "install-shared" makefile targets
+  Added PNG_1_0_X macro which can be used to build a 1.0.x-compatible library.
+
+Version 1.2.2beta5 [March 26, 2002]
+  Added missing PNGAPI to several function definitions.
+  Check for invalid bit_depth or color_type in png_get_IHDR(), and
+    check for missing PLTE or IHDR in png_push_read_chunk() (Matthias Clasen).
+  Revised iTXt support to accept NULL for lang and lang_key.
+  Compute gamma for color components of background even when color_type is gray.
+  Changed "()" to "{}" in scripts/libpng.pc.in.
+  Revised makefiles to put png.h and pngconf.h only in $prefix/include/libpngNN
+  Revised makefiles to make symlink to libpng.so.NN in addition to libpngNN.so
+
+Version 1.2.2beta6 [March 31, 2002]
+
+Version 1.0.13beta1 [March 31, 2002]
+  Prevent png_zalloc() from trying to memset memory that it failed to acquire.
+  Add typecasts of PNG_MAX_UINT in pngset_cHRM_fixed() (Matt Holgate).
+  Ensure that the right function (user or default) is used to free the
+    png_struct after an error in png_create_read_struct_2().
+
+Version 1.2.2rc1 [April 7, 2002]
+
+Version 1.0.13rc1 [April 7, 2002]
+  Save the ebx register in pnggccrd.c (Sami Farin)
+  Add "mem_ptr = png_ptr->mem_ptr" in png_destroy_write_struct() (Paul Gardner).
+  Updated makefiles to put headers in include/libpng and remove old include/*.h.
+
+Version 1.2.2 [April 15, 2002]
+
+Version 1.0.13 [April 15, 2002]
+  Revised description of png_set_filter() in libpng.3/libpng.txt.
+  Revised makefile.netbsd and added makefile.neNNbsd and makefile.freebsd
+
+Version 1.0.13patch01 [April 17, 2002]
+
+Version 1.2.2patch01 [April 17, 2002]
+  Changed ${PNGMAJ}.${PNGVER} bug to ${PNGVER} in makefile.sgi and
+    makefile.sggcc
+  Fixed VER -> PNGVER typo in makefile.macosx and added install-static to
+    install
+  Added install: target to makefile.32sunu and makefile.64sunu
+
+Version 1.0.13patch03 [April 18, 2002]
+
+Version 1.2.2patch03 [April 18, 2002]
+  Revised 15 makefiles to link libpng.a to libpngNN.a and the include libpng
+  subdirectory to libpngNN subdirectory without the full pathname.
+  Moved generation of libpng.pc from "install" to "all" in 15 makefiles.
+
+Version 1.2.3rc1 [April 28, 2002]
+  Added install-man target to 15 makefiles (Dimitri Papadopolous-Orfanos).
+  Added $(DESTDIR) feature to 24 makefiles (Tim Mooney)
+  Fixed bug with $prefix, should be $(prefix) in makefile.hpux.
+  Updated cygwin-specific portion of pngconf.h and revised makefile.cygwin
+  Added a link from libpngNN.pc to libpng.pc in 15 makefiles.
+  Added links from include/libpngNN/*.h to include/*.h in 24 makefiles.
+  Revised makefile.darwin to make relative links without full pathname.
+  Added setjmp() at the end of png_create_*_struct_2() in case user forgets
+    to put one in their application.
+  Restored png_zalloc() and png_zfree() prototypes to version 1.2.1 and
+    removed them from module definition files.
+
+Version 1.2.3rc2 [May 1, 2002]
+  Fixed bug in reporting number of channels in pngget.c and pngset.c,
+    that was introduced in version 1.2.2beta5.
+  Exported png_zalloc(), png_zfree(), png_default_read(), png_default_write(),
+    png_default_flush(), and png_push_fill_buffer() and included them in
+    module definition files.
+  Added "libpng.pc" dependency to the "install-shared" target in 15 makefiles.
+
+Version 1.2.3rc3 [May 1, 2002]
+  Revised prototype for png_default_flush()
+  Remove old libpng.pc and libpngNN.pc before installing new ones.
+
+Version 1.2.3rc4 [May 2, 2002]
+  Typos in *.def files (png_default_read|write -> png_default_read|write_data)
+  In makefiles, changed rm libpng.NN.pc to rm libpngNN.pc
+  Added libpng-config and libpngNN-config and modified makefiles to install
+    them.
+  Changed $(MANPATH) to $(DESTDIR)$(MANPATH) in makefiles
+  Added "Win32 DLL VB" configuration to projects/msvc/libpng.dsp
+
+Version 1.2.3rc5 [May 11, 2002]
+  Changed "error" and "message" in prototypes to "error_message" and
+    "warning_message" to avoid namespace conflict.
+  Revised 15 makefiles to build libpng-config from libpng-config-*.in
+  Once more restored png_zalloc and png_zfree to regular nonexported form.
+  Restored png_default_read|write_data, png_default_flush, png_read_fill_buffer
+    to nonexported form, but with PNGAPI, and removed them from module def
+    files.
+
+Version 1.2.3rc6 [May 14, 2002]
+  Removed "PNGAPI" from png_zalloc() and png_zfree() in png.c
+  Changed "Gz" to "Gd" in projects/msvc/libpng.dsp and zlib.dsp.
+  Removed leftover libpng-config "sed" script from four makefiles.
+  Revised libpng-config creating script in 16 makefiles.
+
+Version 1.2.3 [May 22, 2002]
+  Revised libpng-config target in makefile.cygwin.
+  Removed description of png_set_mem_fn() from documentation.
+  Revised makefile.freebsd.
+  Minor cosmetic changes to 15 makefiles, e.g., $(DI) = $(DESTDIR)/$(INCDIR).
+  Revised projects/msvc/README.txt
+  Changed -lpng to -lpngNN in LDFLAGS in several makefiles.
+
+Version 1.2.4beta1 [May 24, 2002]
+  Added libpng.pc and libpng-config to "all:" target in 16 makefiles.
+  Fixed bug in 16 makefiles: $(DESTDIR)/$(LIBPATH) to $(DESTDIR)$(LIBPATH)
+  Added missing "\" before closing double quote in makefile.gcmmx.
+  Plugged various memory leaks; added png_malloc_warn() and png_set_text_2()
+    functions.
+
+Version 1.2.4beta2 [June 25, 2002]
+  Plugged memory leak of png_ptr->current_text (Matt Holgate).
+  Check for buffer overflow before reading CRC in pngpread.c (Warwick Allison)
+  Added -soname to the loader flags in makefile.dec, makefile.sgi, and
+    makefile.sggcc.
+  Added "test-installed" target to makefile.linux, makefile.gcmmx,
+    makefile.sgi, and makefile.sggcc.
+
+Version 1.2.4beta3 [June 28, 2002]
+  Plugged memory leak of row_buf in pngtest.c when there is a png_error().
+  Detect buffer overflow in pngpread.c when IDAT is corrupted with extra data.
+  Added "test-installed" target to makefile.32sunu, makefile.64sunu,
+    makefile.beos, makefile.darwin, makefile.dec, makefile.macosx,
+    makefile.solaris, makefile.hpux, makefile.hpgcc, and makefile.so9.
+
+Version 1.2.4rc1 and 1.0.14rc1 [July 2, 2002]
+  Added "test-installed" target to makefile.cygwin and makefile.sco.
+  Revised pnggccrd.c to be able to back out version 1.0.x via PNG_1_0_X macro.
+
+Version 1.2.4 and 1.0.14 [July 8, 2002]
+  Changed png_warning() to png_error() when width is too large to process.
+
+Version 1.2.4patch01 [July 20, 2002]
+  Revised makefile.cygwin to use DLL number 12 instead of 13.
+
+Version 1.2.5beta1 [August 6, 2002]
+  Added code to contrib/gregbook/readpng2.c to ignore unused chunks.
+  Replaced toucan.png in contrib/gregbook (it has been corrupt since 1.0.11)
+  Removed some stray *.o files from contrib/gregbook.
+  Changed png_error() to png_warning() about "Too much data" in pngpread.c
+    and about "Extra compressed data" in pngrutil.c.
+  Prevent png_ptr->pass from exceeding 7 in png_push_finish_row().
+  Updated makefile.hpgcc
+  Updated png.c and pnggccrd.c handling of return from png_mmx_support()
+
+Version 1.2.5beta2 [August 15, 2002]
+  Only issue png_warning() about "Too much data" in pngpread.c when avail_in
+    is nonzero.
+  Updated makefiles to install a separate libpng.so.3 with its own rpath.
+
+Version 1.2.5rc1 and 1.0.15rc1 [August 24, 2002]
+  Revised makefiles to not remove previous minor versions of shared libraries.
+
+Version 1.2.5rc2 and 1.0.15rc2 [September 16, 2002]
+  Revised 13 makefiles to remove "-lz" and "-L$(ZLIBLIB)", etc., from shared
+    library loader directive.
+  Added missing "$OBJSDLL" line to makefile.gcmmx.
+  Added missing "; fi" to makefile.32sunu.
+
+Version 1.2.5rc3 and 1.0.15rc3 [September 18, 2002]
+  Revised libpng-config script.
+
+Version 1.2.5 and 1.0.15 [October 3, 2002]
+  Revised makefile.macosx, makefile.darwin, makefile.hpgcc, and makefile.hpux,
+    and makefile.aix.
+  Relocated two misplaced PNGAPI lines in pngtest.c
+
+Version 1.2.6beta1 [October 22, 2002]
+  Commented out warning about uninitialized mmx_support in pnggccrd.c.
+  Changed "IBMCPP__" flag to "__IBMCPP__" in pngconf.h.
+  Relocated two more misplaced PNGAPI lines in pngtest.c
+  Fixed memory overrun bug in png_do_read_filler() with 16-bit datastreams,
+    introduced in version 1.0.2.
+  Revised makefile.macosx, makefile.dec, makefile.aix, and makefile.32sunu.
+
+Version 1.2.6beta2 [November 1, 2002]
+  Added libpng-config "--ldopts" output.
+  Added "AR=ar" and "ARFLAGS=rc" and changed "ar rc" to "$(AR) $(ARFLAGS)"
+    in makefiles.
+
+Version 1.2.6beta3 [July 18, 2004]
+  Reverted makefile changes from version 1.2.6beta2 and some of the changes
+    from version 1.2.6beta1; these will be postponed until version 1.2.7.
+    Version 1.2.6 is going to be a simple bugfix release.
+  Changed the one instance of "ln -sf" to "ln -f -s" in each Sun makefile.
+  Fixed potential overrun in pngerror.c by using strncpy instead of memcpy.
+  Added "#!/bin/sh" at the top of configure, for recognition of the
+    'x' flag under Cygwin (Cosmin).
+  Optimized vacuous tests that silence compiler warnings, in png.c (Cosmin).
+  Added support for PNG_USER_CONFIG, in pngconf.h (Cosmin).
+  Fixed the special memory handler for Borland C under DOS, in pngmem.c
+    (Cosmin).
+  Removed some spurious assignments in pngrutil.c (Cosmin).
+  Replaced 65536 with 65536L, and 0xffff with 0xffffL, to silence warnings
+    on 16-bit platforms (Cosmin).
+  Enclosed shift op expressions in parentheses, to silence warnings (Cosmin).
+  Used proper type png_fixed_point, to avoid problems on 16-bit platforms,
+    in png_handle_sRGB() (Cosmin).
+  Added compression_type to png_struct, and optimized the window size
+    inside the deflate stream (Cosmin).
+  Fixed definition of isnonalpha(), in pngerror.c and pngrutil.c (Cosmin).
+  Fixed handling of unknown chunks that come after IDAT (Cosmin).
+  Allowed png_error() and png_warning() to work even if png_ptr == NULL
+    (Cosmin).
+  Replaced row_info->rowbytes with row_bytes in png_write_find_filter()
+    (Cosmin).
+  Fixed definition of PNG_LIBPNG_VER_DLLNUM (Simon-Pierre).
+  Used PNG_LIBPNG_VER and PNG_LIBPNG_VER_STRING instead of the hardcoded
+    values in png.c (Simon-Pierre, Cosmin).
+  Initialized png_libpng_ver[] with PNG_LIBPNG_VER_STRING (Simon-Pierre).
+  Replaced PNG_LIBPNG_VER_MAJOR with PNG_LIBPNG_VER_DLLNUM in png.rc
+    (Simon-Pierre).
+  Moved the definition of PNG_HEADER_VERSION_STRING near the definitions
+    of the other PNG_LIBPNG_VER_... symbols in png.h (Cosmin).
+  Relocated #ifndef PNGAPI guards in pngconf.h (Simon-Pierre, Cosmin).
+  Updated scripts/makefile.vc(a)win32 (Cosmin).
+  Updated the MSVC project (Simon-Pierre, Cosmin).
+  Updated the Borland C++ Builder project (Cosmin).
+  Avoided access to asm_flags in pngvcrd.c, if PNG_1_0_X is defined (Cosmin).
+  Commented out warning about uninitialized mmx_support in pngvcrd.c (Cosmin).
+  Removed scripts/makefile.bd32 and scripts/pngdef.pas (Cosmin).
+  Added extra guard around inclusion of Turbo C memory headers, in pngconf.h
+    (Cosmin).
+  Renamed projects/msvc/ to projects/visualc6/, and projects/borland/ to
+    projects/cbuilder5/ (Cosmin).
+  Moved projects/visualc6/png32ms.def to scripts/pngw32.def,
+    and projects/visualc6/png.rc to scripts/pngw32.rc (Cosmin).
+  Added projects/visualc6/pngtest.dsp; removed contrib/msvctest/ (Cosmin).
+  Changed line endings to DOS style in cbuilder5 and visualc6 files, even
+    in the tar.* distributions (Cosmin).
+  Updated contrib/visupng/VisualPng.dsp (Cosmin).
+  Updated contrib/visupng/cexcept.h to version 2.0.0 (Cosmin).
+  Added a separate distribution with "configure" and supporting files (Junichi).
+
+Version 1.2.6beta4 [July 28, 2004]
+  Added user ability to change png_size_t via a PNG_SIZE_T macro.
+  Added png_sizeof() and png_convert_size() functions.
+  Added PNG_SIZE_MAX (maximum value of a png_size_t variable.
+  Added check in png_malloc_default() for (size_t)size != (png_uint_32)size
+    which would indicate an overflow.
+  Changed sPLT failure action from png_error to png_warning and abandon chunk.
+  Changed sCAL and iCCP failures from png_error to png_warning and abandon.
+  Added png_get_uint_31(png_ptr, buf) function.
+  Added PNG_UINT_32_MAX macro.
+  Renamed PNG_MAX_UINT to PNG_UINT_31_MAX.
+  Made png_zalloc() issue a png_warning and return NULL on potential
+    overflow.
+  Turn on PNG_NO_ZALLOC_ZERO by default in version 1.2.x
+  Revised "clobber list" in pnggccrd.c so it will compile under gcc-3.4.
+  Revised Borland portion of png_malloc() to return NULL or issue
+    png_error() according to setting of PNG_FLAG_MALLOC_NULL_MEM_OK.
+  Added PNG_NO_SEQUENTIAL_READ_SUPPORTED macro to conditionally remove
+    sequential read support.
+  Added some "#if PNG_WRITE_SUPPORTED" blocks.
+  Added #ifdef to remove some redundancy in png_malloc_default().
+  Use png_malloc instead of png_zalloc to allocate the pallete.
+
+Version 1.0.16rc1 and 1.2.6rc1 [August 4, 2004]
+  Fixed buffer overflow vulnerability in png_handle_tRNS()
+  Fixed integer arithmetic overflow vulnerability in png_read_png().
+  Fixed some harmless bugs in png_handle_sBIT, etc, that would cause
+    duplicate chunk types to go undetected.
+  Fixed some timestamps in the -config version
+  Rearranged order of processing of color types in png_handle_tRNS().
+  Added ROWBYTES macro to calculate rowbytes without integer overflow.
+  Updated makefile.darwin and removed makefile.macosx from scripts directory.
+  Imposed default one million column, one-million row limits on the image
+    dimensions, and added png_set_user_limits() function to override them.
+  Revised use of PNG_SET_USER_LIMITS_SUPPORTED macro.
+  Fixed wrong cast of returns from png_get_user_width|height_max().
+  Changed some "keep the compiler happy" from empty statements to returns,
+  Revised libpng.txt to remove 1.2.x stuff from the 1.0.x distribution
+
+Version 1.0.16rc2 and 1.2.6rc2 [August 7, 2004]
+  Revised makefile.darwin and makefile.solaris.  Removed makefile.macosx.
+  Revised pngtest's png_debug_malloc() to use png_malloc() instead of
+    png_malloc_default() which is not supposed to be exported.
+  Fixed off-by-one error in one of the conversions to PNG_ROWBYTES() in
+    pngpread.c.  Bug was introduced in 1.2.6rc1.
+  Fixed bug in RGB to RGBX transformation introduced in 1.2.6rc1.
+  Fixed old bug in RGB to Gray transformation.
+  Fixed problem with 64-bit compilers by casting arguments to abs()
+    to png_int_32.
+  Changed "ln -sf" to "ln -f -s" in three makefiles (solaris, sco, so9).
+  Changed "HANDLE_CHUNK_*" to "PNG_HANDLE_CHUNK_*" (Cosmin)
+  Added "-@/bin/rm -f $(DL)/$(LIBNAME).so.$(PNGMAJ)" to 15 *NIX makefiles.
+  Added code to update the row_info->colortype in png_do_read_filler() (MSB).
+
+Version 1.0.16rc3 and 1.2.6rc3 [August 9, 2004]
+  Eliminated use of "abs()" in testing cHRM and gAMA values, to avoid
+    trouble with some 64-bit compilers.  Created PNG_OUT_OF_RANGE() macro.
+  Revised documentation of png_set_keep_unknown_chunks().
+  Check handle_as_unknown status in pngpread.c, as in pngread.c previously.
+  Moved  "PNG_HANDLE_CHUNK_*" macros out of PNG_INTERNAL section of png.h
+  Added "rim" definitions for CONST4 and CONST6 in pnggccrd.c
+
+Version 1.0.16rc4 and 1.2.6rc4 [August 10, 2004]
+  Fixed mistake in pngtest.c introduced in 1.2.6rc2 (declaration of
+    "pinfo" was out of place).
+
+Version 1.0.16rc5 and 1.2.6rc5 [August 10, 2004]
+  Moved  "PNG_HANDLE_CHUNK_*" macros out of PNG_ASSEMBLER_CODE_SUPPORTED
+     section of png.h where they were inadvertently placed in version rc3.
+
+Version 1.2.6 and 1.0.16 [August 15, 2004]
+  Revised pngtest so memory allocation testing is only done when PNG_DEBUG==1.
+
+Version 1.2.7beta1 [August 26, 2004]
+  Removed unused pngasmrd.h file.
+  Removed references to uu.net for archived files.  Added references to
+    PNG Spec (second edition) and the PNG ISO/IEC Standard.
+  Added "test-dd" target in 15 makefiles, to run pngtest in DESTDIR.
+  Fixed bug with "optimized window size" in the IDAT datastream, that
+    causes libpng to write PNG files with incorrect zlib header bytes.
+
+Version 1.2.7beta2 [August 28, 2004]
+  Fixed bug with sCAL chunk and big-endian machines (David Munro).
+  Undid new code added in 1.2.6rc2 to update the color_type in
+    png_set_filler().
+  Added png_set_add_alpha() that updates color type.
+
+Version 1.0.17rc1 and 1.2.7rc1 [September 4, 2004]
+  Revised png_set_strip_filler() to not remove alpha if color_type has alpha.
+
+Version 1.2.7 and 1.0.17 [September 12, 2004]
+  Added makefile.hp64
+  Changed projects/msvc/png32ms.def to scripts/png32ms.def in makefile.cygwin
+
+Version 1.2.8beta1 [November 1, 2004]
+  Fixed bug in png_text_compress() that would fail to complete a large block.
+  Fixed bug, introduced in libpng-1.2.7, that overruns a buffer during
+    strip alpha operation in png_do_strip_filler().
+  Added PNG_1_2_X definition in pngconf.h
+  Use #ifdef to comment out png_info_init in png.c and png_read_init in
+    pngread.c (as of 1.3.0)
+
+Version 1.2.8beta2 [November 2, 2004]
+  Reduce color_type to a nonalpha type after strip alpha operation in
+    png_do_strip_filler().
+
+Version 1.2.8beta3 [November 3, 2004]
+  Revised definitions of PNG_MAX_UINT_32, PNG_MAX_SIZE, and PNG_MAXSUM
+
+Version 1.2.8beta4 [November 12, 2004]
+  Fixed (again) definition of PNG_LIBPNG_VER_DLLNUM in png.h (Cosmin).
+  Added PNG_LIBPNG_BUILD_PRIVATE in png.h (Cosmin).
+  Set png_ptr->zstream.data_type to Z_BINARY, to avoid unnecessary detection
+    of data type in deflate (Cosmin).
+  Deprecated but continue to support SPECIALBUILD and PRIVATEBUILD in favor of
+    PNG_LIBPNG_BUILD_SPECIAL_STRING and PNG_LIBPNG_BUILD_PRIVATE_STRING.
+
+Version 1.2.8beta5 [November 20, 2004]
+  Use png_ptr->flags instead of png_ptr->transformations to pass
+    PNG_STRIP_ALPHA info to png_do_strip_filler(), to preserve ABI
+    compatibility.
+  Revised handling of SPECIALBUILD, PRIVATEBUILD,
+    PNG_LIBPNG_BUILD_SPECIAL_STRING and PNG_LIBPNG_BUILD_PRIVATE_STRING.
+
+Version 1.2.8rc1 [November 24, 2004]
+  Moved handling of BUILD macros from pngconf.h to png.h
+  Added definition of PNG_LIBPNG_BASE_TYPE in png.h, inadvertently
+    omitted from beta5.
+  Revised scripts/pngw32.rc
+  Despammed mailing addresses by masking "@" with "at".
+  Inadvertently installed a supposedly faster test version of pngrutil.c
+
+Version 1.2.8rc2 [November 26, 2004]
+  Added two missing "\" in png.h
+  Change tests in pngread.c and pngpread.c to
+    if (png_ptr->transformations || (png_ptr->flags&PNG_FLAG_STRIP_ALPHA))
+       png_do_read_transformations(png_ptr);
+
+Version 1.2.8rc3 [November 28, 2004]
+  Reverted pngrutil.c to version libpng-1.2.8beta5.
+  Added scripts/makefile.elf with supporting code in pngconf.h for symbol
+    versioning (John Bowler).
+
+Version 1.2.8rc4 [November 29, 2004]
+  Added projects/visualc7 (Simon-pierre).
+
+Version 1.2.8rc5 [November 29, 2004]
+  Fixed new typo in scripts/pngw32.rc
+
+Version 1.2.8 [December 3, 2004]
+  Removed projects/visualc7, added projects/visualc71.
+
+Version 1.2.9beta1 [February 21, 2006]
+  Initialized some structure members in pngwutil.c to avoid gcc-4.0.0 complaints
+  Revised man page and libpng.txt to make it clear that one should not call
+    png_read_end or png_write_end after png_read_png or png_write_png.
+  Updated references to png-mng-implement mailing list.
+  Fixed an incorrect typecast in pngrutil.c
+  Added PNG_NO_READ_SUPPORTED conditional for making a write-only library.
+  Added PNG_NO_WRITE_INTERLACING_SUPPORTED conditional.
+  Optimized alpha-inversion loops in pngwtran.c
+  Moved test for nonzero gamma outside of png_build_gamma_table() in pngrtran.c
+  Make sure num_trans is <= 256 before copying data in png_set_tRNS().
+  Make sure num_palette is <= 256 before copying data in png_set_PLTE().
+  Interchanged order of write_swap_alpha and write_invert_alpha transforms.
+  Added parentheses in the definition of PNG_LIBPNG_BUILD_TYPE (Cosmin).
+  Optimized zlib window flag (CINFO) in contrib/pngsuite/*.png (Cosmin).
+  Updated scripts/makefile.bc32 for Borland C++ 5.6 (Cosmin).
+  Exported png_get_uint_32, png_save_uint_32, png_get_uint_16, png_save_uint_16,
+    png_get_int_32, png_save_int_32, png_get_uint_31 (Cosmin).
+  Added type cast (png_byte) in png_write_sCAL() (Cosmin).
+  Fixed scripts/makefile.cygwin (Christian Biesinger, Cosmin).
+  Default iTXt support was inadvertently enabled.
+
+Version 1.2.9beta2 [February 21, 2006]
+  Check for png_rgb_to_gray and png_gray_to_rgb read transformations before
+    checking for png_read_dither in pngrtran.c
+  Revised checking of chromaticity limits to accommodate extended RGB
+    colorspace (John Denker).
+  Changed line endings in some of the project files to CRLF, even in the
+    "Unix" tar distributions (Cosmin).
+  Made png_get_int_32 and png_save_int_32 always available (Cosmin).
+  Updated scripts/pngos2.def, scripts/pngw32.def and projects/wince/png32ce.def
+    with the newly exported functions.
+  Eliminated distributions without the "configure" script.
+  Updated INSTALL instructions.
+
+Version 1.2.9beta3 [February 24, 2006]
+  Fixed CRCRLF line endings in contrib/visupng/VisualPng.dsp
+  Made libpng.pc respect EXEC_PREFIX (D. P. Kreil, J. Bowler)
+  Removed reference to pngasmrd.h from Makefile.am
+  Renamed CHANGES to ChangeLog.
+  Renamed LICENSE to COPYING.
+  Renamed ANNOUNCE to NEWS.
+  Created AUTHORS file.
+
+Version 1.2.9beta4 [March 3, 2006]
+  Changed definition of PKGCONFIG from $prefix/lib to $libdir in configure.ac
+  Reverted to filenames LICENSE and ANNOUNCE; removed AUTHORS and COPYING.
+  Removed newline from the end of some error and warning messages.
+  Removed test for sqrt() from configure.ac and configure.
+  Made swap tables in pngtrans.c PNG_CONST (Carlo Bramix).
+  Disabled default iTXt support that was inadvertently enabled in
+    libpng-1.2.9beta1.
+  Added "OS2" to list of systems that don't need underscores, in pnggccrd.c
+  Removed libpng version and date from *.c files.
+
+Version 1.2.9beta5 [March 4, 2006]
+  Removed trailing blanks from source files.
+  Put version and date of latest change in each source file, and changed
+    copyright year accordingly.
+  More cleanup of configure.ac, Makefile.am, and associated scripts.
+  Restored scripts/makefile.elf which was inadvertently deleted.
+
+Version 1.2.9beta6 [March 6, 2006]
+  Fixed typo (RELEASE) in configuration files.
+
+Version 1.2.9beta7 [March 7, 2006]
+  Removed libpng.vers and libpng.sym from libpng12_la_SOURCES in Makefile.am
+  Fixed inconsistent #ifdef's around png_sig_bytes() and png_set_sCAL_s()
+    in png.h.
+  Updated makefile.elf as suggested by debian.
+  Made cosmetic changes to some makefiles, adding LN_SF and other macros.
+  Made some makefiles accept "exec_prefix".
+
+Version 1.2.9beta8 [March 9, 2006]
+  Fixed some "#if defined (..." which should be "#if defined(..."
+    Bug introduced in libpng-1.2.8.
+  Fixed inconsistency in definition of png_default_read_data()
+  Restored blank that was lost from makefile.sggcc "clean" target in beta7.
+  Revised calculation of "current" and "major" for irix in ltmain.sh
+  Changed "mkdir" to "MKDIR_P" in some makefiles.
+  Separated PNG_EXPAND and PNG_EXPAND_tRNS.
+  Added png_set_expand_gray_1_2_4_to_8() and deprecated
+    png_set_gray_1_2_4_to_8() which also expands tRNS to alpha.
+
+Version 1.2.9beta9 [March 10, 2006]
+  Include "config.h" in pngconf.h when available.
+  Added some checks for NULL png_ptr or NULL info_ptr (timeless)
+
+Version 1.2.9beta10 [March 20, 2006]
+  Removed extra CR from contrib/visualpng/VisualPng.dsw (Cosmin)
+  Made pnggccrd.c PIC-compliant (Christian Aichinger).
+  Added makefile.mingw (Wolfgang Glas).
+  Revised pngconf.h MMX checking.
+
+Version 1.2.9beta11 [March 22, 2006]
+  Fixed out-of-order declaration in pngwrite.c that was introduced in beta9
+  Simplified some makefiles by using LIBSO, LIBSOMAJ, and LIBSOVER macros.
+
+Version 1.2.9rc1 [March 31, 2006]
+  Defined PNG_USER_PRIVATEBUILD when including "pngusr.h" (Cosmin).
+  Removed nonsensical assertion check from pngtest.c (Cosmin).
+
+Version 1.2.9 [April 14, 2006]
+  Revised makefile.beos and added "none" selector in ltmain.sh
+
+Version 1.2.10beta1 [April 15, 2006]
+  Renamed "config.h" to "png_conf.h" and revised Makefile.am to add
+    -DPNG_BUILDING_LIBPNG to compile directive, and modified pngconf.h
+    to include png_conf.h only when PNG_BUILDING_LIBPNG is defined.
+
+Version 1.2.10beta2 [April 15, 2006]
+  Manually updated Makefile.in and configure.  Changed png_conf.h.in
+    back to config.h.
+
+Version 1.2.10beta3 [April 15, 2006]
+  Change png_conf.h back to config.h in pngconf.h.
+
+Version 1.2.10beta4 [April 16, 2006]
+  Change PNG_BUILDING_LIBPNG to PNG_CONFIGURE_LIBPNG in config/Makefile*.
+
+Version 1.2.10beta5 [April 16, 2006]
+  Added a configure check for compiling assembler code in pnggccrd.c
+
+Version 1.2.10beta6 [April 17, 2006]
+  Revised the configure check for pnggccrd.c
+  Moved -DPNG_CONFIGURE_LIBPNG into @LIBPNG_DEFINES@
+  Added @LIBPNG_DEFINES@ to arguments when building libpng.sym
+
+Version 1.2.10beta7 [April 18, 2006]
+  Change "exec_prefix=$prefix" to "exec_prefix=$(prefix)" in makefiles.
+
+Version 1.2.10rc1 [April 19, 2006]
+  Ensure pngconf.h doesn't define both PNG_USE_PNGGCCRD and PNG_USE_PNGVCRD
+  Fixed "LN_FS" typo in makefile.sco and makefile.solaris.
+
+Version 1.2.10rc2 [April 20, 2006]
+  Added a backslash between -DPNG_CONFIGURE_LIBPNG and -DPNG_NO_ASSEMBLER_CODE
+   in configure.ac and configure
+  Made the configure warning about versioned symbols less arrogant.
+
+Version 1.2.10rc3 [April 21, 2006]
+  Added a note in libpng.txt that png_set_sig_bytes(8) can be used when
+    writing an embedded PNG without the 8-byte signature.
+  Revised makefiles and configure to avoid making links to libpng.so.*
+
+Version 1.2.10 [April 23, 2006]
+  Reverted configure to "rc2" state.
+
+Version 1.2.11beta1 [May 31, 2006]
+  scripts/libpng.pc.in contained "configure" style version info and would
+    not work with makefiles.
+  The shared-library makefiles were linking to libpng.so.0 instead of
+    libpng.so.3 compatibility as the library.
+
+Version 1.2.11beta2 [June 2, 2006]
+  Increased sprintf buffer from 50 to 52 chars in pngrutil.c to avoid
+    buffer overflow.
+  Fixed bug in example.c (png_set_palette_rgb -> png_set_palette_to_rgb)
+
+Version 1.2.11beta3 [June 5, 2006]
+  Prepended "#! /bin/sh" to ltmail.sh and contrib/pngminus/*.sh (Cosmin).
+  Removed the accidental leftover Makefile.in~ (Cosmin).
+  Avoided potential buffer overflow and optimized buffer in
+    png_write_sCAL(), png_write_sCAL_s() (Cosmin).
+  Removed the include directories and libraries from CFLAGS and LDFLAGS
+    in scripts/makefile.gcc (Nelson A. de Oliveira, Cosmin).
+
+Version 1.2.11beta4 [June 6, 2006]
+  Allow zero-length IDAT chunks after the entire zlib datastream, but not
+    after another intervening chunk type.
+
+Version 1.0.19rc1, 1.2.11rc1 [June 13, 2006]
+  Deleted extraneous square brackets from [config.h] in configure.ac
+
+Version 1.0.19rc2, 1.2.11rc2 [June 14, 2006]
+  Added prototypes for PNG_INCH_CONVERSIONS functions to png.h
+  Revised INSTALL and autogen.sh
+  Fixed typo in several makefiles (-W1 should be -Wl)
+  Added typedef for png_int_32 and png_uint_32 on 64-bit systems.
+
+Version 1.0.19rc3, 1.2.11rc3 [June 15, 2006]
+  Removed the new typedefs for 64-bit systems (delay until version 1.4.0)
+  Added one zero element to png_gamma_shift[] array in pngrtran.c to avoid
+    reading out of bounds.
+
+Version 1.0.19rc4, 1.2.11rc4 [June 15, 2006]
+  Really removed the new typedefs for 64-bit systems.
+
+Version 1.0.19rc5, 1.2.11rc5 [June 22, 2006]
+  Removed png_sig_bytes entry from scripts/pngw32.def
+
+Version 1.0.19, 1.2.11 [June 26, 2006]
+  None.
+
+Version 1.0.20, 1.2.12 [June 27, 2006]
+  Really increased sprintf buffer from 50 to 52 chars in pngrutil.c to avoid
+    buffer overflow.
+
+Version 1.2.13beta1 [October 2, 2006]
+  Removed AC_FUNC_MALLOC from configure.ac
+  Work around Intel-Mac compiler bug by setting PNG_NO_MMX_CODE in pngconf.h
+  Change "logical" to "bitwise" throughout documentation.
+  Detect and fix attempt to write wrong iCCP profile length (CVE-2006-7244)
+
+Version 1.0.21, 1.2.13 [November 14, 2006]
+  Fix potential buffer overflow in sPLT chunk handler.
+  Fix Makefile.am to not try to link to noexistent files.
+  Check all exported functions for NULL png_ptr.
+
+Version 1.2.14beta1 [November 17, 2006]
+  Relocated three misplaced tests for NULL png_ptr.
+  Built Makefile.in with automake-1.9.6 instead of 1.9.2.
+  Build configure with autoconf-2.60 instead of 2.59
+
+Version 1.2.14beta2 [November 17, 2006]
+  Added some typecasts in png_zalloc().
+
+Version 1.2.14rc1 [November 20, 2006]
+  Changed "strtod" to "png_strtod" in pngrutil.c
+
+Version 1.0.22, 1.2.14    [November 27, 2006]
+  Added missing "$(srcdir)" in Makefile.am and Makefile.in
+
+Version 1.2.15beta1 [December 3, 2006]
+  Generated configure with autoconf-2.61 instead of 2.60
+  Revised configure.ac to update libpng.pc and libpng-config.
+
+Version 1.2.15beta2 [December 3, 2006]
+  Always export MMX asm functions, just stubs if not building pnggccrd.c
+
+Version 1.2.15beta3 [December 4, 2006]
+  Add "png_bytep" typecast to profile while calculating length in pngwutil.c
+
+Version 1.2.15beta4 [December 7, 2006]
+  Added scripts/CMakeLists.txt
+  Changed PNG_NO_ASSEMBLER_CODE to PNG_NO_MMX_CODE in scripts, like 1.4.0beta
+
+Version 1.2.15beta5 [December 7, 2006]
+  Changed some instances of PNG_ASSEMBLER_* to PNG_MMX_* in pnggccrd.c
+  Revised scripts/CMakeLists.txt
+
+Version 1.2.15beta6 [December 13, 2006]
+  Revised scripts/CMakeLists.txt and configure.ac
+
+Version 1.2.15rc1 [December 18, 2006]
+  Revised scripts/CMakeLists.txt
+
+Version 1.2.15rc2 [December 21, 2006]
+  Added conditional #undef jmpbuf in pngtest.c to undo #define in AIX headers.
+  Added scripts/makefile.nommx
+
+Version 1.2.15rc3 [December 25, 2006]
+  Fixed shared library numbering error that was introduced in 1.2.15beta6.
+
+Version 1.2.15rc4 [December 27, 2006]
+  Fixed handling of rgb_to_gray when png_ptr->color.gray isn't set.
+
+Version 1.2.15rc5 [December 31, 2006]
+  Revised handling of rgb_to_gray.
+
+Version 1.2.15 [January 5, 2007]
+  Added some (unsigned long) typecasts in pngtest.c to avoid printing errors.
+
+Version 1.2.16beta1 [January 6, 2007]
+  Fix bugs in makefile.nommx
+
+Version 1.2.16beta2 [January 16, 2007]
+  Revised scripts/CMakeLists.txt
+
+Version 1.2.16 [January 31, 2007]
+  No changes.
+
+Version 1.2.17beta1 [March 6, 2007]
+  Revised scripts/CMakeLists.txt to install both shared and static libraries.
+  Deleted a redundant line from pngset.c.
+
+Version 1.2.17beta2 [April 26, 2007]
+  Relocated misplaced test for png_ptr == NULL in pngpread.c
+  Change "==" to "&" for testing PNG_RGB_TO_GRAY_ERR & PNG_RGB_TO_GRAY_WARN
+    flags.
+  Changed remaining instances of PNG_ASSEMBLER_* to PNG_MMX_*
+  Added pngerror() when write_IHDR fails in deflateInit2().
+  Added "const" to some array declarations.
+  Mention examples of libpng usage in the libpng*.txt and libpng.3 documents.
+
+Version 1.2.17rc1 [May 4, 2007]
+  No changes.
+
+Version 1.2.17rc2 [May 8, 2007]
+  Moved several PNG_HAVE_* macros out of PNG_INTERNAL because applications
+    calling set_unknown_chunk_location() need them.
+  Changed transformation flag from PNG_EXPAND_tRNS to PNG_EXPAND in
+    png_set_expand_gray_1_2_4_to_8().
+  Added png_ptr->unknown_chunk to hold working unknown chunk data, so it
+    can be free'ed in case of error.  Revised unknown chunk handling in
+    pngrutil.c and pngpread.c to use this structure.
+
+Version 1.2.17rc3 [May 8, 2007]
+  Revised symbol-handling in configure script.
+
+Version 1.2.17rc4 [May 10, 2007]
+  Revised unknown chunk handling to avoid storing unknown critical chunks.
+
+Version 1.0.25 [May 15, 2007]
+Version 1.2.17 [May 15, 2007]
+  Added "png_ptr->num_trans=0" before error return in png_handle_tRNS,
+    to eliminate a vulnerability (CVE-2007-2445, CERT VU#684664)
+
+Version 1.0.26 [May 15, 2007]
+Version 1.2.18 [May 15, 2007]
+  Reverted the libpng-1.2.17rc3 change to symbol-handling in configure script
+
+Version 1.2.19beta1 [May 18, 2007]
+  Changed "const static" to "static PNG_CONST" everywhere, mostly undoing
+    change of libpng-1.2.17beta2.  Changed other "const" to "PNG_CONST"
+  Changed some handling of unused parameters, to avoid compiler warnings.
+    "if (unused == NULL) return;" becomes "unused = unused".
+
+Version 1.2.19beta2 [May 18, 2007]
+  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)
+
+Version 1.2.19beta3 [May 19, 2007]
+  Add some "png_byte" typecasts in png_check_keyword() and write new_key
+  instead of key in zTXt chunk (Kevin Ryde).
+
+Version 1.2.19beta4 [May 21, 2007]
+  Add png_snprintf() function and use it in place of sprint() for improved
+    defense against buffer overflows.
+
+Version 1.2.19beta5 [May 21, 2007]
+  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
+  Changed handling of more unused parameters, to avoid compiler warnings.
+  Removed some PNG_CONST in pngwutil.c to avoid compiler warnings.
+
+Version 1.2.19beta6 [May 22, 2007]
+  Added some #ifdef PNG_MMX_CODE_SUPPORTED where needed in pngvcrd.c
+  Added a special "_MSC_VER" case that defines png_snprintf to _snprintf
+
+Version 1.2.19beta7 [May 22, 2007]
+  Squelched png_squelch_warnings() in pnggccrd.c and added
+    an #ifdef PNG_MMX_CODE_SUPPORTED block around the declarations that caused
+    the warnings that png_squelch_warnings was squelching.
+
+Version 1.2.19beta8 [May 22, 2007]
+  Removed __MMX__ from test in pngconf.h.
+
+Version 1.2.19beta9 [May 23, 2007]
+  Made png_squelch_warnings() available via PNG_SQUELCH_WARNINGS macro.
+  Revised png_squelch_warnings() so it might work.
+  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.
+
+Version 1.2.19beta10 [May 24, 2007]
+  Resquelched png_squelch_warnings(), use "__attribute__((used))" instead.
+
+Version 1.4.0beta1 [April 20, 2006]
+  Enabled iTXt support (changes png_struct, thus requires so-number change).
+  Cleaned up PNG_ASSEMBLER_CODE_SUPPORTED vs PNG_MMX_CODE_SUPPORTED
+  Eliminated PNG_1_0_X and PNG_1_2_X macros.
+  Removed deprecated functions png_read_init, png_write_init, png_info_init,
+    png_permit_empty_plte, png_set_gray_1_2_4_to_8, png_check_sig, and
+    removed the deprecated macro PNG_MAX_UINT.
+  Moved "PNG_INTERNAL" parts of png.h and pngconf.h into pngintrn.h
+  Removed many WIN32_WCE #ifdefs (Cosmin).
+  Reduced dependency on C-runtime library when on Windows (Simon-Pierre)
+  Replaced sprintf() with png_sprintf() (Simon-Pierre)
+
+Version 1.4.0beta2 [April 20, 2006]
+  Revised makefiles and configure to avoid making links to libpng.so.*
+  Moved some leftover MMX-related defines from pngconf.h to pngintrn.h
+  Updated scripts/pngos2.def, pngw32.def, and projects/wince/png32ce.def
+
+Version 1.4.0beta3 [May 10, 2006]
+  Updated scripts/pngw32.def to comment out MMX functions.
+  Added PNG_NO_GET_INT_32 and PNG_NO_SAVE_INT_32 macros.
+  Scripts/libpng.pc.in contained "configure" style version info and would
+    not work with makefiles.
+  Revised pngconf.h and added pngconf.h.in, so makefiles and configure can
+    pass defines to libpng and applications.
+
+Version 1.4.0beta4 [May 11, 2006]
+  Revised configure.ac, Makefile.am, and many of the makefiles to write
+    their defines in pngconf.h.
+
+Version 1.4.0beta5 [May 15, 2006]
+  Added a missing semicolon in Makefile.am and Makefile.in
+  Deleted extraneous square brackets from configure.ac
+
+Version 1.4.0beta6 [June 2, 2006]
+  Increased sprintf buffer from 50 to 52 chars in pngrutil.c to avoid
+    buffer overflow.
+  Changed sonum from 0 to 1.
+  Removed unused prototype for png_check_sig() from png.h
+
+Version 1.4.0beta7 [June 16, 2006]
+  Exported png_write_sig (Cosmin).
+  Optimized buffer in png_handle_cHRM() (Cosmin).
+  Set pHYs = 2835 x 2835 pixels per meter, and added
+    sCAL = 0.352778e-3 x 0.352778e-3 meters, in pngtest.png (Cosmin).
+  Added png_set_benign_errors(), png_benign_error(), png_chunk_benign_error().
+  Added typedef for png_int_32 and png_uint_32 on 64-bit systems.
+  Added "(unsigned long)" typecast on png_uint_32 variables in printf lists.
+
+Version 1.4.0beta8 [June 22, 2006]
+  Added demonstration of user chunk support in pngtest.c, to support the
+    public sTER chunk and a private vpAg chunk.
+
+Version 1.4.0beta9 [July 3, 2006]
+  Removed ordinals from scripts/pngw32.def and removed png_info_int and
+    png_set_gray_1_2_4_to_8 entries.
+  Inline call of png_get_uint_32() in png_get_uint_31().
+  Use png_get_uint_31() to get vpAg width and height in pngtest.c
+  Removed WINCE and Netware projects.
+  Removed standalone Y2KINFO file.
+
+Version 1.4.0beta10 [July 12, 2006]
+  Eliminated automatic copy of pngconf.h to pngconf.h.in from configure and
+    some makefiles, because it was not working reliably.  Instead, distribute
+    pngconf.h.in along with pngconf.h and cause configure and some of the
+    makefiles to update pngconf.h from pngconf.h.in.
+  Added pngconf.h to DEPENDENCIES in Makefile.am
+
+Version 1.4.0beta11 [August 19, 2006]
+  Removed AC_FUNC_MALLOC from configure.ac.
+  Added a warning when writing iCCP profile with mismatched profile length.
+  Patched pnggccrd.c to assemble on x86_64 platforms.
+  Moved chunk header reading into a separate function png_read_chunk_header()
+    in pngrutil.c.  The chunk header (len+sig) is now serialized in a single
+    operation (Cosmin).
+  Implemented support for I/O states. Added png_ptr member io_state, and
+    functions png_get_io_chunk_name() and png_get_io_state() in pngget.c
+    (Cosmin).
+  Added png_get_io_chunk_name and png_get_io_state to scripts/*.def (Cosmin).
+  Renamed scripts/pngw32.* to scripts/pngwin.* (Cosmin).
+  Removed the include directories and libraries from CFLAGS and LDFLAGS
+    in scripts/makefile.gcc (Cosmin).
+  Used png_save_uint_32() to set vpAg width and height in pngtest.c (Cosmin).
+  Cast to proper type when getting/setting vpAg units in pngtest.c (Cosmin).
+  Added pngintrn.h to the Visual C++ projects (Cosmin).
+  Removed scripts/list (Cosmin).
+  Updated copyright year in scripts/pngwin.def (Cosmin).
+  Removed PNG_TYPECAST_NULL and used standard NULL consistently (Cosmin).
+  Disallowed the user to redefine png_size_t, and enforced a consistent use
+    of png_size_t across libpng (Cosmin).
+  Changed the type of png_ptr->rowbytes, PNG_ROWBYTES() and friends
+    to png_size_t (Cosmin).
+  Removed png_convert_size() and replaced png_sizeof with sizeof (Cosmin).
+  Removed some unnecessary type casts (Cosmin).
+  Changed prototype of png_get_compression_buffer_size() and
+    png_set_compression_buffer_size() to work with png_size_t instead of
+    png_uint_32 (Cosmin).
+  Removed png_memcpy_check() and png_memset_check() (Cosmin).
+  Fixed a typo (png_byte --> png_bytep) in libpng.3 and libpng.txt (Cosmin).
+  Clarified that png_zalloc() does not clear the allocated memory,
+    and png_zalloc() and png_zfree() cannot be PNGAPI (Cosmin).
+  Renamed png_mem_size_t to png_alloc_size_t, fixed its definition in
+    pngconf.h, and used it in all memory allocation functions (Cosmin).
+  Renamed pngintrn.h to pngpriv.h, added a comment at the top of the file
+    mentioning that the symbols declared in that file are private, and
+    updated the scripts and the Visual C++ projects accordingly (Cosmin).
+  Removed circular references between pngconf.h and pngconf.h.in in
+    scripts/makefile.vc*win32 (Cosmin).
+  Removing trailing '.' from the warning and error messages (Cosmin).
+  Added pngdefs.h that is built by makefile or configure, instead of
+    pngconf.h.in (Glenn).
+  Detect and fix attempt to write wrong iCCP profile length.
+
+Version 1.4.0beta12 [October 19, 2006]
+  Changed "logical" to "bitwise" in the documentation.
+  Work around Intel-Mac compiler bug by setting PNG_NO_MMX_CODE in pngconf.h
+  Add a typecast to stifle compiler warning in pngrutil.c
+
+Version 1.4.0beta13 [November 10, 2006]
+  Fix potential buffer overflow in sPLT chunk handler.
+  Fix Makefile.am to not try to link to noexistent files.
+
+Version 1.4.0beta14 [November 15, 2006]
+  Check all exported functions for NULL png_ptr.
+
+Version 1.4.0beta15 [November 17, 2006]
+  Relocated two misplaced tests for NULL png_ptr.
+  Built Makefile.in with automake-1.9.6 instead of 1.9.2.
+  Build configure with autoconf-2.60 instead of 2.59
+  Add "install: all" in Makefile.am so "configure; make install" will work.
+
+Version 1.4.0beta16 [November 17, 2006]
+  Added a typecast in png_zalloc().
+
+Version 1.4.0beta17 [December 4, 2006]
+  Changed "new_key[79] = '\0';" to "(*new_key)[79] = '\0';" in pngwutil.c
+  Add "png_bytep" typecast to profile while calculating length in pngwutil.c
+
+Version 1.4.0beta18 [December 7, 2006]
+  Added scripts/CMakeLists.txt
+
+Version 1.4.0beta19 [May 16, 2007]
+  Revised scripts/CMakeLists.txt
+  Rebuilt configure and Makefile.in with newer tools.
+  Added conditional #undef jmpbuf in pngtest.c to undo #define in AIX headers.
+  Added scripts/makefile.nommx
+
+Version 1.4.0beta20 [July 9, 2008]
+  Moved several PNG_HAVE_* macros from pngpriv.h to png.h because applications
+    calling set_unknown_chunk_location() need them.
+  Moved several macro definitions from pngpriv.h to pngconf.h
+  Merge with changes to the 1.2.X branch, as of 1.2.30beta04.
+  Deleted all use of the MMX assembler code and Intel-licensed optimizations.
+  Revised makefile.mingw
+
+Version 1.4.0beta21 [July 21, 2008]
+  Moved local array "chunkdata" from pngrutil.c to the png_struct, so
+    it will be freed by png_read_destroy() in case of a read error (Kurt
+    Christensen).
+
+Version 1.4.0beta22 [July 21, 2008]
+  Change "purpose" and "buffer" to png_ptr->chunkdata to avoid memory leaking.
+
+Version 1.4.0beta23 [July 22, 2008]
+  Change "chunkdata = NULL" to "png_ptr->chunkdata = NULL" several places in
+    png_decompress_chunk().
+
+Version 1.4.0beta24 [July 25, 2008]
+  Change all remaining "chunkdata" to "png_ptr->chunkdata" in
+    png_decompress_chunk(), and remove "chunkdata" from parameter list.
+  Put a call to png_check_chunk_name() in png_read_chunk_header().
+  Revised png_check_chunk_name() to reject a name with a lowercase 3rd byte.
+  Removed two calls to png_check_chunk_name() occuring later in the process.
+  Define PNG_NO_ERROR_NUMBERS by default in pngconf.h
+
+Version 1.4.0beta25 [July 30, 2008]
+  Added a call to png_check_chunk_name() in pngpread.c
+  Reverted png_check_chunk_name() to accept a name with a lowercase 3rd byte.
+  Added png_push_have_buffer() function to pngpread.c
+  Eliminated PNG_BIG_ENDIAN_SUPPORTED and associated png_get_* macros.
+  Made inline expansion of png_get_*() optional with PNG_USE_READ_MACROS.
+  Eliminated all PNG_USELESS_TESTS and PNG_CORRECT_PALETTE_SUPPORTED code.
+  Synced contrib directory and configure files with libpng-1.2.30beta06.
+  Eliminated no-longer-used pngdefs.h (but it's still built in the makefiles)
+  Relocated a misplaced "#endif /* PNG_NO_WRITE_FILTER */" in pngwutil.c
+
+Version 1.4.0beta26 [August 4, 2008]
+  Removed png_push_have_buffer() function in pngpread.c.  It increased the
+    compiled library size slightly.
+  Changed "-Wall" to "-W -Wall" in the CFLAGS in all makefiles (Cosmin Truta)
+  Declared png_ptr "volatile" in pngread.c and pngwrite.c to avoid warnings.
+  Updated contrib/visupng/cexcept.h to version 2.0.1
+  Added PNG_LITERAL_CHARACTER macros for #, [, and ].
+
+Version 1.4.0beta27 [August 5, 2008]
+  Revised usage of PNG_LITERAL_SHARP in pngerror.c.
+  Moved newline character from individual png_debug messages into the
+    png_debug macros.
+  Allow user to #define their own png_debug, png_debug1, and png_debug2.
+
+Version 1.4.0beta28 [August 5, 2008]
+  Revised usage of PNG_LITERAL_SHARP in pngerror.c.
+  Added PNG_STRING_NEWLINE macro
+
+Version 1.4.0beta29 [August 9, 2008]
+  Revised usage of PNG_STRING_NEWLINE to work on non-ISO compilers.
+  Added PNG_STRING_COPYRIGHT macro.
+  Added non-ISO versions of png_debug macros.
+
+Version 1.4.0beta30 [August 14, 2008]
+  Added premultiplied alpha feature (Volker Wiendl).
+
+Version 1.4.0beta31 [August 18, 2008]
+  Moved png_set_premultiply_alpha from pngtrans.c to pngrtran.c
+  Removed extra crc check at the end of png_handle_cHRM().  Bug introduced
+    in libpng-1.4.0beta20.
+
+Version 1.4.0beta32 [August 19, 2008]
+  Added PNG_WRITE_FLUSH_SUPPORTED block around new png_flush() call.
+  Revised PNG_NO_STDIO version of png_write_flush()
+
+Version 1.4.0beta33 [August 20, 2008]
+  Added png_get|set_chunk_cache_max() to limit the total number of sPLT,
+    text, and unknown chunks that can be stored.
+
+Version 1.4.0beta34 [September 6, 2008]
+  Shortened tIME_string to 29 bytes in pngtest.c
+  Fixed off-by-one error introduced in png_push_read_zTXt() function in
+    libpng-1.2.30beta04/pngpread.c (Harald van Dijk)
+
+Version 1.4.0beta35 [October 6, 2008]
+  Changed "trans_values" to "trans_color".
+  Changed so-number from 0 to 14.  Some OS do not like 0.
+  Revised makefile.darwin to fix shared library numbering.
+  Change png_set_gray_1_2_4_to_8() to png_set_expand_gray_1_2_4_to_8()
+    in example.c (debian bug report)
+
+Version 1.4.0beta36 [October 25, 2008]
+  Sync with tEXt vulnerability fix in libpng-1.2.33rc02.
+
+Version 1.4.0beta37 [November 13, 2008]
+  Added png_check_cHRM in png.c and moved checking from pngget.c, pngrutil.c,
+    and pngwrite.c
+
+Version 1.4.0beta38 [November 22, 2008]
+  Added check for zero-area RGB cHRM triangle in png_check_cHRM() and
+    png_check_cHRM_fixed().
+
+Version 1.4.0beta39 [November 23, 2008]
+  Revised png_warning() to write its message on standard output by default
+    when warning_fn is NULL.
+
+Version 1.4.0beta40 [November 24, 2008]
+  Eliminated png_check_cHRM().  Instead, always use png_check_cHRM_fixed().
+  In png_check_cHRM_fixed(), ensure white_y is > 0, and removed redundant
+    check for all-zero coordinates that is detected by the triangle check.
+
+Version 1.4.0beta41 [November 26, 2008]
+  Fixed string vs pointer-to-string error in png_check_keyword().
+  Rearranged test expressions in png_check_cHRM_fixed() to avoid internal
+    overflows.
+  Added PNG_NO_CHECK_cHRM conditional.
+
+Version 1.4.0beta42, 43 [December 1, 2008]
+  Merge png_debug with version 1.2.34beta04.
+
+Version 1.4.0beta44 [December 6, 2008]
+  Removed redundant check for key==NULL before calling png_check_keyword()
+    to ensure that new_key gets initialized and removed extra warning
+    (Merge with version 1.2.34beta05 -- Arvan Pritchard).
+
+Version 1.4.0beta45 [December 9, 2008]
+  In png_write_png(), respect the placement of the filler bytes in an earlier
+    call to png_set_filler() (Jim Barry).
+
+Version 1.4.0beta46 [December 10, 2008]
+  Undid previous change and added PNG_TRANSFORM_STRIP_FILLER_BEFORE and
+    PNG_TRANSFORM_STRIP_FILLER_AFTER conditionals and deprecated
+    PNG_TRANSFORM_STRIP_FILLER (Jim Barry).
+
+Version 1.4.0beta47 [December 15, 2008]
+  Support for dithering was disabled by default, because it has never
+    been well tested and doesn't work very well.  The code has not
+    been removed, however, and can be enabled by building libpng with
+    PNG_READ_DITHER_SUPPORTED defined.
+
+Version 1.4.0beta48 [February 14, 2009]
+  Added new exported function png_calloc().
+  Combined several instances of png_malloc(); png_memset() into png_calloc().
+  Removed prototype for png_freeptr() that was added in libpng-1.4.0beta24
+    but was never defined.
+
+Version 1.4.0beta49 [February 28, 2009]
+  Added png_fileno() macro to pngconf.h, used in pngwio.c
+  Corrected order of #ifdef's in png_debug definition in png.h
+  Fixed bug introduced in libpng-1.4.0beta48 with the memset arguments
+    for pcal_params.
+  Fixed order of #ifdef directives in the png_debug defines in png.h
+    (bug introduced in libpng-1.2.34/1.4.0beta29).
+  Revised comments in png_set_read_fn() and png_set_write_fn().
+
+Version 1.4.0beta50 [March 18, 2009]
+  Use png_calloc() instead of png_malloc() to allocate big_row_buf when
+    reading an interlaced file, to avoid a possible UMR.
+  Undid revision of PNG_NO_STDIO version of png_write_flush().  Users
+    having trouble with fflush() can build with PNG_NO_WRITE_FLUSH defined
+    or supply their own flush_fn() replacement.
+  Revised libpng*.txt and png.h documentation about use of png_write_flush()
+    and png_set_write_fn().
+  Removed fflush() from pngtest.c.
+  Added "#define PNG_NO_WRITE_FLUSH" to contrib/pngminim/encoder/pngusr.h
+
+Version 1.4.0beta51 [March 21, 2009]
+  Removed new png_fileno() macro from pngconf.h .
+
+Version 1.4.0beta52 [March 27, 2009]
+  Relocated png_do_chop() ahead of building gamma tables in pngrtran.c
+    This avoids building 16-bit gamma tables unnecessarily.
+  Removed fflush() from pngtest.c.
+  Added "#define PNG_NO_WRITE_FLUSH" to contrib/pngminim/encoder/pngusr.h
+  Added a section on differences between 1.0.x and 1.2.x to libpng.3/libpng.txt
+
+Version 1.4.0beta53 [April 1, 2009]
+  Removed some remaining MMX macros from pngpriv.h
+  Fixed potential memory leak of "new_name" in png_write_iCCP() (Ralph Giles)
+
+Version 1.4.0beta54 [April 13, 2009]
+  Added "ifndef PNG_SKIP_SETJMP_CHECK" block in pngconf.h to allow
+    application code writers to bypass the check for multiple inclusion
+    of setjmp.h when they know that it is safe to ignore the situation.
+  Eliminated internal use of setjmp() in pngread.c and pngwrite.c
+  Reordered ancillary chunks in pngtest.png to be the same as what
+    pngtest now produces, and made some cosmetic changes to pngtest output.
+  Eliminated deprecated png_read_init_3() and png_write_init_3() functions.
+
+Version 1.4.0beta55 [April 15, 2009]
+  Simplified error handling in pngread.c and pngwrite.c by putting
+    the new png_read_cleanup() and png_write_cleanup() functions inline.
+
+Version 1.4.0beta56 [April 25, 2009]
+  Renamed "user_chunk_data" to "my_user_chunk_data" in pngtest.c to suppress
+    "shadowed declaration" warning from gcc-4.3.3.
+  Renamed "gamma" to "png_gamma" in pngset.c to avoid "shadowed declaration"
+    warning about a global "gamma" variable in math.h on some platforms.
+
+Version 1.4.0beta57 [May 2, 2009]
+  Removed prototype for png_freeptr() that was added in libpng-1.4.0beta24
+    but was never defined (again).
+  Rebuilt configure scripts with autoconf-2.63 instead of 2.62
+  Removed pngprefs.h and MMX from makefiles
+
+Version 1.4.0beta58 [May 14, 2009]
+  Changed pngw32.def to pngwin.def in makefile.mingw (typo was introduced
+    in beta57).
+  Clarified usage of sig_bit versus sig_bit_p in example.c (Vincent Torri)
+
+Version 1.4.0beta59 [May 15, 2009]
+  Reformated sources in libpng style (3-space intentation, comment format)
+  Fixed typo in libpng docs (PNG_FILTER_AVE should be PNG_FILTER_AVG)
+  Added sections about the git repository and our coding style to the
+    documentation
+  Relocated misplaced #endif in pngwrite.c, sCAL chunk handler.
+
+Version 1.4.0beta60 [May 19, 2009]
+  Conditionally compile png_read_finish_row() which is not used by
+    progressive readers.
+  Added contrib/pngminim/preader to demonstrate building minimal progressive
+    decoder, based on contrib/gregbook with embedded libpng and zlib.
+
+Version 1.4.0beta61 [May 20, 2009]
+  In contrib/pngminim/*, renamed "makefile.std" to "makefile", since there
+    is only one makefile in those directories, and revised the README files
+    accordingly.
+  More reformatting of comments, mostly to capitalize sentences.
+
+Version 1.4.0beta62 [June 2, 2009]
+  Added "#define PNG_NO_WRITE_SWAP" to contrib/pngminim/encoder/pngusr.h
+    and "define PNG_NO_READ_SWAP" to decoder/pngusr.h and preader/pngusr.h
+  Reformatted several remaining "else statement" into two lines.
+  Added a section to the libpng documentation about using png_get_io_ptr()
+    in configure scripts to detect the presence of libpng.
+
+Version 1.4.0beta63 [June 15, 2009]
+  Revised libpng*.txt and libpng.3 to mention calling png_set_IHDR()
+    multiple times and to specify the sample order in the tRNS chunk,
+    because the ISO PNG specification has a typo in the tRNS table.
+  Changed several PNG_UNKNOWN_CHUNK_SUPPORTED to
+    PNG_HANDLE_AS_UNKNOWN_SUPPORTED, to make the png_set_keep mechanism
+    available for ignoring known chunks even when not saving unknown chunks.
+  Adopted preference for consistent use of "#ifdef" and "#ifndef" versus
+    "#if defined()" and "if !defined()" where possible.
+
+Version 1.4.0beta64 [June 24, 2009]
+  Eliminated PNG_LEGACY_SUPPORTED code.
+  Moved the various unknown chunk macro definitions outside of the
+     PNG_READ|WRITE_ANCILLARY_CHUNK_SUPPORTED blocks.
+
+Version 1.4.0beta65 [June 26, 2009]
+  Added a reference to the libpng license in each file.
+
+Version 1.4.0beta66 [June 27, 2009]
+  Refer to the libpng license instead of the libpng license in each file.
+
+Version 1.4.0beta67 [July 6, 2009]
+  Relocated INVERT_ALPHA within png_read_png() and png_write_png().
+  Added high-level API transform PNG_TRANSFORM_GRAY_TO_RGB.
+  Added an "xcode" project to the projects directory (Alam Arias).
+
+Version 1.4.0beta68 [July 19, 2009]
+  Avoid some tests in filter selection in pngwutil.c
+
+Version 1.4.0beta69 [July 25, 2009]
+  Simplified the new filter-selection test.  This runs faster in the
+    common "PNG_ALL_FILTERS" and PNG_FILTER_NONE cases.
+  Removed extraneous declaration from the new call to png_read_gray_to_rgb()
+    (bug introduced in libpng-1.4.0beta67).
+  Fixed up xcode project (Alam Arias)
+  Added a prototype for png_64bit_product() in png.c
+
+Version 1.4.0beta70 [July 27, 2009]
+  Avoid a possible NULL dereference in debug build, in png_set_text_2().
+    (bug introduced in libpng-0.95, discovered by Evan Rouault)
+
+Version 1.4.0beta71 [July 29, 2009]
+  Rebuilt configure scripts with autoconf-2.64.
+
+Version 1.4.0beta72 [August 1, 2009]
+  Replaced *.tar.lzma with *.tar.xz in distribution.  Get the xz codec
+    from <http://tukaani.org/xz>.
+
+Version 1.4.0beta73 [August 1, 2009]
+  Reject attempt to write iCCP chunk with negative embedded profile length
+    (JD Chen) (CVE-2009-5063).
+
+Version 1.4.0beta74 [August 8, 2009]
+  Changed png_ptr and info_ptr member "trans" to "trans_alpha".
+
+Version 1.4.0beta75 [August 21, 2009]
+  Removed an extra png_debug() recently added to png_write_find_filter().
+  Fixed incorrect #ifdef in pngset.c regarding unknown chunk support.
+
+Version 1.4.0beta76 [August 22, 2009]
+  Moved an incorrectly located test in png_read_row() in pngread.c
+
+Version 1.4.0beta77 [August 27, 2009]
+  Removed lpXYZ.tar.bz2 (with CRLF), KNOWNBUG, libpng-x.y.z-KNOWNBUG.txt,
+    and the "noconfig" files from the distribution.
+  Moved CMakeLists.txt from scripts into the main libpng directory.
+  Various bugfixes and improvements to CMakeLists.txt (Philip Lowman)
+
+Version 1.4.0beta78 [August 31, 2009]
+  Converted all PNG_NO_* tests to PNG_*_SUPPORTED everywhere except pngconf.h
+  Eliminated PNG_NO_FREE_ME and PNG_FREE_ME_SUPPORTED macros.
+  Use png_malloc plus a loop instead of png_calloc() to initialize
+    row_pointers in png_read_png().
+
+Version 1.4.0beta79 [September 1, 2009]
+  Eliminated PNG_GLOBAL_ARRAYS and PNG_LOCAL_ARRAYS; always use local arrays.
+  Eliminated PNG_CALLOC_SUPPORTED macro and always provide png_calloc().
+
+Version 1.4.0beta80 [September 17, 2009]
+  Removed scripts/libpng.icc
+  Changed typecast of filler from png_byte to png_uint_16 in png_set_filler().
+    (Dennis Gustafsson)
+  Fixed typo introduced in beta78 in pngtest.c ("#if def " should be "#ifdef ")
+
+Version 1.4.0beta81 [September 23, 2009]
+  Eliminated unused PNG_FLAG_FREE_* defines from pngpriv.h
+  Expanded TAB characters in pngrtran.c
+  Removed PNG_CONST from all "PNG_CONST PNG_CHNK" declarations to avoid
+    compiler complaints about doubly declaring things "const".
+  Changed all "#if [!]defined(X)" to "if[n]def X" where possible.
+  Eliminated unused png_ptr->row_buf_size
+
+Version 1.4.0beta82 [September 25, 2009]
+  Moved redundant IHDR checking into new png_check_IHDR() in png.c
+    and report all errors found in the IHDR data.
+  Eliminated useless call to png_check_cHRM() from pngset.c
+
+Version 1.4.0beta83 [September 25, 2009]
+  Revised png_check_IHDR() to eliminate bogus complaint about filter_type.
+
+Version 1.4.0beta84 [September 30, 2009]
+  Fixed some inconsistent indentation in pngconf.h
+  Revised png_check_IHDR() to add a test for width variable less than 32-bit.
+
+Version 1.4.0beta85 [October 1, 2009]
+  Revised png_check_IHDR() again, to check info_ptr members instead of
+    the contents of the returned parameters.
+
+Version 1.4.0beta86 [October 9, 2009]
+  Updated the "xcode" project (Alam Arias).
+  Eliminated a shadowed declaration of "pp" in png_handle_sPLT().
+
+Version 1.4.0rc01 [October 19, 2009]
+  Trivial cosmetic changes.
+
+Version 1.4.0beta87 [October 30, 2009]
+  Moved version 1.4.0 back into beta.
+
+Version 1.4.0beta88 [October 30, 2009]
+  Revised libpng*.txt section about differences between 1.2.x and 1.4.0
+    because most of the new features have now been ported back to 1.2.41
+
+Version 1.4.0beta89 [November 1, 2009]
+  More bugfixes and improvements to CMakeLists.txt (Philip Lowman)
+  Removed a harmless extra png_set_invert_alpha() from pngwrite.c
+  Apply png_user_chunk_cache_max within png_decompress_chunk().
+  Merged libpng-1.2.41.txt with libpng-1.4.0.txt where appropriate.
+
+Version 1.4.0beta90 [November 2, 2009]
+  Removed all remaining WIN32_WCE #ifdefs except those involving the
+    time.h "tm" structure
+
+Version 1.4.0beta91 [November 3, 2009]
+  Updated scripts/pngw32.def and projects/wince/png32ce.def
+  Copied projects/wince/png32ce.def to the scripts directory.
+  Added scripts/makefile.wce
+  Patched ltmain.sh for wince support.
+  Added PNG_CONVERT_tIME_SUPPORTED macro.
+
+Version 1.4.0beta92 [November 4, 2009]
+  Make inclusion of time.h in pngconf.h depend on PNG_CONVERT_tIME_SUPPORTED
+  Make #define PNG_CONVERT_tIME_SUPPORTED depend on PNG_WRITE_tIME_SUPPORTED
+  Revised libpng*.txt to describe differences from 1.2.40 to 1.4.0 (instead
+    of differences from 1.2.41 to 1.4.0)
+
+Version 1.4.0beta93 [November 7, 2009]
+  Added PNG_DEPSTRUCT, PNG_DEPRECATED, PNG_USE_RESULT, PNG_NORETURN, and
+    PNG_ALLOCATED macros to detect deprecated direct access to the
+    png_struct or info_struct members and other deprecated usage in
+    applications (John Bowler).
+  Updated scripts/makefile* to add "-DPNG_CONFIGURE_LIBPNG" to CFLAGS,
+    to prevent warnings about direct access to png structs by libpng
+    functions while building libpng.  They need to be tested, especially
+    those using compilers other than gcc.
+  Updated projects/visualc6 and visualc71 with "/d PNG_CONFIGURE_LIBPNG".
+    They should work but still need to be updated to remove
+    references to pnggccrd.c or pngvcrd.c and ASM building.
+  Added README.txt to the beos, cbuilder5, netware, and xcode projects warning
+    that they need to be updated, to remove references to pnggccrd.c and
+    pngvcrd.c and to depend on pngpriv.h
+  Removed three direct references to read_info_ptr members in pngtest.c
+    that were detected by the new PNG_DEPSTRUCT macro.
+  Moved the png_debug macro definitions and the png_read_destroy(),
+    png_write_destroy() and png_far_to_near() prototypes from png.h
+    to pngpriv.h (John Bowler)
+  Moved the synopsis lines for png_read_destroy(), png_write_destroy()
+    png_debug(), png_debug1(), and png_debug2() from libpng.3 to libpngpf.3.
+
+Version 1.4.0beta94 [November 9, 2009]
+  Removed the obsolete, unused pnggccrd.c and pngvcrd.c files.
+  Updated CMakeLists.txt to add "-DPNG_CONFIGURE_LIBPNG" to the definitions.
+  Removed dependency of pngtest.o on pngpriv.h in the makefiles.
+  Only #define PNG_DEPSTRUCT, etc. in pngconf.h if not already defined.
+
+Version 1.4.0beta95 [November 10, 2009]
+  Changed png_check_sig() to !png_sig_cmp() in contrib programs.
+  Added -DPNG_CONFIGURE_LIBPNG to contrib/pngminm/*/makefile
+  Changed png_check_sig() to !png_sig_cmp() in contrib programs.
+  Corrected the png_get_IHDR() call in contrib/gregbook/readpng2.c
+  Changed pngminim/*/gather.sh to stop trying to remove pnggccrd.c and pngvcrd.c
+  Added dependency on pngpriv.h in contrib/pngminim/*/makefile
+
+Version 1.4.0beta96 [November 12, 2009]
+  Renamed scripts/makefile.wce to scripts/makefile.cegcc
+  Revised Makefile.am to use libpng.sys while building libpng.so
+    so that only PNG_EXPORT functions are exported.
+  Removed the deprecated png_check_sig() function/macro.
+  Removed recently removed function names from scripts/*.def
+  Revised pngtest.png to put chunks in the same order written by pngtest
+    (evidently the same change made in libpng-1.0beta54 was lost).
+  Added PNG_PRIVATE macro definition in pngconf.h for possible future use.
+
+Version 1.4.0beta97 [November 13, 2009]
+  Restored pngtest.png to the libpng-1.4.0beta7 version.
+  Removed projects/beos and netware.txt; no one seems to be supporting them.
+  Revised Makefile.in
+
+Version 1.4.0beta98 [November 13, 2009]
+  Added the "xcode" project to zip distributions,
+  Fixed a typo in scripts/pngwin.def introduced in beta97.
+
+Version 1.4.0beta99 [November 14, 2009]
+  Moved libpng-config.in and libpng.pc-configure.in out of the scripts
+    directory, to libpng-config.in and libpng-pc.in, respectively, and
+    modified Makefile.am and configure.ac accordingly.  Now "configure"
+    needs nothing from the "scripts" directory.
+  Avoid redefining PNG_CONST in pngconf.h
+
+Version 1.4.0beta100 [November 14, 2009]
+  Removed ASM builds from projects/visualc6 and projects/visualc71
+  Removed scripts/makefile.nommx and makefile.vcawin32
+  Revised CMakeLists.txt to account for new location of libpng-config.in
+    and libpng-pc.in
+  Updated INSTALL to reflect removal and relocation of files.
+
+Version 1.4.0beta101 [November 14, 2009]
+  Restored the binary files (*.jpg, *.png, some project files) that were
+    accidentally deleted from the zip and 7z distributions when the xcode
+    project was added.
+
+Version 1.4.0beta102 [November 18, 2009]
+  Added libpng-config.in and libpng-pc.in to the zip and 7z distributions.
+  Fixed a typo in projects/visualc6/pngtest.dsp, introduced in beta100.
+  Moved descriptions of makefiles and other scripts out of INSTALL into
+    scripts/README.txt
+  Updated the copyright year in scripts/pngwin.rc from 2006 to 2009.
+
+Version 1.4.0beta103 [November 21, 2009]
+  Removed obsolete comments about ASM from projects/visualc71/README_zlib.txt
+  Align row_buf on 16-byte boundary in memory.
+  Restored the PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED guard around the call
+    to png_flush() after png_write_IEND().  See 1.4.0beta32, 1.4.0beta50
+    changes above and 1.2.30, 1.2.30rc01 and rc03 in 1.2.41 CHANGES.  Someone
+    needs this feature.
+  Make the 'png_jmpbuf' macro expand to a call that records the correct
+    longjmp function as well as returning a pointer to the setjmp
+    jmp_buf buffer, and marked direct access to jmpbuf 'deprecated'.
+    (John Bowler)
+
+Version 1.4.0beta104 [November 22, 2009]
+  Removed png_longjmp_ptr from scripts/*.def and libpng.3
+  Rebuilt configure scripts with autoconf-2.65
+
+Version 1.4.0beta105 [November 25, 2009]
+  Use fast integer PNG_DIVIDE_BY_255() or PNG_DIVIDE_BY_65535()
+    to accomplish alpha premultiplication when
+    PNG_READ_COMPOSITE_NODIV_SUPPORTED is defined.
+  Changed "/255" to "/255.0" in background calculations to make it clear
+    that the 255 is used as a double.
+
+Version 1.4.0beta106 [November 27, 2009]
+  Removed premultiplied alpha feature.
+
+Version 1.4.0beta107 [December 4, 2009]
+  Updated README
+  Added "#define PNG_NO_PEDANTIC_WARNINGS" in the libpng source files.
+  Removed "-DPNG_CONFIGURE_LIBPNG" from the makefiles and projects.
+  Revised scripts/makefile.netbsd, makefile.openbsd, and makefile.sco
+    to put png.h and pngconf.h in $prefix/include, like the other scripts,
+    instead of in $prefix/include/libpng.  Also revised makefile.sco
+    to put them in $prefix/include/libpng15 instead of in
+    $prefix/include/libpng/libpng15.
+
+Version 1.4.0beta108 [December 11, 2009]
+  Removed leftover "-DPNG_CONFIGURE_LIBPNG" from contrib/pngminim/*/makefile
+  Relocated png_do_chop() to its original position in pngrtran.c; the
+    change in version 1.2.41beta08 caused transparency to be handled wrong
+    in some 16-bit datastreams (Yusaku Sugai).
+
+Version 1.4.0beta109 [December 13, 2009]
+  Added "bit_depth" parameter to the private png_build_gamma_table() function.
+  Pass bit_depth=8 to png_build_gamma_table() when bit_depth is 16 but the
+    PNG_16_TO_8 transform has been set, to avoid unnecessary build of 16-bit
+    tables.
+
+Version 1.4.0rc02 [December 20, 2009]
+  Declared png_cleanup_needed "volatile" in pngread.c and pngwrite.c
+
+Version 1.4.0rc03 [December 22, 2009]
+  Renamed libpng-pc.in back to libpng.pc.in and revised CMakeLists.txt
+    (revising the change in 1.4.0beta99)
+
+Version 1.4.0rc04 [December 25, 2009]
+  Swapped PNG_UNKNOWN_CHUNKS_SUPPORTED and PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+    in pngset.c to be consistent with other changes in version 1.2.38.
+
+Version 1.4.0rc05 [December 25, 2009]
+  Changed "libpng-pc.in" to "libpng.pc.in" in configure.ac, configure, and
+    Makefile.in to be consistent with changes in libpng-1.4.0rc03
+
+Version 1.4.0rc06 [December 29, 2009]
+  Reverted the gamma_table changes from libpng-1.4.0beta109.
+  Fixed some indentation errors.
+
+Version 1.4.0rc07 [January 1, 2010]
+  Revised libpng*.txt and libpng.3 about 1.2.x->1.4.x differences.
+  Use png_calloc() instead of png_malloc(); png_memset() in pngrutil.c
+  Update copyright year to 2010.
+
+Version 1.4.0rc08 [January 2, 2010]
+  Avoid deprecated references to png_ptr-io_ptr and png_ptr->error_ptr
+    in pngtest.c
+
+Version 1.4.0 [January 3, 2010]
+  No changes.
+
+Version 1.4.1beta01 [January 8, 2010]
+  Updated CMakeLists.txt for consistent indentation and to avoid an
+    unclosed if-statement warning (Philip Lowman).
+  Revised Makefile.am and Makefile.in to remove references to Y2KINFO,
+    KNOWNBUG, and libpng.la (Robert Schwebel).
+  Revised the makefiles to install the same files and symbolic
+    links as configure, except for libpng.la and libpng14.la.
+  Make png_set|get_compression_buffer_size() available even when
+    PNG_WRITE_SUPPORTED is not enabled.
+  Revised Makefile.am and Makefile.in to simplify their maintenance.
+  Revised scripts/makefile.linux to install a link to libpng14.so.14.1
+
+Version 1.4.1beta02 [January 9, 2010]
+  Revised the rest of the makefiles to install a link to libpng14.so.14.1
+
+Version 1.4.1beta03 [January 10, 2010]
+  Removed png_set_premultiply_alpha() from scripts/*.def
+
+Version 1.4.1rc01 [January 16, 2010]
+  No changes.
+
+Version 1.4.1beta04 [January 23, 2010]
+  Revised png_decompress_chunk() to improve speed and memory usage when
+    decoding large chunks.
+  Added png_set|get_chunk_malloc_max() functions.
+
+Version 1.4.1beta05 [January 26, 2010]
+  Relocated "int k" declaration in pngtest.c to minimize its scope.
+
+Version 1.4.1beta06 [January 28, 2010]
+  Revised png_decompress_chunk() to use a two-pass method suggested by
+    John Bowler.
+
+Version 1.4.1beta07 [February 6, 2010]
+  Folded some long lines in the source files.
+  Added defineable PNG_USER_CHUNK_CACHE_MAX, PNG_USER_CHUNK_MALLOC_MAX,
+    and a PNG_USER_LIMITS_SUPPORTED flag.
+  Eliminated use of png_ptr->irowbytes and reused the slot in png_ptr as
+    png_ptr->png_user_chunk_malloc_max.
+  Revised png_push_save_buffer() to do fewer but larger png_malloc() calls.
+
+Version 1.4.1beta08 [February 6, 2010]
+  Minor cleanup and updating of dates and copyright year.
+
+Version 1.5.0beta01 [February 7, 2010]
+  Moved declaration of png_struct into private pngstruct.h and png_info
+    into pnginfo.h
+
+Version 1.4.1beta09 and 1.5.0beta02 [February 7, 2010]
+  Reverted to original png_push_save_buffer() code.
+
+Version 1.4.1beta10 and 1.5.0beta03 [February 8, 2010]
+  Return allocated "old_buffer" in png_push_save_buffer() before
+    calling png_error(), to avoid a potential memory leak.
+  Updated configure script to use SO number 15.
+
+Version 1.5.0beta04 [February 9, 2010]
+  Removed malformed "incomplete struct declaration" of png_info from png.h
+
+Version 1.5.0beta05 [February 12, 2010]
+  Removed PNG_DEPSTRUCT markup in pngstruct.h and pnginfo.h, and undid the
+    linewrapping that it entailed.
+  Revised comments in pngstruct.h and pnginfo.h and added pointers to
+    the libpng license.
+  Changed PNG_INTERNAL to PNG_EXPOSE_INTERNAL_STRUCTURES
+  Removed the cbuilder5 project, which has not been updated to 1.4.0.
+
+Version 1.4.1beta12 and 1.5.0beta06 [February 14, 2010]
+  Fixed type declaration of png_get_chunk_malloc_max() in pngget.c (Daisuke
+    Nishikawa)
+
+Version 1.5.0beta07 [omitted]
+
+Version 1.5.0beta08 [February 19, 2010]
+  Changed #ifdef PNG_NO_STDIO_SUPPORTED to #ifdef PNG_NO_CONSOLE_IO_SUPPORTED
+    wherever png_snprintf() is used to construct error and warning messages.
+  Noted in scripts/makefile.mingw that it expects to be run under MSYS.
+  Removed obsolete unused MMX-querying support from contrib/gregbook
+  Added exported png_longjmp() function.
+  Removed the AIX redefinition of jmpbuf in png.h
+  Added -D_ALLSOURCE in configure.ac, makefile.aix, and CMakeLists.txt
+    when building on AIX.
+
+Version 1.5.0beta09 [February 19, 2010]
+  Removed -D_ALLSOURCE from configure.ac, makefile.aix, and CMakeLists.txt.
+  Changed the name of png_ptr->jmpbuf to png_ptr->png_jmpbuf in pngstruct.h
+
+Version 1.5.0beta10 [February 25, 2010]
+  Removed unused gzio.c from contrib/pngminim gather and makefile scripts
+  Removed replacement error handlers from contrib/gregbook.  Because of
+    the new png_longjmp() function they are no longer needed.
+
+Version 1.5.0beta11 [March 6, 2010]
+  Removed checking for already-included setjmp.h from pngconf.h
+  Fixed inconsistent indentations and made numerous cosmetic changes.
+  Revised the "SEE ALSO" style of libpng.3, libpngpf.3, and png.5
+
+Version 1.5.0beta12 [March 9, 2010]
+  Moved "#include png.h" inside pngpriv.h and removed "#include png.h" from
+    the source files, along with "#define PNG_EXPOSE_INTERNAL_STRUCTURES"
+    and "#define PNG_NO_PEDANTIC_WARNINGS" (John Bowler).
+  Created new pngdebug.h and moved debug definitions there.
+
+Version 1.5.0beta13 [March 10, 2010]
+  Protect pngstruct.h, pnginfo.h, and pngdebug.h from being included twice.
+  Revise the "#ifdef" blocks in png_inflate() so it will compile when neither
+    PNG_USER_CHUNK_MALLOC_MAX nor PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
+    is defined.
+  Removed unused png_measure_compressed_chunk() from pngpriv.h and libpngpf.3
+  Moved the 'config.h' support from pngconf.h to pngpriv.h
+  Removed PNGAPI from the png_longjmp_ptr typedef.
+  Eliminated dependence of pngtest.c on the private pngdebug.h file.
+  Make all png_debug macros into *unterminated* statements or
+    expressions (i.e. a trailing ';' must always be added) and correct
+    the format statements in various png_debug messages.
+
+Version 1.5.0beta14 [March 14, 2010]
+  Removed direct access to png_ptr->io_ptr from the Windows code in pngtest.c
+  Revised Makefile.am to account for recent additions and replacements.
+  Corrected CE and OS/2 DEF files (scripts/png*def) for symbols removed and
+    added ordinal numbers to the Windows DEF file and corrected the duplicated
+    ordinal numbers on CE symbols that are commented out.
+  Added back in export symbols that can be present in the Windows build but
+    are disabled by default.
+  PNG_EXPORT changed to include an 'ordinal' field for DEF file generation.
+    PNG_CALLBACK added to make callback definitions uniform.  PNGAPI split
+    into PNGCAPI (base C form), PNGAPI (exports) and PNGCBAPI (callbacks),
+    and appropriate changes made to all files.  Cygwin builds re-hinged to
+    allow procedure call standard changes and to remove the need for the DEF
+    file (fixes build on Cygwin).
+  Enabled 'attribute' warnings that are relevant to library APIs and callbacks.
+  Changed rules for generation of the various symbol files and added a new
+    rule for a DEF file (which is also added to the distribution).
+  Updated the symbol file generation to stop it adding spurious spaces
+    to EOL (coming from preprocessor macro expansion).  Added a facility
+    to join tokens in the output and rewrite *.dfn to use this.
+  Eliminated scripts/*.def in favor of libpng.def; updated projects/visualc71
+    and removed scripts/makefile.cygwin.
+  Made PNG_BUILD_DLL safe: it can be set whenever a DLL is being built.
+  Removed the include of sys/types.h - apparently unnecessary now on the
+    platforms on which it happened (all but Mac OS and RISC OS).
+  Moved the Mac OS test into pngpriv.h (the only place it is used.)
+
+Version 1.5.0beta15 [March 17, 2010]
+  Added symbols.chk target to Makefile.am to validate the symbols in png.h
+    against the new DEF file scripts/symbols.def.
+  Changed the default DEF file back to pngwin.def.
+  Removed makefile.mingw.
+  Eliminated PNG_NO_EXTERN and PNG_ALL_EXTERN
+
+Version 1.5.0beta16 [April 1, 2010]
+  Make png_text_struct independent of PNG_iTXt_SUPPORTED, so that
+    fields are initialized in all configurations.  The READ/WRITE
+    macros (PNG_(READ|WRITE)_iTXt_SUPPORTED) still function as
+    before to disable code to actually read or write iTXt chunks
+    and iTXt_SUPPORTED can be used to detect presence of either
+    read or write support (but it is probably better to check for
+    the one actually required - read or write.)
+  Combined multiple png_warning() calls for a single error.
+  Restored the macro definition of png_check_sig().
+
+Version 1.5.0beta17 [April 17, 2010]
+  Added some "(long)" typecasts to printf calls in png_handle_cHRM().
+  Documented the fact that png_set_dither() was disabled since libpng-1.4.0.
+  Reenabled png_set_dither() but renamed it to png_set_quantize() to reflect
+    more accurately what it actually does.  At the same time, renamed
+    the PNG_DITHER_[RED,GREEN_BLUE]_BITS macros to
+    PNG_QUANTIZE_[RED,GREEN,BLUE]_BITS.
+  Added some "(long)" typecasts to printf calls in png_handle_cHRM().
+  Freeze build-time only configuration in the build.
+    In all prior versions of libpng most configuration options
+    controlled by compiler #defines had to be repeated by the
+    application code that used libpng.  This patch changes this
+    so that compilation options that can only be changed at build
+    time are frozen in the build.  Options that are compiler
+    dependent (and those that are system dependent) are evaluated
+    each time - pngconf.h holds these.  Options that can be changed
+    per-file in the application are in png.h.  Frozen options are
+    in the new installed header file pnglibconf.h (John Bowler)
+  Removed the xcode project because it has not been updated to work
+    with libpng-1.5.0.
+  Removed the ability to include optional pngusr.h
+
+Version 1.5.0beta18 [April 17, 2010]
+  Restored the ability to include optional pngusr.h
+  Moved replacements for png_error() and png_warning() from the
+    contrib/pngminim project to pngerror.c, for use when warnings or
+    errors are disabled via PNG_NO_WARN or PNG_NO_ERROR_TEXT, to avoid
+    storing unneeded error/warning text.
+  Updated contrib/pngminim project to work with the new pnglibconf.h
+  Added some PNG_NO_* defines to contrib/pngminim/*/pngusr.h to save space.
+
+Version 1.5.0beta19 [April 24, 2010]
+  Added PNG_{READ,WRITE}_INT_FUNCTIONS_SUPPORTED.  This allows the functions
+    to read and write ints to be disabled independently of PNG_USE_READ_MACROS,
+    which allows libpng to be built with the functions even though the default
+    is to use the macros - this allows applications to choose at app build
+    time whether or not to use macros (previously impossible because the
+    functions weren't in the default build.)
+  Changed Windows calling convention back to __cdecl for API functions.
+    For Windows/x86 platforms only:
+      __stdcall is no longer needed for Visual Basic, so libpng-1.5.0 uses
+      __cdecl throughout (both API functions and callbacks) on Windows/x86
+      platforms.
+  Replaced visualc6 and visualc71 projects with new vstudio project
+  Relaxed the overly-restrictive permissions of some files.
+
+Version 1.5.0beta20 [April 24, 2010]
+  Relaxed more overly-restrictive permissions of some files.
+
+Version 1.5.0beta21 [April 27, 2010]
+  Removed some unwanted binary bytes and changed CRLF to NEWLINE in the new
+    vstudio project files, and some trivial editing of some files in the
+    scripts directory.
+  Set PNG_NO_READ_BGR, PNG_NO_IO_STATE, and PNG_NO_TIME_RFC1123 in
+    contrib/pngminim/decoder/pngusr.h to make a smaller decoder application.
+
+Version 1.5.0beta22 [April 28, 2010]
+  Fixed dependencies of GET_INT_32 - it does not require READ_INT_FUNCTIONS
+    because it has a macro equivalent.
+  Improved the options.awk script; added an "everything off" option.
+  Revised contrib/pngminim to use the "everything off" option in pngusr.dfa.
+
+Version 1.5.0beta23 [April 29, 2010]
+  Corrected PNG_REMOVED macro to take five arguments.
+    The macro was documented with two arguments (name,ordinal), however
+    the symbol checking .dfn files assumed five arguments.  The five
+    argument form seems more useful so it is changed to that.
+  Corrected PNG_UNKNOWN_CHUNKS_SUPPORTED to PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+    in gregbook/readpng2.c
+  Corrected protection of png_get_user_transform_ptr. The API declaration in
+    png.h is removed if both READ and WRITE USER_TRANSFORM are turned off
+    but was left defined in pngtrans.c
+  Added logunsupported=1 to cause pnglibconf.h to document disabled options.
+    This makes the installed pnglibconf.h more readable but causes no
+    other change.  The intention is that users of libpng will find it
+    easier to understand if an API they need is missing.
+  Include png_reset_zstream() in png.c only when PNG_READ_SUPPORTED is defined.
+  Removed dummy_inflate.c from contrib/pngminim/encoder
+  Removed contrib/pngminim/*/gather.sh; gathering is now done in the makefile.
+
+Version 1.5.0beta24 [May 7, 2010]
+  Use bitwise "&" instead of arithmetic mod in pngrutil.c calculation of the
+    offset of the png_ptr->rowbuf pointer into png_ptr->big_row_buf.
+  Added more blank lines for readability.
+
+Version 1.5.0beta25 [June 18, 2010]
+  In pngpread.c: png_push_have_row() add check for new_row > height
+  Removed the now-redundant check for out-of-bounds new_row from example.c
+
+Version 1.5.0beta26 [June 18, 2010]
+  In pngpread.c: png_push_process_row() add check for too many rows.
+
+Version 1.5.0beta27 [June 18, 2010]
+  Removed the check added in beta25 as it is now redundant.
+
+Version 1.5.0beta28 [June 20, 2010]
+  Rewrote png_process_IDAT_data to consistently treat extra data as warnings
+    and handle end conditions more cleanly.
+  Removed the new (beta26) check in png_push_process_row().
+
+Version 1.5.0beta29 [June 21, 2010]
+  Revised scripts/options.awk to work on Sunos (but still doesn't work)
+  Added comment to options.awk and contrib/pngminim/*/makefile to try nawk.
+
+Version 1.5.0beta30 [June 22, 2010]
+  Stop memory leak when reading a malformed sCAL chunk.
+
+Version 1.5.0beta31 [June 26, 2010]
+  Revised pngpread.c patch of beta28 to avoid an endless loop.
+  Removed some trailing blanks.
+
+Version 1.5.0beta32 [June 26, 2010]
+  Removed leftover scripts/options.patch and scripts/options.rej
+
+Version 1.5.0beta33 [July 6, 3010]
+  Made FIXED and FLOATING options consistent in the APIs they enable and
+    disable.  Corrected scripts/options.awk to handle both command line
+    options and options specified in the .dfa files.
+  Changed char *msg to PNG_CONST char *msg in pngrutil.c
+  Make png_set_sRGB_gAMA_and_cHRM set values using either the fixed or
+    floating point APIs, but not both.
+  Reversed patch to remove error handler when the jmp_buf is stored in the
+    main program structure, not the png_struct.
+    The error handler is needed because the default handler in libpng will
+    always use the jmp_buf in the library control structure; this is never
+    set.  The gregbook code is a useful example because, even though it
+    uses setjmp/longjmp, it shows how error handling can be implemented
+    using control mechanisms not directly supported by libpng.  The
+    technique will work correctly with mechanisms such as Microsoft
+    Structure Exceptions or C++ exceptions (compiler willing - note that gcc
+    does not by default support interworking of C and C++ error handling.)
+  Reverted changes to call png_longjmp in contrib/gregbook where it is not
+    appropriate.  If mainprog->jmpbuf is used by setjmp, then png_longjmp
+    cannot be used.
+  Changed "extern PNG_EXPORT" to "PNG_EXPORT" in png.h (Jan Nijtmans)
+  Changed "extern" to "PNG_EXTERN" in pngpriv.h (except for the 'extern "C" {')
+
+Version 1.5.0beta34 [July 12, 2010]
+  Put #ifndef PNG_EXTERN, #endif around the define PNG_EXTERN in pngpriv.h
+
+Version 1.5.0beta35 [July 24, 2010]
+  Removed some newly-added TAB characters.
+  Added -DNO_PNG_SNPRINTF to CFLAGS in scripts/makefile.dj2
+  Moved the definition of png_snprintf() outside of the enclosing
+    #ifdef blocks in pngconf.h
+
+Version 1.5.0beta36 [July 29, 2010]
+  Patches by John Bowler:
+  Fixed point APIs are now supported throughout (no missing APIs).
+  Internal fixed point arithmetic support exists for all internal floating
+    point operations.
+  sCAL validates the floating point strings it is passed.
+  Safe, albeit rudimentary, Watcom support is provided by PNG_API_RULE==2
+  Two new APIs exist to get the number of passes without turning on the
+    PNG_INTERLACE transform and to get the number of rows in the current
+    pass.
+  A new test program, pngvalid.c, validates the gamma code.
+  Errors in the 16-bit gamma correction (overflows) have been corrected.
+  cHRM chunk testing is done consistently (previously the floating point
+    API bypassed it, because the test really didn't work on FP, now the test
+    is performed on the actual values to be stored in the PNG file so it
+    works in the FP case too.)
+  Most floating point APIs now simply call the fixed point APIs after
+    converting the values to the fixed point form used in the PNG file.
+  The standard headers no longer include zlib.h, which is currently only
+    required for pngstruct.h and can therefore be internal.
+  Revised png_get_int_32 to undo the PNG two's complement representation of
+    negative numbers.
+
+Version 1.5.0beta37 [July 30, 2010]
+  Added a typecast in png_get_int_32() in png.h and pngrutil.h to avoid
+    a compiler warning.
+  Replaced oFFs 0,0 with oFFs -10,20 in pngtest.png
+
+Version 1.5.0beta38 [July 31, 2010]
+  Implemented remaining "_fixed" functions.
+  Corrected a number of recently introduced warnings mostly resulting from
+    safe but uncast assignments to shorter integers.  Also added a zlib
+    VStudio release library project because the latest zlib Official Windows
+    build does not include such a thing.
+  Revised png_get_int_16() to be similar to png_get_int_32().
+  Restored projects/visualc71.
+
+Version 1.5.0beta39 [August 2, 2010]
+  VisualC/GCC warning fixes, VisualC build fixes
+  The changes include support for function attributes in VC in addition to
+    those already present in GCC - necessary because without these some
+    warnings are unavoidable.  Fixes include signed/unsigned fixes in
+    pngvalid and checks with gcc -Wall -Wextra -Wunused.
+  VC requires function attributes on function definitions as well as
+    declarations, PNG_FUNCTION has been added to enable this and the
+    relevant function definitions changed.
+
+Version 1.5.0beta40 [August 6, 2010]
+  Correct use of _WINDOWS_ in pngconf.h
+  Removed png_mem_ #defines; they are no longer used.
+  Added the sRGB chunk to pngtest.png
+
+Version 1.5.0beta41 [August 11, 2010]
+  Added the cHRM chunk to pngtest.png
+  Don't try to use version-script with cygwin/mingw.
+  Revised contrib/gregbook to work under cygwin/mingw.
+
+Version 1.5.0beta42 [August 18, 2010]
+  Add .dll.a to the list of extensions to be symlinked by Makefile.am (Yaakov)
+  Made all API functions that have const arguments and constant string
+    literal pointers declare them (John Bowler).
+
+Version 1.5.0beta43 [August 20, 2010]
+  Removed spurious tabs, shorten long lines (no source change)
+    Also added scripts/chkfmt to validate the format of all the files that can
+    reasonably be validated (it is suggested to run "make distclean" before
+    checking, because some machine generated files have long lines.)
+  Reformatted the CHANGES file to be more consistent throughout.
+  Made changes to address various issues identified by GCC, mostly
+    signed/unsigned and shortening problems on assignment but also a few
+    difficult to optimize (for GCC) loops.
+  Fixed non-GCC fixed point builds.  In png.c a declaration was misplaced
+    in an earlier update.  Fixed to declare the auto variables at the head.
+  Use cexcept.h in pngvalid.c.
+
+Version 1.5.0beta44 [August 24, 2010]
+  Updated CMakeLists.txt to use CMAKE_INSTALL_LIBDIR variable; useful for
+    installing libpng in /usr/lib64 (Funda Wang).
+  Revised CMakeLists.txt to put the man pages in share/man/man* not man/man*
+  Revised CMakeLists.txt to make symlinks instead of copies when installing.
+  Changed PNG_LIB_NAME from pngNN to libpngNN in CMakeLists.txt (Philip Lowman)
+  Implemented memory checks within pngvalid
+  Reformatted/rearranged pngvalid.c to assist use of progressive reader.
+  Check interlaced images in pngvalid
+  Clarified pngusr.h comments in pnglibconf.dfa
+  Simplified the pngvalid error-handling code now that cexcept.h is in place.
+  Implemented progressive reader in pngvalid.c for standard tests
+  Implemented progressive read in pngvalid.c gamma tests
+  Turn on progressive reader in pngvalid.c by default and tidy code.
+
+Version 1.5.0beta45 [August 26, 2010]
+  Added an explicit make step to projects/vstudio for pnglibconf.h
+    Also corrected zlib.vcxproj into which Visual Studio had introduced
+    what it calls an "authoring error".  The change to make pnglibconf.h
+    simply copies the file; in the future it may actually generate the
+    file from scripts/pnglibconf.dfa as the other build systems do.
+  Changed pngvalid to work when floating point APIs are disabled
+  Renamed the prebuilt scripts/pnglibconf.h to scripts/pnglibconf.h.prebuilt
+  Supply default values for PNG_USER_PRIVATEBUILD and PNG_USER_DLLFNAME_POSTFIX
+    in pngpriv.h in case the user neglected to define them in their pngusr.h
+
+Version 1.5.0beta46 [August 28, 2010]
+  Added new private header files to libpng_sources in CMakeLists.txt
+  Added PNG_READ_16BIT, PNG_WRITE_16BIT, and PNG_16BIT options.
+  Added reference to scripts/pnglibconf.h.prebuilt in the visualc71 project.
+
+Version 1.5.0beta47 [September 11, 2010]
+  Fixed a number of problems with 64-bit compilation reported by Visual
+    Studio 2010 (John Bowler).
+
+Version 1.5.0beta48 [October 4, 2010]
+  Updated CMakeLists.txt (Philip Lowman).
+  Revised autogen.sh to recognize and use $AUTOCONF, $AUTOMAKE, $AUTOHEADER,
+    $AUTOPOINT, $ACLOCAL and $LIBTOOLIZE
+  Fixed problem with symbols creation in Makefile.am which was assuming that
+    all versions of ccp write to standard output by default (Martin Banky). The
+    bug was introduced in libpng-1.2.9beta5.
+  Removed unused mkinstalldirs.
+
+Version 1.5.0beta49 [October 8, 2010]
+  Undid Makefile.am revision of 1.5.0beta48.
+
+Version 1.5.0beta50 [October 14, 2010]
+  Revised Makefile.in to account for mkinstalldirs being removed.
+  Added some "(unsigned long)" typecasts in printf statements in pngvalid.c.
+  Suppressed a compiler warning in png_handle_sPLT().
+  Check for out-of-range text compression mode in png_set_text().
+
+Version 1.5.0beta51 [October 15, 2010]
+  Changed embedded dates to "(PENDING RELEASE) in beta releases (and future
+    rc releases) to minimize the difference between releases.
+
+Version 1.5.0beta52 [October 16, 2010]
+  Restored some of the embedded dates (in png.h, png.c, documentation, etc.)
+
+Version 1.5.0beta53 [October 18, 2010]
+  Updated INSTALL to mention using "make maintainer-clean" and to remove
+    obsolete statement about a custom ltmain.sh
+  Disabled "color-tests" by default in Makefile.am so it will work with
+    automake versions earlier than 1.11.1
+  Use document name "libpng-manual.txt" instead of "libpng-<version>.txt"
+    to simplify version differences.
+  Removed obsolete remarks about setjmp handling from INSTALL.
+  Revised and renamed the typedef in png.h and png.c that was designed
+    to catch library and header mismatch.
+
+Version 1.5.0beta54 [November 10, 2010]
+  Require 48 bytes, not 64 bytes, for big_row_buf in overflow checks.
+  Used a consistent structure for the pngget.c functions.
+
+Version 1.5.0beta55 [November 21, 2010]
+  Revised png_get_uint_32, png_get_int_32, png_get_uint_16 (Cosmin)
+  Moved reading of file signature into png_read_sig (Cosmin)
+  Fixed atomicity of chunk header serialization (Cosmin)
+  Added test for io_state in pngtest.c (Cosmin)
+  Added "#!/bin/sh" at the top of contrib/pngminim/*/gather.sh scripts.
+  Changes to remove gcc warnings (John Bowler)
+    Certain optional gcc warning flags resulted in warnings in libpng code.
+    With these changes only -Wconversion and -Wcast-qual cannot be turned on.
+    Changes are trivial rearrangements of code.  -Wconversion is not possible
+    for pngrutil.c (because of the widespread use of += et al on variables
+    smaller than (int) or (unsigned int)) and -Wcast-qual is not possible
+    with pngwio.c and pngwutil.c because the 'write' callback and zlib
+    compression both fail to declare their input buffers with 'const'.
+
+Version 1.5.0beta56 [December 7, 2010]
+  Added the private PNG_UNUSED() macro definition in pngpriv.h.
+  Added some commentary about PNG_EXPORT in png.h and pngconf.h
+  Revised PNG_EXPORT() macro and added PNG_EXPORTA() macro, with the
+    objective of simplifying and improving the cosmetic appearance of png.h.
+  Fixed some incorrect "=" macro names in pnglibconf.dfa
+  Included documentation of changes in 1.5.0 from 1.4.x in libpng-manual.txt
+
+Version 1.5.0beta57 [December 9, 2010]
+  Documented the pngvalid gamma error summary with additional comments and
+    print statements.
+  Improved missing symbol handling in checksym.awk; symbols missing in both
+    the old and new files can now be optionally ignored, treated as errors
+    or warnings.
+  Removed references to pngvcrd.c and pnggccrd.c from the vstudio project.
+  Updated "libpng14" to "libpng15" in the visualc71 project.
+  Enabled the strip16 tests in pngvalid.`
+  Don't display test results (except PASS/FAIL) when running "make test".
+    Instead put them in pngtest-log.txt
+  Added "--with-zprefix=<string>" to configure.ac
+  Updated the prebuilt configuration files to autoconf version 2.68
+
+Version 1.5.0beta58 [December 19, 2010]
+  Fixed interlace image handling and add test cases (John Bowler)
+  Fixed the clean rule in Makefile.am to remove pngtest-log.txt
+  Made minor changes to work around warnings in gcc 3.4
+
+Version 1.5.0rc01 [December 27, 2010]
+  No changes.
+
+Version 1.5.0rc02 [December 27, 2010]
+  Eliminated references to the scripts/*.def files in project/visualc71.
+
+Version 1.5.0rc03 [December 28, 2010]
+  Eliminated scripts/*.def and revised Makefile.am accordingly
+
+Version 1.5.0rc04 [December 29, 2010]
+  Fixed bug in background transformation handling in pngrtran.c (it was
+    looking for the flag in png_ptr->transformations instead of in
+    png_ptr->flags) (David Raymond).
+
+Version 1.5.0rc05 [December 31, 2010]
+  Fixed typo in a comment in CMakeLists.txt (libpng14 => libpng15) (Cosmin)
+
+Version 1.5.0rc06 [January 4, 2011]
+  Changed the new configure option "zprefix=string" to "zlib-prefix=string"
+
+Version 1.5.0rc07 [January 4, 2011]
+  Updated copyright year.
+
+Version 1.5.0 [January 6, 2011]
+  No changes.
+
+version 1.5.1beta01 [January 8, 2011]
+  Added description of png_set_crc_action() to the manual.
+  Added a note in the manual that the type of the iCCP profile was changed
+    from png_charpp to png_bytepp in png_get_iCCP().  This change happened
+    in version 1.5.0beta36 but is not noted in the CHANGES.  Similarly,
+    it was changed from png_charpp to png_const_bytepp in png_set_iCCP().
+  Ensure that png_rgb_to_gray ignores palette mapped images, if libpng
+    internally happens to call it with one, and fixed a failure to handle
+    palette mapped images correctly.  This fixes CVE-2690.
+
+Version 1.5.1beta02 [January 14, 2011]
+  Fixed a bug in handling of interlaced images (bero at arklinux.org).
+  Updated CMakeLists.txt (Clifford Yapp)
+
+Version 1.5.1beta03 [January 14, 2011]
+  Fixed typecasting of some png_debug() statements (Cosmin)
+
+Version 1.5.1beta04 [January 16, 2011]
+  Updated documentation of png_set|get_tRNS() (Thomas Klausner).
+  Mentioned in the documentation that applications must #include "zlib.h"
+    if they need access to anything in zlib.h, and that a number of
+    macros such as png_memset() are no longer accessible by applications.
+  Corrected pngvalid gamma test "sample" function to access all of the color
+    samples of each pixel, instead of sampling the red channel three times.
+  Prefixed variable names index, div, exp, gamma with "png_" to avoid "shadow"
+    warnings, and (mistakenly) changed png_exp() to exp().
+
+Version 1.5.1beta05 [January 16, 2011]
+  Changed variable names png_index, png_div, png_exp, and png_gamma to
+    char_index, divisor, exp_b10, and gamma_val, respectively, and
+    changed exp() back to png_exp().
+
+Version 1.5.1beta06 [January 20, 2011]
+  Prevent png_push_crc_skip() from hanging while reading an unknown chunk
+    or an over-large compressed zTXt chunk with the progressive reader.
+  Eliminated more GCC "shadow" warnings.
+  Revised png_fixed() in png.c to avoid compiler warning about reaching the
+    end without returning anything.
+
+Version 1.5.1beta07 [January 22, 2011]
+  In the manual, describe the png_get_IHDR() arguments in the correct order.
+  Added const_png_structp and const_png_infop types, and used them in
+    prototypes for most png_get_*() functions.
+
+Version 1.5.1beta08 [January 23, 2011]
+  Added png_get_io_chunk_type() and deprecated png_get_io_chunk_name()
+  Added synopses for the IO_STATE functions and other missing synopses
+    to the manual. Removed the synopses from libpngpf.3 because they
+    were out of date and no longer useful.  Better information can be
+    obtained by reading the prototypes and comments in pngpriv.h
+  Attempted to fix cpp on Solaris with S. Studio 12 cc, fix build
+    Added a make macro DFNCPP that is a CPP that will accept the tokens in
+    a .dfn file and adds configure stuff to test for such a CPP.  ./configure
+    should fail if one is not available.
+  Corrected const_png_ in png.h to png_const_ to avoid polluting the namespace.
+  Added png_get_current_row_number and png_get_current_pass_number for the
+    benefit of the user transform callback.
+  Added png_process_data_pause and png_process_data_skip for the benefit of
+    progressive readers that need to stop data processing or want to optimize
+    skipping of unread data (e.g., if the reader marks a chunk to be skipped.)
+
+Version 1.5.1beta09 [January 24, 2011]
+  Enhanced pngvalid, corrected an error in gray_to_rgb, corrected doc error.
+    pngvalid contains tests of transforms, which tests are currently disabled
+    because they are incompletely tested.  gray_to_rgb was failing to expand
+    the bit depth for smaller bit depth images; this seems to be a long
+    standing error and resulted, apparently, in invalid output
+    (CVE-2011-0408, CERT VU#643140).  The documentation did not accurately
+    describe what libpng really does when converting RGB to gray.
+
+Version 1.5.1beta10 [January 27, 2010]
+  Fixed incorrect examples of callback prototypes in the manual, that were
+    introduced in libpng-1.0.0.
+  In addition the order of the png_get_uint macros with respect to the
+    relevant function definitions has been reversed.  This helps the
+    preprocessing of the symbol files be more robust.  Furthermore, the
+    symbol file preprocessing now uses -DPNG_NO_USE_READ_MACROS even when
+    the library may actually be built with PNG_USE_READ_MACROS; this stops
+    the read macros interfering with the symbol file format.
+  Made the manual, synopses, and function prototypes use the function
+    argument names file_gamma, int_file_gamma, and srgb_intent consistently.
+
+Version 1.5.1beta11 [January 28, 2011]
+  Changed PNG_UNUSED from "param=param;" to "{if(param){}}".
+  Corrected local variable type in new API png_process_data_skip()
+    The type was self-evidently incorrect but only causes problems on 64-bit
+    architectures.
+  Added transform tests to pngvalid and simplified the arguments.
+
+Version 1.5.1rc01 [January 29, 2011]
+  No changes.
+
+Version 1.5.1rc02 [January 31, 2011]
+  Added a request in the manual that applications do not use "png_" or
+    "PNG_" to begin any of their own symbols.
+  Changed PNG_UNUSED to "(void)param;" and updated the commentary in pngpriv.h
+
+Version 1.5.1 [February 3, 2011]
+  No changes.
+
+Version 1.5.2beta01 [February 13, 2011]
+  More -Wshadow fixes for older gcc compilers.  Older gcc versions apparently
+    check formal parameters names in function declarations (as well as
+    definitions) to see if they match a name in the global namespace.
+  Revised PNG_EXPORTA macro to not use an empty parameter, to accommodate the
+    old VisualC++ preprocessor.
+  Turned on interlace handling in png_read_png().
+  Fixed gcc pendantic warnings.
+  Handle longjmp in Cygwin.
+  Fixed png_get_current_row_number() in the interlaced case.
+  Cleaned up ALPHA flags and transformations.
+  Implemented expansion to 16 bits.
+
+Version 1.5.2beta02 [February 19, 2011]
+  Fixed mistake in the descriptions of user read_transform and write_transform
+    function prototypes in the manual.  The row_info struct is png_row_infop.
+  Reverted png_get_current_row_number() to previous (1.5.2beta01) behavior.
+  Corrected png_get_current_row_number documentation
+  Fixed the read/write row callback documentation.
+    This documents the current behavior, where the callback is called after
+    every row with information pertaining to the next row.
+
+Version 1.5.2beta03 [March 3, 2011]
+  Fixed scripts/makefile.vcwin32
+  Updated contrib/pngsuite/README to add the word "modify".
+  Define PNG_ALLOCATED to blank when _MSC_VER<1300.
+
+Version 1.5.2rc01 [March 19, 2011]
+  Define remaining attributes to blank when MSC_VER<1300.
+  ifdef out mask arrays in pngread.c when interlacing is not supported.
+
+Version 1.5.2rc02 [March 22, 2011]
+  Added a hint to try CPP=/bin/cpp if "cpp -E" fails in scripts/pnglibconf.mak
+    and in contrib/pngminim/*/makefile, eg., on SunOS 5.10, and removed "strip"
+    from the makefiles.
+  Fixed a bug (present since libpng-1.0.7) that makes png_handle_sPLT() fail
+    to compile when PNG_NO_POINTER_INDEXING is defined (Chubanov Kirill)
+
+Version 1.5.2rc03 [March 24, 2011]
+  Don't include standard header files in png.h while building the symbol table,
+    to avoid cpp failure on SunOS (introduced PNG_BUILDING_SYMBOL_TABLE macro).
+
+Version 1.5.2 [March 31, 2011]
+  No changes.
+
+Version 1.5.3beta01 [April 1, 2011]
+  Re-initialize the zlib compressor before compressing non-IDAT chunks.
+  Added API functions (png_set_text_compression_level() and four others) to
+    set parameters for zlib compression of non-IDAT chunks.
+
+Version 1.5.3beta02 [April 3, 2011]
+  Updated scripts/symbols.def with new API functions.
+  Only compile the new zlib re-initializing code when text or iCCP is
+    supported, using PNG_WRITE_COMPRESSED_TEXT_SUPPORTED macro.
+  Improved the optimization of the zlib CMF byte (see libpng-1.2.6beta03).
+  Optimize the zlib CMF byte in non-IDAT compressed chunks
+
+Version 1.5.3beta03 [April 16, 2011]
+  Fixed gcc -ansi -pedantic compile. A strict ANSI system does not have
+    snprintf, and the "__STRICT_ANSI__" detects that condition more reliably
+    than __STDC__ (John Bowler).
+  Removed the PNG_PTR_NORETURN attribute because it too dangerous. It tells
+    the compiler that a user supplied callback (the error handler) does not
+    return, yet there is no guarantee in practice that the application code
+    will correctly implement the error handler because the compiler only
+    issues a warning if there is a mistake (John Bowler).
+  Removed the no-longer-used PNG_DEPSTRUCT macro.
+  Updated the zlib version to 1.2.5 in the VStudio project.
+  Fixed 64-bit builds where png_uint_32 is smaller than png_size_t in
+    pngwutil.c (John Bowler).
+  Fixed bug with stripping the filler or alpha channel when writing, that
+    was introduced in libpng-1.5.2beta01 (bug report by Andrew Church).
+
+Version 1.5.3beta04 [April 27, 2011]
+  Updated pngtest.png with the new zlib CMF optimization.
+  Cleaned up conditional compilation code and of background/gamma handling
+    Internal changes only except a new option to avoid compiling the
+    png_build_grayscale_palette API (which is not used at all internally.)
+    The main change is to move the transform tests (READ_TRANSFORMS,
+    WRITE_TRANSFORMS) up one level to the caller of the APIs.  This avoids
+    calls to spurious functions if all transforms are disabled and slightly
+    simplifies those functions.  Pngvalid modified to handle this.
+    A minor change is to stop the strip_16 and expand_16 interfaces from
+    disabling each other; this allows the future alpha premultiplication
+    code to use 16-bit intermediate values while still producing 8-bit output.
+    png_do_background and png_do_gamma have been simplified to take a single
+    pointer to the png_struct rather than pointers to every item required
+    from the png_struct. This makes no practical difference to the internal
+    code.
+  A serious bug in the pngvalid internal routine 'standard_display_init' has
+    been fixed - this failed to initialize the red channel and accidentally
+    initialized the alpha channel twice.
+  Changed png_struct jmp_buf member name from png_jmpbuf to tmp_jmpbuf to
+    avoid a possible clash with the png_jmpbuf macro on some platforms.
+
+Version 1.5.3beta05 [May 6, 2011]
+  Added the "_POSIX_SOURCE" feature test macro to ensure libpng sees the
+    correct API. _POSIX_SOURCE is defined in pngpriv.h, pngtest.c and
+    pngvalid.c to ensure that POSIX conformant systems disable non-POSIX APIs.
+  Removed png_snprintf and added formatted warning messages.  This change adds
+    internal APIs to allow png_warning messages to have parameters without
+    requiring the host OS to implement snprintf.  As a side effect the
+    dependency of the tIME-supporting RFC1132 code on stdio is removed and
+    PNG_NO_WARNINGS does actually work now.
+  Pass "" instead of '\0' to png_default_error() in png_err().  This mistake
+    was introduced in libpng-1.2.20beta01.  This fixes CVE-2011-2691.
+  Added PNG_WRITE_OPTIMIZE_CMF_SUPPORTED macro to make the zlib "CMF" byte
+    optimization configureable.
+  IDAT compression failed if preceded by a compressed text chunk (bug
+    introduced in libpng-1.5.3beta01-02).  This was because the attempt to
+    reset the zlib stream in png_write_IDAT happened after the first IDAT
+    chunk had been deflated - much too late.  In this change internal
+    functions were added to claim/release the z_stream and, hopefully, make
+    the code more robust.  Also deflateEnd checking is added - previously
+    libpng would ignore an error at the end of the stream.
+
+Version 1.5.3beta06 [May 8, 2011]
+  Removed the -D_ALL_SOURCE from definitions for AIX in CMakeLists.txt
+  Implemented premultiplied alpha support: png_set_alpha_mode API
+
+Version 1.5.3beta07 [May 11, 2011]
+  Added expand_16 support to the high level interface.
+  Added named value and 'flag' gamma support to png_set_gamma.  Made a minor
+    change from the previous (unreleased) ABI/API to hide the exact value used
+    for Macs - it's not a good idea to embed this in the ABI!
+  Moved macro definitions for PNG_HAVE_IHDR, PNG_HAVE_PLTE, and PNG_AFTER_IDAT
+    from pngpriv.h to png.h because they must be visible to applications
+    that call png_set_unknown_chunks().
+  Check for up->location !PNG_AFTER_IDAT when writing unknown chunks
+    before IDAT.
+
+Version 1.5.3beta08 [May 16, 2011]
+  Improved "pngvalid --speed" to exclude more of pngvalid from the time.
+  Documented png_set_alpha_mode(), other changes in libpng.3/libpng-manual.txt
+  The cHRM chunk now sets the defaults for png_set_rgb_to_gray() (when negative
+    parameters are supplied by the caller), while in the absence of cHRM
+    sRGB/Rec 709 values are still used.  This introduced a divide-by-zero
+    bug in png_handle_cHRM().
+  The bKGD chunk no longer overwrites the background value set by
+    png_set_background(), allowing the latter to be used before the file
+    header is read. It never performed any useful function to override
+    the default anyway.
+  Added memory overwrite and palette image checks to pngvalid.c
+    Previously palette image code was poorly checked. Since the transformation
+    code has a special palette path in most cases this was a severe weakness.
+  Minor cleanup and some extra checking in pngrutil.c and pngrtran.c. When
+    expanding an indexed image, always expand to RGBA if transparency is
+    present.
+
+Version 1.5.3beta09 [May 17, 2011]
+  Reversed earlier 1.5.3 change of transformation order; move png_expand_16
+    back where it was.  The change doesn't work because it requires 16-bit
+    gamma tables when the code only generates 8-bit ones.  This fails
+    silently; the libpng code just doesn't do any gamma correction.  Moving
+    the tests back leaves the old, inaccurate, 8-bit gamma calculations, but
+    these are clearly better than none!
+
+Version 1.5.3beta10 [May 20, 2011]
+
+  png_set_background() and png_expand_16() did not work together correctly.
+    This problem is present in 1.5.2; if png_set_background is called with
+    need_expand false and the matching 16 bit color libpng erroneously just
+    treats it as an 8-bit color because of where png_do_expand_16 is in the
+    transform list.  This simple fix reduces the supplied colour to 8-bits,
+    so it gets smashed, but this is better than the current behavior.
+  Added tests for expand16, more fixes for palette image tests to pngvalid.
+    Corrects the code for palette image tests and disables attempts to
+    validate palette colors.
+
+Version 1.5.3rc01 [June 3, 2011]
+  No changes.
+
+Version 1.5.3rc02 [June 8, 2011]
+  Fixed uninitialized memory read in png_format_buffer() (Bug report by
+    Frank Busse, CVE-2011-2501, related to CVE-2004-0421).
+
+Version 1.5.3beta11 [June 11, 2011]
+  Fixed png_handle_sCAL which is broken in 1.5. This fixes CVE 2011-2692.
+  Added sCAL to pngtest.png
+  Revised documentation about png_set_user_limits() to say that it also affects
+    png writing.
+  Revised handling of png_set_user_limits() so that it can increase the
+    limit beyond the PNG_USER_WIDTH|HEIGHT_MAX; previously it could only
+    reduce it.
+  Make the 16-to-8 scaling accurate. Dividing by 256 with no rounding is
+    wrong (high by one) 25% of the time. Dividing by 257 with rounding is
+    wrong in 128 out of 65536 cases. Getting the right answer all the time
+    without division is easy.
+  Added "_SUPPORTED" to the PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION macro.
+  Added projects/owatcom, an IDE project for OpenWatcom to replace
+    scripts/makefile.watcom.  This project works with OpenWatcom 1.9. The
+    IDE autogenerates appropriate makefiles (libpng.mk) for batch processing.
+    The project is configurable, unlike the Visual Studio project, so long
+    as the developer has an awk.
+  Changed png_set_gAMA to limit the gamma value range so that the inverse
+    of the stored value cannot overflow the fixed point representation,
+    and changed other things OpenWatcom warns about.
+  Revised pngvalid.c to test PNG_ALPHA_MODE_SUPPORTED correctly. This allows
+    pngvalid to build when ALPHA_MODE is not supported, which is required if
+    it is to build on libpng 1.4.
+  Removed string/memory macros that are no longer used and are not
+    necessarily fully supportable, particularly png_strncpy and png_snprintf.
+  Added log option to pngvalid.c and attempted to improve gamma messages.
+
+Version 1.5.3 [omitted]
+  People found the presence of a beta release following an rc release
+    to be confusing; therefore we bump the version to libpng-1.5.4beta01
+    and there will be no libpng-1.5.3 release.
+
+Version 1.5.4beta01 [June 14, 2011]
+  Made it possible to undefine PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
+    to get the same (inaccurate) output as libpng-1.5.2 and earlier.
+  Moved definitions of PNG_HAVE_IHDR, PNG_AFTER_IDAT, and PNG_HAVE_PLTE
+    outside of an unknown-chunk block in png.h because they are also
+    needed for other uses.
+
+Version 1.5.4beta02 [June 14, 2011]
+  Fixed and clarified LEGACY 16-to-8 scaling code.
+  Added png_set_chop_16() API, to match inaccurate results from previous
+    libpng versions.
+  Removed the ACCURATE and LEGACY options (they are no longer useable)
+  Use the old scaling method for background if png_set_chop_16() was
+    called.
+  Made png_set_chop_16() API removeable by disabling PNG_CHOP_16_TO_8_SUPPORTED
+
+Version 1.5.4beta03 [June 15, 2011]
+  Fixed a problem in png_do_expand_palette() exposed by optimization in
+    1.5.3beta06
+  Also removed a spurious and confusing "trans" member ("trans") from png_info.
+  The palette expand optimization prevented expansion to an intermediate RGBA
+    form if tRNS was present but alpha was marked to be stripped; this exposed
+    a check for tRNS in png_do_expand_palette() which is inconsistent with the
+    code elsewhere in libpng.
+  Correction to the expand_16 code; removed extra instance of
+    png_set_scale_16_to_8 from pngpriv.h
+
+Version 1.5.4beta04 [June 16, 2011]
+  Added a missing "#ifdef PNG_READ_BACKGROUND_SUPPORTED/#endif" in pngrtran.c
+  Added PNG_TRANSFORM_CHOP_16 to the high-level read transforms.
+  Made PNG_READ_16_TO_8_ACCURATE_SCALE configurable again.  If this is
+    not enabled, png_set_strip_16() and png_do_scale_16_to_8() aren't built.
+  Revised contrib/visupng, gregbook, and pngminim to demonstrate chop_16_to_8
+
+Version 1.5.4beta05 [June 16, 2011]
+  Renamed png_set_strip_16() to png_set_scale_16() and renamed
+    png_set_chop_16() to png_set_strip(16) in an attempt to minimize the
+    behavior changes between libpng14 and libpng15.
+
+Version 1.5.4beta06 [June 18, 2011]
+  Fixed new bug that was causing both strip_16 and scale_16 to be applied.
+
+Version 1.5.4beta07 [June 19, 2011]
+  Fixed pngvalid, simplified macros, added checking for 0 in sCAL.
+    The ACCURATE scale macro is no longer defined in 1.5 - call the
+    png_scale_16_to_8 API.  Made sure that PNG_READ_16_TO_8 is still defined
+    if the png_strip_16_to_8 API is present.  png_check_fp_number now
+    maintains some state so that positive, negative and zero values are
+    identified.  sCAL uses these to be strictly spec conformant.
+
+Version 1.5.4beta08 [June 23, 2011]
+  Fixed pngvalid if ACCURATE_SCALE is defined.
+  Updated scripts/pnglibconf.h.prebuilt.
+
+Version 1.5.4rc01 [June 30, 2011]
+  Define PNG_ALLOCATED to "restrict" only if MSC_VER >= 1400.
+
+Version 1.5.4 [July 7, 2011]
+  No changes.
+
+Version 1.5.5beta01 [July 13, 2011]
+  Fixed some typos and made other minor changes in the manual.
+  Updated contrib/pngminus/makefile.std (Samuli Souminen)
+
+Version 1.5.5beta02 [July 14, 2011]
+  Revised Makefile.am and Makefile.in to look in the right directory for
+    pnglibconf.h.prebuilt
+
+Version 1.5.5beta03 [July 27, 2011]
+  Enabled compilation with g++ compiler.  This compiler does not recognize
+    the file extension, so it always compiles with C++ rules.  Made minor
+    changes to pngrutil.c to cast results where C++ expects it but C does not.
+  Minor editing of libpng.3 and libpng-manual.txt.
+
+Version 1.5.5beta04 [July 29, 2011]
+  Revised CMakeLists.txt (Clifford Yapp)
+  Updated commentary about the png_rgb_to_gray() default coefficients
+    in the manual and in pngrtran.c
+
+Version 1.5.5beta05 [August 17, 2011]
+  Prevent unexpected API exports from non-libpng DLLs on Windows.  The "_DLL"
+    is removed from the test of whether a DLL is being built (this erroneously
+    caused the libpng APIs to be marked as DLL exports in static builds under
+    Microsoft Visual Studio).  Almost all of the libpng building configuration
+    is moved from pngconf.h to pngpriv.h, but PNG_DLL_EXPORT remains in
+    pngconf.h, though, so that it is colocated with the import definition (it
+    is no longer used anywhere in the installed headers).  The VStudio project
+    definitions have been cleaned up: "_USRDLL" has been removed from the
+    static library builds (this was incorrect), and PNG_USE_DLL has been added
+    to pngvalid to test the functionality (pngtest does not supply it,
+    deliberately).  The spurious "_EXPORTS" has been removed from the
+    libpng build (all these errors were a result of copy/paste between project
+    configurations.)
+  Added new types and internal functions for CIE RGB end point handling to
+    pngpriv.h (functions yet to be implemented).
+
+Version 1.5.5beta06 [August 26, 2011]
+  Ensure the CMAKE_LIBRARY_OUTPUT_DIRECTORY is set in CMakeLists.txt
+    (Clifford Yap)
+  Fixes to rgb_to_gray and cHRM XYZ APIs (John Bowler):
+    The rgb_to_gray code had errors when combined with gamma correction.
+    Some pixels were treated as true grey when they weren't and such pixels
+    and true grey ones were not gamma corrected (the original value of the
+    red component was used instead).  APIs to get and set cHRM using color
+    space end points have been added and the rgb_to_gray code that defaults
+    based on cHRM, and the divide-by-zero bug in png_handle_cHRM (CERT
+    VU#477046, CVE-2011-3328, introduced in 1.5.4) have been corrected.
+  A considerable number of tests has been added to pngvalid for the
+    rgb_to_gray transform.
+  Arithmetic errors in rgb_to_gray whereby the calculated gray value was
+    truncated to the bit depth rather than rounded have been fixed except in
+    the 8-bit non-gamma-corrected case (where consistency seems more important
+    than correctness.)  The code still has considerable inaccuracies in the
+    8-bit case because 8-bit linear arithmetic is used.
+
+Version 1.5.5beta07 [September 7, 2011]
+  Added "$(ARCH)" option to makefile.darwin
+  Added SunOS support to configure.ac and Makefile.am
+  Changed png_chunk_benign_error() to png_warning() in png.c, in
+    png_XYZ_from_xy_checked().
+
+Version 1.5.5beta08 [September 10, 2011]
+  Fixed 64-bit compilation errors (gcc). The errors fixed relate
+    to conditions where types that are 32 bits in the GCC 32-bit
+    world (uLong and png_size_t) become 64 bits in the 64-bit
+    world.  This produces potential truncation errors which the
+    compiler correctly flags.
+  Relocated new HAVE_SOLARIS_LD definition in configure.ac
+  Constant changes for 64-bit compatibility (removal of L suffixes). The
+    16-bit cases still use "L" as we don't have a 16-bit test system.
+
+Version 1.5.5rc01 [September 15, 2011]
+  Removed "L" suffixes in pngpriv.h
+
+Version 1.5.5 [September 22, 2011]
+  No changes.
+
+Version 1.5.6beta01 [September 22, 2011]
+  Fixed some 64-bit type conversion warnings in pngrtran.c
+  Moved row_info from png_struct to a local variable.
+  The various interlace mask arrays have been made into arrays of
+    bytes and made PNG_CONST and static (previously some arrays were
+    marked PNG_CONST and some weren't).
+  Additional checks have been added to the transform code to validate the
+    pixel depths after the transforms on both read and write.
+  Removed some redundant code from pngwrite.c, in png_destroy_write_struct().
+  Changed chunk reading/writing code to use png_uint_32 instead of png_byte[4].
+    This removes the need to allocate temporary strings for chunk names on
+    the stack in the read/write code.  Unknown chunk handling still uses the
+    string form because this is exposed in the API.
+
+Version 1.5.6beta02 [September 26, 2011]
+  Added a note in the manual the png_read_update_info() must be called only
+    once with a particular info_ptr.
+  Fixed a typo in the definition of the new PNG_STRING_FROM_CHUNK(s,c) macro.
+
+Version 1.5.6beta03 [September 28, 2011]
+  Revised test-pngtest.sh to report FAIL when pngtest fails.
+  Added "--strict" option to pngtest, to report FAIL when the failure is
+    only because the resulting valid files are different.
+  Revised CMakeLists.txt to work with mingw and removed some material from
+    CMakeLists.txt that is no longer useful in libpng-1.5.
+
+Version 1.5.6beta04 [October 5, 2011]
+  Fixed typo in Makefile.in and Makefile.am ("-M Wl" should be "-M -Wl")."
+
+Version 1.5.6beta05 [October 12, 2011]
+  Speed up png_combine_row() for interlaced images. This reduces the generality
+    of the code, allowing it to be optimized for Adam7 interlace.  The masks
+    passed to png_combine_row() are now generated internally, avoiding
+    some code duplication and localizing the interlace handling somewhat.
+  Align png_struct::row_buf - previously it was always unaligned, caused by
+    a bug in the code that attempted to align it; the code needs to subtract
+    one from the pointer to take account of the filter byte prepended to
+    each row.
+  Optimized png_combine_row() when rows are aligned. This gains a small
+    percentage for 16-bit and 32-bit pixels in the typical case where the
+    output row buffers are appropriately aligned. The optimization was not
+    previously possible because the png_struct buffer was always misaligned.
+  Fixed bug in png_write_chunk_header() debug print, introduced in 1.5.6beta01.
+
+Version 1.5.6beta06 [October 17, 2011]
+  Removed two redundant tests for unitialized row.
+  Fixed a relatively harmless memory overwrite in compressed text writing
+    with a 1 byte zlib buffer.
+  Add ability to call png_read_update_info multiple times to pngvalid.c.
+  Fixes for multiple calls to png_read_update_info. These fixes attend to
+    most of the errors revealed in pngvalid, however doing the gamma work
+    twice results in inaccuracies that can't be easily fixed.  There is now
+    a warning in the code if this is going to happen.
+  Turned on multiple png_read_update_info in pngvalid transform tests.
+  Prevent libpng from overwriting unused bits at the end of the image when
+    it is not byte aligned, while reading. Prior to libpng-1.5.6 libpng would
+    overwrite the partial byte at the end of each row if the row width was not
+    an exact multiple of 8 bits and the image is not interlaced.
+
+Version 1.5.6beta07 [October 21, 2011]
+  Made png_ptr->prev_row an aligned pointer into png_ptr->big_prev_row
+    (Mans Rullgard).
+
+Version 1.5.6rc01 [October 26, 2011]
+  Changed misleading "Missing PLTE before cHRM" warning to "Out of place cHRM"
+
+Version 1.5.6rc02 [October 27, 2011]
+  Added LSR() macro to defend against buggy compilers that evaluate non-taken
+    code branches and complain about out-of-range shifts.
+
+Version 1.5.6rc03 [October 28, 2011]
+  Renamed the LSR() macro to PNG_LSR() and added PNG_LSL() macro.
+  Fixed compiler warnings with Intel and MSYS compilers. The logical shift
+    fix for Microsoft Visual C is required by other compilers, so this
+    enables that fix for all compilers when using compile-time constants.
+    Under MSYS 'byte' is a name declared in a system header file, so we
+    changed the name of a local variable to avoid the warnings that result.
+  Added #define PNG_ALIGN_TYPE PNG_ALIGN_NONE to contrib/pngminim/*/pngusr.h
+
+Version 1.5.6 [November 3, 2011]
+  No changes.
+
+Version 1.5.7beta01 [November 4, 2011]
+  Added support for ARM processor (Mans Rullgard)
+  Fixed bug in pngvalid on early allocation failure; fixed type cast in
+    pngmem.c; pngvalid would attempt to call png_error() if the allocation
+    of a png_struct or png_info failed. This would probably have led to a
+    crash.  The pngmem.c implementation of png_malloc() included a cast
+    to png_size_t which would fail on large allocations on 16-bit systems.
+  Fix for the preprocessor of the Intel C compiler. The preprocessor
+    splits adjacent @ signs with a space; this changes the concatentation
+    token from @-@-@ to PNG_JOIN; that should work with all compiler
+    preprocessors.
+  Paeth filter speed improvements from work by Siarhei Siamashka. This
+    changes the 'Paeth' reconstruction function to improve the GCC code
+    generation on x86. The changes are only part of the suggested ones;
+    just the changes that definitely improve speed and remain simple.
+    The changes also slightly increase the clarity of the code.
+
+Version 1.5.7beta02 [November 11, 2011]
+  Check compression_type parameter in png_get_iCCP and remove spurious
+    casts. The compression_type parameter is always assigned to, so must
+    be non-NULL. The cast of the profile length potentially truncated the
+    value unnecessarily on a 16-bit int system, so the cast of the (byte)
+    compression type to (int) is specified by ANSI-C anyway.
+  Fixed FP division by zero in pngvalid.c; the 'test_pixel' code left
+    the sBIT fields in the test pixel as 0, which resulted in a floating
+    point division by zero which was irrelevant but causes systems where
+    FP exceptions cause a crash. Added code to pngvalid to turn on FP
+    exceptions if the appropriate glibc support is there to ensure this is
+    tested in the future.
+  Updated scripts/pnglibconf.mak and scripts/makefile.std to handle the
+    new PNG_JOIN macro.
+  Added versioning to pnglibconf.h comments.
+  Simplified read/write API initial version; basic read/write tested on
+    a variety of images, limited documentation (in the header file.)
+  Installed more accurate linear to sRGB conversion tables. The slightly
+    modified tables reduce the number of 16-bit values that
+    convert to an off-by-one 8-bit value.  The "makesRGB.c" code that was used
+    to generate the tables is now in a contrib/sRGBtables sub-directory.
+
+Version 1.5.7beta03 [November 17, 2011]
+  Removed PNG_CONST from the sRGB table declarations in pngpriv.h and png.c
+  Added run-time detection of NEON support.
+  Added contrib/libtests; includes simplified API test and timing test and
+    a color conversion utility for rapid checking of failed 'pngstest' results.
+  Multiple transform bug fixes plus a work-round for double gamma correction.
+    libpng does not support more than one transform that requires linear data
+    at once - if this is tried typically the results is double gamma
+    correction. Since the simplified APIs can need rgb to gray combined with
+    a compose operation it is necessary to do one of these outside the main
+    libpng transform code. This check-in also contains fixes to various bugs
+    in the simplified APIs themselves and to some bugs in compose and rgb to
+    gray (on palette) itself.
+  Fixes for C++ compilation using g++ When libpng source is compiled
+    using g++. The compiler imposes C++ rules on the C source; thus it
+    is desireable to make the source work with either C or C++ rules
+    without throwing away useful error information.  This change adds
+    png_voidcast to allow C semantic (void*) cases or the corresponding
+    C++ static_cast operation, as appropriate.
+  Added --noexecstack to assembler file compilation. GCC does not set
+    this on assembler compilation, even though it does on C compilation.
+    This creates security issues if assembler code is enabled; the
+    work-around is to set it by default in the flags for $(CCAS)
+  Work around compilers that don't support declaration of const data. Some
+    compilers fault 'extern const' data declarations (because the data is
+    not initialized); this turns on const-ness only for compilers where
+    this is known to work.
+
+Version 1.5.7beta04 [November 17, 2011]
+  Since the gcc driver does not recognize the --noexecstack flag, we must
+    use the -Wa prefix to have it passed through to the assembler.
+    Also removed a duplicate setting of this flag.
+  Added files that were omitted from the libpng-1.5.7beta03 zip distribution.
+
+Version 1.5.7beta05 [November 25, 2011]
+  Removed "zTXt" from warning in generic chunk decompression function.
+  Validate time settings passed to pngset() and png_convert_to_rfc1123()
+    (Frank Busse).
+  Added MINGW support to CMakeLists.txt
+  Reject invalid compression flag or method when reading the iTXt chunk.
+  Backed out 'simplified' API changes. The API seems too complex and there
+    is a lack of consensus or enthusiasm for the proposals.  The API also
+    reveals significant bugs inside libpng (double gamma correction and the
+    known bug of being unable to retrieve a corrected palette). It seems
+    better to wait until the bugs, at least, are corrected.
+  Moved pngvalid.c into contrib/libtests
+  Rebuilt Makefile.in, configure, etc., with autoconf-2.68
+
+Version 1.5.7rc01 [December 1, 2011]
+  Replaced an "#if" with "#ifdef" in pngrtran.c
+  Revised #if PNG_DO_BC block in png.c (use #ifdef and add #else)
+
+Version 1.5.7rc02 [December 5, 2011]
+  Revised project files and contrib/pngvalid/pngvalid.c to account for
+    the relocation of pngvalid into contrib/libtests.
+  Revised pngconf.h to use " __declspec(restrict)" only when MSC_VER >= 1400,
+    as in libpng-1.5.4.
+  Put CRLF line endings in the owatcom project files.
+
+Version 1.5.7rc03 [December 7, 2011]
+  Updated CMakeLists.txt to account for the relocation of pngvalid.c
+
+Version 1.5.7 [December 15, 2011]
+  Minor fixes to pngvalid.c for gcc 4.6.2 compatibility to remove warnings
+    reported by earlier versions.
+
+Version 1.5.8beta01 [January 15, 2011]
+  Removed '#include config.h"' from contrib/libtests/pngvalid.c.  It's not
+    needed and causes trouble for VPATH building.
+  Moved AC_MSG_CHECKING([if libraries can be versioned]) later to the proper
+    location in configure.ac (Gilles Espinasse).
+  Fix bug in pngerror.c: some long warnings were being improperly truncated
+    (CVE-2011-3464, bug introduced in libpng-1.5.3beta05).
+
+Version 1.5.8rc01 [January 21, 2012]
+  No changes.
+
+Version 1.5.8rc02 [January 25, 2012]
+  Fixed Min/GW uninstall to remove libpng.dll.a
+  Conditionalize the install rules for MINGW and CYGWIN in CMakeLists.txt
+
+Version 1.5.8 [February 1, 2012]
+  No changes.
+
+Version 1.5.9beta01 [February 3, 2012]
+  Rebuilt configure scripts in the tar distributions.
+
+Version 1.5.9beta02 [February 16, 2012]
+  Removed two unused definitions from scripts/pnglibconf.h.prebuilt
+  Removed some unused arrays (with #ifdef) from png_read_push_finish_row().
+  Removed tests for no-longer-used *_EMPTY_PLTE_SUPPORTED from pngstruct.h
+
+Version 1.5.9rc01 [February 17, 2012]
+  Fixed CVE-2011-3026 buffer overrun bug.  This bug was introduced when
+    iCCP chunk support was added at libpng-1.0.6. Deal more correctly with the
+    test on iCCP chunk length. Also removed spurious casts that may hide
+    problems on 16-bit systems.
+
+Version 1.5.9 [February 18, 2012]
+  No changes.
+
+Version 1.5.10beta01 [February 24, 2012]
+  Removed two useless #ifdef directives from pngread.c and one from pngrutil.c
+  Always put the CMAKE_LIBRARY in "lib" (removed special WIN32 case).
+  Removed empty vstudio/pngstest directory (Clifford Yapp).
+  Eliminated redundant png_push_read_tEXt|zTXt|iTXt|unknown code from
+    pngpread.c and use the sequential png_handle_tEXt, etc., in pngrutil.c;
+    now that png_ptr->buffer is inaccessible to applications, the special
+    handling is no longer useful.
+  Fixed bug with png_handle_hIST with odd chunk length (Frank Busse).
+  Added PNG_SAFE_LIMITS feature to pnglibconf.dfa and code in pngconf.h
+    to reset the user limits to safe ones if PNG_SAFE_LIMITS is defined.
+    To enable, use "CPPFLAGS=-DPNG_SAFE_LIMITS_SUPPORTED" on the configure
+    command or put "#define PNG_SAFE_LIMITS_SUPPORTED" in pnglibconf.h.
+  Revised the SAFE_LIMITS feature to be the same as the feature in libpng16.
+  Added information about the new limits in the manual.
+
+Version 1.5.10beta02 [February 27, 2012]
+  Updated Makefile.in
+
+Version 1.5.10beta03 [March 6, 2012]
+  Removed unused "current_text" members of png_struct and the png_free()
+    of png_ptr->current_text from pngread.c
+  Added palette-index checking. Issue a png_warning() if an invalid index is
+    found.
+
+Version 1.5.10beta04 [March 10, 2012]
+  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition.
+  Fixed CMF optimization of non-IDAT compressed chunks, which was added at
+    libpng-1.5.4.  It sometimes produced too small of a window.
+
+Version 1.5.10beta05 [March 10, 2012]
+  Reject all iCCP chunks after the first, even if the first one is invalid.
+  Issue a png_benign_error() instead of png_warning() about bad palette index.
+  Fixed an off-by-one error in the palette index checking function.
+  Revised example.c to put text strings in a temporary character array
+    instead of directly assigning string constants to png_textp members.
+    This avoids compiler warnings when -Wwrite-strings is enabled.
+
+Version 1.5.10 [March 29, 2012]
+  Prevent PNG_EXPAND+PNG_SHIFT doing the shift twice.
+  Revised png_set_text_2() to avoid potential memory corruption (fixes
+    CVE-2011-3048).
+
+Version 1.5.11beta01 [April 28, 2012]
+  Revised scripts/makefile.darwin: use system zlib; remove quotes around
+    architecture list; add missing ppc architecture; add architecture options
+    to shared library link; don't try to create a shared lib based on missing
+    RELEASE variable.
+  Enable png_set_check_for_invalid_index() for both read and write.
+  Removed #ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED/#endif in pngpriv.h around
+    declaration of png_handle_unknown().
+  Added -lssp_nonshared in a comment in scripts/makefile.freebsd
+    and changed deprecated NOOBJ and NOPROFILE to NO_OBJ and NO_PROFILE.
+
+Version 1.5.11rc01 [May 23, 2012]
+  No changes.
+
+Version 1.5.11rc02 [May 29, 2012]
+  Fixed some typos in comments.
+  Revised CMakeLists.txt to not attempt to make a symlink under mingw.
+  Added two images to contrib/pngsuite (1-bit and 2-bit transparent grayscale),
+    and renamed three whose names were inconsistent with those in
+    pngsuite/README.txt.
+
+Version 1.5.11rc03 [June 4, 2012]
+  Do not depend upon a GCC feature macro being available for use in generating
+    the linker mapfile symbol prefix.
+  Made fixes for new optimization warnings from gcc 4.7.0. The compiler
+    performed an optimization which is safe but then warned about it.
+    Changing the type of 'palette_number' in pngvalid.c removes the warning.
+
+Version 1.5.11rc04 [June 6, 2012]
+  Improved performance of new do_check_palette_indexes() function.
+
+Version 1.5.11rc05 [June 7, 2012]
+  Don't check palette indexes if num_palette is 0 (as it can be in MNG files).
+
+Version 1.5.11 [June 14, 2012]
+  Include zlib.h in contrib/gregbook and contrib/visupng examples.
+
+Version 1.5.12 [July 11, 2012]
+  Removed scripts/makefile.cegcc from the *.zip and *.7z distributions; it
+    depends on configure, which is not included in those archives.
+  Changed "a+w" to "u+w" in Makefile.in to fix CVE-2012-3386.
+
+Send comments/corrections/commendations to png-mng-implement at lists.sf.net
+(subscription required; visit
+https://lists.sourceforge.net/lists/listinfo/png-mng-implement
+to subscribe)
+or to glennrp at users.sourceforge.net
+
+Glenn R-P
+#endif
diff -urN a/media/libpng/LICENSE b/media/libpng/LICENSE
--- a/media/libpng/LICENSE	2012-07-11 03:33:19 +0800
+++ b/media/libpng/LICENSE	2012-07-13 12:40:57 +0800
@@ -1,111 +1,111 @@
-
-This copy of the libpng notices is provided for your convenience.  In case of
-any discrepancy between this copy and the notices in the file png.h that is
-included in the libpng distribution, the latter shall prevail.
-
-COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
-
-If you modify libpng you may insert additional notices immediately following
-this sentence.
-
-This code is released under the libpng license.
-
-libpng versions 1.2.6, August 15, 2004, through 1.5.9, February 18, 2012, are
-Copyright (c) 2004, 2006-2011 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.2.5
-with the following individual added to the list of Contributing Authors
-
-   Cosmin Truta
-
-libpng versions 1.0.7, July 1, 2000, through 1.2.5 - October 3, 2002, are
-Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-1.0.6
-with the following individuals added to the list of Contributing Authors
-
-   Simon-Pierre Cadieux
-   Eric S. Raymond
-   Gilles Vollant
-
-and with the following additions to the disclaimer:
-
-   There is no warranty against interference with your enjoyment of the
-   library or against infringement.  There is no warranty that our
-   efforts or the library will fulfill any of your particular purposes
-   or needs.  This library is provided with all faults, and the entire
-   risk of satisfactory quality, performance, accuracy, and effort is with
-   the user.
-
-libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
-Copyright (c) 1998, 1999 Glenn Randers-Pehrson, and are
-distributed according to the same disclaimer and license as libpng-0.96,
-with the following individuals added to the list of Contributing Authors:
-
-   Tom Lane
-   Glenn Randers-Pehrson
-   Willem van Schaik
-
-libpng versions 0.89, June 1996, through 0.96, May 1997, are
-Copyright (c) 1996, 1997 Andreas Dilger
-Distributed according to the same disclaimer and license as libpng-0.88,
-with the following individuals added to the list of Contributing Authors:
-
-   John Bowler
-   Kevin Bracey
-   Sam Bushell
-   Magnus Holmgren
-   Greg Roelofs
-   Tom Tanner
-
-libpng versions 0.5, May 1995, through 0.88, January 1996, are
-Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
-
-For the purposes of this copyright and license, "Contributing Authors"
-is defined as the following set of individuals:
-
-   Andreas Dilger
-   Dave Martindale
-   Guy Eric Schalnat
-   Paul Schmidt
-   Tim Wegner
-
-The PNG Reference Library is supplied "AS IS".  The Contributing Authors
-and Group 42, Inc. disclaim all warranties, expressed or implied,
-including, without limitation, the warranties of merchantability and of
-fitness for any purpose.  The Contributing Authors and Group 42, Inc.
-assume no liability for direct, indirect, incidental, special, exemplary,
-or consequential damages, which may result from the use of the PNG
-Reference Library, even if advised of the possibility of such damage.
-
-Permission is hereby granted to use, copy, modify, and distribute this
-source code, or portions hereof, for any purpose, without fee, subject
-to the following restrictions:
-
-1. The origin of this source code must not be misrepresented.
-
-2. Altered versions must be plainly marked as such and must not
-   be misrepresented as being the original source.
-
-3. This Copyright notice may not be removed or altered from any
-   source or altered source distribution.
-
-The Contributing Authors and Group 42, Inc. specifically permit, without
-fee, and encourage the use of this source code as a component to
-supporting the PNG file format in commercial products.  If you use this
-source code in a product, acknowledgment is not required but would be
-appreciated.
-
-
-A "png_get_copyright" function is available, for convenient use in "about"
-boxes and the like:
-
-   printf("%s",png_get_copyright(NULL));
-
-Also, the PNG logo (in PNG format, of course) is supplied in the
-files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
-
-Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a
-certification mark of the Open Source Initiative.
-
-Glenn Randers-Pehrson
-glennrp at users.sourceforge.net
-February 18, 2012
+
+This copy of the libpng notices is provided for your convenience.  In case of
+any discrepancy between this copy and the notices in the file png.h that is
+included in the libpng distribution, the latter shall prevail.
+
+COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
+
+If you modify libpng you may insert additional notices immediately following
+this sentence.
+
+This code is released under the libpng license.
+
+libpng versions 1.2.6, August 15, 2004, through 1.5.12, July 11, 2012, are
+Copyright (c) 2004, 2006-2012 Glenn Randers-Pehrson, and are
+distributed according to the same disclaimer and license as libpng-1.2.5
+with the following individual added to the list of Contributing Authors
+
+   Cosmin Truta
+
+libpng versions 1.0.7, July 1, 2000, through 1.2.5 - October 3, 2002, are
+Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are
+distributed according to the same disclaimer and license as libpng-1.0.6
+with the following individuals added to the list of Contributing Authors
+
+   Simon-Pierre Cadieux
+   Eric S. Raymond
+   Gilles Vollant
+
+and with the following additions to the disclaimer:
+
+   There is no warranty against interference with your enjoyment of the
+   library or against infringement.  There is no warranty that our
+   efforts or the library will fulfill any of your particular purposes
+   or needs.  This library is provided with all faults, and the entire
+   risk of satisfactory quality, performance, accuracy, and effort is with
+   the user.
+
+libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
+Copyright (c) 1998, 1999 Glenn Randers-Pehrson, and are
+distributed according to the same disclaimer and license as libpng-0.96,
+with the following individuals added to the list of Contributing Authors:
+
+   Tom Lane
+   Glenn Randers-Pehrson
+   Willem van Schaik
+
+libpng versions 0.89, June 1996, through 0.96, May 1997, are
+Copyright (c) 1996, 1997 Andreas Dilger
+Distributed according to the same disclaimer and license as libpng-0.88,
+with the following individuals added to the list of Contributing Authors:
+
+   John Bowler
+   Kevin Bracey
+   Sam Bushell
+   Magnus Holmgren
+   Greg Roelofs
+   Tom Tanner
+
+libpng versions 0.5, May 1995, through 0.88, January 1996, are
+Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
+
+For the purposes of this copyright and license, "Contributing Authors"
+is defined as the following set of individuals:
+
+   Andreas Dilger
+   Dave Martindale
+   Guy Eric Schalnat
+   Paul Schmidt
+   Tim Wegner
+
+The PNG Reference Library is supplied "AS IS".  The Contributing Authors
+and Group 42, Inc. disclaim all warranties, expressed or implied,
+including, without limitation, the warranties of merchantability and of
+fitness for any purpose.  The Contributing Authors and Group 42, Inc.
+assume no liability for direct, indirect, incidental, special, exemplary,
+or consequential damages, which may result from the use of the PNG
+Reference Library, even if advised of the possibility of such damage.
+
+Permission is hereby granted to use, copy, modify, and distribute this
+source code, or portions hereof, for any purpose, without fee, subject
+to the following restrictions:
+
+1. The origin of this source code must not be misrepresented.
+
+2. Altered versions must be plainly marked as such and must not
+   be misrepresented as being the original source.
+
+3. This Copyright notice may not be removed or altered from any
+   source or altered source distribution.
+
+The Contributing Authors and Group 42, Inc. specifically permit, without
+fee, and encourage the use of this source code as a component to
+supporting the PNG file format in commercial products.  If you use this
+source code in a product, acknowledgment is not required but would be
+appreciated.
+
+
+A "png_get_copyright" function is available, for convenient use in "about"
+boxes and the like:
+
+   printf("%s",png_get_copyright(NULL));
+
+Also, the PNG logo (in PNG format, of course) is supplied in the
+files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
+
+Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a
+certification mark of the Open Source Initiative.
+
+Glenn Randers-Pehrson
+glennrp at users.sourceforge.net
+July 11, 2012
diff -urN a/media/libpng/MOZCHANGES b/media/libpng/MOZCHANGES
--- a/media/libpng/MOZCHANGES	2012-07-11 03:33:19 +0800
+++ b/media/libpng/MOZCHANGES	2012-07-13 12:40:57 +0800
@@ -1,5 +1,8 @@
 
 Changes made to pristine png source by mozilla.org developers.
+2012/07/11  -- Synced with libpng-1.5.12 (bug #759067).
+
+2012/04/13  -- Synced with libpng-1.5.10 (bug #745178).
 
 2012/02/19  -- Synced with libpng-1.5.9 (bug #648690).
 
diff -urN a/media/libpng/Makefile.in b/media/libpng/Makefile.in
--- a/media/libpng/Makefile.in	2012-07-11 03:33:19 +0800
+++ b/media/libpng/Makefile.in	2012-07-13 16:43:50 +0800
@@ -75,7 +75,7 @@
 DEFINES		+= -DMOZ_PNG_READ \
 		-DMOZ_PNG_WRITE
 
-EXPORTS		= png.h pngconf.h mozpngconf.h
+EXPORTS		= png.h pngconf.h pnglibconf.h mozpngconf.h
 
 LOCAL_INCLUDES	= -I$(srcdir)
 
diff -urN a/media/libpng/README b/media/libpng/README
--- a/media/libpng/README	2012-07-11 03:33:19 +0800
+++ b/media/libpng/README	2012-07-13 12:40:57 +0800
@@ -1,202 +1,202 @@
-README for libpng version 1.5.9 - February 18, 2012 (shared library 15.0)
-See the note about version numbers near the top of png.h
-
-See INSTALL for instructions on how to install libpng.
-
-Libpng comes in several distribution formats.  Get libpng-*.tar.gz,
-libpng-*.tar.xz or libpng-*.tar.bz2 if you want UNIX-style line endings
-in the text files, or lpng*.zip if you want DOS-style line endings.
-
-Version 0.89 was the first official release of libpng.  Don't let the
-fact that it's the first release fool you.  The libpng library has been in
-extensive use and testing since mid-1995.  By late 1997 it had
-finally gotten to the stage where there hadn't been significant
-changes to the API in some time, and people have a bad feeling about
-libraries with versions < 1.0.  Version 1.0.0 was released in
-March 1998.
-
-****
-Note that some of the changes to the png_info structure render this
-version of the library binary incompatible with libpng-0.89 or
-earlier versions if you are using a shared library.  The type of the
-"filler" parameter for png_set_filler() has changed from png_byte to
-png_uint_32, which will affect shared-library applications that use
-this function.
-
-To avoid problems with changes to the internals of png_info_struct,
-new APIs have been made available in 0.95 to avoid direct application
-access to info_ptr.  These functions are the png_set_<chunk> and
-png_get_<chunk> functions.  These functions should be used when
-accessing/storing the info_struct data, rather than manipulating it
-directly, to avoid such problems in the future.
-
-It is important to note that the APIs do not make current programs
-that access the info struct directly incompatible with the new
-library.  However, it is strongly suggested that new programs use
-the new APIs (as shown in example.c and pngtest.c), and older programs
-be converted to the new format, to facilitate upgrades in the future.
-****
-
-Additions since 0.90 include the ability to compile libpng as a
-Windows DLL, and new APIs for accessing data in the info struct.
-Experimental functions include the ability to set weighting and cost
-factors for row filter selection, direct reads of integers from buffers
-on big-endian processors that support misaligned data access, faster
-methods of doing alpha composition, and more accurate 16->8 bit color
-conversion.
-
-The additions since 0.89 include the ability to read from a PNG stream
-which has had some (or all) of the signature bytes read by the calling
-application.  This also allows the reading of embedded PNG streams that
-do not have the PNG file signature.  As well, it is now possible to set
-the library action on the detection of chunk CRC errors.  It is possible
-to set different actions based on whether the CRC error occurred in a
-critical or an ancillary chunk.
-
-The changes made to the library, and bugs fixed are based on discussions
-on the PNG-implement mailing list and not on material submitted
-privately to Guy, Andreas, or Glenn.  They will forward any good
-suggestions to the list.
-
-For a detailed description on using libpng, read libpng-manual.txt.  For
-examples of libpng in a program, see example.c and pngtest.c.  For usage
-information and restrictions (what little they are) on libpng, see
-png.h.  For a description on using zlib (the compression library used by
-libpng) and zlib's restrictions, see zlib.h
-
-I have included a general makefile, as well as several machine and
-compiler specific ones, but you may have to modify one for your own needs.
-
-You should use zlib 1.0.4 or later to run this, but it MAY work with
-versions as old as zlib 0.95.  Even so, there are bugs in older zlib
-versions which can cause the output of invalid compression streams for
-some images.  You will definitely need zlib 1.0.4 or later if you are
-taking advantage of the MS-DOS "far" structure allocation for the small
-and medium memory models.  You should also note that zlib is a
-compression library that is useful for more things than just PNG files.
-You can use zlib as a drop-in replacement for fread() and fwrite() if
-you are so inclined.
-
-zlib should be available at the same place that libpng is, or at.
-ftp://ftp.info-zip.org/pub/infozip/zlib
-
-You may also want a copy of the PNG specification.  It is available
-as an RFC, a W3C Recommendation, and an ISO/IEC Standard.  You can find
-these at http://www.libpng.org/pub/png/documents/
-
-This code is currently being archived at libpng.sf.net in the
-[DOWNLOAD] area, and on CompuServe, Lib 20 (PNG SUPPORT)
-at GO GRAPHSUP.  If you can't find it in any of those places,
-e-mail me, and I'll help you find it.
-
-If you have any code changes, requests, problems, etc., please e-mail
-them to me.  Also, I'd appreciate any make files or project files,
-and any modifications you needed to make to get libpng to compile,
-along with a #define variable to tell what compiler/system you are on.
-If you needed to add transformations to libpng, or wish libpng would
-provide the image in a different way, drop me a note (and code, if
-possible), so I can consider supporting the transformation.
-Finally, if you get any warning messages when compiling libpng
-(note: not zlib), and they are easy to fix, I'd appreciate the
-fix.  Please mention "libpng" somewhere in the subject line.  Thanks.
-
-This release was created and will be supported by myself (of course
-based in a large way on Guy's and Andreas' earlier work), and the PNG
-development group.
-
-Send comments/corrections/commendations to png-mng-implement at
-lists.sourceforge.net (subscription required; visit 
-https://lists.sourceforge.net/lists/listinfo/png-mng-implement
-to subscribe) or to glennrp at users.sourceforge.net
-
-You can't reach Guy, the original libpng author, at the addresses
-given in previous versions of this document.  He and Andreas will
-read mail addressed to the png-implement list, however.
-
-Please do not send general questions about PNG.  Send them to
-png-mng-misc at lists.sf.net (subscription required; visit
-https://lists.sourceforge.net/lists/listinfo/png-mng-misc to
-subscribe).  If you have a question about something
-in the PNG specification that is related to using libpng, send it
-to me.  Send me any questions that start with "I was using libpng,
-and ...".  If in doubt, send questions to me.  I'll bounce them
-to others, if necessary.
-
-Please do not send suggestions on how to change PNG.  We have
-been discussing PNG for sixteen years now, and it is official and
-finished.  If you have suggestions for libpng, however, I'll
-gladly listen.  Even if your suggestion is not used immediately,
-it may be used later.
-
-Files in this distribution:
-
-      ANNOUNCE      =>  Announcement of this version, with recent changes
-      CHANGES       =>  Description of changes between libpng versions
-      KNOWNBUG      =>  List of known bugs and deficiencies
-      LICENSE       =>  License to use and redistribute libpng
-      README        =>  This file
-      TODO          =>  Things not implemented in the current library
-      Y2KINFO       =>  Statement of Y2K compliance
-      example.c     =>  Example code for using libpng functions
-      libpng.3      =>  manual page for libpng (includes libpng-manual.txt)
-      libpng-manual.txt  =>  Description of libpng and its functions
-      libpngpf.3    =>  manual page for libpng's private functions
-      png.5         =>  manual page for the PNG format
-      png.c         =>  Basic interface functions common to library
-      png.h         =>  Library function and interface declarations (public)
-      pngpriv.h     =>  Library function and interface declarations (private)
-      pngconf.h     =>  System specific library configuration (public)
-      pngstruct.h   =>  png_struct declaration (private)
-      pnginfo.h     =>  png_info struct declaration (private)
-      pngdebug.h    =>  debugging macros (private)
-      pngerror.c    =>  Error/warning message I/O functions
-      pngget.c      =>  Functions for retrieving info from struct
-      pngmem.c      =>  Memory handling functions
-      pngbar.png    =>  PNG logo, 88x31
-      pngnow.png    =>  PNG logo, 98x31
-      pngpread.c    =>  Progressive reading functions
-      pngread.c     =>  Read data/helper high-level functions
-      pngrio.c      =>  Lowest-level data read I/O functions
-      pngrtran.c    =>  Read data transformation functions
-      pngrutil.c    =>  Read data utility functions
-      pngset.c      =>  Functions for storing data into the info_struct
-      pngtest.c     =>  Library test program
-      pngtest.png   =>  Library test sample image
-      pngtrans.c    =>  Common data transformation functions
-      pngwio.c      =>  Lowest-level write I/O functions
-      pngwrite.c    =>  High-level write functions
-      pngwtran.c    =>  Write data transformations
-      pngwutil.c    =>  Write utility functions
-      contrib       =>  Contributions
-       gregbook         =>  source code for PNG reading and writing, from
-                            Greg Roelofs' "PNG: The Definitive Guide",
-                            O'Reilly, 1999
-       msvctest     =>  Builds and runs pngtest using a MSVC workspace
-       pngminus     =>  Simple pnm2png and png2pnm programs
-       pngsuite     =>  Test images
-       visupng      =>  Contains a MSVC workspace for VisualPng
-      projects      =>  Contains project files and workspaces for
-                        building a DLL
-       cbuilder5        =>  Contains a Borland workspace for building
-                            libpng and zlib
-       visualc6         =>  Contains a Microsoft Visual C++ (MSVC)
-                            workspace for building libpng and zlib
-       visualc71        =>  Contains a Microsoft Visual C++ (MSVC)
-                            workspace for building libpng and zlib
-       xcode            =>  Contains an Apple xcode
-                            workspace for building libpng and zlib
-      scripts       =>  Directory containing scripts for building libpng:
-                            (see scripts/README.txt for the list of scripts)
-
-Good luck, and happy coding.
-
--Glenn Randers-Pehrson (current maintainer, since 1998)
- Internet: glennrp at users.sourceforge.net
-
--Andreas Eric Dilger (former maintainer, 1996-1997)
- Internet: adilger at enel.ucalgary.ca
- Web: http://www-mddsp.enel.ucalgary.ca/People/adilger/
-
--Guy Eric Schalnat (original author and former maintainer, 1995-1996)
- (formerly of Group 42, Inc)
- Internet: gschal at infinet.com
+README for libpng version 1.5.12 - July 11, 2012 (shared library 15.0)
+See the note about version numbers near the top of png.h
+
+See INSTALL for instructions on how to install libpng.
+
+Libpng comes in several distribution formats.  Get libpng-*.tar.gz,
+libpng-*.tar.xz or libpng-*.tar.bz2 if you want UNIX-style line endings
+in the text files, or lpng*.zip if you want DOS-style line endings.
+
+Version 0.89 was the first official release of libpng.  Don't let the
+fact that it's the first release fool you.  The libpng library has been in
+extensive use and testing since mid-1995.  By late 1997 it had
+finally gotten to the stage where there hadn't been significant
+changes to the API in some time, and people have a bad feeling about
+libraries with versions < 1.0.  Version 1.0.0 was released in
+March 1998.
+
+****
+Note that some of the changes to the png_info structure render this
+version of the library binary incompatible with libpng-0.89 or
+earlier versions if you are using a shared library.  The type of the
+"filler" parameter for png_set_filler() has changed from png_byte to
+png_uint_32, which will affect shared-library applications that use
+this function.
+
+To avoid problems with changes to the internals of png_info_struct,
+new APIs have been made available in 0.95 to avoid direct application
+access to info_ptr.  These functions are the png_set_<chunk> and
+png_get_<chunk> functions.  These functions should be used when
+accessing/storing the info_struct data, rather than manipulating it
+directly, to avoid such problems in the future.
+
+It is important to note that the APIs do not make current programs
+that access the info struct directly incompatible with the new
+library.  However, it is strongly suggested that new programs use
+the new APIs (as shown in example.c and pngtest.c), and older programs
+be converted to the new format, to facilitate upgrades in the future.
+****
+
+Additions since 0.90 include the ability to compile libpng as a
+Windows DLL, and new APIs for accessing data in the info struct.
+Experimental functions include the ability to set weighting and cost
+factors for row filter selection, direct reads of integers from buffers
+on big-endian processors that support misaligned data access, faster
+methods of doing alpha composition, and more accurate 16->8 bit color
+conversion.
+
+The additions since 0.89 include the ability to read from a PNG stream
+which has had some (or all) of the signature bytes read by the calling
+application.  This also allows the reading of embedded PNG streams that
+do not have the PNG file signature.  As well, it is now possible to set
+the library action on the detection of chunk CRC errors.  It is possible
+to set different actions based on whether the CRC error occurred in a
+critical or an ancillary chunk.
+
+The changes made to the library, and bugs fixed are based on discussions
+on the PNG-implement mailing list and not on material submitted
+privately to Guy, Andreas, or Glenn.  They will forward any good
+suggestions to the list.
+
+For a detailed description on using libpng, read libpng-manual.txt.  For
+examples of libpng in a program, see example.c and pngtest.c.  For usage
+information and restrictions (what little they are) on libpng, see
+png.h.  For a description on using zlib (the compression library used by
+libpng) and zlib's restrictions, see zlib.h
+
+I have included a general makefile, as well as several machine and
+compiler specific ones, but you may have to modify one for your own needs.
+
+You should use zlib 1.0.4 or later to run this, but it MAY work with
+versions as old as zlib 0.95.  Even so, there are bugs in older zlib
+versions which can cause the output of invalid compression streams for
+some images.  You will definitely need zlib 1.0.4 or later if you are
+taking advantage of the MS-DOS "far" structure allocation for the small
+and medium memory models.  You should also note that zlib is a
+compression library that is useful for more things than just PNG files.
+You can use zlib as a drop-in replacement for fread() and fwrite() if
+you are so inclined.
+
+zlib should be available at the same place that libpng is, or at.
+ftp://ftp.info-zip.org/pub/infozip/zlib
+
+You may also want a copy of the PNG specification.  It is available
+as an RFC, a W3C Recommendation, and an ISO/IEC Standard.  You can find
+these at http://www.libpng.org/pub/png/documents/
+
+This code is currently being archived at libpng.sf.net in the
+[DOWNLOAD] area, and on CompuServe, Lib 20 (PNG SUPPORT)
+at GO GRAPHSUP.  If you can't find it in any of those places,
+e-mail me, and I'll help you find it.
+
+If you have any code changes, requests, problems, etc., please e-mail
+them to me.  Also, I'd appreciate any make files or project files,
+and any modifications you needed to make to get libpng to compile,
+along with a #define variable to tell what compiler/system you are on.
+If you needed to add transformations to libpng, or wish libpng would
+provide the image in a different way, drop me a note (and code, if
+possible), so I can consider supporting the transformation.
+Finally, if you get any warning messages when compiling libpng
+(note: not zlib), and they are easy to fix, I'd appreciate the
+fix.  Please mention "libpng" somewhere in the subject line.  Thanks.
+
+This release was created and will be supported by myself (of course
+based in a large way on Guy's and Andreas' earlier work), and the PNG
+development group.
+
+Send comments/corrections/commendations to png-mng-implement at
+lists.sourceforge.net (subscription required; visit 
+https://lists.sourceforge.net/lists/listinfo/png-mng-implement
+to subscribe) or to glennrp at users.sourceforge.net
+
+You can't reach Guy, the original libpng author, at the addresses
+given in previous versions of this document.  He and Andreas will
+read mail addressed to the png-implement list, however.
+
+Please do not send general questions about PNG.  Send them to
+png-mng-misc at lists.sf.net (subscription required; visit
+https://lists.sourceforge.net/lists/listinfo/png-mng-misc to
+subscribe).  If you have a question about something
+in the PNG specification that is related to using libpng, send it
+to me.  Send me any questions that start with "I was using libpng,
+and ...".  If in doubt, send questions to me.  I'll bounce them
+to others, if necessary.
+
+Please do not send suggestions on how to change PNG.  We have
+been discussing PNG for sixteen years now, and it is official and
+finished.  If you have suggestions for libpng, however, I'll
+gladly listen.  Even if your suggestion is not used immediately,
+it may be used later.
+
+Files in this distribution:
+
+      ANNOUNCE      =>  Announcement of this version, with recent changes
+      CHANGES       =>  Description of changes between libpng versions
+      KNOWNBUG      =>  List of known bugs and deficiencies
+      LICENSE       =>  License to use and redistribute libpng
+      README        =>  This file
+      TODO          =>  Things not implemented in the current library
+      Y2KINFO       =>  Statement of Y2K compliance
+      example.c     =>  Example code for using libpng functions
+      libpng.3      =>  manual page for libpng (includes libpng-manual.txt)
+      libpng-manual.txt  =>  Description of libpng and its functions
+      libpngpf.3    =>  manual page for libpng's private functions
+      png.5         =>  manual page for the PNG format
+      png.c         =>  Basic interface functions common to library
+      png.h         =>  Library function and interface declarations (public)
+      pngpriv.h     =>  Library function and interface declarations (private)
+      pngconf.h     =>  System specific library configuration (public)
+      pngstruct.h   =>  png_struct declaration (private)
+      pnginfo.h     =>  png_info struct declaration (private)
+      pngdebug.h    =>  debugging macros (private)
+      pngerror.c    =>  Error/warning message I/O functions
+      pngget.c      =>  Functions for retrieving info from struct
+      pngmem.c      =>  Memory handling functions
+      pngbar.png    =>  PNG logo, 88x31
+      pngnow.png    =>  PNG logo, 98x31
+      pngpread.c    =>  Progressive reading functions
+      pngread.c     =>  Read data/helper high-level functions
+      pngrio.c      =>  Lowest-level data read I/O functions
+      pngrtran.c    =>  Read data transformation functions
+      pngrutil.c    =>  Read data utility functions
+      pngset.c      =>  Functions for storing data into the info_struct
+      pngtest.c     =>  Library test program
+      pngtest.png   =>  Library test sample image
+      pngtrans.c    =>  Common data transformation functions
+      pngwio.c      =>  Lowest-level write I/O functions
+      pngwrite.c    =>  High-level write functions
+      pngwtran.c    =>  Write data transformations
+      pngwutil.c    =>  Write utility functions
+      contrib       =>  Contributions
+       gregbook         =>  source code for PNG reading and writing, from
+                            Greg Roelofs' "PNG: The Definitive Guide",
+                            O'Reilly, 1999
+       msvctest     =>  Builds and runs pngtest using a MSVC workspace
+       pngminus     =>  Simple pnm2png and png2pnm programs
+       pngsuite     =>  Test images
+       visupng      =>  Contains a MSVC workspace for VisualPng
+      projects      =>  Contains project files and workspaces for
+                        building a DLL
+       cbuilder5        =>  Contains a Borland workspace for building
+                            libpng and zlib
+       visualc6         =>  Contains a Microsoft Visual C++ (MSVC)
+                            workspace for building libpng and zlib
+       visualc71        =>  Contains a Microsoft Visual C++ (MSVC)
+                            workspace for building libpng and zlib
+       xcode            =>  Contains an Apple xcode
+                            workspace for building libpng and zlib
+      scripts       =>  Directory containing scripts for building libpng:
+                            (see scripts/README.txt for the list of scripts)
+
+Good luck, and happy coding.
+
+-Glenn Randers-Pehrson (current maintainer, since 1998)
+ Internet: glennrp at users.sourceforge.net
+
+-Andreas Eric Dilger (former maintainer, 1996-1997)
+ Internet: adilger at enel.ucalgary.ca
+ Web: http://www-mddsp.enel.ucalgary.ca/People/adilger/
+
+-Guy Eric Schalnat (original author and former maintainer, 1995-1996)
+ (formerly of Group 42, Inc)
+ Internet: gschal at infinet.com
diff -urN a/media/libpng/apng.patch b/media/libpng/apng.patch
--- a/media/libpng/apng.patch	2012-07-11 03:33:19 +0800
+++ b/media/libpng/apng.patch	2012-07-13 12:40:57 +0800
@@ -1,39 +1,18 @@
-diff -up8 png.h png.h
---- png.h	2012-02-18 15:31:14 -0500
-+++ png.h	2012-02-19 16:08:36 -0500
-@@ -417,24 +417,18 @@
- /* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
-  * We must not include leading zeros.
-  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
-  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
-  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
-  */
- #define PNG_LIBPNG_VER 10509 /* 1.5.9 */
- 
--/* Library configuration: these options cannot be changed after
-- * the library has been built.
-- */
--#ifndef PNGLCONF_H
--    /* If pnglibconf.h is missing, you can
--     * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
--     */
--#   include "pnglibconf.h"
-+#ifndef MOZPNGCONF_H
-+#   include "mozpngconf.h"
+diff -Naru libpng-1.5.11.org/png.h libpng-1.5.11/png.h
+--- libpng-1.5.11.org/png.h	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/png.h	2012-06-15 22:17:27.000000000 +0900
+@@ -438,6 +438,10 @@
+ #   include "pnglibconf.h"
  #endif
  
++#define PNG_APNG_SUPPORTED
++#define PNG_READ_APNG_SUPPORTED
++#define PNG_WRITE_APNG_SUPPORTED
++
  #ifndef PNG_VERSION_INFO_ONLY
  #  ifndef PNG_BUILDING_SYMBOL_TABLE
    /*
-    *   Standard header files (not needed for the version info or while
-    *   building symbol table -- see scripts/pnglibconf.dfa)
-    */
-@@ -534,16 +528,27 @@ extern "C" {
-  * Otherwise the calls are mapped to png_error.
-  */
- 
- /* Section 2: type definitions, including structures and compile time
-  * constants.
+@@ -545,6 +549,17 @@
   * See pngconf.h for base types that vary by machine/system
   */
  
@@ -51,17 +30,7 @@
  /* This triggers a compiler error in png.c, if png.c and png.h
   * do not agree upon the version number.
   */
- typedef char* png_libpng_version_1_5_9;
- 
- /* Three color definitions.  The order of the red, green, and blue, (and the
-  * exact size) is not important, although the size of the fields need to
-  * be png_byte or png_uint_16 (as defined below).
-@@ -817,16 +822,20 @@ typedef png_info FAR * FAR * png_infopp;
- #define PNG_INFO_oFFs 0x0100
- #define PNG_INFO_tIME 0x0200
- #define PNG_INFO_pCAL 0x0400
- #define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
- #define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
+@@ -828,6 +843,10 @@
  #define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
  #define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
  #define PNG_INFO_IDAT 0x8000   /* ESR, 1.0.6 */
@@ -72,17 +41,7 @@
  
  /* This is used for the transformation routines, as some of them
   * change these values for the row.  It also should enable using
-  * the routines for other purposes.
-  */
- typedef struct png_row_info_struct
- {
-    png_uint_32 width;    /* width of row */
-@@ -862,16 +871,20 @@ typedef PNG_CALLBACK(void, *png_flush_pt
- typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
-     int));
- typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
-     int));
- 
+@@ -873,6 +892,10 @@
  #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
  typedef PNG_CALLBACK(void, *png_progressive_info_ptr, (png_structp, png_infop));
  typedef PNG_CALLBACK(void, *png_progressive_end_ptr, (png_structp, png_infop));
@@ -93,85 +52,75 @@
  
  /* The following callback receives png_uint_32 row_number, int pass for the
   * png_bytep data of the row.  When transforming an interlaced image the
-  * row number is the row number within the sub-image of the interlace pass, so
-  * the value will increase to the height of the sub-image (not the full image)
-  * then reset to 0 for the next pass.
-  *
-  * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
-@@ -2632,26 +2645,99 @@ PNG_EXPORT(207, void, png_save_uint_16, 
-        ((unsigned int)(*((buf) + 1)))))
- 
- #  define png_get_int_32(buf) \
-      ((png_int_32)((*(buf) & 0x80) \
-       ? -((png_int_32)((png_get_uint_32(buf) ^ 0xffffffffL) + 1)) \
-       : (png_int_32)png_get_uint_32(buf)))
+@@ -2649,6 +2672,75 @@
+     int allowed));
  #endif
  
 +#ifdef PNG_APNG_SUPPORTED
-+PNG_EXPORT(234, png_uint_32, png_get_acTL, (png_structp png_ptr,
++PNG_EXPORT(235, png_uint_32, png_get_acTL, (png_structp png_ptr,
 +   png_infop info_ptr, png_uint_32 *num_frames, png_uint_32 *num_plays));
 +
-+PNG_EXPORT(235, png_uint_32, png_set_acTL, (png_structp png_ptr,
++PNG_EXPORT(236, png_uint_32, png_set_acTL, (png_structp png_ptr,
 +   png_infop info_ptr, png_uint_32 num_frames, png_uint_32 num_plays));
 +
-+PNG_EXPORT(236, png_uint_32, png_get_num_frames, (png_structp png_ptr,
++PNG_EXPORT(237, png_uint_32, png_get_num_frames, (png_structp png_ptr,
 +   png_infop info_ptr));
 +
-+PNG_EXPORT(237, png_uint_32, png_get_num_plays, (png_structp png_ptr,
++PNG_EXPORT(238, png_uint_32, png_get_num_plays, (png_structp png_ptr,
 +   png_infop info_ptr));
 +
-+PNG_EXPORT(238, png_uint_32, png_get_next_frame_fcTL,
++PNG_EXPORT(239, png_uint_32, png_get_next_frame_fcTL,
 +   (png_structp png_ptr, png_infop info_ptr, png_uint_32 *width,
 +   png_uint_32 *height, png_uint_32 *x_offset, png_uint_32 *y_offset,
 +   png_uint_16 *delay_num, png_uint_16 *delay_den, png_byte *dispose_op,
 +   png_byte *blend_op));
 +
-+PNG_EXPORT(239, png_uint_32, png_set_next_frame_fcTL,
++PNG_EXPORT(240, png_uint_32, png_set_next_frame_fcTL,
 +   (png_structp png_ptr, png_infop info_ptr, png_uint_32 width,
 +   png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset,
 +   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
 +   png_byte blend_op));
 +
-+PNG_EXPORT(240, png_uint_32, png_get_next_frame_width,
++PNG_EXPORT(241, png_uint_32, png_get_next_frame_width,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(241, png_uint_32, png_get_next_frame_height,
++PNG_EXPORT(242, png_uint_32, png_get_next_frame_height,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(242, png_uint_32, png_get_next_frame_x_offset,
++PNG_EXPORT(243, png_uint_32, png_get_next_frame_x_offset,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(243, png_uint_32, png_get_next_frame_y_offset,
++PNG_EXPORT(244, png_uint_32, png_get_next_frame_y_offset,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(244, png_uint_16, png_get_next_frame_delay_num,
++PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_num,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_den,
++PNG_EXPORT(246, png_uint_16, png_get_next_frame_delay_den,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(246, png_byte, png_get_next_frame_dispose_op,
++PNG_EXPORT(247, png_byte, png_get_next_frame_dispose_op,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(247, png_byte, png_get_next_frame_blend_op,
++PNG_EXPORT(248, png_byte, png_get_next_frame_blend_op,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(248, png_byte, png_get_first_frame_is_hidden,
++PNG_EXPORT(249, png_byte, png_get_first_frame_is_hidden,
 +   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(249, png_uint_32, png_set_first_frame_is_hidden,
++PNG_EXPORT(250, png_uint_32, png_set_first_frame_is_hidden,
 +   (png_structp png_ptr, png_infop info_ptr, png_byte is_hidden));
 +
 +#ifdef PNG_READ_APNG_SUPPORTED
-+PNG_EXPORT(250, void, png_read_frame_head, (png_structp png_ptr,
++PNG_EXPORT(251, void, png_read_frame_head, (png_structp png_ptr,
 +   png_infop info_ptr));
 +#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-+PNG_EXPORT(251, void, png_set_progressive_frame_fn, (png_structp png_ptr,
++PNG_EXPORT(252, void, png_set_progressive_frame_fn, (png_structp png_ptr,
 +   png_progressive_frame_ptr frame_info_fn,
 +   png_progressive_frame_ptr frame_end_fn));
 +#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 +#endif /* PNG_READ_APNG_SUPPORTED */
 +
 +#ifdef PNG_WRITE_APNG_SUPPORTED
-+PNG_EXPORT(252, void, png_write_frame_head, (png_structp png_ptr,
++PNG_EXPORT(253, void, png_write_frame_head, (png_structp png_ptr,
 +   png_infop info_ptr, png_bytepp row_pointers,
 +   png_uint_32 width, png_uint_32 height,
 +   png_uint_32 x_offset, png_uint_32 y_offset,
 +   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
 +   png_byte blend_op));
 +
-+PNG_EXPORT(253, void, png_write_frame_tail, (png_structp png_ptr,
++PNG_EXPORT(254, void, png_write_frame_tail, (png_structp png_ptr,
 +   png_infop info_ptr));
 +#endif /* PNG_WRITE_APNG_SUPPORTED */
 +#endif /* PNG_APNG_SUPPORTED */
@@ -179,34 +128,22 @@
  /* Maintainer: Put new public prototypes here ^, in libpng.3, and project
   * defs
   */
- 
- /* The last ordinal number (this is the *last* one already used; the next
-  * one to use is one more than this.)  Maintainer, remember to add an entry to
+@@ -2658,7 +2750,11 @@
   * scripts/symbols.def as well.
   */
  #ifdef PNG_EXPORT_LAST_ORDINAL
 +#ifdef PNG_APNG_SUPPORTED
-+  PNG_EXPORT_LAST_ORDINAL(253);
++  PNG_EXPORT_LAST_ORDINAL(254);
 +#else
-   PNG_EXPORT_LAST_ORDINAL(233);
+   PNG_EXPORT_LAST_ORDINAL(234);
 +#endif /* PNG_APNG_SUPPORTED */
  #endif
  
  #ifdef __cplusplus
- }
- #endif
- 
- #endif /* PNG_VERSION_INFO_ONLY */
- /* Do not put anything past this line */
-diff -up8 pngget.c pngget.c
---- pngget.c	2012-02-18 15:31:14 -0500
-+++ pngget.c	2012-02-19 16:02:28 -0500
-@@ -1116,9 +1116,171 @@ png_get_io_chunk_type (png_const_structp
- png_const_bytep PNGAPI
- png_get_io_chunk_name (png_structp png_ptr)
- {
-    PNG_CSTRING_FROM_CHUNK(png_ptr->io_chunk_string, png_ptr->chunk_name);
-    return png_ptr->io_chunk_string;
+diff -Naru libpng-1.5.11.org/pngget.c libpng-1.5.11/pngget.c
+--- libpng-1.5.11.org/pngget.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngget.c	2012-06-15 22:17:27.000000000 +0900
+@@ -1121,4 +1121,166 @@
  }
  #endif /* ?PNG_IO_STATE_SUPPORTED */
  
@@ -373,15 +310,10 @@
 +}
 +#endif /* PNG_APNG_SUPPORTED */
  #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
-diff -up8 pnginfo.h pnginfo.h
---- pnginfo.h	2012-02-18 15:31:14 -0500
-+++ pnginfo.h	2012-02-19 16:02:28 -0500
-@@ -260,10 +260,23 @@ defined(PNG_READ_BACKGROUND_SUPPORTED)
- 
- #ifdef PNG_INFO_IMAGE_SUPPORTED
-    /* Memory has been allocated if (valid & PNG_ALLOCATED_INFO_ROWS)
-       non-zero */
-    /* Data valid if (valid & PNG_INFO_IDAT) non-zero */
+diff -Naru libpng-1.5.11.org/pnginfo.h libpng-1.5.11/pnginfo.h
+--- libpng-1.5.11.org/pnginfo.h	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pnginfo.h	2012-06-15 22:17:27.000000000 +0900
+@@ -265,5 +265,18 @@
     png_bytepp row_pointers;        /* the image bits */
  #endif
  
@@ -400,15 +332,10 @@
 +
  };
  #endif /* PNGINFO_H */
-diff -up8 pngpread.c pngpread.c
---- pngpread.c	2012-02-18 15:31:14 -0500
-+++ pngpread.c	2012-02-19 16:02:28 -0500
-@@ -233,16 +233,119 @@ png_push_read_chunk(png_structp png_ptr,
-       png_crc_read(png_ptr, chunk_tag, 4);
-       png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
-       png_check_chunk_name(png_ptr, png_ptr->chunk_name);
-       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
-    }
+diff -Naru libpng-1.5.11.org/pngpread.c libpng-1.5.11/pngpread.c
+--- libpng-1.5.11.org/pngpread.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngpread.c	2012-06-15 22:17:27.000000000 +0900
+@@ -215,6 +215,109 @@
  
     chunk_name = png_ptr->chunk_name;
  
@@ -518,17 +445,7 @@
     if (chunk_name == png_IDAT)
     {
        /* This is here above the if/else case statement below because if the
-        * unknown handling marks 'IDAT' as unknown then the IDAT handling case is
-        * completely skipped.
-        *
-        * TODO: there must be a better way of doing this.
-        */
-@@ -336,16 +439,20 @@ png_push_read_chunk(png_structp png_ptr,
-          if (!(png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT))
-             if (png_ptr->push_length == 0)
-                return;
- 
-          if (png_ptr->mode & PNG_AFTER_IDAT)
+@@ -318,6 +421,10 @@
              png_benign_error(png_ptr, "Too many IDATs found");
        }
  
@@ -539,21 +456,10 @@
        png_ptr->idat_size = png_ptr->push_length;
        png_ptr->mode |= PNG_HAVE_IDAT;
        png_ptr->process_mode = PNG_READ_IDAT_MODE;
-       png_push_have_info(png_ptr, info_ptr);
-       png_ptr->zstream.avail_out =
-           (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
-           png_ptr->iwidth) + 1;
-       png_ptr->zstream.next_out = png_ptr->row_buf;
-@@ -568,16 +675,39 @@ png_push_read_chunk(png_structp png_ptr,
-          png_push_save_buffer(png_ptr);
-          return;
-       }
- 
-       png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
-    }
+@@ -551,6 +658,28 @@
  
  #endif
-+
+ 
 +#ifdef PNG_READ_APNG_SUPPORTED
 +   else if (chunk_name == png_acTL)
 +   {
@@ -579,17 +485,7 @@
     else
     {
        if (png_ptr->push_length + 4 > png_ptr->buffer_size)
-       {
-          png_push_save_buffer(png_ptr);
-          return;
-       }
-       png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
-@@ -767,40 +897,91 @@ void /* PRIVATE */
- png_push_read_IDAT(png_structp png_ptr)
- {
-    if (!(png_ptr->mode & PNG_HAVE_CHUNK_HEADER))
-    {
-       png_byte chunk_length[4];
+@@ -758,7 +887,11 @@
        png_byte chunk_tag[4];
  
        /* TODO: this code can be commoned up with the same code in push_read */
@@ -601,12 +497,7 @@
        {
           png_push_save_buffer(png_ptr);
           return;
-       }
- 
-       png_push_fill_buffer(png_ptr, chunk_length, 4);
-       png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
-       png_reset_crc(png_ptr);
-       png_crc_read(png_ptr, chunk_tag, 4);
+@@ -771,17 +904,64 @@
        png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
        png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
  
@@ -671,17 +562,23 @@
     }
  
     if (png_ptr->idat_size && png_ptr->save_buffer_size)
-    {
-       png_size_t save_size = png_ptr->save_buffer_size;
-       png_uint_32 idat_size = png_ptr->idat_size;
- 
-       /* We want the smaller of 'idat_size' and 'current_buffer_size', but they
-@@ -1827,16 +2008,27 @@ png_set_progressive_read_fn(png_structp 
- 
-    png_ptr->info_fn = info_fn;
-    png_ptr->row_fn = row_fn;
-    png_ptr->end_fn = end_fn;
+@@ -859,6 +1039,15 @@
+    if (!(buffer_length > 0) || buffer == NULL)
+       png_error(png_ptr, "No IDAT data (internal error)");
  
++#ifdef PNG_READ_APNG_SUPPORTED
++   /* If the app is not APNG-aware, decode only the first frame */
++   if (!(png_ptr->apng_flags & PNG_APNG_APP) && png_ptr->num_frames_read > 0)
++   {
++     png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
++     return;
++   }
++#endif
++
+    /* This routine must process all the data it has been given
+     * before returning, calling the row callback as required to
+     * handle the uncompressed results.
+@@ -1304,6 +1493,18 @@
     png_set_read_fn(png_ptr, progressive_ptr, png_push_fill_buffer);
  }
  
@@ -693,47 +590,28 @@
 +{
 +   png_ptr->frame_info_fn = frame_info_fn;
 +   png_ptr->frame_end_fn = frame_end_fn;
++   png_ptr->apng_flags |= PNG_APNG_APP;
 +}
 +#endif
 +
  png_voidp PNGAPI
  png_get_progressive_ptr(png_const_structp png_ptr)
  {
-    if (png_ptr == NULL)
-       return (NULL);
- 
-    return png_ptr->io_ptr;
- }
-diff -up8 pngpriv.h pngpriv.h
---- pngpriv.h	2012-02-18 15:31:14 -0500
-+++ pngpriv.h	2012-02-19 16:02:28 -0500
-@@ -421,16 +421,20 @@ typedef PNG_CONST png_uint_16p FAR * png
- #define PNG_HAVE_cHRM               0x40
- #define PNG_HAVE_sRGB               0x80
- #define PNG_HAVE_CHUNK_HEADER      0x100
- #define PNG_WROTE_tIME             0x200
- #define PNG_WROTE_INFO_BEFORE_PLTE 0x400
- #define PNG_BACKGROUND_IS_GRAY     0x800
+diff -Naru libpng-1.5.11.org/pngpriv.h libpng-1.5.11/pngpriv.h
+--- libpng-1.5.11.org/pngpriv.h	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngpriv.h	2012-06-15 22:17:27.000000000 +0900
+@@ -467,6 +467,10 @@
  #define PNG_HAVE_PNG_SIGNATURE    0x1000
  #define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
+ #define PNG_HAVE_iCCP             0x4000
 +#ifdef PNG_APNG_SUPPORTED
-+#define PNG_HAVE_acTL             0x4000
-+#define PNG_HAVE_fcTL             0x8000
++#define PNG_HAVE_acTL             0x8000
++#define PNG_HAVE_fcTL            0x10000
 +#endif
  
  /* Flags for the transformations the PNG library does on the image data */
  #define PNG_BGR                 0x0001
- #define PNG_INTERLACE           0x0002
- #define PNG_PACK                0x0004
- #define PNG_SHIFT               0x0008
- #define PNG_SWAP_BYTES          0x0010
- #define PNG_INVERT_MONO         0x0020
-@@ -616,16 +620,25 @@ PNG_EXTERN png_fixed_point png_fixed PNG
- #define png_sPLT PNG_CHUNK(115,  80,  76,  84)
- #define png_sRGB PNG_CHUNK(115,  82,  71,  66)
- #define png_sTER PNG_CHUNK(115,  84,  69,  82)
- #define png_tEXt PNG_CHUNK(116,  69,  88, 116)
- #define png_tIME PNG_CHUNK(116,  73,  77,  69)
+@@ -662,6 +666,16 @@
  #define png_tRNS PNG_CHUNK(116,  82,  78,  83)
  #define png_zTXt PNG_CHUNK(122,  84,  88, 116)
  
@@ -744,22 +622,13 @@
 +
 +/* For png_struct.apng_flags: */
 +#define PNG_FIRST_FRAME_HIDDEN       0x0001
++#define PNG_APNG_APP                 0x0002
 +#endif
 +
  /* The following will work on (signed char*) strings, whereas the get_uint_32
   * macro will fail on top-bit-set values because of the sign extension.
   */
- #define PNG_CHUNK_FROM_STRING(s)\
-    PNG_CHUNK(0xff&(s)[0], 0xff&(s)[1], 0xff&(s)[2], 0xff&(s)[3])
- 
- /* This uses (char), not (png_byte) to avoid warnings on systems where (char) is
-  * signed and the argument is a (char[])  This macro will fail miserably on
-@@ -1299,16 +1312,55 @@ PNG_EXTERN void png_push_read_iTXt PNGAR
- 
- #ifdef PNG_MNG_FEATURES_SUPPORTED
- PNG_EXTERN void png_do_read_intrapixel PNGARG((png_row_infop row_info,
-     png_bytep row));
- PNG_EXTERN void png_do_write_intrapixel PNGARG((png_row_infop row_info,
+@@ -1343,6 +1357,45 @@
      png_bytep row));
  #endif
  
@@ -805,20 +674,10 @@
  /* Added at libpng version 1.4.0 */
  #ifdef PNG_CHECK_cHRM_SUPPORTED
  PNG_EXTERN int png_check_cHRM_fixed PNGARG((png_structp png_ptr,
-     png_fixed_point int_white_x, png_fixed_point int_white_y,
-     png_fixed_point int_red_x, png_fixed_point int_red_y, png_fixed_point
-     int_green_x, png_fixed_point int_green_y, png_fixed_point int_blue_x,
-     png_fixed_point int_blue_y));
- #endif
-diff -up8 pngread.c pngread.c
---- pngread.c	2012-02-18 15:31:14 -0500
-+++ pngread.c	2012-02-19 16:03:41 -0500
-@@ -239,16 +239,19 @@ png_read_info(png_structp png_ptr, png_i
-       {
-          if (!(png_ptr->mode & PNG_HAVE_IHDR))
-             png_error(png_ptr, "Missing IHDR before IDAT");
- 
-          else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
+diff -Naru libpng-1.5.11.org/pngread.c libpng-1.5.11/pngread.c
+--- libpng-1.5.11.org/pngread.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngread.c	2012-06-15 22:17:27.000000000 +0900
+@@ -240,6 +240,9 @@
               !(png_ptr->mode & PNG_HAVE_PLTE))
              png_error(png_ptr, "Missing PLTE before IDAT");
  
@@ -828,17 +687,7 @@
           png_ptr->idat_size = length;
           png_ptr->mode |= PNG_HAVE_IDAT;
           break;
-       }
- 
- #ifdef PNG_READ_bKGD_SUPPORTED
-       else if (chunk_name == png_bKGD)
-          png_handle_bKGD(png_ptr, info_ptr, length);
-@@ -329,22 +332,100 @@ png_read_info(png_structp png_ptr, png_i
-          png_handle_zTXt(png_ptr, info_ptr, length);
- #endif
- 
- #ifdef PNG_READ_iTXt_SUPPORTED
-       else if (chunk_name == png_iTXt)
+@@ -330,12 +333,90 @@
           png_handle_iTXt(png_ptr, info_ptr, length);
  #endif
  
@@ -929,17 +778,7 @@
  /* Optional call to update the users info_ptr structure */
  void PNGAPI
  png_read_update_info(png_structp png_ptr, png_infop info_ptr)
- {
-    png_debug(1, "in png_read_update_info");
- 
-    if (png_ptr == NULL)
-       return;
-@@ -536,24 +617,57 @@ png_read_row(png_structp png_ptr, png_by
-    png_ptr->zstream.avail_out =
-        (uInt)(PNG_ROWBYTES(png_ptr->pixel_depth,
-        png_ptr->iwidth) + 1);
- 
-    do
+@@ -537,6 +618,38 @@
     {
        if (!(png_ptr->zstream.avail_in))
        {
@@ -978,8 +817,7 @@
           while (!png_ptr->idat_size)
           {
              png_crc_finish(png_ptr, 0);
- 
-             png_ptr->idat_size = png_read_chunk_header(png_ptr);
+@@ -545,6 +658,7 @@
              if (png_ptr->chunk_name != png_IDAT)
                 png_error(png_ptr, "Not enough image data");
           }
@@ -987,17 +825,7 @@
           png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
           png_ptr->zstream.next_in = png_ptr->zbuf;
           if (png_ptr->zbuf_size > png_ptr->idat_size)
-             png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
-          png_crc_read(png_ptr, png_ptr->zbuf,
-              (png_size_t)png_ptr->zstream.avail_in);
-          png_ptr->idat_size -= png_ptr->zstream.avail_in;
-       }
-@@ -562,16 +676,19 @@ png_read_row(png_structp png_ptr, png_by
- 
-       if (ret == Z_STREAM_END)
-       {
-          if (png_ptr->zstream.avail_out || png_ptr->zstream.avail_in ||
-             png_ptr->idat_size)
+@@ -563,6 +677,9 @@
              png_benign_error(png_ptr, "Extra compressed data");
           png_ptr->mode |= PNG_AFTER_IDAT;
           png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
@@ -1007,46 +835,10 @@
           break;
        }
  
-       if (ret != Z_OK)
-          png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
-              "Decompression error");
- 
-    } while (png_ptr->zstream.avail_out);
-@@ -924,16 +1041,25 @@ png_read_end(png_structp png_ptr, png_in
-          png_handle_zTXt(png_ptr, info_ptr, length);
- #endif
- 
- #ifdef PNG_READ_iTXt_SUPPORTED
-       else if (chunk_name == png_iTXt)
-          png_handle_iTXt(png_ptr, info_ptr, length);
- #endif
- 
-+#ifdef PNG_READ_APNG_SUPPORTED
-+      else if (chunk_name == png_acTL)
-+         png_handle_acTL(png_ptr, info_ptr, length);
-+      else if (chunk_name == png_fcTL)
-+         png_handle_fcTL(png_ptr, info_ptr, length);
-+      else if (chunk_name == png_fdAT)
-+         png_handle_fdAT(png_ptr, info_ptr, length);
-+#endif
-+
-       else
-          png_handle_unknown(png_ptr, info_ptr, length);
-    } while (!(png_ptr->mode & PNG_HAVE_IEND));
- }
- #endif /* PNG_SEQUENTIAL_READ_SUPPORTED */
- 
- /* Free all memory used by the read */
- void PNGAPI
-diff -up8 pngrutil.c pngrutil.c
---- pngrutil.c	2012-02-18 15:31:14 -0500
-+++ pngrutil.c	2012-02-19 16:02:28 -0500
-@@ -544,16 +544,21 @@ png_handle_IHDR(png_structp png_ptr, png
-    width = png_get_uint_31(png_ptr, buf);
-    height = png_get_uint_31(png_ptr, buf + 4);
-    bit_depth = buf[8];
-    color_type = buf[9];
-    compression_type = buf[10];
+diff -Naru libpng-1.5.11.org/pngrutil.c libpng-1.5.11/pngrutil.c
+--- libpng-1.5.11.org/pngrutil.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngrutil.c	2012-06-15 22:17:27.000000000 +0900
+@@ -547,6 +547,11 @@
     filter_type = buf[11];
     interlace_type = buf[12];
  
@@ -1058,17 +850,7 @@
     /* Set internal variables */
     png_ptr->width = width;
     png_ptr->height = height;
-    png_ptr->bit_depth = (png_byte)bit_depth;
-    png_ptr->interlaced = (png_byte)interlace_type;
-    png_ptr->color_type = (png_byte)color_type;
- #ifdef PNG_MNG_FEATURES_SUPPORTED
-    png_ptr->filter_type = (png_byte)filter_type;
-@@ -2608,16 +2613,189 @@ png_handle_iTXt(png_structp png_ptr, png
-    png_free(png_ptr, png_ptr->chunkdata);
-    png_ptr->chunkdata = NULL;
- 
-    if (ret)
-       png_error(png_ptr, "Insufficient memory to store iTXt chunk");
+@@ -2614,6 +2619,179 @@
  }
  #endif
  
@@ -1248,17 +1030,7 @@
  /* This function is called when we haven't found a handler for a
   * chunk.  If there isn't a problem with the chunk itself (ie bad
   * chunk name, CRC, or a critical chunk), the chunk is silently ignored
-  * -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which
-  * case it will be saved away to be written out later.
-  */
- void /* PRIVATE */
- png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-@@ -4150,9 +4328,86 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
-    png_debug1(3, "iwidth = %u,", png_ptr->iwidth);
-    png_debug1(3, "num_rows = %u,", png_ptr->num_rows);
-    png_debug1(3, "rowbytes = %lu,", (unsigned long)png_ptr->rowbytes);
-    png_debug1(3, "irowbytes = %lu",
-        (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);
+@@ -4156,4 +4334,81 @@
  
     png_ptr->flags |= PNG_FLAG_ROW_INIT;
  }
@@ -1340,15 +1112,10 @@
 +#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 +#endif /* PNG_READ_APNG_SUPPORTED */
  #endif /* PNG_READ_SUPPORTED */
-diff -up8 pngset.c pngset.c
---- pngset.c	2012-02-18 15:31:14 -0500
-+++ pngset.c	2012-02-19 16:02:28 -0500
-@@ -257,16 +257,21 @@ png_set_IHDR(png_structp png_ptr, png_in
-        (PNG_UINT_32_MAX >> 3)      /* 8-byte RRGGBBAA pixels */
-        - 48       /* bigrowbuf hack */
-        - 1        /* filter byte */
-        - 7*8      /* rounding of width to multiple of 8 pixels */
-        - 8)       /* extra max_pixel_depth pad */
+diff -Naru libpng-1.5.11.org/pngset.c libpng-1.5.11/pngset.c
+--- libpng-1.5.11.org/pngset.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngset.c	2012-06-15 22:17:27.000000000 +0900
+@@ -262,6 +262,11 @@
        info_ptr->rowbytes = 0;
     else
        info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
@@ -1360,17 +1127,7 @@
  }
  
  #ifdef PNG_oFFs_SUPPORTED
- void PNGAPI
- png_set_oFFs(png_structp png_ptr, png_infop info_ptr,
-     png_int_32 offset_x, png_int_32 offset_y, int unit_type)
- {
-    png_debug1(1, "in %s storage function", "oFFs");
-@@ -1008,16 +1013,157 @@ png_set_sPLT(png_structp png_ptr,
- 
-    info_ptr->splt_palettes = np;
-    info_ptr->splt_palettes_num += nentries;
-    info_ptr->valid |= PNG_INFO_sPLT;
-    info_ptr->free_me |= PNG_FREE_SPLT;
+@@ -1022,6 +1027,147 @@
  }
  #endif /* PNG_sPLT_SUPPORTED */
  
@@ -1518,20 +1275,10 @@
  #ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
  void PNGAPI
  png_set_unknown_chunks(png_structp png_ptr,
-    png_infop info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)
- {
-    png_unknown_chunkp np;
-    int i;
- 
-diff -up8 pngstruct.h pngstruct.h
---- pngstruct.h	2012-02-18 15:31:14 -0500
-+++ pngstruct.h	2012-02-19 16:02:28 -0500
-@@ -288,16 +288,37 @@ struct png_struct_def
-    png_uint_32 mng_features_permitted;
- #endif
- 
- /* New member added in libpng-1.0.9, ifdef'ed out in 1.0.12, enabled in 1.2.0 */
- #ifdef PNG_MNG_FEATURES_SUPPORTED
+diff -Naru libpng-1.5.11.org/pngstruct.h libpng-1.5.11/pngstruct.h
+--- libpng-1.5.11.org/pngstruct.h	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngstruct.h	2012-06-15 22:17:27.000000000 +0900
+@@ -293,6 +293,27 @@
     png_byte filter_type;
  #endif
  
@@ -1559,20 +1306,135 @@
  /* New members added in libpng-1.2.0 */
  
  /* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */
- #ifdef PNG_USER_MEM_SUPPORTED
-    png_voidp mem_ptr;             /* user supplied struct for mem functions */
-    png_malloc_ptr malloc_fn;      /* function for allocating memory */
-    png_free_ptr free_fn;          /* function for freeing memory */
+diff -Naru libpng-1.5.11.org/pngtest.c libpng-1.5.11/pngtest.c
+--- libpng-1.5.11.org/pngtest.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngtest.c	2012-06-15 22:17:27.000000000 +0900
+@@ -785,6 +785,10 @@
+    jmp_buf tmp_jmpbuf;
+ #endif
  #endif
-diff -up8 pngwrite.c pngwrite.c
---- pngwrite.c	2012-02-18 15:31:14 -0500
-+++ pngwrite.c	2012-02-19 16:02:28 -0500
-@@ -53,16 +53,20 @@ png_write_info_before_PLTE(png_structp p
- #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-        info_ptr->interlace_type);
- #else
-        0);
++#ifdef PNG_APNG_SUPPORTED
++   png_uint_32 num_frames;
++   png_uint_32 num_plays;
++#endif
+ 
+    char inbuf[256], outbuf[256];
+ 
+@@ -1215,6 +1219,20 @@
+       }
+    }
+ #endif
++#ifdef PNG_APNG_SUPPORTED
++   if (png_get_valid(read_ptr, read_info_ptr, PNG_INFO_acTL))
++   {
++      if (png_get_acTL(read_ptr, read_info_ptr, &num_frames, &num_plays))
++      {
++         png_byte is_hidden;
++         pngtest_debug2("Handling acTL chunks (frames %ld, plays %ld)",
++                    num_frames, num_plays);
++         png_set_acTL(write_ptr, write_info_ptr, num_frames, num_plays);
++         is_hidden = png_get_first_frame_is_hidden(read_ptr, read_info_ptr);
++         png_set_first_frame_is_hidden(write_ptr, write_info_ptr, is_hidden);
++      }
++   }
++#endif
+ #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
+    {
+       png_unknown_chunkp unknowns;
+@@ -1307,6 +1325,89 @@
+    t_misc += (t_stop - t_start);
+    t_start = t_stop;
  #endif
++#ifdef PNG_APNG_SUPPORTED
++   if (png_get_valid(read_ptr, read_info_ptr, PNG_INFO_acTL))
++   {
++      png_uint_32 frame;
++      for (frame = 0; frame < num_frames; frame++)
++      {
++         png_uint_32 frame_width;
++         png_uint_32 frame_height;
++         png_uint_32 x_offset;
++         png_uint_32 y_offset;
++         png_uint_16 delay_num;
++         png_uint_16 delay_den;
++         png_byte dispose_op;
++         png_byte blend_op;
++         png_read_frame_head(read_ptr, read_info_ptr);
++         if (png_get_valid(read_ptr, read_info_ptr, PNG_INFO_fcTL))
++         {
++            png_get_next_frame_fcTL(read_ptr, read_info_ptr,
++                                    &frame_width, &frame_height,
++                                    &x_offset, &y_offset,
++                                    &delay_num, &delay_den,
++                                    &dispose_op, &blend_op);
++         }
++         else
++         {
++            frame_width = width;
++            frame_height = height;
++            x_offset = 0;
++            y_offset = 0;
++            delay_num = 1;
++            delay_den = 1;
++            dispose_op = PNG_DISPOSE_OP_NONE;
++            blend_op = PNG_BLEND_OP_SOURCE;
++         }
++#ifdef PNG_WRITE_APNG_SUPPORTED
++         png_write_frame_head(write_ptr, write_info_ptr, (png_bytepp)&row_buf,
++                              frame_width, frame_height,
++                              x_offset, y_offset,
++                              delay_num, delay_den,
++                              dispose_op, blend_op);
++#endif
++         for (pass = 0; pass < num_pass; pass++)
++         {
++            pngtest_debug1("Writing row data for pass %d", pass);
++            for (y = 0; y < frame_height; y++)
++            {
++#ifndef SINGLE_ROWBUF_ALLOC
++               pngtest_debug2("Allocating row buffer (pass %d, y = %ld)...", pass, y);
++               row_buf = (png_bytep)png_malloc(read_ptr,
++                  png_get_rowbytes(read_ptr, read_info_ptr));
++               pngtest_debug2("0x%08lx (%ld bytes)", (unsigned long)row_buf,
++                  png_get_rowbytes(read_ptr, read_info_ptr));
++#endif /* !SINGLE_ROWBUF_ALLOC */
++               png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);
++
++#ifdef PNG_WRITE_SUPPORTED
++#ifdef PNGTEST_TIMING
++               t_stop = (float)clock();
++               t_decode += (t_stop - t_start);
++               t_start = t_stop;
++#endif
++               png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
++#ifdef PNGTEST_TIMING
++               t_stop = (float)clock();
++               t_encode += (t_stop - t_start);
++               t_start = t_stop;
++#endif
++#endif /* PNG_WRITE_SUPPORTED */
++
++#ifndef SINGLE_ROWBUF_ALLOC
++               pngtest_debug2("Freeing row buffer (pass %d, y = %ld)", pass, y);
++               png_free(read_ptr, row_buf);
++               row_buf = NULL;
++#endif /* !SINGLE_ROWBUF_ALLOC */
++            }
++         }
++#ifdef PNG_WRITE_APNG_SUPPORTED
++         png_write_frame_tail(write_ptr, write_info_ptr);
++#endif
++      }
++   }
++   else
++#endif
+    for (pass = 0; pass < num_pass; pass++)
+    {
+       pngtest_debug1("Writing row data for pass %d", pass);
+diff -Naru libpng-1.5.11.org/pngwrite.c libpng-1.5.11/pngwrite.c
+--- libpng-1.5.11.org/pngwrite.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngwrite.c	2012-06-15 22:17:27.000000000 +0900
+@@ -58,6 +58,10 @@
     /* The rest of these check to see if the valid field has the appropriate
      * flag set, and if it does, writes the chunk.
      */
@@ -1583,19 +1445,9 @@
  #ifdef PNG_WRITE_gAMA_SUPPORTED
     if (info_ptr->valid & PNG_INFO_gAMA)
        png_write_gAMA_fixed(png_ptr, info_ptr->gamma);
+@@ -310,6 +314,11 @@
+       png_benign_error(png_ptr, "Wrote palette index exceeding num_palette");
  #endif
- #ifdef PNG_WRITE_sRGB_SUPPORTED
-    if (info_ptr->valid & PNG_INFO_sRGB)
-       png_write_sRGB(png_ptr, (int)info_ptr->srgb_intent);
- #endif
-@@ -300,16 +304,21 @@ png_write_end(png_structp png_ptr, png_i
-    png_debug(1, "in png_write_end");
- 
-    if (png_ptr == NULL)
-       return;
- 
-    if (!(png_ptr->mode & PNG_HAVE_IDAT))
-       png_error(png_ptr, "No IDATs written into file");
  
 +#ifdef PNG_WRITE_APNG_SUPPORTED
 +   if (png_ptr->num_frames_written != png_ptr->num_frames_to_write)
@@ -1605,17 +1457,7 @@
     /* See if user wants us to write information chunks */
     if (info_ptr != NULL)
     {
- #ifdef PNG_WRITE_TEXT_SUPPORTED
-       int i; /* local index variable */
- #endif
- #ifdef PNG_WRITE_tIME_SUPPORTED
-       /* Check to see if user has supplied a time chunk */
-@@ -1647,9 +1656,47 @@ png_write_png(png_structp png_ptr, png_i
- 
-    /* It is REQUIRED to call this to finish writing the rest of the file */
-    png_write_end(png_ptr, info_ptr);
- 
-    PNG_UNUSED(transforms)   /* Quiet compiler warnings */
+@@ -1665,4 +1674,42 @@
     PNG_UNUSED(params)
  }
  #endif
@@ -1658,15 +1500,10 @@
 +}
 +#endif /* PNG_WRITE_APNG_SUPPORTED */
  #endif /* PNG_WRITE_SUPPORTED */
-diff -up8 pngwutil.c pngwutil.c
---- pngwutil.c	2012-02-18 15:31:14 -0500
-+++ pngwutil.c	2012-02-19 16:02:28 -0500
-@@ -815,16 +815,21 @@ png_write_IHDR(png_structp png_ptr, png_
-    buf[9] = (png_byte)color_type;
-    buf[10] = (png_byte)compression_type;
-    buf[11] = (png_byte)filter_type;
-    buf[12] = (png_byte)interlace_type;
- 
+diff -Naru libpng-1.5.11.org/pngwutil.c libpng-1.5.11/pngwutil.c
+--- libpng-1.5.11.org/pngwutil.c	2012-06-15 22:17:27.000000000 +0900
++++ libpng-1.5.11/pngwutil.c	2012-06-15 22:17:27.000000000 +0900
+@@ -821,6 +821,11 @@
     /* Write the chunk */
     png_write_complete_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
  
@@ -1678,17 +1515,7 @@
     /* Initialize zlib with PNG info */
     png_ptr->zstream.zalloc = png_zalloc;
     png_ptr->zstream.zfree = png_zfree;
-    png_ptr->zstream.opaque = (voidpf)png_ptr;
- 
-    if (!(png_ptr->do_filter))
-    {
-       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-@@ -1029,17 +1034,38 @@ png_write_IDAT(png_structp png_ptr, png_
-       }
- 
-       else
-          png_error(png_ptr,
-              "Invalid zlib compression method or flags in IDAT");
+@@ -1035,7 +1040,28 @@
     }
  #endif /* PNG_WRITE_OPTIMIZE_CMF_SUPPORTED */
  
@@ -1717,17 +1544,7 @@
     png_ptr->mode |= PNG_HAVE_IDAT;
  
     /* Prior to 1.5.4 this code was replicated in every caller (except at the
-     * end, where it isn't technically necessary).  Since this function has
-     * flushed the data we can safely reset the zlib output buffer here.
-     */
-    png_ptr->zstream.next_out = png_ptr->zbuf;
-    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-@@ -1993,16 +2019,74 @@ png_write_tIME(png_structp png_ptr, png_
-    buf[4] = mod_time->hour;
-    buf[5] = mod_time->minute;
-    buf[6] = mod_time->second;
- 
-    png_write_complete_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
+@@ -1997,6 +2023,64 @@
  }
  #endif
  
@@ -1792,17 +1609,7 @@
  /* Initializes the row writing capability of libpng */
  void /* PRIVATE */
  png_write_start_row(png_structp png_ptr)
- {
- #ifdef PNG_WRITE_INTERLACING_SUPPORTED
-    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
- 
-    /* Start of interlace block */
-@@ -3172,9 +3256,44 @@ png_write_filtered_row(png_structp png_p
- 
-    if (png_ptr->flush_dist > 0 &&
-        png_ptr->flush_rows >= png_ptr->flush_dist)
-    {
-       png_write_flush(png_ptr);
+@@ -3176,4 +3260,39 @@
     }
  #endif
  }
diff -urN a/media/libpng/libpng.txt b/media/libpng/libpng.txt
--- a/media/libpng/libpng.txt	2012-07-11 03:33:19 +0800
+++ b/media/libpng/libpng.txt	2012-07-13 12:40:57 +0800
@@ -1,4628 +1,4657 @@
-libpng-manual.txt - A description on how to use and modify libpng
-
- libpng version 1.5.9 - February 18, 2012
- Updated and distributed by Glenn Randers-Pehrson
- <glennrp at users.sourceforge.net>
- Copyright (c) 1998-2011 Glenn Randers-Pehrson
-
- This document is released under the libpng license.
- For conditions of distribution and use, see the disclaimer
- and license in png.h
-
- Based on:
-
- libpng versions 0.97, January 1998, through 1.5.9 - February 18, 2012
- Updated and distributed by Glenn Randers-Pehrson
- Copyright (c) 1998-2011 Glenn Randers-Pehrson
-
- libpng 1.0 beta 6  version 0.96 May 28, 1997
- Updated and distributed by Andreas Dilger
- Copyright (c) 1996, 1997 Andreas Dilger
-
- libpng 1.0 beta 2 - version 0.88  January 26, 1996
- For conditions of distribution and use, see copyright
- notice in png.h. Copyright (c) 1995, 1996 Guy Eric
- Schalnat, Group 42, Inc.
-
- Updated/rewritten per request in the libpng FAQ
- Copyright (c) 1995, 1996 Frank J. T. Wojcik
- December 18, 1995 & January 20, 1996
-
-I. Introduction
-
-This file describes how to use and modify the PNG reference library
-(known as libpng) for your own use.  There are five sections to this
-file: introduction, structures, reading, writing, and modification and
-configuration notes for various special platforms.  In addition to this
-file, example.c is a good starting point for using the library, as
-it is heavily commented and should include everything most people
-will need.  We assume that libpng is already installed; see the
-INSTALL file for instructions on how to install libpng.
-
-For examples of libpng usage, see the files "example.c", "pngtest.c",
-and the files in the "contrib" directory, all of which are included in
-the libpng distribution.
-
-Libpng was written as a companion to the PNG specification, as a way
-of reducing the amount of time and effort it takes to support the PNG
-file format in application programs.
-
-The PNG specification (second edition), November 2003, is available as
-a W3C Recommendation and as an ISO Standard (ISO/IEC 15948:2003 (E)) at
-<http://www.w3.org/TR/2003/REC-PNG-20031110/
-The W3C and ISO documents have identical technical content.
-
-The PNG-1.2 specification is available at
-<http://www.libpng.org/pub/png/documents/>.  It is technically equivalent
-to the PNG specification (second edition) but has some additional material.
-
-The PNG-1.0 specification is available
-as RFC 2083 <http://www.libpng.org/pub/png/documents/> and as a
-W3C Recommendation <http://www.w3.org/TR/REC.png.html>.
-
-Some additional chunks are described in the special-purpose public chunks
-documents at <http://www.libpng.org/pub/png/documents/>.
-
-Other information
-about PNG, and the latest version of libpng, can be found at the PNG home
-page, <http://www.libpng.org/pub/png/>.
-
-Most users will not have to modify the library significantly; advanced
-users may want to modify it more.  All attempts were made to make it as
-complete as possible, while keeping the code easy to understand.
-Currently, this library only supports C.  Support for other languages
-is being considered.
-
-Libpng has been designed to handle multiple sessions at one time,
-to be easily modifiable, to be portable to the vast majority of
-machines (ANSI, K&R, 16-, 32-, and 64-bit) available, and to be easy
-to use.  The ultimate goal of libpng is to promote the acceptance of
-the PNG file format in whatever way possible.  While there is still
-work to be done (see the TODO file), libpng should cover the
-majority of the needs of its users.
-
-Libpng uses zlib for its compression and decompression of PNG files.
-Further information about zlib, and the latest version of zlib, can
-be found at the zlib home page, <http://www.info-zip.org/pub/infozip/zlib/>.
-The zlib compression utility is a general purpose utility that is
-useful for more than PNG files, and can be used without libpng.
-See the documentation delivered with zlib for more details.
-You can usually find the source files for the zlib utility wherever you
-find the libpng source files.
-
-Libpng is thread safe, provided the threads are using different
-instances of the structures.  Each thread should have its own
-png_struct and png_info instances, and thus its own image.
-Libpng does not protect itself against two threads using the
-same instance of a structure.
-
-II. Structures
-
-There are two main structures that are important to libpng, png_struct
-and png_info.  Both are internal structures that are no longer exposed
-in the libpng interface (as of libpng 1.5.0).
-
-The png_info structure is designed to provide information about the
-PNG file.  At one time, the fields of png_info were intended to be
-directly accessible to the user.  However, this tended to cause problems
-with applications using dynamically loaded libraries, and as a result
-a set of interface functions for png_info (the png_get_*() and png_set_*()
-functions) was developed, and direct access to the png_info fields was
-deprecated..
-
-The png_struct structure is the object used by the library to decode a
-single image.  As of 1.5.0 this structure is also not exposed.
-
-Almost all libpng APIs require a pointer to a png_struct as the first argument.
-Many (in particular the png_set and png_get APIs) also require a pointer
-to png_info as the second argument.  Some application visible macros
-defined in png.h designed for basic data access (reading and writing
-integers in the PNG format) don't take a png_info pointer, but it's almost
-always safe to assume that a (png_struct*) has to be passed to call an API
-function.
-
-You can have more than one png_info structure associated with an image,
-as illustrated in pngtest.c, one for information valid prior to the
-IDAT chunks and another (called "end_info" below) for things after them.
-
-The png.h header file is an invaluable reference for programming with libpng.
-And while I'm on the topic, make sure you include the libpng header file:
-
-#include <png.h>
-
-and also (as of libpng-1.5.0) the zlib header file, if you need it:
-
-#include <zlib.h>
-
-Types
-
-The png.h header file defines a number of integral types used by the
-APIs.  Most of these are fairly obvious; for example types corresponding
-to integers of particular sizes and types for passing color values.
-
-One exception is how non-integral numbers are handled.  For application
-convenience most APIs that take such numbers have C (double) arguments,
-however internally PNG, and libpng, use 32 bit signed integers and encode
-the value by multiplying by 100,000.  As of libpng 1.5.0 a convenience
-macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
-which is simply (png_int_32).
-
-All APIs that take (double) arguments also have a matching API that
-takes the corresponding fixed point integer arguments.  The fixed point
-API has the same name as the floating point one with "_fixed" appended.
-The actual range of values permitted in the APIs is frequently less than
-the full range of (png_fixed_point) (-21474 to +21474).  When APIs require
-a non-negative argument the type is recorded as png_uint_32 above.  Consult
-the header file and the text below for more information.
-
-Special care must be take with sCAL chunk handling because the chunk itself
-uses non-integral values encoded as strings containing decimal floating point
-numbers.  See the comments in the header file.
-
-Configuration
-
-The main header file function declarations are frequently protected by C
-preprocessing directives of the form:
-
-    #ifdef PNG_feature_SUPPORTED
-    declare-function
-    #endif
-    ...
-    #ifdef PNG_feature_SUPPORTED
-    use-function
-    #endif
-
-The library can be built without support for these APIs, although a
-standard build will have all implemented APIs.  Application programs
-should check the feature macros before using an API for maximum
-portability.  From libpng 1.5.0 the feature macros set during the build
-of libpng are recorded in the header file "pnglibconf.h" and this file
-is always included by png.h.
-
-If you don't need to change the library configuration from the default, skip to
-the next section ("Reading").
-
-Notice that some of the makefiles in the 'scripts' directory and (in 1.5.0) all
-of the build project files in the 'projects' directory simply copy
-scripts/pnglibconf.h.prebuilt to pnglibconf.h.  This means that these build
-systems do not permit easy auto-configuration of the library - they only
-support the default configuration.
-
-The easiest way to make minor changes to the libpng configuration when
-auto-configuration is supported is to add definitions to the command line
-using (typically) CPPFLAGS.  For example:
-
-CPPFLAGS=-DPNG_NO_FLOATING_ARITHMETIC
-
-will change the internal libpng math implementation for gamma correction and
-other arithmetic calculations to fixed point, avoiding the need for fast
-floating point support.  The result can be seen in the generated pnglibconf.h -
-make sure it contains the changed feature macro setting.
-
-If you need to make more extensive configuration changes - more than one or two
-feature macro settings - you can either add -DPNG_USER_CONFIG to the build
-command line and put a list of feature macro settings in pngusr.h or you can set
-DFA_XTRA (a makefile variable) to a file containing the same information in the
-form of 'option' settings.
-
-A. Changing pnglibconf.h
-
-A variety of methods exist to build libpng.  Not all of these support
-reconfiguration of pnglibconf.h.  To reconfigure pnglibconf.h it must either be
-rebuilt from scripts/pnglibconf.dfa using awk or it must be edited by hand.
-
-Hand editing is achieved by copying scripts/pnglibconf.h.prebuilt to
-pnglibconf.h and changing the lines defining the supported features, paying
-very close attention to the 'option' information in scripts/pnglibconf.dfa
-that describes those features and their requirements.  This is easy to get
-wrong.
-
-B. Configuration using DFA_XTRA
-
-Rebuilding from pnglibconf.dfa is easy if a functioning 'awk', or a later
-variant such as 'nawk' or 'gawk', is available.  The configure build will
-automatically find an appropriate awk and build pnglibconf.h.
-The scripts/pnglibconf.mak file contains a set of make rules for doing the
-same thing if configure is not used, and many of the makefiles in the scripts
-directory use this approach.
-
-When rebuilding simply write a new file containing changed options and set
-DFA_XTRA to the name of this file.  This causes the build to append the new file
-to the end of scripts/pnglibconf.dfa.  The pngusr.dfa file should contain lines
-of the following forms:
-
-everything = off
-
-This turns all optional features off.  Include it at the start of pngusr.dfa to
-make it easier to build a minimal configuration.  You will need to turn at least
-some features on afterward to enable either reading or writing code, or both.
-
-option feature on
-option feature off
-
-Enable or disable a single feature.  This will automatically enable other
-features required by a feature that is turned on or disable other features that
-require a feature which is turned off.  Conflicting settings will cause an error
-message to be emitted by awk.
-
-setting feature default value
-
-Changes the default value of setting 'feature' to 'value'.  There are a small
-number of settings listed at the top of pnglibconf.h, they are documented in the
-source code.  Most of these values have performance implications for the library
-but most of them have no visible effect on the API.  Some can also be overridden
-from the API.
-
-This method of building a customized pnglibconf.h is illustrated in
-contrib/pngminim/*.  See the "$(PNGCONF):" target in the makefile and
-pngusr.dfa in these directories.
-
-C. Configuration using PNG_USR_CONFIG
-
-If -DPNG_USR_CONFIG is added to the CFLAGS when pnglibconf.h is built the file
-pngusr.h will automatically be included before the options in
-scripts/pnglibconf.dfa are processed.  Your pngusr.h file should contain only
-macro definitions turning features on or off or setting settings.
-
-Apart from the global setting "everything = off" all the options listed above
-can be set using macros in pngusr.h:
-
-#define PNG_feature_SUPPORTED
-
-is equivalent to:
-
-option feature on
-
-#define PNG_NO_feature
-
-is equivalent to:
-
-option feature off
-
-#define PNG_feature value
-
-is equivalent to:
-
-setting feature default value
-
-Notice that in both cases, pngusr.dfa and pngusr.h, the contents of the
-pngusr file you supply override the contents of scripts/pnglibconf.dfa
-
-If confusing or incomprehensible behavior results it is possible to
-examine the intermediate file pnglibconf.dfn to find the full set of
-dependency information for each setting and option.  Simply locate the
-feature in the file and read the C comments that precede it.
-
-This method is also illustrated in the contrib/pngminim/* makefiles and
-pngusr.h.
-
-III. Reading
-
-We'll now walk you through the possible functions to call when reading
-in a PNG file sequentially, briefly explaining the syntax and purpose
-of each one.  See example.c and png.h for more detail.  While
-progressive reading is covered in the next section, you will still
-need some of the functions discussed in this section to read a PNG
-file.
-
-Setup
-
-You will want to do the I/O initialization(*) before you get into libpng,
-so if it doesn't work, you don't have much to undo.  Of course, you
-will also want to insure that you are, in fact, dealing with a PNG
-file.  Libpng provides a simple check to see if a file is a PNG file.
-To use it, pass in the first 1 to 8 bytes of the file to the function
-png_sig_cmp(), and it will return 0 (false) if the bytes match the
-corresponding bytes of the PNG signature, or nonzero (true) otherwise.
-Of course, the more bytes you pass in, the greater the accuracy of the
-prediction.
-
-If you are intending to keep the file pointer open for use in libpng,
-you must ensure you don't read more than 8 bytes from the beginning
-of the file, and you also have to make a call to png_set_sig_bytes_read()
-with the number of bytes you read from the beginning.  Libpng will
-then only check the bytes (if any) that your program didn't read.
-
-(*): If you are not using the standard I/O functions, you will need
-to replace them with custom functions.  See the discussion under
-Customizing libpng.
-
-
-    FILE *fp = fopen(file_name, "rb");
-    if (!fp)
-    {
-       return (ERROR);
-    }
-
-    fread(header, 1, number, fp);
-    is_png = !png_sig_cmp(header, 0, number);
-
-    if (!is_png)
-    {
-       return (NOT_PNG);
-    }
-
-
-Next, png_struct and png_info need to be allocated and initialized.  In
-order to ensure that the size of these structures is correct even with a
-dynamically linked libpng, there are functions to initialize and
-allocate the structures.  We also pass the library version, optional
-pointers to error handling functions, and a pointer to a data struct for
-use by the error functions, if necessary (the pointer and functions can
-be NULL if the default error handlers are to be used).  See the section
-on Changes to Libpng below regarding the old initialization functions.
-The structure allocation functions quietly return NULL if they fail to
-create the structure, so your application should check for that.
-
-    png_structp png_ptr = png_create_read_struct
-        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn);
-
-    if (!png_ptr)
-       return (ERROR);
-
-    png_infop info_ptr = png_create_info_struct(png_ptr);
-
-    if (!info_ptr)
-    {
-       png_destroy_read_struct(&png_ptr,
-           (png_infopp)NULL, (png_infopp)NULL);
-       return (ERROR);
-    }
-
-If you want to use your own memory allocation routines,
-use a libpng that was built with PNG_USER_MEM_SUPPORTED defined, and use
-png_create_read_struct_2() instead of png_create_read_struct():
-
-    png_structp png_ptr = png_create_read_struct_2
-        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn, (png_voidp)
-        user_mem_ptr, user_malloc_fn, user_free_fn);
-
-The error handling routines passed to png_create_read_struct()
-and the memory alloc/free routines passed to png_create_struct_2()
-are only necessary if you are not using the libpng supplied error
-handling and memory alloc/free functions.
-
-When libpng encounters an error, it expects to longjmp back
-to your routine.  Therefore, you will need to call setjmp and pass
-your png_jmpbuf(png_ptr).  If you read the file from different
-routines, you will need to update the longjmp buffer every time you enter
-a new routine that will call a png_*() function.
-
-See your documentation of setjmp/longjmp for your compiler for more
-information on setjmp/longjmp.  See the discussion on libpng error
-handling in the Customizing Libpng section below for more information
-on the libpng error handling.  If an error occurs, and libpng longjmp's
-back to your setjmp, you will want to call png_destroy_read_struct() to
-free any memory.
-
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-           &end_info);
-       fclose(fp);
-       return (ERROR);
-    }
-
-Pass (png_infopp)NULL instead of &end_info if you didn't create
-an end_info structure.
-
-If you would rather avoid the complexity of setjmp/longjmp issues,
-you can compile libpng with PNG_NO_SETJMP, in which case
-errors will result in a call to PNG_ABORT() which defaults to abort().
-
-You can #define PNG_ABORT() to a function that does something
-more useful than abort(), as long as your function does not
-return.
-
-Now you need to set up the input code.  The default for libpng is to
-use the C function fread().  If you use this, you will need to pass a
-valid FILE * in the function png_init_io().  Be sure that the file is
-opened in binary mode.  If you wish to handle reading data in another
-way, you need not call the png_init_io() function, but you must then
-implement the libpng I/O methods discussed in the Customizing Libpng
-section below.
-
-    png_init_io(png_ptr, fp);
-
-If you had previously opened the file and read any of the signature from
-the beginning in order to see if this was a PNG file, you need to let
-libpng know that there are some bytes missing from the start of the file.
-
-    png_set_sig_bytes(png_ptr, number);
-
-You can change the zlib compression buffer size to be used while
-reading compressed data with
-
-    png_set_compression_buffer_size(png_ptr, buffer_size);
-
-where the default size is 8192 bytes.  Note that the buffer size
-is changed immediately and the buffer is reallocated immediately,
-instead of setting a flag to be acted upon later.
-
-If you want CRC errors to be handled in a different manner than
-the default, use
-
-    png_set_crc_action(png_ptr, crit_action, ancil_action);
-
-The values for png_set_crc_action() say how libpng is to handle CRC errors in
-ancillary and critical chunks, and whether to use the data contained
-therein.  Note that it is impossible to "discard" data in a critical
-chunk.
-
-Choices for (int) crit_action are
-   PNG_CRC_DEFAULT      0  error/quit
-   PNG_CRC_ERROR_QUIT   1  error/quit
-   PNG_CRC_WARN_USE     3  warn/use data
-   PNG_CRC_QUIET_USE    4  quiet/use data
-   PNG_CRC_NO_CHANGE    5  use the current value
-
-Choices for (int) ancil_action are
-   PNG_CRC_DEFAULT      0  error/quit
-   PNG_CRC_ERROR_QUIT   1  error/quit
-   PNG_CRC_WARN_DISCARD 2  warn/discard data
-   PNG_CRC_WARN_USE     3  warn/use data
-   PNG_CRC_QUIET_USE    4  quiet/use data
-   PNG_CRC_NO_CHANGE    5  use the current value
-
-Setting up callback code
-
-You can set up a callback function to handle any unknown chunks in the
-input stream. You must supply the function
-
-    read_chunk_callback(png_structp png_ptr,
-         png_unknown_chunkp chunk);
-    {
-       /* The unknown chunk structure contains your
-          chunk data, along with similar data for any other
-          unknown chunks: */
-
-           png_byte name[5];
-           png_byte *data;
-           png_size_t size;
-
-       /* Note that libpng has already taken care of
-          the CRC handling */
-
-       /* put your code here.  Search for your chunk in the
-          unknown chunk structure, process it, and return one
-          of the following: */
-
-       return (-n); /* chunk had an error */
-       return (0); /* did not recognize */
-       return (n); /* success */
-    }
-
-(You can give your function another name that you like instead of
-"read_chunk_callback")
-
-To inform libpng about your function, use
-
-    png_set_read_user_chunk_fn(png_ptr, user_chunk_ptr,
-        read_chunk_callback);
-
-This names not only the callback function, but also a user pointer that
-you can retrieve with
-
-    png_get_user_chunk_ptr(png_ptr);
-
-If you call the png_set_read_user_chunk_fn() function, then all unknown
-chunks will be saved when read, in case your callback function will need
-one or more of them.  This behavior can be changed with the
-png_set_keep_unknown_chunks() function, described below.
-
-At this point, you can set up a callback function that will be
-called after each row has been read, which you can use to control
-a progress meter or the like.  It's demonstrated in pngtest.c.
-You must supply a function
-
-    void read_row_callback(png_structp png_ptr,
-       png_uint_32 row, int pass);
-    {
-      /* put your code here */
-    }
-
-(You can give it another name that you like instead of "read_row_callback")
-
-To inform libpng about your function, use
-
-    png_set_read_status_fn(png_ptr, read_row_callback);
-
-When this function is called the row has already been completely processed and
-the 'row' and 'pass' refer to the next row to be handled.  For the
-non-interlaced case the row that was just handled is simply one less than the
-passed in row number, and pass will always be 0.  For the interlaced case the
-same applies unless the row value is 0, in which case the row just handled was
-the last one from one of the preceding passes.  Because interlacing may skip a
-pass you cannot be sure that the preceding pass is just 'pass-1', if you really
-need to know what the last pass is record (row,pass) from the callback and use
-the last recorded value each time.
-
-As with the user transform you can find the output row using the
-PNG_ROW_FROM_PASS_ROW macro.
-
-Unknown-chunk handling
-
-Now you get to set the way the library processes unknown chunks in the
-input PNG stream. Both known and unknown chunks will be read.  Normal
-behavior is that known chunks will be parsed into information in
-various info_ptr members while unknown chunks will be discarded. This
-behavior can be wasteful if your application will never use some known
-chunk types. To change this, you can call:
-
-    png_set_keep_unknown_chunks(png_ptr, keep,
-        chunk_list, num_chunks);
-    keep       - 0: default unknown chunk handling
-                 1: ignore; do not keep
-                 2: keep only if safe-to-copy
-                 3: keep even if unsafe-to-copy
-
-               You can use these definitions:
-                 PNG_HANDLE_CHUNK_AS_DEFAULT   0
-                 PNG_HANDLE_CHUNK_NEVER        1
-                 PNG_HANDLE_CHUNK_IF_SAFE      2
-                 PNG_HANDLE_CHUNK_ALWAYS       3
-
-    chunk_list - list of chunks affected (a byte string,
-                 five bytes per chunk, NULL or '\0' if
-                 num_chunks is 0)
-
-    num_chunks - number of chunks affected; if 0, all
-                 unknown chunks are affected.  If nonzero,
-                 only the chunks in the list are affected
-
-Unknown chunks declared in this way will be saved as raw data onto a
-list of png_unknown_chunk structures.  If a chunk that is normally
-known to libpng is named in the list, it will be handled as unknown,
-according to the "keep" directive.  If a chunk is named in successive
-instances of png_set_keep_unknown_chunks(), the final instance will
-take precedence.  The IHDR and IEND chunks should not be named in
-chunk_list; if they are, libpng will process them normally anyway.
-If you know that your application will never make use of some particular
-chunks, use PNG_HANDLE_CHUNK_NEVER (or 1) as demonstrated below.
-
-Here is an example of the usage of png_set_keep_unknown_chunks(),
-where the private "vpAg" chunk will later be processed by a user chunk
-callback function:
-
-    png_byte vpAg[5]={118, 112,  65, 103, (png_byte) '\0'};
-
-    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-      png_byte unused_chunks[]=
-      {
-        104,  73,  83,  84, (png_byte) '\0',   /* hIST */
-        105,  84,  88, 116, (png_byte) '\0',   /* iTXt */
-        112,  67,  65,  76, (png_byte) '\0',   /* pCAL */
-        115,  67,  65,  76, (png_byte) '\0',   /* sCAL */
-        115,  80,  76,  84, (png_byte) '\0',   /* sPLT */
-        116,  73,  77,  69, (png_byte) '\0',   /* tIME */
-      };
-    #endif
-
-    ...
-
-    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
-      /* ignore all unknown chunks: */
-      png_set_keep_unknown_chunks(read_ptr, 1, NULL, 0);
-
-      /* except for vpAg: */
-      png_set_keep_unknown_chunks(read_ptr, 2, vpAg, 1);
-
-      /* also ignore unused known chunks: */
-      png_set_keep_unknown_chunks(read_ptr, 1, unused_chunks,
-         (int)sizeof(unused_chunks)/5);
-    #endif
-
-User limits
-
-The PNG specification allows the width and height of an image to be as
-large as 2^31-1 (0x7fffffff), or about 2.147 billion rows and columns.
-Since very few applications really need to process such large images,
-we have imposed an arbitrary 1-million limit on rows and columns.
-Larger images will be rejected immediately with a png_error() call. If
-you wish to change this limit, you can use
-
-   png_set_user_limits(png_ptr, width_max, height_max);
-
-to set your own limits, or use width_max = height_max = 0x7fffffffL
-to allow all valid dimensions (libpng may reject some very large images
-anyway because of potential buffer overflow conditions).
-
-You should put this statement after you create the PNG structure and
-before calling png_read_info(), png_read_png(), or png_process_data().
-
-When writing a PNG datastream, put this statement before calling
-png_write_info() or png_write_png().
-
-If you need to retrieve the limits that are being applied, use
-
-   width_max = png_get_user_width_max(png_ptr);
-   height_max = png_get_user_height_max(png_ptr);
-
-The PNG specification sets no limit on the number of ancillary chunks
-allowed in a PNG datastream.  You can impose a limit on the total number
-of sPLT, tEXt, iTXt, zTXt, and unknown chunks that will be stored, with
-
-   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);
-
-where 0x7fffffffL means unlimited.  You can retrieve this limit with
-
-   chunk_cache_max = png_get_chunk_cache_max(png_ptr);
-
-This limit also applies to the number of buffers that can be allocated
-by png_decompress_chunk() while decompressing iTXt, zTXt, and iCCP chunks.
-
-You can also set a limit on the amount of memory that a compressed chunk
-other than IDAT can occupy, with
-
-   png_set_chunk_malloc_max(png_ptr, user_chunk_malloc_max);
-
-and you can retrieve the limit with
-
-   chunk_malloc_max = png_get_chunk_malloc_max(png_ptr);
-
-Any chunks that would cause either of these limits to be exceeded will
-be ignored.
-
-Information about your system
-
-If you intend to display the PNG or to incorporate it in other image data you
-need to tell libpng information about your display or drawing surface so that
-libpng can convert the values in the image to match the display.
-
-From libpng-1.5.4 this information can be set before reading the PNG file
-header.  In earlier versions png_set_gamma() existed but behaved incorrectly if
-called before the PNG file header had been read and png_set_alpha_mode() did not
-exist.
-
-If you need to support versions prior to libpng-1.5.4 test the version number
-as illustrated below using "PNG_LIBPNG_VER >= 10504" and follow the procedures
-described in the appropriate manual page.
-
-You give libpng the encoding expected by your system expressed as a 'gamma'
-value.  You can also specify a default encoding for the PNG file in
-case the required information is missing from the file.  By default libpng
-assumes that the PNG data matches your system, to keep this default call:
-
-   png_set_gamma(png_ptr, screen_gamma, 1/screen_gamma/*file gamma*/);
-
-or you can use the fixed point equivalent:
-
-   png_set_gamma_fixed(png_ptr, PNG_FP_1*screen_gamma, PNG_FP_1/screen_gamma);
-
-If you don't know the gamma for your system it is probably 2.2 - a good
-approximation to the IEC standard for display systems (sRGB).  If images are
-too contrasty or washed out you got the value wrong - check your system
-documentation!
-
-Many systems permit the system gamma to be changed via a lookup table in the
-display driver, a few systems, including older Macs, change the response by
-default.  As of 1.5.4 three special values are available to handle common
-situations:
-
-   PNG_DEFAULT_sRGB: Indicates that the system conforms to the IEC 61966-2-1
-                     standard.  This matches almost all systems.
-   PNG_GAMMA_MAC_18: Indicates that the system is an older (pre Mac OS 10.6)
-                     Apple Macintosh system with the default settings.
-   PNG_GAMMA_LINEAR: Just the fixed point value for 1.0 - indicates that the
-                     system expects data with no gamma encoding.
-
-You would use the linear (unencoded) value if you need to process the pixel
-values further because this avoids the need to decode and reencode each
-component value whenever arithmetic is performed.  A lot of graphics software
-uses linear values for this reason, often with higher precision component values
-to preserve overall accuracy.
-
-The second thing you may need to tell libpng about is how your system handles
-alpha channel information.  Some, but not all, PNG files contain an alpha
-channel.  To display these files correctly you need to compose the data onto a
-suitable background, as described in the PNG specification.
-
-Libpng only supports composing onto a single color (using png_set_background;
-see below).  Otherwise you must do the composition yourself and, in this case,
-you may need to call png_set_alpha_mode:
-
-#if PNG_LIBPNG_VER >= 10504
-   png_set_alpha_mode(png_ptr, mode, screen_gamma);
-#else
-   png_set_gamma(png_ptr, screen_gamma, 1.0/screen_gamma);
-#endif
-
-The screen_gamma value is the same as the argument to png_set_gamma; however,
-how it affects the output depends on the mode.  png_set_alpha_mode() sets the
-file gamma default to 1/screen_gamma, so normally you don't need to call
-png_set_gamma.  If you need different defaults call png_set_gamma() before
-png_set_alpha_mode() - if you call it after it will override the settings made
-by png_set_alpha_mode().
-
-The mode is as follows:
-
-    PNG_ALPHA_PNG: The data is encoded according to the PNG specification.  Red,
-green and blue, or gray, components are gamma encoded color
-values and are not premultiplied by the alpha value.  The
-alpha value is a linear measure of the contribution of the
-pixel to the corresponding final output pixel.
-
-You should normally use this format if you intend to perform
-color correction on the color values; most, maybe all, color
-correction software has no handling for the alpha channel and,
-anyway, the math to handle pre-multiplied component values is
-unnecessarily complex.
-
-Before you do any arithmetic on the component values you need
-to remove the gamma encoding and multiply out the alpha
-channel.  See the PNG specification for more detail.  It is
-important to note that when an image with an alpha channel is
-scaled, linear encoded, pre-multiplied component values must
-be used!
-
-The remaining modes assume you don't need to do any further color correction or
-that if you do, your color correction software knows all about alpha (it
-probably doesn't!)
-
-    PNG_ALPHA_STANDARD:  The data libpng produces
-is encoded in the standard way
-assumed by most correctly written graphics software.
-The gamma encoding will be removed by libpng and the
-linear component values will be pre-multiplied by the
-alpha channel.
-
-With this format the final image must be re-encoded to
-match the display gamma before the image is displayed.
-If your system doesn't do that, yet still seems to
-perform arithmetic on the pixels without decoding them,
-it is broken - check out the modes below.
-
-With PNG_ALPHA_STANDARD libpng always produces linear
-component values, whatever screen_gamma you supply.  The
-screen_gamma value is, however, used as a default for
-the file gamma if the PNG file has no gamma information.
-
-If you call png_set_gamma() after png_set_alpha_mode() you
-will override the linear encoding.  Instead the
-pre-multiplied pixel values will be gamma encoded but
-the alpha channel will still be linear.  This may
-actually match the requirements of some broken software,
-but it is unlikely.
-
-While linear 8-bit data is often used it has
-insufficient precision for any image with a reasonable
-dynamic range.  To avoid problems, and if your software
-supports it, use png_set_expand_16() to force all
-components to 16 bits.
-
-    PNG_ALPHA_OPTIMIZED: This mode is the same
-as PNG_ALPHA_STANDARD except that
-completely opaque pixels are gamma encoded according to
-the screen_gamma value.  Pixels with alpha less than 1.0
-will still have linear components.
-
-Use this format if you have control over your
-compositing software and do don't do other arithmetic
-(such as scaling) on the data you get from libpng.  Your
-compositing software can simply copy opaque pixels to
-the output but still has linear values for the
-non-opaque pixels.
-
-In normal compositing, where the alpha channel encodes
-partial pixel coverage (as opposed to broad area
-translucency), the inaccuracies of the 8-bit
-representation of non-opaque pixels are irrelevant.
-
-You can also try this format if your software is broken;
-it might look better.
-
-    PNG_ALPHA_BROKEN: This is PNG_ALPHA_STANDARD;
-however, all component values,
-including the alpha channel are gamma encoded.  This is
-an appropriate format to try if your software, or more
-likely hardware, is totally broken, i.e., if it performs
-linear arithmetic directly on gamma encoded values.
-
-In most cases of broken software or hardware the bug in the final display
-manifests as a subtle halo around composited parts of the image.  You may not
-even perceive this as a halo; the composited part of the image may simply appear
-separate from the background, as though it had been cut out of paper and pasted
-on afterward.
-
-If you don't have to deal with bugs in software or hardware, or if you can fix
-them, there are three recommended ways of using png_set_alpha_mode():
-
-   png_set_alpha_mode(png_ptr, PNG_ALPHA_PNG,
-       screen_gamma);
-
-You can do color correction on the result (libpng does not currently
-support color correction internally).  When you handle the alpha channel
-you need to undo the gamma encoding and multiply out the alpha.
-
-   png_set_alpha_mode(png_ptr, PNG_ALPHA_STANDARD,
-       screen_gamma);
-   png_set_expand_16(png_ptr);
-
-If you are using the high level interface, don't call png_set_expand_16();
-instead pass PNG_TRANSFORM_EXPAND_16 to the interface.
-
-With this mode you can't do color correction, but you can do arithmetic,
-including composition and scaling, on the data without further processing.
-
-   png_set_alpha_mode(png_ptr, PNG_ALPHA_OPTIMIZED,
-       screen_gamma);
-
-You can avoid the expansion to 16-bit components with this mode, but you
-lose the ability to scale the image or perform other linear arithmetic.
-All you can do is compose the result onto a matching output.  Since this
-mode is libpng-specific you also need to write your own composition
-software.
-
-If you don't need, or can't handle, the alpha channel you can call
-png_set_background() to remove it by compositing against a fixed color.  Don't
-call png_set_strip_alpha() to do this - it will leave spurious pixel values in
-transparent parts of this image.
-
-   png_set_background(png_ptr, &background_color,
-       PNG_BACKGROUND_GAMMA_SCREEN, 0, 1);
-
-The background_color is an RGB or grayscale value according to the data format
-libpng will produce for you.  Because you don't yet know the format of the PNG
-file, if you call png_set_background at this point you must arrange for the
-format produced by libpng to always have 8-bit or 16-bit components and then
-store the color as an 8-bit or 16-bit color as appropriate.  The color contains
-separate gray and RGB component values, so you can let libpng produce gray or
-RGB output according to the input format, but low bit depth grayscale images
-must always be converted to at least 8-bit format.  (Even though low bit depth
-grayscale images can't have an alpha channel they can have a transparent
-color!)
-
-You set the transforms you need later, either as flags to the high level
-interface or libpng API calls for the low level interface.  For reference the
-settings and API calls required are:
-
-8-bit values:
-   PNG_TRANSFORM_SCALE_16 | PNG_EXPAND
-   png_set_expand(png_ptr); png_set_scale_16(png_ptr);
-
-   If you must get exactly the same inaccurate results
-   produced by default in versions prior to libpng-1.5.4,
-   use PNG_TRANSFORM_STRIP_16 and png_set_strip_16(png_ptr)
-   instead.
-
-16-bit values:
-   PNG_TRANSFORM_EXPAND_16
-   png_set_expand_16(png_ptr);
-
-In either case palette image data will be expanded to RGB.  If you just want
-color data you can add PNG_TRANSFORM_GRAY_TO_RGB or png_set_gray_to_rgb(png_ptr)
-to the list.
-
-Calling png_set_background before the PNG file header is read will not work
-prior to libpng-1.5.4.  Because the failure may result in unexpected warnings or
-errors it is therefore much safer to call png_set_background after the head has
-been read.  Unfortunately this means that prior to libpng-1.5.4 it cannot be
-used with the high level interface.
-
-The high-level read interface
-
-At this point there are two ways to proceed; through the high-level
-read interface, or through a sequence of low-level read operations.
-You can use the high-level interface if (a) you are willing to read
-the entire image into memory, and (b) the input transformations
-you want to do are limited to the following set:
-
-    PNG_TRANSFORM_IDENTITY      No transformation
-    PNG_TRANSFORM_SCALE_16      Strip 16-bit samples to
-                                8-bit accurately
-    PNG_TRANSFORM_STRIP_16      Chop 16-bit samples to
-                                8-bit less accurately
-    PNG_TRANSFORM_STRIP_ALPHA   Discard the alpha channel
-    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit
-                                samples to bytes
-    PNG_TRANSFORM_PACKSWAP      Change order of packed
-                                pixels to LSB first
-    PNG_TRANSFORM_EXPAND        Perform set_expand()
-    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
-    PNG_TRANSFORM_SHIFT         Normalize pixels to the
-                                sBIT depth
-    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA
-                                to BGRA
-    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA
-                                to AG
-    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity
-                                to transparency
-    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
-    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
-                                to RGB (or GA to RGBA)
-    PNG_TRANSFORM_EXPAND_16     Expand samples to 16 bits
-
-(This excludes setting a background color, doing gamma transformation,
-quantizing, and setting filler.)  If this is the case, simply do this:
-
-    png_read_png(png_ptr, info_ptr, png_transforms, NULL)
-
-where png_transforms is an integer containing the bitwise OR of some
-set of transformation flags.  This call is equivalent to png_read_info(),
-followed the set of transformations indicated by the transform mask,
-then png_read_image(), and finally png_read_end().
-
-(The final parameter of this call is not yet used.  Someday it might point
-to transformation parameters required by some future input transform.)
-
-You must use png_transforms and not call any png_set_transform() functions
-when you use png_read_png().
-
-After you have called png_read_png(), you can retrieve the image data
-with
-
-   row_pointers = png_get_rows(png_ptr, info_ptr);
-
-where row_pointers is an array of pointers to the pixel data for each row:
-
-   png_bytep row_pointers[height];
-
-If you know your image size and pixel size ahead of time, you can allocate
-row_pointers prior to calling png_read_png() with
-
-   if (height > PNG_UINT_32_MAX/png_sizeof(png_byte))
-      png_error (png_ptr,
-          "Image is too tall to process in memory");
-
-   if (width > PNG_UINT_32_MAX/pixel_size)
-      png_error (png_ptr,
-          "Image is too wide to process in memory");
-
-   row_pointers = png_malloc(png_ptr,
-       height*png_sizeof(png_bytep));
-
-   for (int i=0; i<height, i++)
-      row_pointers[i]=NULL;  /* security precaution */
-
-   for (int i=0; i<height, i++)
-      row_pointers[i]=png_malloc(png_ptr,
-          width*pixel_size);
-
-   png_set_rows(png_ptr, info_ptr, &row_pointers);
-
-Alternatively you could allocate your image in one big block and define
-row_pointers[i] to point into the proper places in your block.
-
-If you use png_set_rows(), the application is responsible for freeing
-row_pointers (and row_pointers[i], if they were separately allocated).
-
-If you don't allocate row_pointers ahead of time, png_read_png() will
-do it, and it'll be free'ed by libpng when you call png_destroy_*().
-
-The low-level read interface
-
-If you are going the low-level route, you are now ready to read all
-the file information up to the actual image data.  You do this with a
-call to png_read_info().
-
-    png_read_info(png_ptr, info_ptr);
-
-This will process all chunks up to but not including the image data.
-
-This also copies some of the data from the PNG file into the decode structure
-for use in later transformations.  Important information copied in is:
-
-1) The PNG file gamma from the gAMA chunk.  This overwrites the default value
-provided by an earlier call to png_set_gamma or png_set_alpha_mode.
-
-2) Prior to libpng-1.5.4 the background color from a bKGd chunk.  This
-damages the information provided by an earlier call to png_set_background
-resulting in unexpected behavior.  Libpng-1.5.4 no longer does this.
-
-3) The number of significant bits in each component value.  Libpng uses this to
-optimize gamma handling by reducing the internal lookup table sizes.
-
-4) The transparent color information from a tRNS chunk.  This can be modified by
-a later call to png_set_tRNS.
-
-Querying the info structure
-
-Functions are used to get the information from the info_ptr once it
-has been read.  Note that these fields may not be completely filled
-in until png_read_end() has read the chunk data following the image.
-
-    png_get_IHDR(png_ptr, info_ptr, &width, &height,
-       &bit_depth, &color_type, &interlace_type,
-       &compression_type, &filter_method);
-
-    width          - holds the width of the image
-                     in pixels (up to 2^31).
-
-    height         - holds the height of the image
-                     in pixels (up to 2^31).
-
-    bit_depth      - holds the bit depth of one of the
-                     image channels.  (valid values are
-                     1, 2, 4, 8, 16 and depend also on
-                     the color_type.  See also
-                     significant bits (sBIT) below).
-
-    color_type     - describes which color/alpha channels
-                         are present.
-                     PNG_COLOR_TYPE_GRAY
-                        (bit depths 1, 2, 4, 8, 16)
-                     PNG_COLOR_TYPE_GRAY_ALPHA
-                        (bit depths 8, 16)
-                     PNG_COLOR_TYPE_PALETTE
-                        (bit depths 1, 2, 4, 8)
-                     PNG_COLOR_TYPE_RGB
-                        (bit_depths 8, 16)
-                     PNG_COLOR_TYPE_RGB_ALPHA
-                        (bit_depths 8, 16)
-
-                     PNG_COLOR_MASK_PALETTE
-                     PNG_COLOR_MASK_COLOR
-                     PNG_COLOR_MASK_ALPHA
-
-    interlace_type - (PNG_INTERLACE_NONE or
-                     PNG_INTERLACE_ADAM7)
-
-    compression_type - (must be PNG_COMPRESSION_TYPE_BASE
-                     for PNG 1.0)
-
-    filter_method  - (must be PNG_FILTER_TYPE_BASE
-                     for PNG 1.0, and can also be
-                     PNG_INTRAPIXEL_DIFFERENCING if
-                     the PNG datastream is embedded in
-                     a MNG-1.0 datastream)
-
-    Any or all of interlace_type, compression_type, or
-    filter_method can be NULL if you are
-    not interested in their values.
-
-    Note that png_get_IHDR() returns 32-bit data into
-    the application's width and height variables.
-    This is an unsafe situation if these are 16-bit
-    variables.  In such situations, the
-    png_get_image_width() and png_get_image_height()
-    functions described below are safer.
-
-    width            = png_get_image_width(png_ptr,
-                         info_ptr);
-
-    height           = png_get_image_height(png_ptr,
-                         info_ptr);
-
-    bit_depth        = png_get_bit_depth(png_ptr,
-                         info_ptr);
-
-    color_type       = png_get_color_type(png_ptr,
-                         info_ptr);
-
-    interlace_type   = png_get_interlace_type(png_ptr,
-                         info_ptr);
-
-    compression_type = png_get_compression_type(png_ptr,
-                         info_ptr);
-
-    filter_method    = png_get_filter_type(png_ptr,
-                         info_ptr);
-
-    channels = png_get_channels(png_ptr, info_ptr);
-
-    channels       - number of channels of info for the
-                     color type (valid values are 1 (GRAY,
-                     PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
-                     4 (RGB_ALPHA or RGB + filler byte))
-
-    rowbytes = png_get_rowbytes(png_ptr, info_ptr);
-
-    rowbytes       - number of bytes needed to hold a row
-
-    signature = png_get_signature(png_ptr, info_ptr);
-
-    signature      - holds the signature read from the
-                     file (if any).  The data is kept in
-                     the same offset it would be if the
-                     whole signature were read (i.e. if an
-                     application had already read in 4
-                     bytes of signature before starting
-                     libpng, the remaining 4 bytes would
-                     be in signature[4] through signature[7]
-                     (see png_set_sig_bytes())).
-
-These are also important, but their validity depends on whether the chunk
-has been read.  The png_get_valid(png_ptr, info_ptr, PNG_INFO_<chunk>) and
-png_get_<chunk>(png_ptr, info_ptr, ...) functions return non-zero if the
-data has been read, or zero if it is missing.  The parameters to the
-png_get_<chunk> are set directly if they are simple data types, or a
-pointer into the info_ptr is returned for any complex types.
-
-    png_get_PLTE(png_ptr, info_ptr, &palette,
-                     &num_palette);
-
-    palette        - the palette for the file
-                     (array of png_color)
-
-    num_palette    - number of entries in the palette
-
-    png_get_gAMA(png_ptr, info_ptr, &file_gamma);
-    png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);
-
-    file_gamma     - the gamma at which the file is
-                     written (PNG_INFO_gAMA)
-
-    int_file_gamma - 100,000 times the gamma at which the
-                     file is written
-
-    png_get_cHRM(png_ptr, info_ptr,  &white_x, &white_y, &red_x, &red_y,
-                     &green_x, &green_y, &blue_x, &blue_y)
-    png_get_cHRM_XYZ(png_ptr, info_ptr, &red_X, &red_Y, &red_Z, &green_X,
-                     &green_Y, &green_Z, &blue_X, &blue_Y, &blue_Z)
-    png_get_cHRM_fixed(png_ptr, info_ptr, &int_white_x, &int_white_y,
-                     &int_red_x, &int_red_y, &int_green_x, &int_green_y,
-                     &int_blue_x, &int_blue_y)
-    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &int_red_X, &int_red_Y,
-                     &int_red_Z, &int_green_X, &int_green_Y, &int_green_Z,
-                     &int_blue_X, &int_blue_Y, &int_blue_Z)
-
-    {white,red,green,blue}_{x,y}
-                     A color space encoding specified using the chromaticities
-                     of the end points and the white point. (PNG_INFO_cHRM)
-
-    {red,green,blue}_{X,Y,Z}
-                     A color space encoding specified using the encoding end
-                     points - the CIE tristimulus specification of the intended
-                     color of the red, green and blue channels in the PNG RGB
-                     data.  The white point is simply the sum of the three end
-                     points. (PNG_INFO_cHRM)
-
-    png_get_sRGB(png_ptr, info_ptr, &srgb_intent);
-
-    file_srgb_intent - the rendering intent (PNG_INFO_sRGB)
-                     The presence of the sRGB chunk
-                     means that the pixel data is in the
-                     sRGB color space.  This chunk also
-                     implies specific values of gAMA and
-                     cHRM.
-
-    png_get_iCCP(png_ptr, info_ptr, &name,
-       &compression_type, &profile, &proflen);
-
-    name             - The profile name.
-
-    compression_type - The compression type; always
-                       PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
-                       You may give NULL to this argument to
-                       ignore it.
-
-    profile          - International Color Consortium color
-                       profile data. May contain NULs.
-
-    proflen          - length of profile data in bytes.
-
-    png_get_sBIT(png_ptr, info_ptr, &sig_bit);
-
-    sig_bit        - the number of significant bits for
-                     (PNG_INFO_sBIT) each of the gray,
-                     red, green, and blue channels,
-                     whichever are appropriate for the
-                     given color type (png_color_16)
-
-    png_get_tRNS(png_ptr, info_ptr, &trans_alpha,
-                     &num_trans, &trans_color);
-
-    trans_alpha    - array of alpha (transparency)
-                     entries for palette (PNG_INFO_tRNS)
-
-    num_trans      - number of transparent entries
-                     (PNG_INFO_tRNS)
-
-    trans_color    - graylevel or color sample values of
-                     the single transparent color for
-                     non-paletted images (PNG_INFO_tRNS)
-
-    png_get_hIST(png_ptr, info_ptr, &hist);
-                     (PNG_INFO_hIST)
-
-    hist           - histogram of palette (array of
-                     png_uint_16)
-
-    png_get_tIME(png_ptr, info_ptr, &mod_time);
-
-    mod_time       - time image was last modified
-                    (PNG_VALID_tIME)
-
-    png_get_bKGD(png_ptr, info_ptr, &background);
-
-    background     - background color (of type
-                     png_color_16p) (PNG_VALID_bKGD)
-                     valid 16-bit red, green and blue
-                     values, regardless of color_type
-
-    num_comments   = png_get_text(png_ptr, info_ptr,
-                     &text_ptr, &num_text);
-
-    num_comments   - number of comments
-
-    text_ptr       - array of png_text holding image
-                     comments
-
-    text_ptr[i].compression - type of compression used
-                 on "text" PNG_TEXT_COMPRESSION_NONE
-                           PNG_TEXT_COMPRESSION_zTXt
-                           PNG_ITXT_COMPRESSION_NONE
-                           PNG_ITXT_COMPRESSION_zTXt
-
-    text_ptr[i].key   - keyword for comment.  Must contain
-                         1-79 characters.
-
-    text_ptr[i].text  - text comments for current
-                         keyword.  Can be empty.
-
-    text_ptr[i].text_length - length of text string,
-                 after decompression, 0 for iTXt
-
-    text_ptr[i].itxt_length - length of itxt string,
-                 after decompression, 0 for tEXt/zTXt
-
-    text_ptr[i].lang  - language of comment (empty
-                         string for unknown).
-
-    text_ptr[i].lang_key  - keyword in UTF-8
-                         (empty string for unknown).
-
-    Note that the itxt_length, lang, and lang_key
-    members of the text_ptr structure only exist when the
-    library is built with iTXt chunk support.  Prior to
-    libpng-1.4.0 the library was built by default without
-    iTXt support. Also note that when iTXt is supported,
-    they contain NULL pointers when the "compression"
-    field contains PNG_TEXT_COMPRESSION_NONE or
-    PNG_TEXT_COMPRESSION_zTXt.
-
-    num_text       - number of comments (same as
-                     num_comments; you can put NULL here
-                     to avoid the duplication)
-
-    Note while png_set_text() will accept text, language,
-    and translated keywords that can be NULL pointers, the
-    structure returned by png_get_text will always contain
-    regular zero-terminated C strings.  They might be
-    empty strings but they will never be NULL pointers.
-
-    num_spalettes = png_get_sPLT(png_ptr, info_ptr,
-       &palette_ptr);
-
-    num_spalettes  - number of sPLT chunks read.
-
-    palette_ptr    - array of palette structures holding
-                     contents of one or more sPLT chunks
-                     read.
-
-    png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
-       &unit_type);
-
-    offset_x       - positive offset from the left edge
-                     of the screen (can be negative)
-
-    offset_y       - positive offset from the top edge
-                     of the screen (can be negative)
-
-    unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
-
-    png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
-       &unit_type);
-
-    res_x          - pixels/unit physical resolution in
-                     x direction
-
-    res_y          - pixels/unit physical resolution in
-                     x direction
-
-    unit_type      - PNG_RESOLUTION_UNKNOWN,
-                     PNG_RESOLUTION_METER
-
-    png_get_sCAL(png_ptr, info_ptr, &unit, &width,
-       &height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-
-    height      - height of a pixel in physical scale units
-                 (width and height are doubles)
-
-    png_get_sCAL_s(png_ptr, info_ptr, &unit, &width,
-       &height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-                  (expressed as a string)
-
-    height      - height of a pixel in physical scale units
-                 (width and height are strings like "2.54")
-
-    num_unknown_chunks = png_get_unknown_chunks(png_ptr,
-       info_ptr, &unknowns)
-
-    unknowns          - array of png_unknown_chunk
-                        structures holding unknown chunks
-
-    unknowns[i].name  - name of unknown chunk
-
-    unknowns[i].data  - data of unknown chunk
-
-    unknowns[i].size  - size of unknown chunk's data
-
-    unknowns[i].location - position of chunk in file
-
-    The value of "i" corresponds to the order in which the
-    chunks were read from the PNG file or inserted with the
-    png_set_unknown_chunks() function.
-
-    The value of "location" is a bitwise "or" of
-
-         PNG_HAVE_IHDR  (0x01)
-         PNG_HAVE_PLTE  (0x02)
-         PNG_AFTER_IDAT (0x08)
-
-The data from the pHYs chunk can be retrieved in several convenient
-forms:
-
-    res_x = png_get_x_pixels_per_meter(png_ptr,
-       info_ptr)
-
-    res_y = png_get_y_pixels_per_meter(png_ptr,
-       info_ptr)
-
-    res_x_and_y = png_get_pixels_per_meter(png_ptr,
-       info_ptr)
-
-    res_x = png_get_x_pixels_per_inch(png_ptr,
-       info_ptr)
-
-    res_y = png_get_y_pixels_per_inch(png_ptr,
-       info_ptr)
-
-    res_x_and_y = png_get_pixels_per_inch(png_ptr,
-       info_ptr)
-
-    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
-       info_ptr)
-
-    Each of these returns 0 [signifying "unknown"] if
-       the data is not present or if res_x is 0;
-       res_x_and_y is 0 if res_x != res_y
-
-    Note that because of the way the resolutions are
-       stored internally, the inch conversions won't
-       come out to exactly even number.  For example,
-       72 dpi is stored as 0.28346 pixels/meter, and
-       when this is retrieved it is 71.9988 dpi, so
-       be sure to round the returned value appropriately
-       if you want to display a reasonable-looking result.
-
-The data from the oFFs chunk can be retrieved in several convenient
-forms:
-
-    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
-
-    y_offset = png_get_y_offset_microns(png_ptr, info_ptr);
-
-    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
-
-    y_offset = png_get_y_offset_inches(png_ptr, info_ptr);
-
-    Each of these returns 0 [signifying "unknown" if both
-       x and y are 0] if the data is not present or if the
-       chunk is present but the unit is the pixel.  The
-       remark about inexact inch conversions applies here
-       as well, because a value in inches can't always be
-       converted to microns and back without some loss
-       of precision.
-
-For more information, see the
-PNG specification for chunk contents.  Be careful with trusting
-rowbytes, as some of the transformations could increase the space
-needed to hold a row (expand, filler, gray_to_rgb, etc.).
-See png_read_update_info(), below.
-
-A quick word about text_ptr and num_text.  PNG stores comments in
-keyword/text pairs, one pair per chunk, with no limit on the number
-of text chunks, and a 2^31 byte limit on their size.  While there are
-suggested keywords, there is no requirement to restrict the use to these
-strings.  It is strongly suggested that keywords and text be sensible
-to humans (that's the point), so don't use abbreviations.  Non-printing
-symbols are not allowed.  See the PNG specification for more details.
-There is also no requirement to have text after the keyword.
-
-Keywords should be limited to 79 Latin-1 characters without leading or
-trailing spaces, but non-consecutive spaces are allowed within the
-keyword.  It is possible to have the same keyword any number of times.
-The text_ptr is an array of png_text structures, each holding a
-pointer to a language string, a pointer to a keyword and a pointer to
-a text string.  The text string, language code, and translated
-keyword may be empty or NULL pointers.  The keyword/text
-pairs are put into the array in the order that they are received.
-However, some or all of the text chunks may be after the image, so, to
-make sure you have read all the text chunks, don't mess with these
-until after you read the stuff after the image.  This will be
-mentioned again below in the discussion that goes with png_read_end().
-
-Input transformations
-
-After you've read the header information, you can set up the library
-to handle any special transformations of the image data.  The various
-ways to transform the data will be described in the order that they
-should occur.  This is important, as some of these change the color
-type and/or bit depth of the data, and some others only work on
-certain color types and bit depths.
-
-Transformations you request are ignored if they don't have any meaning for a
-particular input data format.  However some transformations can have an effect
-as a result of a previous transformation.  If you specify a contradictory set of
-transformations, for example both adding and removing the alpha channel, you
-cannot predict the final result.
-
-The color used for the transparency values should be supplied in the same
-format/depth as the current image data.  It is stored in the same format/depth
-as the image data in a tRNS chunk, so this is what libpng expects for this data.
-
-The color used for the background value depends on the need_expand argument as
-described below.
-
-Data will be decoded into the supplied row buffers packed into bytes
-unless the library has been told to transform it into another format.
-For example, 4 bit/pixel paletted or grayscale data will be returned
-2 pixels/byte with the leftmost pixel in the high-order bits of the
-byte, unless png_set_packing() is called.  8-bit RGB data will be stored
-in RGB RGB RGB format unless png_set_filler() or png_set_add_alpha()
-is called to insert filler bytes, either before or after each RGB triplet.
-16-bit RGB data will be returned RRGGBB RRGGBB, with the most significant
-byte of the color value first, unless png_set_scale_16() is called to
-transform it to regular RGB RGB triplets, or png_set_filler() or
-png_set_add alpha() is called to insert filler bytes, either before or
-after each RRGGBB triplet.  Similarly, 8-bit or 16-bit grayscale data can
-be modified with png_set_filler(), png_set_add_alpha(), png_set_strip_16(),
-or png_set_scale_16().
-
-The following code transforms grayscale images of less than 8 to 8 bits,
-changes paletted images to RGB, and adds a full alpha channel if there is
-transparency information in a tRNS chunk.  This is most useful on
-grayscale images with bit depths of 2 or 4 or if there is a multiple-image
-viewing application that wishes to treat all images in the same way.
-
-    if (color_type == PNG_COLOR_TYPE_PALETTE)
-        png_set_palette_to_rgb(png_ptr);
-
-    if (png_get_valid(png_ptr, info_ptr,
-        PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);
-
-    if (color_type == PNG_COLOR_TYPE_GRAY &&
-        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
-
-The first two functions are actually aliases for png_set_expand(), added
-in libpng version 1.0.4, with the function names expanded to improve code
-readability.  In some future version they may actually do different
-things.
-
-As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
-added.  It expands the sample depth without changing tRNS to alpha.
-
-As of libpng version 1.5.2, png_set_expand_16() was added.  It behaves as
-png_set_expand(); however, the resultant channels have 16 bits rather than 8.
-Use this when the output color or gray channels are made linear to avoid fairly
-severe accuracy loss.
-
-   if (bit_depth < 16)
-      png_set_expand_16(png_ptr);
-
-PNG can have files with 16 bits per channel.  If you only can handle
-8 bits per channel, this will strip the pixels down to 8-bit.
-
-    if (bit_depth == 16)
-#if PNG_LIBPNG_VER >= 10504
-       png_set_scale_16(png_ptr);
-#else
-       png_set_strip_16(png_ptr);
-#endif
-
-(The more accurate "png_set_scale_16()" API became available in libpng version
-1.5.4).
-
-If you need to process the alpha channel on the image separately from the image
-data (for example if you convert it to a bitmap mask) it is possible to have
-libpng strip the channel leaving just RGB or gray data:
-
-    if (color_type & PNG_COLOR_MASK_ALPHA)
-       png_set_strip_alpha(png_ptr);
-
-If you strip the alpha channel you need to find some other way of dealing with
-the information.  If, instead, you want to convert the image to an opaque
-version with no alpha channel use png_set_background; see below.
-
-As of libpng version 1.5.2, almost all useful expansions are supported, the
-major ommissions are conversion of grayscale to indexed images (which can be
-done trivially in the application) and conversion of indexed to grayscale (which
-can be done by a trivial manipulation of the palette.)
-
-In the following table, the 01 means grayscale with depth<8, 31 means
-indexed with depth<8, other numerals represent the color type, "T" means
-the tRNS chunk is present, A means an alpha channel is present, and O
-means tRNS or alpha is present but all pixels in the image are opaque.
-
-  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O
-   TO
-   01    -  [G]  -   -   -   -   -   -   -   -   -   -   -   -   -
-   31   [Q]  Q  [Q] [Q] [Q]  Q   Q   Q   Q   Q   Q  [Q] [Q]  Q   Q
-    0    1   G   +   .   .   G   G   G   G   G   G   B   B  GB  GB
-   0T    lt  Gt  t   +   .   Gt  G   G   Gt  G   G   Bt  Bt GBt GBt
-   0O    lt  Gt  t   .   +   Gt  Gt  G   Gt  Gt  G   Bt  Bt GBt GBt
-    2    C   P   C   C   C   +   .   .   C   -   -  CB  CB   B   B
-   2T    Ct  -   Ct  C   C   t   +   t   -   -   -  CBt CBt  Bt  Bt
-   2O    Ct  -   Ct  C   C   t   t   +   -   -   -  CBt CBt  Bt  Bt
-    3   [Q]  p  [Q] [Q] [Q]  Q   Q   Q   +   .   .  [Q] [Q]  Q   Q
-   3T   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   +   t  [Qt][Qt] Qt  Qt
-   3O   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   t   +  [Qt][Qt] Qt  Qt
-   4A    lA  G   A   T   T   GA  GT  GT  GA  GT  GT  +   BA  G  GBA
-   4O    lA GBA  A   T   T   GA  GT  GT  GA  GT  GT  BA  +  GBA  G
-   6A    CA  PA  CA  C   C   A   T  tT   PA  P   P   C  CBA  +   BA
-   6O    CA PBA  CA  C   C   A  tT   T   PA  P   P  CBA  C   BA  +
-
-Within the matrix,
-     "+" identifies entries where 'from' and 'to' are the same.
-     "-" means the transformation is not supported.
-     "." means nothing is necessary (a tRNS chunk can just be ignored).
-     "t" means the transformation is obtained by png_set_tRNS.
-     "A" means the transformation is obtained by png_set_add_alpha().
-     "X" means the transformation is obtained by png_set_expand().
-     "1" means the transformation is obtained by
-         png_set_expand_gray_1_2_4_to_8() (and by png_set_expand() if there
-         is no transparency in the original or the final format).
-     "C" means the transformation is obtained by png_set_gray_to_rgb().
-     "G" means the transformation is obtained by png_set_rgb_to_gray().
-     "P" means the transformation is obtained by
-         png_set_expand_palette_to_rgb().
-     "p" means the transformation is obtained by png_set_packing().
-     "Q" means the transformation is obtained by png_set_quantize().
-     "T" means the transformation is obtained by png_set_tRNS_to_alpha().
-     "B" means the transformation is obtained by png_set_background(), or
-         png_strip_alpha().
-
-When an entry has multiple transforms listed all are required to cause the
-right overall transformation.  When two transforms are separated by a comma
-either will do the job.  When transforms are enclosed in [] the transform should
-do the job but this is currently unimplemented - a different format will result
-if the suggested transformations are used.
-
-In PNG files, the alpha channel in an image
-is the level of opacity.  If you need the alpha channel in an image to
-be the level of transparency instead of opacity, you can invert the
-alpha channel (or the tRNS chunk data) after it's read, so that 0 is
-fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit
-images) is fully transparent, with
-
-    png_set_invert_alpha(png_ptr);
-
-PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
-they can, resulting in, for example, 8 pixels per byte for 1 bit
-files.  This code expands to 1 pixel per byte without changing the
-values of the pixels:
-
-    if (bit_depth < 8)
-       png_set_packing(png_ptr);
-
-PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
-stored in a PNG image have been "scaled" or "shifted" up to the next
-higher possible bit depth (e.g. from 5 bits/sample in the range [0,31]
-to 8 bits/sample in the range [0, 255]).  However, it is also possible
-to convert the PNG pixel data back to the original bit depth of the
-image.  This call reduces the pixels back down to the original bit depth:
-
-    png_color_8p sig_bit;
-
-    if (png_get_sBIT(png_ptr, info_ptr, &sig_bit))
-       png_set_shift(png_ptr, sig_bit);
-
-PNG files store 3-color pixels in red, green, blue order.  This code
-changes the storage of the pixels to blue, green, red:
-
-    if (color_type == PNG_COLOR_TYPE_RGB ||
-        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-       png_set_bgr(png_ptr);
-
-PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them
-into 4 or 8 bytes for windowing systems that need them in this format:
-
-    if (color_type == PNG_COLOR_TYPE_RGB)
-       png_set_filler(png_ptr, filler, PNG_FILLER_BEFORE);
-
-where "filler" is the 8 or 16-bit number to fill with, and the location is
-either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether
-you want the filler before the RGB or after.  This transformation
-does not affect images that already have full alpha channels.  To add an
-opaque alpha channel, use filler=0xff or 0xffff and PNG_FILLER_AFTER which
-will generate RGBA pixels.
-
-Note that png_set_filler() does not change the color type.  If you want
-to do that, you can add a true alpha channel with
-
-    if (color_type == PNG_COLOR_TYPE_RGB ||
-       color_type == PNG_COLOR_TYPE_GRAY)
-       png_set_add_alpha(png_ptr, filler, PNG_FILLER_AFTER);
-
-where "filler" contains the alpha value to assign to each pixel.
-This function was added in libpng-1.2.7.
-
-If you are reading an image with an alpha channel, and you need the
-data as ARGB instead of the normal PNG format RGBA:
-
-    if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-       png_set_swap_alpha(png_ptr);
-
-For some uses, you may want a grayscale image to be represented as
-RGB.  This code will do that conversion:
-
-    if (color_type == PNG_COLOR_TYPE_GRAY ||
-        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-       png_set_gray_to_rgb(png_ptr);
-
-Conversely, you can convert an RGB or RGBA image to grayscale or grayscale
-with alpha.
-
-    if (color_type == PNG_COLOR_TYPE_RGB ||
-        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-       png_set_rgb_to_gray(png_ptr, error_action, double red_weight,
-          double green_weight);
-
-    error_action = 1: silently do the conversion
-
-    error_action = 2: issue a warning if the original
-                      image has any pixel where
-                      red != green or red != blue
-
-    error_action = 3: issue an error and abort the
-                      conversion if the original
-                      image has any pixel where
-                      red != green or red != blue
-
-    red_weight:       weight of red component
-
-    green_weight:     weight of green component
-                      If either weight is negative, default
-                      weights are used.
-
-In the corresponding fixed point API the red_weight and green_weight values are
-simply scaled by 100,000:
-
-    png_set_rgb_to_gray(png_ptr, error_action, png_fixed_point red_weight,
-       png_fixed_point green_weight);
-
-If you have set error_action = 1 or 2, you can
-later check whether the image really was gray, after processing
-the image rows, with the png_get_rgb_to_gray_status(png_ptr) function.
-It will return a png_byte that is zero if the image was gray or
-1 if there were any non-gray pixels.  Background and sBIT data
-will be silently converted to grayscale, using the green channel
-data for sBIT, regardless of the error_action setting.
-
-The default values come from the PNG file cHRM chunk if present; otherwise, the
-defaults correspond to the ITU-R recommendation 709, and also the sRGB color
-space, as recommended in the Charles Poynton's Colour FAQ,
-<http://www.poynton.com/>, in section 9:
-
-   <http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9>
-
-    Y = 0.2126 * R + 0.7152 * G + 0.0722 * B
-
-Previous versions of this document, 1998 through 2002, recommended a slightly
-different formula:
-
-    Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
-
-Libpng uses an integer approximation:
-
-    Y = (6968 * R + 23434 * G + 2366 * B)/32768
-
-The calculation is done in a linear colorspace, if the image gamma
-can be determined.
-
-The png_set_background() function has been described already; it tells libpng to
-composite images with alpha or simple transparency against the supplied
-background color.  For compatibility with versions of libpng earlier than
-libpng-1.5.4 it is recommended that you call the function after reading the file
-header, even if you don't want to use the color in a bKGD chunk, if one exists.
-
-If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
-you may use this color, or supply another color more suitable for
-the current display (e.g., the background color from a web page).  You
-need to tell libpng how the color is represented, both the format of the
-component values in the color (the number of bits) and the gamma encoding of the
-color.  The function takes two arguments, background_gamma_mode and need_expand
-to convey this information, however only two combinations are likely to be
-useful:
-
-    png_color_16 my_background;
-    png_color_16p image_background;
-
-    if (png_get_bKGD(png_ptr, info_ptr, &image_background))
-       png_set_background(png_ptr, image_background,
-           PNG_BACKGROUND_GAMMA_FILE, 1/*needs to be expanded*/, 1);
-    else
-       png_set_background(png_ptr, &my_background,
-           PNG_BACKGROUND_GAMMA_SCREEN, 0/*do not expand*/, 1);
-
-The second call was described above - my_background is in the format of the
-final, display, output produced by libpng.  Because you now know the format of
-the PNG it is possible to avoid the need to choose either 8-bit or 16-bit
-output and to retain palette images (the palette colors will be modified
-appropriately and the tRNS chunk removed.)  However, if you are doing this,
-take great care not to ask for transformations without checking first that
-they apply!
-
-In the first call the background color has the original bit depth and color type
-of the PNG file.  So, for palette images the color is supplied as a palette
-index and for low bit greyscale images the color is a reduced bit value in
-image_background->gray.
-
-If you didn't call png_set_gamma() before reading the file header, for example
-if you need your code to remain compatible with older versions of libpng prior
-to libpng-1.5.4, this is the place to call it.
-
-Do not call it if you called png_set_alpha_mode(); doing so will damage the
-settings put in place by png_set_alpha_mode().  (If png_set_alpha_mode() is
-supported then you can certainly do png_set_gamma() before reading the PNG
-header.)
-
-This API unconditionally sets the screen and file gamma values, so it will
-override the value in the PNG file unless it is called before the PNG file
-reading starts.  For this reason you must always call it with the PNG file
-value when you call it in this position:
-
-   if (png_get_gAMA(png_ptr, info_ptr, &file_gamma))
-      png_set_gamma(png_ptr, screen_gamma, file_gamma);
-
-   else
-      png_set_gamma(png_ptr, screen_gamma, 0.45455);
-
-If you need to reduce an RGB file to a paletted file, or if a paletted
-file has more entries then will fit on your screen, png_set_quantize()
-will do that.  Note that this is a simple match quantization that merely
-finds the closest color available.  This should work fairly well with
-optimized palettes, but fairly badly with linear color cubes.  If you
-pass a palette that is larger than maximum_colors, the file will
-reduce the number of colors in the palette so it will fit into
-maximum_colors.  If there is a histogram, libpng will use it to make
-more intelligent choices when reducing the palette.  If there is no
-histogram, it may not do as good a job.
-
-   if (color_type & PNG_COLOR_MASK_COLOR)
-   {
-      if (png_get_valid(png_ptr, info_ptr,
-          PNG_INFO_PLTE))
-      {
-         png_uint_16p histogram = NULL;
-
-         png_get_hIST(png_ptr, info_ptr,
-             &histogram);
-         png_set_quantize(png_ptr, palette, num_palette,
-            max_screen_colors, histogram, 1);
-      }
-
-      else
-      {
-         png_color std_color_cube[MAX_SCREEN_COLORS] =
-            { ... colors ... };
-
-         png_set_quantize(png_ptr, std_color_cube,
-            MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
-            NULL,0);
-      }
-   }
-
-PNG files describe monochrome as black being zero and white being one.
-The following code will reverse this (make black be one and white be
-zero):
-
-   if (bit_depth == 1 && color_type == PNG_COLOR_TYPE_GRAY)
-      png_set_invert_mono(png_ptr);
-
-This function can also be used to invert grayscale and gray-alpha images:
-
-   if (color_type == PNG_COLOR_TYPE_GRAY ||
-       color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      png_set_invert_mono(png_ptr);
-
-PNG files store 16-bit pixels in network byte order (big-endian,
-ie. most significant bits first).  This code changes the storage to the
-other way (little-endian, i.e. least significant bits first, the
-way PCs store them):
-
-    if (bit_depth == 16)
-       png_set_swap(png_ptr);
-
-If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
-need to change the order the pixels are packed into bytes, you can use:
-
-    if (bit_depth < 8)
-       png_set_packswap(png_ptr);
-
-Finally, you can write your own transformation function if none of
-the existing ones meets your needs.  This is done by setting a callback
-with
-
-    png_set_read_user_transform_fn(png_ptr,
-        read_transform_fn);
-
-You must supply the function
-
-    void read_transform_fn(png_structp png_ptr, png_row_infop
-        row_info, png_bytep data)
-
-See pngtest.c for a working example.  Your function will be called
-after all of the other transformations have been processed.  Take care with
-interlaced images if you do the interlace yourself - the width of the row is the
-width in 'row_info', not the overall image width.
-
-If supported, libpng provides two information routines that you can use to find
-where you are in processing the image:
-
-   png_get_current_pass_number(png_structp png_ptr);
-   png_get_current_row_number(png_structp png_ptr);
-
-Don't try using these outside a transform callback - firstly they are only
-supported if user transforms are supported, secondly they may well return
-unexpected results unless the row is actually being processed at the moment they
-are called.
-
-With interlaced
-images the value returned is the row in the input sub-image image.  Use
-PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
-find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
-
-The discussion of interlace handling above contains more information on how to
-use these values.
-
-You can also set up a pointer to a user structure for use by your
-callback function, and you can inform libpng that your transform
-function will change the number of channels or bit depth with the
-function
-
-    png_set_user_transform_info(png_ptr, user_ptr,
-        user_depth, user_channels);
-
-The user's application, not libpng, is responsible for allocating and
-freeing any memory required for the user structure.
-
-You can retrieve the pointer via the function
-png_get_user_transform_ptr().  For example:
-
-    voidp read_user_transform_ptr =
-        png_get_user_transform_ptr(png_ptr);
-
-The last thing to handle is interlacing; this is covered in detail below,
-but you must call the function here if you want libpng to handle expansion
-of the interlaced image.
-
-    number_of_passes = png_set_interlace_handling(png_ptr);
-
-After setting the transformations, libpng can update your png_info
-structure to reflect any transformations you've requested with this
-call.
-
-    png_read_update_info(png_ptr, info_ptr);
-
-This is most useful to update the info structure's rowbytes
-field so you can use it to allocate your image memory.  This function
-will also update your palette with the correct screen_gamma and
-background if these have been given with the calls above.  You may
-only call png_read_update_info() once with a particular info_ptr.
-
-After you call png_read_update_info(), you can allocate any
-memory you need to hold the image.  The row data is simply
-raw byte data for all forms of images.  As the actual allocation
-varies among applications, no example will be given.  If you
-are allocating one large chunk, you will need to build an
-array of pointers to each row, as it will be needed for some
-of the functions below.
-
-Remember: Before you call png_read_update_info(), the png_get_*()
-functions return the values corresponding to the original PNG image.
-After you call png_read_update_info the values refer to the image
-that libpng will output.  Consequently you must call all the png_set_
-functions before you call png_read_update_info().  This is particularly
-important for png_set_interlace_handling() - if you are going to call
-png_read_update_info() you must call png_set_interlace_handling() before
-it unless you want to receive interlaced output.
-
-Reading image data
-
-After you've allocated memory, you can read the image data.
-The simplest way to do this is in one function call.  If you are
-allocating enough memory to hold the whole image, you can just
-call png_read_image() and libpng will read in all the image data
-and put it in the memory area supplied.  You will need to pass in
-an array of pointers to each row.
-
-This function automatically handles interlacing, so you don't
-need to call png_set_interlace_handling() (unless you call
-png_read_update_info()) or call this function multiple times, or any
-of that other stuff necessary with png_read_rows().
-
-   png_read_image(png_ptr, row_pointers);
-
-where row_pointers is:
-
-   png_bytep row_pointers[height];
-
-You can point to void or char or whatever you use for pixels.
-
-If you don't want to read in the whole image at once, you can
-use png_read_rows() instead.  If there is no interlacing (check
-interlace_type == PNG_INTERLACE_NONE), this is simple:
-
-    png_read_rows(png_ptr, row_pointers, NULL,
-        number_of_rows);
-
-where row_pointers is the same as in the png_read_image() call.
-
-If you are doing this just one row at a time, you can do this with
-a single row_pointer instead of an array of row_pointers:
-
-    png_bytep row_pointer = row;
-    png_read_row(png_ptr, row_pointer, NULL);
-
-If the file is interlaced (interlace_type != 0 in the IHDR chunk), things
-get somewhat harder.  The only current (PNG Specification version 1.2)
-interlacing type for PNG is (interlace_type == PNG_INTERLACE_ADAM7);
-a somewhat complicated 2D interlace scheme, known as Adam7, that
-breaks down an image into seven smaller images of varying size, based
-on an 8x8 grid.  This number is defined (from libpng 1.5) as
-PNG_INTERLACE_ADAM7_PASSES in png.h
-
-libpng can fill out those images or it can give them to you "as is".
-It is almost always better to have libpng handle the interlacing for you.
-If you want the images filled out, there are two ways to do that.  The one
-mentioned in the PNG specification is to expand each pixel to cover
-those pixels that have not been read yet (the "rectangle" method).
-This results in a blocky image for the first pass, which gradually
-smooths out as more pixels are read.  The other method is the "sparkle"
-method, where pixels are drawn only in their final locations, with the
-rest of the image remaining whatever colors they were initialized to
-before the start of the read.  The first method usually looks better,
-but tends to be slower, as there are more pixels to put in the rows.
-
-If, as is likely, you want libpng to expand the images, call this before
-calling png_start_read_image() or png_read_update_info():
-
-    if (interlace_type == PNG_INTERLACE_ADAM7)
-       number_of_passes
-           = png_set_interlace_handling(png_ptr);
-
-This will return the number of passes needed.  Currently, this is seven,
-but may change if another interlace type is added.  This function can be
-called even if the file is not interlaced, where it will return one pass.
-You then need to read the whole image 'number_of_passes' times.  Each time
-will distribute the pixels from the current pass to the correct place in
-the output image, so you need to supply the same rows to png_read_rows in
-each pass.
-
-If you are not going to display the image after each pass, but are
-going to wait until the entire image is read in, use the sparkle
-effect.  This effect is faster and the end result of either method
-is exactly the same.  If you are planning on displaying the image
-after each pass, the "rectangle" effect is generally considered the
-better looking one.
-
-If you only want the "sparkle" effect, just call png_read_rows() as
-normal, with the third parameter NULL.  Make sure you make pass over
-the image number_of_passes times, and you don't change the data in the
-rows between calls.  You can change the locations of the data, just
-not the data.  Each pass only writes the pixels appropriate for that
-pass, and assumes the data from previous passes is still valid.
-
-    png_read_rows(png_ptr, row_pointers, NULL,
-        number_of_rows);
-
-If you only want the first effect (the rectangles), do the same as
-before except pass the row buffer in the third parameter, and leave
-the second parameter NULL.
-
-    png_read_rows(png_ptr, NULL, row_pointers,
-        number_of_rows);
-
-If you don't want libpng to handle the interlacing details, just call
-png_read_rows() PNG_INTERLACE_ADAM7_PASSES times to read in all the images.
-Each of the images is a valid image by itself, however you will almost
-certainly need to distribute the pixels from each sub-image to the
-correct place.  This is where everything gets very tricky.
-
-If you want to retrieve the separate images you must pass the correct
-number of rows to each successive call of png_read_rows().  The calculation
-gets pretty complicated for small images, where some sub-images may
-not even exist because either their width or height ends up zero.
-libpng provides two macros to help you in 1.5 and later versions:
-
-   png_uint_32 width = PNG_PASS_COLS(image_width, pass_number);
-   png_uint_32 height = PNG_PASS_ROWS(image_height, pass_number);
-
-Respectively these tell you the width and height of the sub-image
-corresponding to the numbered pass.  'pass' is in in the range 0 to 6 -
-this can be confusing because the specification refers to the same passes
-as 1 to 7!  Be careful, you must check both the width and height before
-calling png_read_rows() and not call it for that pass if either is zero.
-
-You can, of course, read each sub-image row by row.  If you want to
-produce optimal code to make a pixel-by-pixel transformation of an
-interlaced image this is the best approach; read each row of each pass,
-transform it, and write it out to a new interlaced image.
-
-If you want to de-interlace the image yourself libpng provides further
-macros to help that tell you where to place the pixels in the output image.
-Because the interlacing scheme is rectangular - sub-image pixels are always
-arranged on a rectangular grid - all you need to know for each pass is the
-starting column and row in the output image of the first pixel plus the
-spacing between each pixel.  As of libpng 1.5 there are four macros to
-retrieve this information:
-
-   png_uint_32 x = PNG_PASS_START_COL(pass);
-   png_uint_32 y = PNG_PASS_START_ROW(pass);
-   png_uint_32 xStep = 1U << PNG_PASS_COL_SHIFT(pass);
-   png_uint_32 yStep = 1U << PNG_PASS_ROW_SHIFT(pass);
-
-These allow you to write the obvious loop:
-
-   png_uint_32 input_y = 0;
-   png_uint_32 output_y = PNG_PASS_START_ROW(pass);
-
-   while (output_y < output_image_height)
-   {
-      png_uint_32 input_x = 0;
-      png_uint_32 output_x = PNG_PASS_START_COL(pass);
-
-      while (output_x < output_image_width)
-      {
-         image[output_y][output_x] =
-             subimage[pass][input_y][input_x++];
-
-         output_x += xStep;
-      }
-
-      ++input_y;
-      output_y += yStep;
-   }
-
-Notice that the steps between successive output rows and columns are
-returned as shifts.  This is possible because the pixels in the subimages
-are always a power of 2 apart - 1, 2, 4 or 8 pixels - in the original
-image.  In practice you may need to directly calculate the output coordinate
-given an input coordinate.  libpng provides two further macros for this
-purpose:
-
-   png_uint_32 output_x = PNG_COL_FROM_PASS_COL(input_x, pass);
-   png_uint_32 output_y = PNG_ROW_FROM_PASS_ROW(input_y, pass);
-
-Finally a pair of macros are provided to tell you if a particular image
-row or column appears in a given pass:
-
-   int col_in_pass = PNG_COL_IN_INTERLACE_PASS(output_x, pass);
-   int row_in_pass = PNG_ROW_IN_INTERLACE_PASS(output_y, pass);
-
-Bear in mind that you will probably also need to check the width and height
-of the pass in addition to the above to be sure the pass even exists!
-
-With any luck you are convinced by now that you don't want to do your own
-interlace handling.  In reality normally the only good reason for doing this
-is if you are processing PNG files on a pixel-by-pixel basis and don't want
-to load the whole file into memory when it is interlaced.
-
-libpng includes a test program, pngvalid, that illustrates reading and
-writing of interlaced images.  If you can't get interlacing to work in your
-code and don't want to leave it to libpng (the recommended approach), see
-how pngvalid.c does it.
-
-Finishing a sequential read
-
-After you are finished reading the image through the
-low-level interface, you can finish reading the file.  If you are
-interested in comments or time, which may be stored either before or
-after the image data, you should pass the separate png_info struct if
-you want to keep the comments from before and after the image
-separate.
-
-    png_infop end_info = png_create_info_struct(png_ptr);
-
-    if (!end_info)
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-           (png_infopp)NULL);
-       return (ERROR);
-    }
-
-   png_read_end(png_ptr, end_info);
-
-If you are not interested, you should still call png_read_end()
-but you can pass NULL, avoiding the need to create an end_info structure.
-
-   png_read_end(png_ptr, (png_infop)NULL);
-
-If you don't call png_read_end(), then your file pointer will be
-left pointing to the first chunk after the last IDAT, which is probably
-not what you want if you expect to read something beyond the end of
-the PNG datastream.
-
-When you are done, you can free all memory allocated by libpng like this:
-
-   png_destroy_read_struct(&png_ptr, &info_ptr,
-       &end_info);
-
-or, if you didn't create an end_info structure,
-
-   png_destroy_read_struct(&png_ptr, &info_ptr,
-       (png_infopp)NULL);
-
-It is also possible to individually free the info_ptr members that
-point to libpng-allocated storage with the following function:
-
-    png_free_data(png_ptr, info_ptr, mask, seq)
-
-    mask - identifies data to be freed, a mask
-           containing the bitwise OR of one or
-           more of
-             PNG_FREE_PLTE, PNG_FREE_TRNS,
-             PNG_FREE_HIST, PNG_FREE_ICCP,
-             PNG_FREE_PCAL, PNG_FREE_ROWS,
-             PNG_FREE_SCAL, PNG_FREE_SPLT,
-             PNG_FREE_TEXT, PNG_FREE_UNKN,
-           or simply PNG_FREE_ALL
-
-    seq  - sequence number of item to be freed
-           (-1 for all items)
-
-This function may be safely called when the relevant storage has
-already been freed, or has not yet been allocated, or was allocated
-by the user and not by libpng,  and will in those cases do nothing.
-The "seq" parameter is ignored if only one item of the selected data
-type, such as PLTE, is allowed.  If "seq" is not -1, and multiple items
-are allowed for the data type identified in the mask, such as text or
-sPLT, only the n'th item in the structure is freed, where n is "seq".
-
-The default behavior is only to free data that was allocated internally
-by libpng.  This can be changed, so that libpng will not free the data,
-or so that it will free data that was allocated by the user with png_malloc()
-or png_zalloc() and passed in via a png_set_*() function, with
-
-    png_data_freer(png_ptr, info_ptr, freer, mask)
-
-    freer  - one of
-               PNG_DESTROY_WILL_FREE_DATA
-               PNG_SET_WILL_FREE_DATA
-               PNG_USER_WILL_FREE_DATA
-
-    mask   - which data elements are affected
-             same choices as in png_free_data()
-
-This function only affects data that has already been allocated.
-You can call this function after reading the PNG data but before calling
-any png_set_*() functions, to control whether the user or the png_set_*()
-function is responsible for freeing any existing data that might be present,
-and again after the png_set_*() functions to control whether the user
-or png_destroy_*() is supposed to free the data.  When the user assumes
-responsibility for libpng-allocated data, the application must use
-png_free() to free it, and when the user transfers responsibility to libpng
-for data that the user has allocated, the user must have used png_malloc()
-or png_zalloc() to allocate it.
-
-If you allocated your row_pointers in a single block, as suggested above in
-the description of the high level read interface, you must not transfer
-responsibility for freeing it to the png_set_rows or png_read_destroy function,
-because they would also try to free the individual row_pointers[i].
-
-If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
-separately, do not transfer responsibility for freeing text_ptr to libpng,
-because when libpng fills a png_text structure it combines these members with
-the key member, and png_free_data() will free only text_ptr.key.  Similarly,
-if you transfer responsibility for free'ing text_ptr from libpng to your
-application, your application must not separately free those members.
-
-The png_free_data() function will turn off the "valid" flag for anything
-it frees.  If you need to turn the flag off for a chunk that was freed by
-your application instead of by libpng, you can use
-
-    png_set_invalid(png_ptr, info_ptr, mask);
-
-    mask - identifies the chunks to be made invalid,
-           containing the bitwise OR of one or
-           more of
-             PNG_INFO_gAMA, PNG_INFO_sBIT,
-             PNG_INFO_cHRM, PNG_INFO_PLTE,
-             PNG_INFO_tRNS, PNG_INFO_bKGD,
-             PNG_INFO_hIST, PNG_INFO_pHYs,
-             PNG_INFO_oFFs, PNG_INFO_tIME,
-             PNG_INFO_pCAL, PNG_INFO_sRGB,
-             PNG_INFO_iCCP, PNG_INFO_sPLT,
-             PNG_INFO_sCAL, PNG_INFO_IDAT
-
-For a more compact example of reading a PNG image, see the file example.c.
-
-Reading PNG files progressively
-
-The progressive reader is slightly different then the non-progressive
-reader.  Instead of calling png_read_info(), png_read_rows(), and
-png_read_end(), you make one call to png_process_data(), which calls
-callbacks when it has the info, a row, or the end of the image.  You
-set up these callbacks with png_set_progressive_read_fn().  You don't
-have to worry about the input/output functions of libpng, as you are
-giving the library the data directly in png_process_data().  I will
-assume that you have read the section on reading PNG files above,
-so I will only highlight the differences (although I will show
-all of the code).
-
-png_structp png_ptr;
-png_infop info_ptr;
-
- /*  An example code fragment of how you would
-     initialize the progressive reader in your
-     application. */
- int
- initialize_png_reader()
- {
-    png_ptr = png_create_read_struct
-        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-         user_error_fn, user_warning_fn);
-
-    if (!png_ptr)
-        return (ERROR);
-
-    info_ptr = png_create_info_struct(png_ptr);
-
-    if (!info_ptr)
-    {
-       png_destroy_read_struct(&png_ptr,
-          (png_infopp)NULL, (png_infopp)NULL);
-       return (ERROR);
-    }
-
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-          (png_infopp)NULL);
-       return (ERROR);
-    }
-
-    /* This one's new.  You can provide functions
-       to be called when the header info is valid,
-       when each row is completed, and when the image
-       is finished.  If you aren't using all functions,
-       you can specify NULL parameters.  Even when all
-       three functions are NULL, you need to call
-       png_set_progressive_read_fn().  You can use
-       any struct as the user_ptr (cast to a void pointer
-       for the function call), and retrieve the pointer
-       from inside the callbacks using the function
-
-          png_get_progressive_ptr(png_ptr);
-
-       which will return a void pointer, which you have
-       to cast appropriately.
-     */
-    png_set_progressive_read_fn(png_ptr, (void *)user_ptr,
-        info_callback, row_callback, end_callback);
-
-    return 0;
- }
-
- /* A code fragment that you call as you receive blocks
-   of data */
- int
- process_data(png_bytep buffer, png_uint_32 length)
- {
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-       png_destroy_read_struct(&png_ptr, &info_ptr,
-           (png_infopp)NULL);
-       return (ERROR);
-    }
-
-    /* This one's new also.  Simply give it a chunk
-       of data from the file stream (in order, of
-       course).  On machines with segmented memory
-       models machines, don't give it any more than
-       64K.  The library seems to run fine with sizes
-       of 4K. Although you can give it much less if
-       necessary (I assume you can give it chunks of
-       1 byte, I haven't tried less then 256 bytes
-       yet).  When this function returns, you may
-       want to display any rows that were generated
-       in the row callback if you don't already do
-       so there.
-     */
-    png_process_data(png_ptr, info_ptr, buffer, length);
-
-    /* At this point you can call png_process_data_skip if
-       you want to handle data the library will skip yourself;
-       it simply returns the number of bytes to skip (and stops
-       libpng skipping that number of bytes on the next
-       png_process_data call).
-    return 0;
- }
-
- /* This function is called (as set by
-    png_set_progressive_read_fn() above) when enough data
-    has been supplied so all of the header has been
-    read.
- */
- void
- info_callback(png_structp png_ptr, png_infop info)
- {
-    /* Do any setup here, including setting any of
-       the transformations mentioned in the Reading
-       PNG files section.  For now, you _must_ call
-       either png_start_read_image() or
-       png_read_update_info() after all the
-       transformations are set (even if you don't set
-       any).  You may start getting rows before
-       png_process_data() returns, so this is your
-       last chance to prepare for that.
-
-       This is where you turn on interlace handling,
-       assuming you don't want to do it yourself.
-
-       If you need to you can stop the processing of
-       your original input data at this point by calling
-       png_process_data_pause.  This returns the number
-       of unprocessed bytes from the last png_process_data
-       call - it is up to you to ensure that the next call
-       sees these bytes again.  If you don't want to bother
-       with this you can get libpng to cache the unread
-       bytes by setting the 'save' parameter (see png.h) but
-       then libpng will have to copy the data internally.
-     */
- }
-
- /* This function is called when each row of image
-    data is complete */
- void
- row_callback(png_structp png_ptr, png_bytep new_row,
-    png_uint_32 row_num, int pass)
- {
-    /* If the image is interlaced, and you turned
-       on the interlace handler, this function will
-       be called for every row in every pass.  Some
-       of these rows will not be changed from the
-       previous pass.  When the row is not changed,
-       the new_row variable will be NULL.  The rows
-       and passes are called in order, so you don't
-       really need the row_num and pass, but I'm
-       supplying them because it may make your life
-       easier.
-
-       If you did not turn on interlace handling then
-       the callback is called for each row of each
-       sub-image when the image is interlaced.  In this
-       case 'row_num' is the row in the sub-image, not
-       the row in the output image as it is in all other
-       cases.
-
-       For the non-NULL rows of interlaced images when
-       you have switched on libpng interlace handling,
-       you must call png_progressive_combine_row()
-       passing in the row and the old row.  You can
-       call this function for NULL rows (it will just
-       return) and for non-interlaced images (it just
-       does the memcpy for you) if it will make the
-       code easier.  Thus, you can just do this for
-       all cases if you switch on interlace handling;
-     */
-
-        png_progressive_combine_row(png_ptr, old_row,
-          new_row);
-
-    /* where old_row is what was displayed for
-       previously for the row.  Note that the first
-       pass (pass == 0, really) will completely cover
-       the old row, so the rows do not have to be
-       initialized.  After the first pass (and only
-       for interlaced images), you will have to pass
-       the current row, and the function will combine
-       the old row and the new row.
-
-       You can also call png_process_data_pause in this
-       callback - see above.
-    */
- }
-
- void
- end_callback(png_structp png_ptr, png_infop info)
- {
-    /* This function is called after the whole image
-       has been read, including any chunks after the
-       image (up to and including the IEND).  You
-       will usually have the same info chunk as you
-       had in the header, although some data may have
-       been added to the comments and time fields.
-
-       Most people won't do much here, perhaps setting
-       a flag that marks the image as finished.
-     */
- }
-
-
-
-IV. Writing
-
-Much of this is very similar to reading.  However, everything of
-importance is repeated here, so you won't have to constantly look
-back up in the reading section to understand writing.
-
-Setup
-
-You will want to do the I/O initialization before you get into libpng,
-so if it doesn't work, you don't have anything to undo. If you are not
-using the standard I/O functions, you will need to replace them with
-custom writing functions.  See the discussion under Customizing libpng.
-
-    FILE *fp = fopen(file_name, "wb");
-
-    if (!fp)
-       return (ERROR);
-
-Next, png_struct and png_info need to be allocated and initialized.
-As these can be both relatively large, you may not want to store these
-on the stack, unless you have stack space to spare.  Of course, you
-will want to check if they return NULL.  If you are also reading,
-you won't want to name your read structure and your write structure
-both "png_ptr"; you can call them anything you like, such as
-"read_ptr" and "write_ptr".  Look at pngtest.c, for example.
-
-    png_structp png_ptr = png_create_write_struct
-       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn);
-
-    if (!png_ptr)
-       return (ERROR);
-
-    png_infop info_ptr = png_create_info_struct(png_ptr);
-    if (!info_ptr)
-    {
-       png_destroy_write_struct(&png_ptr,
-           (png_infopp)NULL);
-       return (ERROR);
-    }
-
-If you want to use your own memory allocation routines,
-define PNG_USER_MEM_SUPPORTED and use
-png_create_write_struct_2() instead of png_create_write_struct():
-
-    png_structp png_ptr = png_create_write_struct_2
-       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
-        user_error_fn, user_warning_fn, (png_voidp)
-        user_mem_ptr, user_malloc_fn, user_free_fn);
-
-After you have these structures, you will need to set up the
-error handling.  When libpng encounters an error, it expects to
-longjmp() back to your routine.  Therefore, you will need to call
-setjmp() and pass the png_jmpbuf(png_ptr).  If you
-write the file from different routines, you will need to update
-the png_jmpbuf(png_ptr) every time you enter a new routine that will
-call a png_*() function.  See your documentation of setjmp/longjmp
-for your compiler for more information on setjmp/longjmp.  See
-the discussion on libpng error handling in the Customizing Libpng
-section below for more information on the libpng error handling.
-
-    if (setjmp(png_jmpbuf(png_ptr)))
-    {
-    png_destroy_write_struct(&png_ptr, &info_ptr);
-       fclose(fp);
-       return (ERROR);
-    }
-    ...
-    return;
-
-If you would rather avoid the complexity of setjmp/longjmp issues,
-you can compile libpng with PNG_NO_SETJMP, in which case
-errors will result in a call to PNG_ABORT() which defaults to abort().
-
-You can #define PNG_ABORT() to a function that does something
-more useful than abort(), as long as your function does not
-return.
-
-Now you need to set up the output code.  The default for libpng is to
-use the C function fwrite().  If you use this, you will need to pass a
-valid FILE * in the function png_init_io().  Be sure that the file is
-opened in binary mode.  Again, if you wish to handle writing data in
-another way, see the discussion on libpng I/O handling in the Customizing
-Libpng section below.
-
-    png_init_io(png_ptr, fp);
-
-If you are embedding your PNG into a datastream such as MNG, and don't
-want libpng to write the 8-byte signature, or if you have already
-written the signature in your application, use
-
-    png_set_sig_bytes(png_ptr, 8);
-
-to inform libpng that it should not write a signature.
-
-Write callbacks
-
-At this point, you can set up a callback function that will be
-called after each row has been written, which you can use to control
-a progress meter or the like.  It's demonstrated in pngtest.c.
-You must supply a function
-
-    void write_row_callback(png_structp png_ptr, png_uint_32 row,
-       int pass);
-    {
-      /* put your code here */
-    }
-
-(You can give it another name that you like instead of "write_row_callback")
-
-To inform libpng about your function, use
-
-    png_set_write_status_fn(png_ptr, write_row_callback);
-
-When this function is called the row has already been completely processed and
-it has also been written out.  The 'row' and 'pass' refer to the next row to be
-handled.  For the
-non-interlaced case the row that was just handled is simply one less than the
-passed in row number, and pass will always be 0.  For the interlaced case the
-same applies unless the row value is 0, in which case the row just handled was
-the last one from one of the preceding passes.  Because interlacing may skip a
-pass you cannot be sure that the preceding pass is just 'pass-1', if you really
-need to know what the last pass is record (row,pass) from the callback and use
-the last recorded value each time.
-
-As with the user transform you can find the output row using the
-PNG_ROW_FROM_PASS_ROW macro.
-
-You now have the option of modifying how the compression library will
-run.  The following functions are mainly for testing, but may be useful
-in some cases, like if you need to write PNG files extremely fast and
-are willing to give up some compression, or if you want to get the
-maximum possible compression at the expense of slower writing.  If you
-have no special needs in this area, let the library do what it wants by
-not calling this function at all, as it has been tuned to deliver a good
-speed/compression ratio. The second parameter to png_set_filter() is
-the filter method, for which the only valid values are 0 (as of the
-July 1999 PNG specification, version 1.2) or 64 (if you are writing
-a PNG datastream that is to be embedded in a MNG datastream).  The third
-parameter is a flag that indicates which filter type(s) are to be tested
-for each scanline.  See the PNG specification for details on the specific
-filter types.
-
-
-    /* turn on or off filtering, and/or choose
-       specific filters.  You can use either a single
-       PNG_FILTER_VALUE_NAME or the bitwise OR of one
-       or more PNG_FILTER_NAME masks.
-     */
-    png_set_filter(png_ptr, 0,
-       PNG_FILTER_NONE  | PNG_FILTER_VALUE_NONE |
-       PNG_FILTER_SUB   | PNG_FILTER_VALUE_SUB  |
-       PNG_FILTER_UP    | PNG_FILTER_VALUE_UP   |
-       PNG_FILTER_AVG   | PNG_FILTER_VALUE_AVG  |
-       PNG_FILTER_PAETH | PNG_FILTER_VALUE_PAETH|
-       PNG_ALL_FILTERS);
-
-If an application wants to start and stop using particular filters during
-compression, it should start out with all of the filters (to ensure that
-the previous row of pixels will be stored in case it's needed later),
-and then add and remove them after the start of compression.
-
-If you are writing a PNG datastream that is to be embedded in a MNG
-datastream, the second parameter can be either 0 or 64.
-
-The png_set_compression_*() functions interface to the zlib compression
-library, and should mostly be ignored unless you really know what you are
-doing.  The only generally useful call is png_set_compression_level()
-which changes how much time zlib spends on trying to compress the image
-data.  See the Compression Library (zlib.h and algorithm.txt, distributed
-with zlib) for details on the compression levels.
-
-    #include zlib.h
-
-    /* Set the zlib compression level */
-    png_set_compression_level(png_ptr,
-        Z_BEST_COMPRESSION);
-
-    /* Set other zlib parameters for compressing IDAT */
-    png_set_compression_mem_level(png_ptr, 8);
-    png_set_compression_strategy(png_ptr,
-        Z_DEFAULT_STRATEGY);
-    png_set_compression_window_bits(png_ptr, 15);
-    png_set_compression_method(png_ptr, 8);
-    png_set_compression_buffer_size(png_ptr, 8192)
-
-    /* Set zlib parameters for text compression
-     * If you don't call these, the parameters
-     * fall back on those defined for IDAT chunks
-     */
-    png_set_text_compression_mem_level(png_ptr, 8);
-    png_set_text_compression_strategy(png_ptr,
-        Z_DEFAULT_STRATEGY);
-    png_set_text_compression_window_bits(png_ptr, 15);
-    png_set_text_compression_method(png_ptr, 8);
-
-Setting the contents of info for output
-
-You now need to fill in the png_info structure with all the data you
-wish to write before the actual image.  Note that the only thing you
-are allowed to write after the image is the text chunks and the time
-chunk (as of PNG Specification 1.2, anyway).  See png_write_end() and
-the latest PNG specification for more information on that.  If you
-wish to write them before the image, fill them in now, and flag that
-data as being valid.  If you want to wait until after the data, don't
-fill them until png_write_end().  For all the fields in png_info and
-their data types, see png.h.  For explanations of what the fields
-contain, see the PNG specification.
-
-Some of the more important parts of the png_info are:
-
-    png_set_IHDR(png_ptr, info_ptr, width, height,
-       bit_depth, color_type, interlace_type,
-       compression_type, filter_method)
-
-    width          - holds the width of the image
-                     in pixels (up to 2^31).
-
-    height         - holds the height of the image
-                     in pixels (up to 2^31).
-
-    bit_depth      - holds the bit depth of one of the
-                     image channels.
-                     (valid values are 1, 2, 4, 8, 16
-                     and depend also on the
-                     color_type.  See also significant
-                     bits (sBIT) below).
-
-    color_type     - describes which color/alpha
-                     channels are present.
-                     PNG_COLOR_TYPE_GRAY
-                        (bit depths 1, 2, 4, 8, 16)
-                     PNG_COLOR_TYPE_GRAY_ALPHA
-                        (bit depths 8, 16)
-                     PNG_COLOR_TYPE_PALETTE
-                        (bit depths 1, 2, 4, 8)
-                     PNG_COLOR_TYPE_RGB
-                        (bit_depths 8, 16)
-                     PNG_COLOR_TYPE_RGB_ALPHA
-                        (bit_depths 8, 16)
-
-                     PNG_COLOR_MASK_PALETTE
-                     PNG_COLOR_MASK_COLOR
-                     PNG_COLOR_MASK_ALPHA
-
-    interlace_type - PNG_INTERLACE_NONE or
-                     PNG_INTERLACE_ADAM7
-
-    compression_type - (must be
-                     PNG_COMPRESSION_TYPE_DEFAULT)
-
-    filter_method  - (must be PNG_FILTER_TYPE_DEFAULT
-                     or, if you are writing a PNG to
-                     be embedded in a MNG datastream,
-                     can also be
-                     PNG_INTRAPIXEL_DIFFERENCING)
-
-If you call png_set_IHDR(), the call must appear before any of the
-other png_set_*() functions, because they might require access to some of
-the IHDR settings.  The remaining png_set_*() functions can be called
-in any order.
-
-If you wish, you can reset the compression_type, interlace_type, or
-filter_method later by calling png_set_IHDR() again; if you do this, the
-width, height, bit_depth, and color_type must be the same in each call.
-
-    png_set_PLTE(png_ptr, info_ptr, palette,
-       num_palette);
-
-    palette        - the palette for the file
-                     (array of png_color)
-    num_palette    - number of entries in the palette
-
-    png_set_gAMA(png_ptr, info_ptr, file_gamma);
-    png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
-
-    file_gamma     - the gamma at which the image was
-                     created (PNG_INFO_gAMA)
-
-    int_file_gamma - 100,000 times the gamma at which
-                     the image was created
-
-    png_set_cHRM(png_ptr, info_ptr,  white_x, white_y, red_x, red_y,
-                     green_x, green_y, blue_x, blue_y)
-    png_set_cHRM_XYZ(png_ptr, info_ptr, red_X, red_Y, red_Z, green_X,
-                     green_Y, green_Z, blue_X, blue_Y, blue_Z)
-    png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y,
-                     int_red_x, int_red_y, int_green_x, int_green_y,
-                     int_blue_x, int_blue_y)
-    png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, int_red_X, int_red_Y,
-                     int_red_Z, int_green_X, int_green_Y, int_green_Z,
-                     int_blue_X, int_blue_Y, int_blue_Z)
-
-    {white,red,green,blue}_{x,y}
-                     A color space encoding specified using the chromaticities
-                     of the end points and the white point.
-
-    {red,green,blue}_{X,Y,Z}
-                     A color space encoding specified using the encoding end
-                     points - the CIE tristimulus specification of the intended
-                     color of the red, green and blue channels in the PNG RGB
-                     data.  The white point is simply the sum of the three end
-                     points.
-
-    png_set_sRGB(png_ptr, info_ptr, srgb_intent);
-
-    srgb_intent    - the rendering intent
-                     (PNG_INFO_sRGB) The presence of
-                     the sRGB chunk means that the pixel
-                     data is in the sRGB color space.
-                     This chunk also implies specific
-                     values of gAMA and cHRM.  Rendering
-                     intent is the CSS-1 property that
-                     has been defined by the International
-                     Color Consortium
-                     (http://www.color.org).
-                     It can be one of
-                     PNG_sRGB_INTENT_SATURATION,
-                     PNG_sRGB_INTENT_PERCEPTUAL,
-                     PNG_sRGB_INTENT_ABSOLUTE, or
-                     PNG_sRGB_INTENT_RELATIVE.
-
-
-    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,
-       srgb_intent);
-
-    srgb_intent    - the rendering intent
-                     (PNG_INFO_sRGB) The presence of the
-                     sRGB chunk means that the pixel
-                     data is in the sRGB color space.
-                     This function also causes gAMA and
-                     cHRM chunks with the specific values
-                     that are consistent with sRGB to be
-                     written.
-
-    png_set_iCCP(png_ptr, info_ptr, name, compression_type,
-                       profile, proflen);
-
-    name             - The profile name.
-
-    compression_type - The compression type; always
-                       PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
-                       You may give NULL to this argument to
-                       ignore it.
-
-    profile          - International Color Consortium color
-                       profile data. May contain NULs.
-
-    proflen          - length of profile data in bytes.
-
-    png_set_sBIT(png_ptr, info_ptr, sig_bit);
-
-    sig_bit        - the number of significant bits for
-                     (PNG_INFO_sBIT) each of the gray, red,
-                     green, and blue channels, whichever are
-                     appropriate for the given color type
-                     (png_color_16)
-
-    png_set_tRNS(png_ptr, info_ptr, trans_alpha,
-       num_trans, trans_color);
-
-    trans_alpha    - array of alpha (transparency)
-                     entries for palette (PNG_INFO_tRNS)
-
-    num_trans      - number of transparent entries
-                     (PNG_INFO_tRNS)
-
-    trans_color    - graylevel or color sample values
-                     (in order red, green, blue) of the
-                     single transparent color for
-                     non-paletted images (PNG_INFO_tRNS)
-
-    png_set_hIST(png_ptr, info_ptr, hist);
-
-    hist           - histogram of palette (array of
-                     png_uint_16) (PNG_INFO_hIST)
-
-    png_set_tIME(png_ptr, info_ptr, mod_time);
-
-    mod_time       - time image was last modified
-                     (PNG_VALID_tIME)
-
-    png_set_bKGD(png_ptr, info_ptr, background);
-
-    background     - background color (of type
-                     png_color_16p) (PNG_VALID_bKGD)
-
-    png_set_text(png_ptr, info_ptr, text_ptr, num_text);
-
-    text_ptr       - array of png_text holding image
-                     comments
-
-    text_ptr[i].compression - type of compression used
-                 on "text" PNG_TEXT_COMPRESSION_NONE
-                           PNG_TEXT_COMPRESSION_zTXt
-                           PNG_ITXT_COMPRESSION_NONE
-                           PNG_ITXT_COMPRESSION_zTXt
-    text_ptr[i].key   - keyword for comment.  Must contain
-                 1-79 characters.
-    text_ptr[i].text  - text comments for current
-                         keyword.  Can be NULL or empty.
-    text_ptr[i].text_length - length of text string,
-                 after decompression, 0 for iTXt
-    text_ptr[i].itxt_length - length of itxt string,
-                 after decompression, 0 for tEXt/zTXt
-    text_ptr[i].lang  - language of comment (NULL or
-                         empty for unknown).
-    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
-                         or empty for unknown).
-
-    Note that the itxt_length, lang, and lang_key
-    members of the text_ptr structure only exist when the
-    library is built with iTXt chunk support.  Prior to
-    libpng-1.4.0 the library was built by default without
-    iTXt support. Also note that when iTXt is supported,
-    they contain NULL pointers when the "compression"
-    field contains PNG_TEXT_COMPRESSION_NONE or
-    PNG_TEXT_COMPRESSION_zTXt.
-
-    num_text       - number of comments
-
-    png_set_sPLT(png_ptr, info_ptr, &palette_ptr,
-       num_spalettes);
-
-    palette_ptr    - array of png_sPLT_struct structures
-                     to be added to the list of palettes
-                     in the info structure.
-    num_spalettes  - number of palette structures to be
-                     added.
-
-    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
-        unit_type);
-
-    offset_x  - positive offset from the left
-                     edge of the screen
-
-    offset_y  - positive offset from the top
-                     edge of the screen
-
-    unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
-
-    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
-        unit_type);
-
-    res_x       - pixels/unit physical resolution
-                  in x direction
-
-    res_y       - pixels/unit physical resolution
-                  in y direction
-
-    unit_type   - PNG_RESOLUTION_UNKNOWN,
-                  PNG_RESOLUTION_METER
-
-    png_set_sCAL(png_ptr, info_ptr, unit, width, height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-
-    height      - height of a pixel in physical scale units
-                  (width and height are doubles)
-
-    png_set_sCAL_s(png_ptr, info_ptr, unit, width, height)
-
-    unit        - physical scale units (an integer)
-
-    width       - width of a pixel in physical scale units
-                  expressed as a string
-
-    height      - height of a pixel in physical scale units
-                 (width and height are strings like "2.54")
-
-    png_set_unknown_chunks(png_ptr, info_ptr, &unknowns,
-       num_unknowns)
-
-    unknowns          - array of png_unknown_chunk
-                        structures holding unknown chunks
-    unknowns[i].name  - name of unknown chunk
-    unknowns[i].data  - data of unknown chunk
-    unknowns[i].size  - size of unknown chunk's data
-    unknowns[i].location - position to write chunk in file
-                           0: do not write chunk
-                           PNG_HAVE_IHDR: before PLTE
-                           PNG_HAVE_PLTE: before IDAT
-                           PNG_AFTER_IDAT: after IDAT
-
-The "location" member is set automatically according to
-what part of the output file has already been written.
-You can change its value after calling png_set_unknown_chunks()
-as demonstrated in pngtest.c.  Within each of the "locations",
-the chunks are sequenced according to their position in the
-structure (that is, the value of "i", which is the order in which
-the chunk was either read from the input file or defined with
-png_set_unknown_chunks).
-
-A quick word about text and num_text.  text is an array of png_text
-structures.  num_text is the number of valid structures in the array.
-Each png_text structure holds a language code, a keyword, a text value,
-and a compression type.
-
-The compression types have the same valid numbers as the compression
-types of the image data.  Currently, the only valid number is zero.
-However, you can store text either compressed or uncompressed, unlike
-images, which always have to be compressed.  So if you don't want the
-text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
-Because tEXt and zTXt chunks don't have a language field, if you
-specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt
-any language code or translated keyword will not be written out.
-
-Until text gets around a few hundred bytes, it is not worth compressing it.
-After the text has been written out to the file, the compression type
-is set to PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR,
-so that it isn't written out again at the end (in case you are calling
-png_write_end() with the same struct).
-
-The keywords that are given in the PNG Specification are:
-
-    Title            Short (one line) title or
-                     caption for image
-
-    Author           Name of image's creator
-
-    Description      Description of image (possibly long)
-
-    Copyright        Copyright notice
-
-    Creation Time    Time of original image creation
-                     (usually RFC 1123 format, see below)
-
-    Software         Software used to create the image
-
-    Disclaimer       Legal disclaimer
-
-    Warning          Warning of nature of content
-
-    Source           Device used to create the image
-
-    Comment          Miscellaneous comment; conversion
-                     from other image format
-
-The keyword-text pairs work like this.  Keywords should be short
-simple descriptions of what the comment is about.  Some typical
-keywords are found in the PNG specification, as is some recommendations
-on keywords.  You can repeat keywords in a file.  You can even write
-some text before the image and some after.  For example, you may want
-to put a description of the image before the image, but leave the
-disclaimer until after, so viewers working over modem connections
-don't have to wait for the disclaimer to go over the modem before
-they start seeing the image.  Finally, keywords should be full
-words, not abbreviations.  Keywords and text are in the ISO 8859-1
-(Latin-1) character set (a superset of regular ASCII) and can not
-contain NUL characters, and should not contain control or other
-unprintable characters.  To make the comments widely readable, stick
-with basic ASCII, and avoid machine specific character set extensions
-like the IBM-PC character set.  The keyword must be present, but
-you can leave off the text string on non-compressed pairs.
-Compressed pairs must have a text string, as only the text string
-is compressed anyway, so the compression would be meaningless.
-
-PNG supports modification time via the png_time structure.  Two
-conversion routines are provided, png_convert_from_time_t() for
-time_t and png_convert_from_struct_tm() for struct tm.  The
-time_t routine uses gmtime().  You don't have to use either of
-these, but if you wish to fill in the png_time structure directly,
-you should provide the time in universal time (GMT) if possible
-instead of your local time.  Note that the year number is the full
-year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and
-that months start with 1.
-
-If you want to store the time of the original image creation, you should
-use a plain tEXt chunk with the "Creation Time" keyword.  This is
-necessary because the "creation time" of a PNG image is somewhat vague,
-depending on whether you mean the PNG file, the time the image was
-created in a non-PNG format, a still photo from which the image was
-scanned, or possibly the subject matter itself.  In order to facilitate
-machine-readable dates, it is recommended that the "Creation Time"
-tEXt chunk use RFC 1123 format dates (e.g. "22 May 1997 18:07:10 GMT"),
-although this isn't a requirement.  Unlike the tIME chunk, the
-"Creation Time" tEXt chunk is not expected to be automatically changed
-by the software.  To facilitate the use of RFC 1123 dates, a function
-png_convert_to_rfc1123(png_timep) is provided to convert from PNG
-time to an RFC 1123 format string.
-
-Writing unknown chunks
-
-You can use the png_set_unknown_chunks function to queue up chunks
-for writing.  You give it a chunk name, raw data, and a size; that's
-all there is to it.  The chunks will be written by the next following
-png_write_info_before_PLTE, png_write_info, or png_write_end function.
-Any chunks previously read into the info structure's unknown-chunk
-list will also be written out in a sequence that satisfies the PNG
-specification's ordering rules.
-
-The high-level write interface
-
-At this point there are two ways to proceed; through the high-level
-write interface, or through a sequence of low-level write operations.
-You can use the high-level interface if your image data is present
-in the info structure.  All defined output
-transformations are permitted, enabled by the following masks.
-
-    PNG_TRANSFORM_IDENTITY      No transformation
-    PNG_TRANSFORM_PACKING       Pack 1, 2 and 4-bit samples
-    PNG_TRANSFORM_PACKSWAP      Change order of packed
-                                pixels to LSB first
-    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
-    PNG_TRANSFORM_SHIFT         Normalize pixels to the
-                                sBIT depth
-    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA
-                                to BGRA
-    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA
-                                to AG
-    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity
-                                to transparency
-    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
-    PNG_TRANSFORM_STRIP_FILLER        Strip out filler
-                                      bytes (deprecated).
-    PNG_TRANSFORM_STRIP_FILLER_BEFORE Strip out leading
-                                      filler bytes
-    PNG_TRANSFORM_STRIP_FILLER_AFTER  Strip out trailing
-                                      filler bytes
-
-If you have valid image data in the info structure (you can use
-png_set_rows() to put image data in the info structure), simply do this:
-
-    png_write_png(png_ptr, info_ptr, png_transforms, NULL)
-
-where png_transforms is an integer containing the bitwise OR of some set of
-transformation flags.  This call is equivalent to png_write_info(),
-followed the set of transformations indicated by the transform mask,
-then png_write_image(), and finally png_write_end().
-
-(The final parameter of this call is not yet used.  Someday it might point
-to transformation parameters required by some future output transform.)
-
-You must use png_transforms and not call any png_set_transform() functions
-when you use png_write_png().
-
-The low-level write interface
-
-If you are going the low-level route instead, you are now ready to
-write all the file information up to the actual image data.  You do
-this with a call to png_write_info().
-
-    png_write_info(png_ptr, info_ptr);
-
-Note that there is one transformation you may need to do before
-png_write_info().  In PNG files, the alpha channel in an image is the
-level of opacity.  If your data is supplied as a level of transparency,
-you can invert the alpha channel before you write it, so that 0 is
-fully transparent and 255 (in 8-bit or paletted images) or 65535
-(in 16-bit images) is fully opaque, with
-
-    png_set_invert_alpha(png_ptr);
-
-This must appear before png_write_info() instead of later with the
-other transformations because in the case of paletted images the tRNS
-chunk data has to be inverted before the tRNS chunk is written.  If
-your image is not a paletted image, the tRNS data (which in such cases
-represents a single color to be rendered as transparent) won't need to
-be changed, and you can safely do this transformation after your
-png_write_info() call.
-
-If you need to write a private chunk that you want to appear before
-the PLTE chunk when PLTE is present, you can write the PNG info in
-two steps, and insert code to write your own chunk between them:
-
-    png_write_info_before_PLTE(png_ptr, info_ptr);
-    png_set_unknown_chunks(png_ptr, info_ptr, ...);
-    png_write_info(png_ptr, info_ptr);
-
-After you've written the file information, you can set up the library
-to handle any special transformations of the image data.  The various
-ways to transform the data will be described in the order that they
-should occur.  This is important, as some of these change the color
-type and/or bit depth of the data, and some others only work on
-certain color types and bit depths.  Even though each transformation
-checks to see if it has data that it can do something with, you should
-make sure to only enable a transformation if it will be valid for the
-data.  For example, don't swap red and blue on grayscale data.
-
-PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells
-the library to strip input data that has 4 or 8 bytes per pixel down
-to 3 or 6 bytes (or strip 2 or 4-byte grayscale+filler data to 1 or 2
-bytes per pixel).
-
-    png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
-
-where the 0 is unused, and the location is either PNG_FILLER_BEFORE or
-PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
-is stored XRGB or RGBX.
-
-PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
-they can, resulting in, for example, 8 pixels per byte for 1 bit files.
-If the data is supplied at 1 pixel per byte, use this code, which will
-correctly pack the pixels into a single byte:
-
-    png_set_packing(png_ptr);
-
-PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  If your
-data is of another bit depth, you can write an sBIT chunk into the
-file so that decoders can recover the original data if desired.
-
-    /* Set the true bit depth of the image data */
-    if (color_type & PNG_COLOR_MASK_COLOR)
-    {
-       sig_bit.red = true_bit_depth;
-       sig_bit.green = true_bit_depth;
-       sig_bit.blue = true_bit_depth;
-    }
-
-    else
-    {
-       sig_bit.gray = true_bit_depth;
-    }
-
-    if (color_type & PNG_COLOR_MASK_ALPHA)
-    {
-       sig_bit.alpha = true_bit_depth;
-    }
-
-    png_set_sBIT(png_ptr, info_ptr, &sig_bit);
-
-If the data is stored in the row buffer in a bit depth other than
-one supported by PNG (e.g. 3 bit data in the range 0-7 for a 4-bit PNG),
-this will scale the values to appear to be the correct bit depth as
-is required by PNG.
-
-    png_set_shift(png_ptr, &sig_bit);
-
-PNG files store 16-bit pixels in network byte order (big-endian,
-ie. most significant bits first).  This code would be used if they are
-supplied the other way (little-endian, i.e. least significant bits
-first, the way PCs store them):
-
-    if (bit_depth > 8)
-       png_set_swap(png_ptr);
-
-If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
-need to change the order the pixels are packed into bytes, you can use:
-
-    if (bit_depth < 8)
-       png_set_packswap(png_ptr);
-
-PNG files store 3 color pixels in red, green, blue order.  This code
-would be used if they are supplied as blue, green, red:
-
-    png_set_bgr(png_ptr);
-
-PNG files describe monochrome as black being zero and white being
-one. This code would be used if the pixels are supplied with this reversed
-(black being one and white being zero):
-
-    png_set_invert_mono(png_ptr);
-
-Finally, you can write your own transformation function if none of
-the existing ones meets your needs.  This is done by setting a callback
-with
-
-    png_set_write_user_transform_fn(png_ptr,
-       write_transform_fn);
-
-You must supply the function
-
-    void write_transform_fn(png_structp png_ptr, png_row_infop
-       row_info, png_bytep data)
-
-See pngtest.c for a working example.  Your function will be called
-before any of the other transformations are processed.  If supported
-libpng also supplies an information routine that may be called from
-your callback:
-
-   png_get_current_row_number(png_ptr);
-   png_get_current_pass_number(png_ptr);
-
-This returns the current row passed to the transform.  With interlaced
-images the value returned is the row in the input sub-image image.  Use
-PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
-find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
-
-The discussion of interlace handling above contains more information on how to
-use these values.
-
-You can also set up a pointer to a user structure for use by your
-callback function.
-
-    png_set_user_transform_info(png_ptr, user_ptr, 0, 0);
-
-The user_channels and user_depth parameters of this function are ignored
-when writing; you can set them to zero as shown.
-
-You can retrieve the pointer via the function png_get_user_transform_ptr().
-For example:
-
-    voidp write_user_transform_ptr =
-       png_get_user_transform_ptr(png_ptr);
-
-It is possible to have libpng flush any pending output, either manually,
-or automatically after a certain number of lines have been written.  To
-flush the output stream a single time call:
-
-    png_write_flush(png_ptr);
-
-and to have libpng flush the output stream periodically after a certain
-number of scanlines have been written, call:
-
-    png_set_flush(png_ptr, nrows);
-
-Note that the distance between rows is from the last time png_write_flush()
-was called, or the first row of the image if it has never been called.
-So if you write 50 lines, and then png_set_flush 25, it will flush the
-output on the next scanline, and every 25 lines thereafter, unless
-png_write_flush() is called before 25 more lines have been written.
-If nrows is too small (less than about 10 lines for a 640 pixel wide
-RGB image) the image compression may decrease noticeably (although this
-may be acceptable for real-time applications).  Infrequent flushing will
-only degrade the compression performance by a few percent over images
-that do not use flushing.
-
-Writing the image data
-
-That's it for the transformations.  Now you can write the image data.
-The simplest way to do this is in one function call.  If you have the
-whole image in memory, you can just call png_write_image() and libpng
-will write the image.  You will need to pass in an array of pointers to
-each row.  This function automatically handles interlacing, so you don't
-need to call png_set_interlace_handling() or call this function multiple
-times, or any of that other stuff necessary with png_write_rows().
-
-    png_write_image(png_ptr, row_pointers);
-
-where row_pointers is:
-
-    png_byte *row_pointers[height];
-
-You can point to void or char or whatever you use for pixels.
-
-If you don't want to write the whole image at once, you can
-use png_write_rows() instead.  If the file is not interlaced,
-this is simple:
-
-    png_write_rows(png_ptr, row_pointers,
-       number_of_rows);
-
-row_pointers is the same as in the png_write_image() call.
-
-If you are just writing one row at a time, you can do this with
-a single row_pointer instead of an array of row_pointers:
-
-    png_bytep row_pointer = row;
-
-    png_write_row(png_ptr, row_pointer);
-
-When the file is interlaced, things can get a good deal more complicated.
-The only currently (as of the PNG Specification version 1.2, dated July
-1999) defined interlacing scheme for PNG files is the "Adam7" interlace
-scheme, that breaks down an image into seven smaller images of varying
-size.  libpng will build these images for you, or you can do them
-yourself.  If you want to build them yourself, see the PNG specification
-for details of which pixels to write when.
-
-If you don't want libpng to handle the interlacing details, just
-use png_set_interlace_handling() and call png_write_rows() the
-correct number of times to write all the sub-images
-(png_set_interlace_handling() returns the number of sub-images.)
-
-If you want libpng to build the sub-images, call this before you start
-writing any rows:
-
-    number_of_passes = png_set_interlace_handling(png_ptr);
-
-This will return the number of passes needed.  Currently, this is seven,
-but may change if another interlace type is added.
-
-Then write the complete image number_of_passes times.
-
-    png_write_rows(png_ptr, row_pointers, number_of_rows);
-
-Think carefully before you write an interlaced image.  Typically code that
-reads such images reads all the image data into memory, uncompressed, before
-doing any processing.  Only code that can display an image on the fly can
-take advantage of the interlacing and even then the image has to be exactly
-the correct size for the output device, because scaling an image requires
-adjacent pixels and these are not available until all the passes have been
-read.
-
-If you do write an interlaced image you will hardly ever need to handle
-the interlacing yourself.  Call png_set_interlace_handling() and use the
-approach described above.
-
-The only time it is conceivable that you will really need to write an
-interlaced image pass-by-pass is when you have read one pass by pass and
-made some pixel-by-pixel transformation to it, as described in the read
-code above.  In this case use the PNG_PASS_ROWS and PNG_PASS_COLS macros
-to determine the size of each sub-image in turn and simply write the rows
-you obtained from the read code.
-
-Finishing a sequential write
-
-After you are finished writing the image, you should finish writing
-the file.  If you are interested in writing comments or time, you should
-pass an appropriately filled png_info pointer.  If you are not interested,
-you can pass NULL.
-
-    png_write_end(png_ptr, info_ptr);
-
-When you are done, you can free all memory used by libpng like this:
-
-    png_destroy_write_struct(&png_ptr, &info_ptr);
-
-It is also possible to individually free the info_ptr members that
-point to libpng-allocated storage with the following function:
-
-    png_free_data(png_ptr, info_ptr, mask, seq)
-
-    mask  - identifies data to be freed, a mask
-            containing the bitwise OR of one or
-            more of
-              PNG_FREE_PLTE, PNG_FREE_TRNS,
-              PNG_FREE_HIST, PNG_FREE_ICCP,
-              PNG_FREE_PCAL, PNG_FREE_ROWS,
-              PNG_FREE_SCAL, PNG_FREE_SPLT,
-              PNG_FREE_TEXT, PNG_FREE_UNKN,
-            or simply PNG_FREE_ALL
-
-    seq   - sequence number of item to be freed
-            (-1 for all items)
-
-This function may be safely called when the relevant storage has
-already been freed, or has not yet been allocated, or was allocated
-by the user  and not by libpng,  and will in those cases do nothing.
-The "seq" parameter is ignored if only one item of the selected data
-type, such as PLTE, is allowed.  If "seq" is not -1, and multiple items
-are allowed for the data type identified in the mask, such as text or
-sPLT, only the n'th item in the structure is freed, where n is "seq".
-
-If you allocated data such as a palette that you passed in to libpng
-with png_set_*, you must not free it until just before the call to
-png_destroy_write_struct().
-
-The default behavior is only to free data that was allocated internally
-by libpng.  This can be changed, so that libpng will not free the data,
-or so that it will free data that was allocated by the user with png_malloc()
-or png_zalloc() and passed in via a png_set_*() function, with
-
-    png_data_freer(png_ptr, info_ptr, freer, mask)
-
-    freer  - one of
-               PNG_DESTROY_WILL_FREE_DATA
-               PNG_SET_WILL_FREE_DATA
-               PNG_USER_WILL_FREE_DATA
-
-    mask   - which data elements are affected
-             same choices as in png_free_data()
-
-For example, to transfer responsibility for some data from a read structure
-to a write structure, you could use
-
-    png_data_freer(read_ptr, read_info_ptr,
-       PNG_USER_WILL_FREE_DATA,
-       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
-
-    png_data_freer(write_ptr, write_info_ptr,
-       PNG_DESTROY_WILL_FREE_DATA,
-       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
-
-thereby briefly reassigning responsibility for freeing to the user but
-immediately afterwards reassigning it once more to the write_destroy
-function.  Having done this, it would then be safe to destroy the read
-structure and continue to use the PLTE, tRNS, and hIST data in the write
-structure.
-
-This function only affects data that has already been allocated.
-You can call this function before calling after the png_set_*() functions
-to control whether the user or png_destroy_*() is supposed to free the data.
-When the user assumes responsibility for libpng-allocated data, the
-application must use
-png_free() to free it, and when the user transfers responsibility to libpng
-for data that the user has allocated, the user must have used png_malloc()
-or png_zalloc() to allocate it.
-
-If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
-separately, do not transfer responsibility for freeing text_ptr to libpng,
-because when libpng fills a png_text structure it combines these members with
-the key member, and png_free_data() will free only text_ptr.key.  Similarly,
-if you transfer responsibility for free'ing text_ptr from libpng to your
-application, your application must not separately free those members.
-For a more compact example of writing a PNG image, see the file example.c.
-
-V. Modifying/Customizing libpng:
-
-There are two issues here.  The first is changing how libpng does
-standard things like memory allocation, input/output, and error handling.
-The second deals with more complicated things like adding new chunks,
-adding new transformations, and generally changing how libpng works.
-Both of those are compile-time issues; that is, they are generally
-determined at the time the code is written, and there is rarely a need
-to provide the user with a means of changing them.
-
-Memory allocation, input/output, and error handling
-
-All of the memory allocation, input/output, and error handling in libpng
-goes through callbacks that are user-settable.  The default routines are
-in pngmem.c, pngrio.c, pngwio.c, and pngerror.c, respectively.  To change
-these functions, call the appropriate png_set_*_fn() function.
-
-Memory allocation is done through the functions png_malloc(), png_calloc(),
-and png_free().  These currently just call the standard C functions.
-png_calloc() calls png_malloc() and then clears the newly
-allocated memory to zero.  There is limited support for certain systems
-with segmented memory architectures and the types of pointers declared by
-png.h match this; you will have to use appropriate pointers in your
-application.  Since it is
-unlikely that the method of handling memory allocation on a platform
-will change between applications, these functions must be modified in
-the library at compile time.  If you prefer to use a different method
-of allocating and freeing data, you can use png_create_read_struct_2() or
-png_create_write_struct_2() to register your own functions as described
-above.  These functions also provide a void pointer that can be retrieved
-via
-
-    mem_ptr=png_get_mem_ptr(png_ptr);
-
-Your replacement memory functions must have prototypes as follows:
-
-    png_voidp malloc_fn(png_structp png_ptr,
-       png_alloc_size_t size);
-
-    void free_fn(png_structp png_ptr, png_voidp ptr);
-
-Your malloc_fn() must return NULL in case of failure.  The png_malloc()
-function will normally call png_error() if it receives a NULL from the
-system memory allocator or from your replacement malloc_fn().
-
-Your free_fn() will never be called with a NULL ptr, since libpng's
-png_free() checks for NULL before calling free_fn().
-
-Input/Output in libpng is done through png_read() and png_write(),
-which currently just call fread() and fwrite().  The FILE * is stored in
-png_struct and is initialized via png_init_io().  If you wish to change
-the method of I/O, the library supplies callbacks that you can set
-through the function png_set_read_fn() and png_set_write_fn() at run
-time, instead of calling the png_init_io() function.  These functions
-also provide a void pointer that can be retrieved via the function
-png_get_io_ptr().  For example:
-
-    png_set_read_fn(png_structp read_ptr,
-        voidp read_io_ptr, png_rw_ptr read_data_fn)
-
-    png_set_write_fn(png_structp write_ptr,
-        voidp write_io_ptr, png_rw_ptr write_data_fn,
-        png_flush_ptr output_flush_fn);
-
-    voidp read_io_ptr = png_get_io_ptr(read_ptr);
-    voidp write_io_ptr = png_get_io_ptr(write_ptr);
-
-The replacement I/O functions must have prototypes as follows:
-
-    void user_read_data(png_structp png_ptr,
-        png_bytep data, png_size_t length);
-
-    void user_write_data(png_structp png_ptr,
-        png_bytep data, png_size_t length);
-
-    void user_flush_data(png_structp png_ptr);
-
-The user_read_data() function is responsible for detecting and
-handling end-of-data errors.
-
-Supplying NULL for the read, write, or flush functions sets them back
-to using the default C stream functions, which expect the io_ptr to
-point to a standard *FILE structure.  It is probably a mistake
-to use NULL for one of write_data_fn and output_flush_fn but not both
-of them, unless you have built libpng with PNG_NO_WRITE_FLUSH defined.
-It is an error to read from a write stream, and vice versa.
-
-Error handling in libpng is done through png_error() and png_warning().
-Errors handled through png_error() are fatal, meaning that png_error()
-should never return to its caller.  Currently, this is handled via
-setjmp() and longjmp() (unless you have compiled libpng with
-PNG_NO_SETJMP, in which case it is handled via PNG_ABORT()),
-but you could change this to do things like exit() if you should wish,
-as long as your function does not return.
-
-On non-fatal errors, png_warning() is called
-to print a warning message, and then control returns to the calling code.
-By default png_error() and png_warning() print a message on stderr via
-fprintf() unless the library is compiled with PNG_NO_CONSOLE_IO defined
-(because you don't want the messages) or PNG_NO_STDIO defined (because
-fprintf() isn't available).  If you wish to change the behavior of the error
-functions, you will need to set up your own message callbacks.  These
-functions are normally supplied at the time that the png_struct is created.
-It is also possible to redirect errors and warnings to your own replacement
-functions after png_create_*_struct() has been called by calling:
-
-    png_set_error_fn(png_structp png_ptr,
-        png_voidp error_ptr, png_error_ptr error_fn,
-        png_error_ptr warning_fn);
-
-    png_voidp error_ptr = png_get_error_ptr(png_ptr);
-
-If NULL is supplied for either error_fn or warning_fn, then the libpng
-default function will be used, calling fprintf() and/or longjmp() if a
-problem is encountered.  The replacement error functions should have
-parameters as follows:
-
-    void user_error_fn(png_structp png_ptr,
-        png_const_charp error_msg);
-
-    void user_warning_fn(png_structp png_ptr,
-        png_const_charp warning_msg);
-
-The motivation behind using setjmp() and longjmp() is the C++ throw and
-catch exception handling methods.  This makes the code much easier to write,
-as there is no need to check every return code of every function call.
-However, there are some uncertainties about the status of local variables
-after a longjmp, so the user may want to be careful about doing anything
-after setjmp returns non-zero besides returning itself.  Consult your
-compiler documentation for more details.  For an alternative approach, you
-may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net),
-which is illustrated in pngvalid.c and in contrib/visupng.
-
-Custom chunks
-
-If you need to read or write custom chunks, you may need to get deeper
-into the libpng code.  The library now has mechanisms for storing
-and writing chunks of unknown type; you can even declare callbacks
-for custom chunks.  However, this may not be good enough if the
-library code itself needs to know about interactions between your
-chunk and existing `intrinsic' chunks.
-
-If you need to write a new intrinsic chunk, first read the PNG
-specification. Acquire a first level of understanding of how it works.
-Pay particular attention to the sections that describe chunk names,
-and look at how other chunks were designed, so you can do things
-similarly.  Second, check out the sections of libpng that read and
-write chunks.  Try to find a chunk that is similar to yours and use
-it as a template.  More details can be found in the comments inside
-the code.  It is best to handle private or unknown chunks in a generic method,
-via callback functions, instead of by modifying libpng functions. This
-is illustrated in pngtest.c, which uses a callback function to handle a
-private "vpAg" chunk and the new "sTER" chunk, which are both unknown to
-libpng.
-
-If you wish to write your own transformation for the data, look through
-the part of the code that does the transformations, and check out some of
-the simpler ones to get an idea of how they work.  Try to find a similar
-transformation to the one you want to add and copy off of it.  More details
-can be found in the comments inside the code itself.
-
-Configuring for 16-bit platforms
-
-You will want to look into zconf.h to tell zlib (and thus libpng) that
-it cannot allocate more then 64K at a time.  Even if you can, the memory
-won't be accessible.  So limit zlib and libpng to 64K by defining MAXSEG_64K.
-
-Configuring for DOS
-
-For DOS users who only have access to the lower 640K, you will
-have to limit zlib's memory usage via a png_set_compression_mem_level()
-call.  See zlib.h or zconf.h in the zlib library for more information.
-
-Configuring for Medium Model
-
-Libpng's support for medium model has been tested on most of the popular
-compilers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
-defined, and FAR gets defined to far in pngconf.h, and you should be
-all set.  Everything in the library (except for zlib's structure) is
-expecting far data.  You must use the typedefs with the p or pp on
-the end for pointers (or at least look at them and be careful).  Make
-note that the rows of data are defined as png_bytepp, which is
-an "unsigned char far * far *".
-
-Configuring for gui/windowing platforms:
-
-You will need to write new error and warning functions that use the GUI
-interface, as described previously, and set them to be the error and
-warning functions at the time that png_create_*_struct() is called,
-in order to have them available during the structure initialization.
-They can be changed later via png_set_error_fn().  On some compilers,
-you may also have to change the memory allocators (png_malloc, etc.).
-
-Configuring for compiler xxx:
-
-All includes for libpng are in pngconf.h.  If you need to add, change
-or delete an include, this is the place to do it.
-The includes that are not needed outside libpng are placed in pngpriv.h,
-which is only used by the routines inside libpng itself.
-The files in libpng proper only include pngpriv.h and png.h, which
-in turn includes pngconf.h and, as of libpng-1.5.0, pnglibconf.h.
-As of libpng-1.5.0, pngpriv.h also includes three other private header
-files, pngstruct.h, pnginfo.h, and pngdebug.h, which contain material
-that previously appeared in the public headers.
-
-Configuring zlib:
-
-There are special functions to configure the compression.  Perhaps the
-most useful one changes the compression level, which currently uses
-input compression values in the range 0 - 9.  The library normally
-uses the default compression level (Z_DEFAULT_COMPRESSION = 6).  Tests
-have shown that for a large majority of images, compression values in
-the range 3-6 compress nearly as well as higher levels, and do so much
-faster.  For online applications it may be desirable to have maximum speed
-(Z_BEST_SPEED = 1).  With versions of zlib after v0.99, you can also
-specify no compression (Z_NO_COMPRESSION = 0), but this would create
-files larger than just storing the raw bitmap.  You can specify the
-compression level by calling:
-
-    #include zlib.h
-    png_set_compression_level(png_ptr, level);
-
-Another useful one is to reduce the memory level used by the library.
-The memory level defaults to 8, but it can be lowered if you are
-short on memory (running DOS, for example, where you only have 640K).
-Note that the memory level does have an effect on compression; among
-other things, lower levels will result in sections of incompressible
-data being emitted in smaller stored blocks, with a correspondingly
-larger relative overhead of up to 15% in the worst case.
-
-    #include zlib.h
-    png_set_compression_mem_level(png_ptr, level);
-
-The other functions are for configuring zlib.  They are not recommended
-for normal use and may result in writing an invalid PNG file.  See
-zlib.h for more information on what these mean.
-
-    #include zlib.h
-    png_set_compression_strategy(png_ptr,
-        strategy);
-
-    png_set_compression_window_bits(png_ptr,
-        window_bits);
-
-    png_set_compression_method(png_ptr, method);
-
-    png_set_compression_buffer_size(png_ptr, size);
-
-As of libpng version 1.5.4, additional APIs became
-available to set these separately for non-IDAT
-compressed chunks such as zTXt, iTXt, and iCCP:
-
-    #include zlib.h
-    #if PNG_LIBPNG_VER <= 10504
-    png_set_text_compression_level(png_ptr, level);
-
-    png_set_text_compression_mem_level(png_ptr, level);
-
-    png_set_text_compression_strategy(png_ptr,
-        strategy);
-
-    png_set_text_compression_window_bits(png_ptr,
-        window_bits);
-
-    png_set_text_compression_method(png_ptr, method);
-    #endif
-
-Controlling row filtering
-
-If you want to control whether libpng uses filtering or not, which
-filters are used, and how it goes about picking row filters, you
-can call one of these functions.  The selection and configuration
-of row filters can have a significant impact on the size and
-encoding speed and a somewhat lesser impact on the decoding speed
-of an image.  Filtering is enabled by default for RGB and grayscale
-images (with and without alpha), but not for paletted images nor
-for any images with bit depths less than 8 bits/pixel.
-
-The 'method' parameter sets the main filtering method, which is
-currently only '0' in the PNG 1.2 specification.  The 'filters'
-parameter sets which filter(s), if any, should be used for each
-scanline.  Possible values are PNG_ALL_FILTERS and PNG_NO_FILTERS
-to turn filtering on and off, respectively.
-
-Individual filter types are PNG_FILTER_NONE, PNG_FILTER_SUB,
-PNG_FILTER_UP, PNG_FILTER_AVG, PNG_FILTER_PAETH, which can be bitwise
-ORed together with '|' to specify one or more filters to use.
-These filters are described in more detail in the PNG specification.
-If you intend to change the filter type during the course of writing
-the image, you should start with flags set for all of the filters
-you intend to use so that libpng can initialize its internal
-structures appropriately for all of the filter types.  (Note that this
-means the first row must always be adaptively filtered, because libpng
-currently does not allocate the filter buffers until png_write_row()
-is called for the first time.)
-
-    filters = PNG_FILTER_NONE | PNG_FILTER_SUB
-              PNG_FILTER_UP | PNG_FILTER_AVG |
-              PNG_FILTER_PAETH | PNG_ALL_FILTERS;
-
-    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,
-       filters);
-              The second parameter can also be
-              PNG_INTRAPIXEL_DIFFERENCING if you are
-              writing a PNG to be embedded in a MNG
-              datastream.  This parameter must be the
-              same as the value of filter_method used
-              in png_set_IHDR().
-
-It is also possible to influence how libpng chooses from among the
-available filters.  This is done in one or both of two ways - by
-telling it how important it is to keep the same filter for successive
-rows, and by telling it the relative computational costs of the filters.
-
-    double weights[3] = {1.5, 1.3, 1.1},
-       costs[PNG_FILTER_VALUE_LAST] =
-       {1.0, 1.3, 1.3, 1.5, 1.7};
-
-    png_set_filter_heuristics(png_ptr,
-       PNG_FILTER_HEURISTIC_WEIGHTED, 3,
-       weights, costs);
-
-The weights are multiplying factors that indicate to libpng that the
-row filter should be the same for successive rows unless another row filter
-is that many times better than the previous filter.  In the above example,
-if the previous 3 filters were SUB, SUB, NONE, the SUB filter could have a
-"sum of absolute differences" 1.5 x 1.3 times higher than other filters
-and still be chosen, while the NONE filter could have a sum 1.1 times
-higher than other filters and still be chosen.  Unspecified weights are
-taken to be 1.0, and the specified weights should probably be declining
-like those above in order to emphasize recent filters over older filters.
-
-The filter costs specify for each filter type a relative decoding cost
-to be considered when selecting row filters.  This means that filters
-with higher costs are less likely to be chosen over filters with lower
-costs, unless their "sum of absolute differences" is that much smaller.
-The costs do not necessarily reflect the exact computational speeds of
-the various filters, since this would unduly influence the final image
-size.
-
-Note that the numbers above were invented purely for this example and
-are given only to help explain the function usage.  Little testing has
-been done to find optimum values for either the costs or the weights.
-
-Removing unwanted object code
-
-There are a bunch of #define's in pngconf.h that control what parts of
-libpng are compiled.  All the defines end in _SUPPORTED.  If you are
-never going to use a capability, you can change the #define to #undef
-before recompiling libpng and save yourself code and data space, or
-you can turn off individual capabilities with defines that begin with
-PNG_NO_.
-
-In libpng-1.5.0 and later, the #define's are in pnglibconf.h instead.
-
-You can also turn all of the transforms and ancillary chunk capabilities
-off en masse with compiler directives that define
-PNG_NO_READ[or WRITE]_TRANSFORMS, or PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS,
-or all four,
-along with directives to turn on any of the capabilities that you do
-want.  The PNG_NO_READ[or WRITE]_TRANSFORMS directives disable the extra
-transformations but still leave the library fully capable of reading
-and writing PNG files with all known public chunks. Use of the
-PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS directive produces a library
-that is incapable of reading or writing ancillary chunks.  If you are
-not using the progressive reading capability, you can turn that off
-with PNG_NO_PROGRESSIVE_READ (don't confuse this with the INTERLACING
-capability, which you'll still have).
-
-All the reading and writing specific code are in separate files, so the
-linker should only grab the files it needs.  However, if you want to
-make sure, or if you are building a stand alone library, all the
-reading files start with "pngr" and all the writing files start with "pngw".
-The files that don't match either (like png.c, pngtrans.c, etc.)
-are used for both reading and writing, and always need to be included.
-The progressive reader is in pngpread.c
-
-If you are creating or distributing a dynamically linked library (a .so
-or DLL file), you should not remove or disable any parts of the library,
-as this will cause applications linked with different versions of the
-library to fail if they call functions not available in your library.
-The size of the library itself should not be an issue, because only
-those sections that are actually used will be loaded into memory.
-
-Requesting debug printout
-
-The macro definition PNG_DEBUG can be used to request debugging
-printout.  Set it to an integer value in the range 0 to 3.  Higher
-numbers result in increasing amounts of debugging information.  The
-information is printed to the "stderr" file, unless another file
-name is specified in the PNG_DEBUG_FILE macro definition.
-
-When PNG_DEBUG > 0, the following functions (macros) become available:
-
-   png_debug(level, message)
-   png_debug1(level, message, p1)
-   png_debug2(level, message, p1, p2)
-
-in which "level" is compared to PNG_DEBUG to decide whether to print
-the message, "message" is the formatted string to be printed,
-and p1 and p2 are parameters that are to be embedded in the string
-according to printf-style formatting directives.  For example,
-
-   png_debug1(2, "foo=%d\n", foo);
-
-is expanded to
-
-   if (PNG_DEBUG > 2)
-      fprintf(PNG_DEBUG_FILE, "foo=%d\n", foo);
-
-When PNG_DEBUG is defined but is zero, the macros aren't defined, but you
-can still use PNG_DEBUG to control your own debugging:
-
-   #ifdef PNG_DEBUG
-       fprintf(stderr, ...
-   #endif
-
-When PNG_DEBUG = 1, the macros are defined, but only png_debug statements
-having level = 0 will be printed.  There aren't any such statements in
-this version of libpng, but if you insert some they will be printed.
-
-VI.  MNG support
-
-The MNG specification (available at http://www.libpng.org/pub/mng) allows
-certain extensions to PNG for PNG images that are embedded in MNG datastreams.
-Libpng can support some of these extensions.  To enable them, use the
-png_permit_mng_features() function:
-
-   feature_set = png_permit_mng_features(png_ptr, mask)
-
-   mask is a png_uint_32 containing the bitwise OR of the
-        features you want to enable.  These include
-        PNG_FLAG_MNG_EMPTY_PLTE
-        PNG_FLAG_MNG_FILTER_64
-        PNG_ALL_MNG_FEATURES
-
-   feature_set is a png_uint_32 that is the bitwise AND of
-      your mask with the set of MNG features that is
-      supported by the version of libpng that you are using.
-
-It is an error to use this function when reading or writing a standalone
-PNG file with the PNG 8-byte signature.  The PNG datastream must be wrapped
-in a MNG datastream.  As a minimum, it must have the MNG 8-byte signature
-and the MHDR and MEND chunks.  Libpng does not provide support for these
-or any other MNG chunks; your application must provide its own support for
-them.  You may wish to consider using libmng (available at
-http://www.libmng.com) instead.
-
-VII.  Changes to Libpng from version 0.88
-
-It should be noted that versions of libpng later than 0.96 are not
-distributed by the original libpng author, Guy Schalnat, nor by
-Andreas Dilger, who had taken over from Guy during 1996 and 1997, and
-distributed versions 0.89 through 0.96, but rather by another member
-of the original PNG Group, Glenn Randers-Pehrson.  Guy and Andreas are
-still alive and well, but they have moved on to other things.
-
-The old libpng functions png_read_init(), png_write_init(),
-png_info_init(), png_read_destroy(), and png_write_destroy() have been
-moved to PNG_INTERNAL in version 0.95 to discourage their use.  These
-functions will be removed from libpng version 1.4.0.
-
-The preferred method of creating and initializing the libpng structures is
-via the png_create_read_struct(), png_create_write_struct(), and
-png_create_info_struct() because they isolate the size of the structures
-from the application, allow version error checking, and also allow the
-use of custom error handling routines during the initialization, which
-the old functions do not.  The functions png_read_destroy() and
-png_write_destroy() do not actually free the memory that libpng
-allocated for these structs, but just reset the data structures, so they
-can be used instead of png_destroy_read_struct() and
-png_destroy_write_struct() if you feel there is too much system overhead
-allocating and freeing the png_struct for each image read.
-
-Setting the error callbacks via png_set_message_fn() before
-png_read_init() as was suggested in libpng-0.88 is no longer supported
-because this caused applications that do not use custom error functions
-to fail if the png_ptr was not initialized to zero.  It is still possible
-to set the error callbacks AFTER png_read_init(), or to change them with
-png_set_error_fn(), which is essentially the same function, but with a new
-name to force compilation errors with applications that try to use the old
-method.
-
-Starting with version 1.0.7, you can find out which version of the library
-you are using at run-time:
-
-   png_uint_32 libpng_vn = png_access_version_number();
-
-The number libpng_vn is constructed from the major version, minor
-version with leading zero, and release number with leading zero,
-(e.g., libpng_vn for version 1.0.7 is 10007).
-
-Note that this function does not take a png_ptr, so you can call it
-before you've created one.
-
-You can also check which version of png.h you used when compiling your
-application:
-
-   png_uint_32 application_vn = PNG_LIBPNG_VER;
-
-VIII.  Changes to Libpng from version 1.0.x to 1.2.x
-
-Support for user memory management was enabled by default.  To
-accomplish this, the functions png_create_read_struct_2(),
-png_create_write_struct_2(), png_set_mem_fn(), png_get_mem_ptr(),
-png_malloc_default(), and png_free_default() were added.
-
-Support for the iTXt chunk has been enabled by default as of
-version 1.2.41.
-
-Support for certain MNG features was enabled.
-
-Support for numbered error messages was added.  However, we never got
-around to actually numbering the error messages.  The function
-png_set_strip_error_numbers() was added (Note: the prototype for this
-function was inadvertently removed from png.h in PNG_NO_ASSEMBLER_CODE
-builds of libpng-1.2.15.  It was restored in libpng-1.2.36).
-
-The png_malloc_warn() function was added at libpng-1.2.3.  This issues
-a png_warning and returns NULL instead of aborting when it fails to
-acquire the requested memory allocation.
-
-Support for setting user limits on image width and height was enabled
-by default.  The functions png_set_user_limits(), png_get_user_width_max(),
-and png_get_user_height_max() were added at libpng-1.2.6.
-
-The png_set_add_alpha() function was added at libpng-1.2.7.
-
-The function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9.
-Unlike png_set_gray_1_2_4_to_8(), the new function does not expand the
-tRNS chunk to alpha. The png_set_gray_1_2_4_to_8() function is
-deprecated.
-
-A number of macro definitions in support of runtime selection of
-assembler code features (especially Intel MMX code support) were
-added at libpng-1.2.0:
-
-    PNG_ASM_FLAG_MMX_SUPPORT_COMPILED
-    PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
-    PNG_ASM_FLAG_MMX_READ_COMBINE_ROW
-    PNG_ASM_FLAG_MMX_READ_INTERLACE
-    PNG_ASM_FLAG_MMX_READ_FILTER_SUB
-    PNG_ASM_FLAG_MMX_READ_FILTER_UP
-    PNG_ASM_FLAG_MMX_READ_FILTER_AVG
-    PNG_ASM_FLAG_MMX_READ_FILTER_PAETH
-    PNG_ASM_FLAGS_INITIALIZED
-    PNG_MMX_READ_FLAGS
-    PNG_MMX_FLAGS
-    PNG_MMX_WRITE_FLAGS
-    PNG_MMX_FLAGS
-
-We added the following functions in support of runtime
-selection of assembler code features:
-
-    png_get_mmx_flagmask()
-    png_set_mmx_thresholds()
-    png_get_asm_flags()
-    png_get_mmx_bitdepth_threshold()
-    png_get_mmx_rowbytes_threshold()
-    png_set_asm_flags()
-
-We replaced all of these functions with simple stubs in libpng-1.2.20,
-when the Intel assembler code was removed due to a licensing issue.
-
-These macros are deprecated:
-
-    PNG_READ_TRANSFORMS_NOT_SUPPORTED
-    PNG_PROGRESSIVE_READ_NOT_SUPPORTED
-    PNG_NO_SEQUENTIAL_READ_SUPPORTED
-    PNG_WRITE_TRANSFORMS_NOT_SUPPORTED
-    PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED
-    PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED
-
-They have been replaced, respectively, by:
-
-    PNG_NO_READ_TRANSFORMS
-    PNG_NO_PROGRESSIVE_READ
-    PNG_NO_SEQUENTIAL_READ
-    PNG_NO_WRITE_TRANSFORMS
-    PNG_NO_READ_ANCILLARY_CHUNKS
-    PNG_NO_WRITE_ANCILLARY_CHUNKS
-
-PNG_MAX_UINT was replaced with PNG_UINT_31_MAX.  It has been
-deprecated since libpng-1.0.16 and libpng-1.2.6.
-
-The function
-    png_check_sig(sig, num)
-was replaced with
-    !png_sig_cmp(sig, 0, num)
-It has been deprecated since libpng-0.90.
-
-The function
-    png_set_gray_1_2_4_to_8()
-which also expands tRNS to alpha was replaced with
-    png_set_expand_gray_1_2_4_to_8()
-which does not. It has been deprecated since libpng-1.0.18 and 1.2.9.
-
-IX.  Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
-
-Private libpng prototypes and macro definitions were moved from
-png.h and pngconf.h into a new pngpriv.h header file.
-
-Functions png_set_benign_errors(), png_benign_error(), and
-png_chunk_benign_error() were added.
-
-Support for setting the maximum amount of memory that the application
-will allocate for reading chunks was added, as a security measure.
-The functions png_set_chunk_cache_max() and png_get_chunk_cache_max()
-were added to the library.
-
-We implemented support for I/O states by adding png_ptr member io_state
-and functions png_get_io_chunk_name() and png_get_io_state() in pngget.c
-
-We added PNG_TRANSFORM_GRAY_TO_RGB to the available high-level
-input transforms.
-
-Checking for and reporting of errors in the IHDR chunk is more thorough.
-
-Support for global arrays was removed, to improve thread safety.
-
-Some obsolete/deprecated macros and functions have been removed.
-
-Typecasted NULL definitions such as
-   #define png_voidp_NULL            (png_voidp)NULL
-were eliminated.  If you used these in your application, just use
-NULL instead.
-
-The png_struct and info_struct members "trans" and "trans_values" were
-changed to "trans_alpha" and "trans_color", respectively.
-
-The obsolete, unused pnggccrd.c and pngvcrd.c files and related makefiles
-were removed.
-
-The PNG_1_0_X and PNG_1_2_X macros were eliminated.
-
-The PNG_LEGACY_SUPPORTED macro was eliminated.
-
-Many WIN32_WCE #ifdefs were removed.
-
-The functions png_read_init(info_ptr), png_write_init(info_ptr),
-png_info_init(info_ptr), png_read_destroy(), and png_write_destroy()
-have been removed.  They have been deprecated since libpng-0.95.
-
-The png_permit_empty_plte() was removed. It has been deprecated
-since libpng-1.0.9.  Use png_permit_mng_features() instead.
-
-We removed the obsolete stub functions png_get_mmx_flagmask(),
-png_set_mmx_thresholds(), png_get_asm_flags(),
-png_get_mmx_bitdepth_threshold(), png_get_mmx_rowbytes_threshold(),
-png_set_asm_flags(), and png_mmx_supported()
-
-We removed the obsolete png_check_sig(), png_memcpy_check(), and
-png_memset_check() functions.  Instead use !png_sig_cmp(), memcpy(),
-and memset(), respectively.
-
-The function png_set_gray_1_2_4_to_8() was removed. It has been
-deprecated since libpng-1.0.18 and 1.2.9, when it was replaced with
-png_set_expand_gray_1_2_4_to_8() because the former function also
-expanded any tRNS chunk to an alpha channel.
-
-Macros for png_get_uint_16, png_get_uint_32, and png_get_int_32
-were added and are used by default instead of the corresponding
-functions. Unfortunately,
-from libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
-function) incorrectly returned a value of type png_uint_32.
-
-We changed the prototype for png_malloc() from
-    png_malloc(png_structp png_ptr, png_uint_32 size)
-to
-    png_malloc(png_structp png_ptr, png_alloc_size_t size)
-
-This also applies to the prototype for the user replacement malloc_fn().
-
-The png_calloc() function was added and is used in place of
-of "png_malloc(); memset();" except in the case in png_read_png()
-where the array consists of pointers; in this case a "for" loop is used
-after the png_malloc() to set the pointers to NULL, to give robust.
-behavior in case the application runs out of memory part-way through
-the process.
-
-We changed the prototypes of png_get_compression_buffer_size() and
-png_set_compression_buffer_size() to work with png_size_t instead of
-png_uint_32.
-
-Support for numbered error messages was removed by default, since we
-never got around to actually numbering the error messages. The function
-png_set_strip_error_numbers() was removed from the library by default.
-
-The png_zalloc() and png_zfree() functions are no longer exported.
-The png_zalloc() function no longer zeroes out the memory that it
-allocates.
-
-Support for dithering was disabled by default in libpng-1.4.0, because
-it has not been well tested and doesn't actually "dither".
-The code was not
-removed, however, and could be enabled by building libpng with
-PNG_READ_DITHER_SUPPORTED defined.  In libpng-1.4.2, this support
-was reenabled, but the function was renamed png_set_quantize() to
-reflect more accurately what it actually does.  At the same time,
-the PNG_DITHER_[RED,GREEN_BLUE]_BITS macros were also renamed to
-PNG_QUANTIZE_[RED,GREEN,BLUE]_BITS, and PNG_READ_DITHER_SUPPORTED
-was renamed to PNG_READ_QUANTIZE_SUPPORTED.
-
-We removed the trailing '.' from the warning and error messages.
-
-X.  Changes to Libpng from version 1.4.x to 1.5.x
-
-From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
-function) incorrectly returned a value of type png_uint_32.
-
-A. Changes that affect users of libpng
-
-There are no substantial API changes between the non-deprecated parts of
-the 1.4.5 API and the 1.5.0 API, however the ability to directly access
-the main libpng control structures, png_struct and png_info, deprecated
-in earlier versions of libpng, has been completely removed from
-libpng 1.5.
-
-We no longer include zlib.h in png.h.  Applications that need access
-to information in zlib.h will need to add the '#include "zlib.h"'
-directive.  It does not matter whether it is placed prior to or after
-the '"#include png.h"' directive.
-
-We moved the png_strcpy(), png_strncpy(), png_strlen(), png_memcpy(),
-png_memcmp(), png_sprintf, and png_memcpy() macros into a private
-header file (pngpriv.h) that is not accessible to applications.
-
-In png_get_iCCP, the type of "profile" was changed from png_charpp
-to png_bytepp, and in png_set_iCCP, from png_charp to png_const_bytep.
-
-There are changes of form in png.h, including new and changed macros to
-declare parts of the API.  Some API functions with arguments that are
-pointers to data not modified within the function have been corrected to
-declare these arguments with PNG_CONST.
-
-Much of the internal use of C macros to control the library build has also
-changed and some of this is visible in the exported header files, in
-particular the use of macros to control data and API elements visible
-during application compilation may require significant revision to
-application code.  (It is extremely rare for an application to do this.)
-
-Any program that compiled against libpng 1.4 and did not use deprecated
-features or access internal library structures should compile and work
-against libpng 1.5, except for the change in the prototype for
-png_get_iCCP() and png_set_iCCP() API functions mentioned above.
-
-libpng 1.5.0 adds PNG_ PASS macros to help in the reading and writing of
-interlaced images.  The macros return the number of rows and columns in
-each pass and information that can be used to de-interlace and (if
-absolutely necessary) interlace an image.
-
-libpng 1.5.0 adds an API png_longjmp(png_ptr, value).  This API calls
-the application-provided png_longjmp_ptr on the internal, but application
-initialized, longjmp buffer.  It is provided as a convenience to avoid
-the need to use the png_jmpbuf macro, which had the unnecessary side
-effect of resetting the internal png_longjmp_ptr value.
-
-libpng 1.5.0 includes a complete fixed point API.  By default this is
-present along with the corresponding floating point API.  In general the
-fixed point API is faster and smaller than the floating point one because
-the PNG file format used fixed point, not floating point.  This applies
-even if the library uses floating point in internal calculations.  A new
-macro, PNG_FLOATING_ARITHMETIC_SUPPORTED, reveals whether the library
-uses floating point arithmetic (the default) or fixed point arithmetic
-internally for performance critical calculations such as gamma correction.
-In some cases, the gamma calculations may produce slightly different
-results.  This has changed the results in png_rgb_to_gray and in alpha
-composition (png_set_background for example). This applies even if the
-original image was already linear (gamma == 1.0) and, therefore, it is
-not necessary to linearize the image.  This is because libpng has *not*
-been changed to optimize that case correctly, yet.
-
-Fixed point support for the sCAL chunk comes with an important caveat;
-the sCAL specification uses a decimal encoding of floating point values
-and the accuracy of PNG fixed point values is insufficient for
-representation of these values. Consequently a "string" API
-(png_get_sCAL_s and png_set_sCAL_s) is the only reliable way of reading
-arbitrary sCAL chunks in the absence of either the floating point API or
-internal floating point calculations.
-
-Applications no longer need to include the optional distribution header
-file pngusr.h or define the corresponding macros during application
-build in order to see the correct variant of the libpng API.  From 1.5.0
-application code can check for the corresponding _SUPPORTED macro:
-
-#ifdef PNG_INCH_CONVERSIONS_SUPPORTED
-   /* code that uses the inch conversion APIs. */
-#endif
-
-This macro will only be defined if the inch conversion functions have been
-compiled into libpng.  The full set of macros, and whether or not support
-has been compiled in, are available in the header file pnglibconf.h.
-This header file is specific to the libpng build.  Notice that prior to
-1.5.0 the _SUPPORTED macros would always have the default definition unless
-reset by pngusr.h or by explicit settings on the compiler command line.
-These settings may produce compiler warnings or errors in 1.5.0 because
-of macro redefinition.
-
-From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
-function) incorrectly returned a value of type png_uint_32.  libpng 1.5.0
-is consistent with the implementation in 1.4.5 and 1.2.x (where the macro
-did not exist.)
-
-Applications can now choose whether to use these macros or to call the
-corresponding function by defining PNG_USE_READ_MACROS or
-PNG_NO_USE_READ_MACROS before including png.h.  Notice that this is
-only supported from 1.5.0 -defining PNG_NO_USE_READ_MACROS prior to 1.5.0
-will lead to a link failure.
-
-Prior to libpng-1.5.4, the zlib compressor used the same set of parameters
-when compressing the IDAT data and textual data such as zTXt and iCCP.
-In libpng-1.5.4 we reinitialized the zlib stream for each type of data.
-We added five png_set_text_*() functions for setting the parameters to
-use with textual data.
-
-Prior to libpng-1.5.4, the PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
-option was off by default, and slightly inaccurate scaling occurred.
-This option can no longer be turned off, and the choice of accurate
-or inaccurate 16-to-8 scaling is by using the new png_set_scale_16_to_8()
-API for accurate scaling or the old png_set_strip_16_to_8() API for simple
-chopping.
-
-Prior to libpng-1.5.4, the png_set_user_limits() function could only be
-used to reduce the width and height limits from the value of
-PNG_USER_WIDTH_MAX and PNG_USER_HEIGHT_MAX, although this document said
-that it could be used to override them.  Now this function will reduce or
-increase the limits.
-
-B. Changes to the build and configuration of libpng
-
-Details of internal changes to the library code can be found in the CHANGES
-file and in the GIT repository logs.  These will be of no concern to the vast
-majority of library users or builders, however the few who configure libpng
-to a non-default feature set may need to change how this is done.
-
-There should be no need for library builders to alter build scripts if
-these use the distributed build support - configure or the makefiles -
-however users of the makefiles may care to update their build scripts
-to build pnglibconf.h where the corresponding makefile does not do so.
-
-Building libpng with a non-default configuration has changed completely.
-The old method using pngusr.h should still work correctly even though the
-way pngusr.h is used in the build has been changed; however, library
-builders will probably want to examine the changes to take advantage of
-new capabilities and to simplify their build system.
-
-B.1 Specific changes to library configuration capabilities
-
-The library now supports a complete fixed point implementation and can
-thus be used on systems that have no floating point support or very
-limited or slow support.  Previously gamma correction, an essential part
-of complete PNG support, required reasonably fast floating point.
-
-As part of this the choice of internal implementation has been made
-independent of the choice of fixed versus floating point APIs and all the
-missing fixed point APIs have been implemented.
-
-The exact mechanism used to control attributes of API functions has
-changed.  A single set of operating system independent macro definitions
-is used and operating system specific directives are defined in
-pnglibconf.h
-
-As part of this the mechanism used to choose procedure call standards on
-those systems that allow a choice has been changed.  At present this only
-affects certain Microsoft (DOS, Windows) and IBM (OS/2) operating systems
-running on Intel processors.  As before, PNGAPI is defined where required
-to control the exported API functions; however, two new macros, PNGCBAPI
-and PNGCAPI, are used instead for callback functions (PNGCBAPI) and
-(PNGCAPI) for functions that must match a C library prototype (currently
-only png_longjmp_ptr, which must match the C longjmp function.)  The new
-approach is documented in pngconf.h
-
-Despite these changes, libpng 1.5.0 only supports the native C function
-calling standard on those platforms tested so far (__cdecl on Microsoft
-Windows).  This is because the support requirements for alternative
-calling conventions seem to no longer exist.  Developers who find it
-necessary to set PNG_API_RULE to 1 should advise the mailing list
-(png-mng-implement) of this and library builders who use Openwatcom and
-therefore set PNG_API_RULE to 2 should also contact the mailing list.
-
-A new test program, pngvalid, is provided in addition to pngtest.
-pngvalid validates the arithmetic accuracy of the gamma correction
-calculations and includes a number of validations of the file format.
-A subset of the full range of tests is run when "make check" is done
-(in the 'configure' build.)  pngvalid also allows total allocated memory
-usage to be evaluated and performs additional memory overwrite validation.
-
-Many changes to individual feature macros have been made. The following
-are the changes most likely to be noticed by library builders who
-configure libpng:
-
-1) All feature macros now have consistent naming:
-
-#define PNG_NO_feature turns the feature off
-#define PNG_feature_SUPPORTED turns the feature on
-
-pnglibconf.h contains one line for each feature macro which is either:
-
-#define PNG_feature_SUPPORTED
-
-if the feature is supported or:
-
-/*#undef PNG_feature_SUPPORTED*/
-
-if it is not.  Library code consistently checks for the 'SUPPORTED' macro.
-It does not, and libpng applications should not, check for the 'NO' macro
-which will not normally be defined even if the feature is not supported.
-The 'NO' macros are only used internally for setting or not setting the
-corresponding 'SUPPORTED' macros.
-
-Compatibility with the old names is provided as follows:
-
-PNG_INCH_CONVERSIONS turns on PNG_INCH_CONVERSIONS_SUPPORTED
-
-And the following definitions disable the corresponding feature:
-
-PNG_SETJMP_NOT_SUPPORTED disables SETJMP
-PNG_READ_TRANSFORMS_NOT_SUPPORTED disables READ_TRANSFORMS
-PNG_NO_READ_COMPOSITED_NODIV disables READ_COMPOSITE_NODIV
-PNG_WRITE_TRANSFORMS_NOT_SUPPORTED disables WRITE_TRANSFORMS
-PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED disables READ_ANCILLARY_CHUNKS
-PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED disables WRITE_ANCILLARY_CHUNKS
-
-Library builders should remove use of the above, inconsistent, names.
-
-2) Warning and error message formatting was previously conditional on
-the STDIO feature. The library has been changed to use the
-CONSOLE_IO feature instead. This means that if CONSOLE_IO is disabled
-the library no longer uses the printf(3) functions, even though the
-default read/write implementations use (FILE) style stdio.h functions.
-
-3) Three feature macros now control the fixed/floating point decisions:
-
-PNG_FLOATING_POINT_SUPPORTED enables the floating point APIs
-
-PNG_FIXED_POINT_SUPPORTED enables the fixed point APIs; however, in
-practice these are normally required internally anyway (because the PNG
-file format is fixed point), therefore in most cases PNG_NO_FIXED_POINT
-merely stops the function from being exported.
-
-PNG_FLOATING_ARITHMETIC_SUPPORTED chooses between the internal floating
-point implementation or the fixed point one.  Typically the fixed point
-implementation is larger and slower than the floating point implementation
-on a system that supports floating point, however it may be faster on a
-system which lacks floating point hardware and therefore uses a software
-emulation.
-
-4) Added PNG_{READ,WRITE}_INT_FUNCTIONS_SUPPORTED.  This allows the
-functions to read and write ints to be disabled independently of
-PNG_USE_READ_MACROS, which allows libpng to be built with the functions
-even though the default is to use the macros - this allows applications
-to choose at app buildtime whether or not to use macros (previously
-impossible because the functions weren't in the default build.)
-
-B.2 Changes to the configuration mechanism
-
-Prior to libpng-1.5.0 library builders who needed to configure libpng
-had either to modify the exported pngconf.h header file to add system
-specific configuration or had to write feature selection macros into
-pngusr.h and cause this to be included into pngconf.h by defining
-PNG_USER_CONFIG. The latter mechanism had the disadvantage that an
-application built without PNG_USER_CONFIG defined would see the
-unmodified, default, libpng API and thus would probably fail to link.
-
-These mechanisms still work in the configure build and in any makefile
-build that builds pnglibconf.h, although the feature selection macros
-have changed somewhat as described above.  In 1.5.0, however, pngusr.h is
-processed only once, when the exported header file pnglibconf.h is built.
-pngconf.h no longer includes pngusr.h, therefore pngusr.h is ignored after the
-build of pnglibconf.h and it is never included in an application build.
-
-The rarely used alternative of adding a list of feature macros to the
-CFLAGS setting in the build also still works, however the macros will be
-copied to pnglibconf.h and this may produce macro redefinition warnings
-when the individual C files are compiled.
-
-All configuration now only works if pnglibconf.h is built from
-scripts/pnglibconf.dfa.  This requires the program awk.  Brian Kernighan
-(the original author of awk) maintains C source code of that awk and this
-and all known later implementations (often called by subtly different
-names - nawk and gawk for example) are adequate to build pnglibconf.h.
-The Sun Microsystems (now Oracle) program 'awk' is an earlier version
-and does not work; this may also apply to other systems that have a
-functioning awk called 'nawk'.
-
-Configuration options are now documented in scripts/pnglibconf.dfa.  This
-file also includes dependency information that ensures a configuration is
-consistent; that is, if a feature is switched off dependent features are
-also removed.  As a recommended alternative to using feature macros in
-pngusr.h a system builder may also define equivalent options in pngusr.dfa
-(or, indeed, any file) and add that to the configuration by setting
-DFA_XTRA to the file name.  The makefiles in contrib/pngminim illustrate
-how to do this, and a case where pngusr.h is still required.
-
-XI. Detecting libpng
-
-The png_get_io_ptr() function has been present since libpng-0.88, has never
-changed, and is unaffected by conditional compilation macros.  It is the
-best choice for use in configure scripts for detecting the presence of any
-libpng version since 0.88.  In an autoconf "configure.in" you could use
-
-    AC_CHECK_LIB(png, png_get_io_ptr, ...
-
-XII. Source code repository
-
-Since about February 2009, version 1.2.34, libpng has been under "git" source
-control.  The git repository was built from old libpng-x.y.z.tar.gz files
-going back to version 0.70.  You can access the git repository (read only)
-at
-
-    git://libpng.git.sourceforge.net/gitroot/libpng
-
-or you can browse it via "gitweb" at
-
-    http://libpng.git.sourceforge.net/git/gitweb.cgi?p=libpng
-
-Patches can be sent to glennrp at users.sourceforge.net or to
-png-mng-implement at lists.sourceforge.net or you can upload them to
-the libpng bug tracker at
-
-    http://libpng.sourceforge.net
-
-We also accept patches built from the tar or zip distributions, and
-simple verbal discriptions of bug fixes, reported either to the
-SourceForge bug tracker, to the png-mng-implement at lists.sf.net
-mailing list, or directly to glennrp.
-
-XIII. Coding style
-
-Our coding style is similar to the "Allman" style, with curly
-braces on separate lines:
-
-    if (condition)
-    {
-       action;
-    }
-
-    else if (another condition)
-    {
-       another action;
-    }
-
-The braces can be omitted from simple one-line actions:
-
-    if (condition)
-       return (0);
-
-We use 3-space indentation, except for continued statements which
-are usually indented the same as the first line of the statement
-plus four more spaces.
-
-For macro definitions we use 2-space indentation, always leaving the "#"
-in the first column.
-
-    #ifndef PNG_NO_FEATURE
-    #  ifndef PNG_FEATURE_SUPPORTED
-    #    define PNG_FEATURE_SUPPORTED
-    #  endif
-    #endif
-
-Comments appear with the leading "/*" at the same indentation as
-the statement that follows the comment:
-
-    /* Single-line comment */
-    statement;
-
-    /* This is a multiple-line
-     * comment.
-     */
-    statement;
-
-Very short comments can be placed after the end of the statement
-to which they pertain:
-
-    statement;    /* comment */
-
-We don't use C++ style ("//") comments. We have, however,
-used them in the past in some now-abandoned MMX assembler
-code.
-
-Functions and their curly braces are not indented, and
-exported functions are marked with PNGAPI:
-
- /* This is a public function that is visible to
-  * application programmers. It does thus-and-so.
-  */
- void PNGAPI
- png_exported_function(png_ptr, png_info, foo)
- {
-    body;
- }
-
-The prototypes for all exported functions appear in png.h,
-above the comment that says
-
-    /* Maintainer: Put new public prototypes here ... */
-
-We mark all non-exported functions with "/* PRIVATE */"":
-
- void /* PRIVATE */
- png_non_exported_function(png_ptr, png_info, foo)
- {
-    body;
- }
-
-The prototypes for non-exported functions (except for those in
-pngtest) appear in
-pngpriv.h
-above the comment that says
-
-  /* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
-
-To avoid polluting the global namespace, the names of all exported
-functions and variables begin with  "png_", and all publicly visible C
-preprocessor macros begin with "PNG_".  We request that applications that
-use libpng *not* begin any of their own symbols with either of these strings.
-
-We put a space after each comma and after each semicolon
-in "for" statements, and we put spaces before and after each
-C binary operator and after "for" or "while", and before
-"?".  We don't put a space between a typecast and the expression
-being cast, nor do we put one between a function name and the
-left parenthesis that follows it:
-
-    for (i = 2; i > 0; --i)
-       y[i] = a(x) + (int)b;
-
-We prefer #ifdef and #ifndef to #if defined() and if !defined()
-when there is only one macro being tested.
-
-We prefer to express integers that are used as bit masks in hex format,
-with an even number of lower-case hex digits (e.g., 0x00, 0xff, 0x0100).
-
-We do not use the TAB character for indentation in the C sources.
-
-Lines do not exceed 80 characters.
-
-Other rules can be inferred by inspecting the libpng source.
-
-XIV. Y2K Compliance in libpng
-
-February 18, 2012
-
-Since the PNG Development group is an ad-hoc body, we can't make
-an official declaration.
-
-This is your unofficial assurance that libpng from version 0.71 and
-upward through 1.5.9 are Y2K compliant.  It is my belief that earlier
-versions were also Y2K compliant.
-
-Libpng only has three year fields.  One is a 2-byte unsigned integer that
-will hold years up to 65535.  The other two hold the date in text
-format, and will hold years up to 9999.
-
-The integer is
-    "png_uint_16 year" in png_time_struct.
-
-The strings are
-    "png_charp time_buffer" in png_struct and
-    "near_time_buffer", which is a local character string in png.c.
-
-There are seven time-related functions:
-
-    png_convert_to_rfc_1123() in png.c
-      (formerly png_convert_to_rfc_1152() in error)
-    png_convert_from_struct_tm() in pngwrite.c, called
-      in pngwrite.c
-    png_convert_from_time_t() in pngwrite.c
-    png_get_tIME() in pngget.c
-    png_handle_tIME() in pngrutil.c, called in pngread.c
-    png_set_tIME() in pngset.c
-    png_write_tIME() in pngwutil.c, called in pngwrite.c
-
-All appear to handle dates properly in a Y2K environment.  The
-png_convert_from_time_t() function calls gmtime() to convert from system
-clock time, which returns (year - 1900), which we properly convert to
-the full 4-digit year.  There is a possibility that applications using
-libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
-function, or that they are incorrectly passing only a 2-digit year
-instead of "year - 1900" into the png_convert_from_struct_tm() function,
-but this is not under our control.  The libpng documentation has always
-stated that it works with 4-digit years, and the APIs have been
-documented as such.
-
-The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
-integer to hold the year, and can hold years as large as 65535.
-
-zlib, upon which libpng depends, is also Y2K compliant.  It contains
-no date-related code.
-
-
-   Glenn Randers-Pehrson
-   libpng maintainer
-   PNG Development Group
+Libpng-manual.txt - A description on how to use and modify libpng
+
+ libpng version 1.5.12 - July 11, 2012
+ Updated and distributed by Glenn Randers-Pehrson
+ <glennrp at users.sourceforge.net>
+ Copyright (c) 1998-2011 Glenn Randers-Pehrson
+
+ This document is released under the libpng license.
+ For conditions of distribution and use, see the disclaimer
+ and license in png.h
+
+ Based on:
+
+ libpng versions 0.97, January 1998, through 1.5.12 - July 11, 2012
+ Updated and distributed by Glenn Randers-Pehrson
+ Copyright (c) 1998-2011 Glenn Randers-Pehrson
+
+ libpng 1.0 beta 6  version 0.96 May 28, 1997
+ Updated and distributed by Andreas Dilger
+ Copyright (c) 1996, 1997 Andreas Dilger
+
+ libpng 1.0 beta 2 - version 0.88  January 26, 1996
+ For conditions of distribution and use, see copyright
+ notice in png.h. Copyright (c) 1995, 1996 Guy Eric
+ Schalnat, Group 42, Inc.
+
+ Updated/rewritten per request in the libpng FAQ
+ Copyright (c) 1995, 1996 Frank J. T. Wojcik
+ December 18, 1995 & January 20, 1996
+
+I. Introduction
+
+This file describes how to use and modify the PNG reference library
+(known as libpng) for your own use.  There are five sections to this
+file: introduction, structures, reading, writing, and modification and
+configuration notes for various special platforms.  In addition to this
+file, example.c is a good starting point for using the library, as
+it is heavily commented and should include everything most people
+will need.  We assume that libpng is already installed; see the
+INSTALL file for instructions on how to install libpng.
+
+For examples of libpng usage, see the files "example.c", "pngtest.c",
+and the files in the "contrib" directory, all of which are included in
+the libpng distribution.
+
+Libpng was written as a companion to the PNG specification, as a way
+of reducing the amount of time and effort it takes to support the PNG
+file format in application programs.
+
+The PNG specification (second edition), November 2003, is available as
+a W3C Recommendation and as an ISO Standard (ISO/IEC 15948:2003 (E)) at
+<http://www.w3.org/TR/2003/REC-PNG-20031110/
+The W3C and ISO documents have identical technical content.
+
+The PNG-1.2 specification is available at
+<http://www.libpng.org/pub/png/documents/>.  It is technically equivalent
+to the PNG specification (second edition) but has some additional material.
+
+The PNG-1.0 specification is available
+as RFC 2083 <http://www.libpng.org/pub/png/documents/> and as a
+W3C Recommendation <http://www.w3.org/TR/REC.png.html>.
+
+Some additional chunks are described in the special-purpose public chunks
+documents at <http://www.libpng.org/pub/png/documents/>.
+
+Other information
+about PNG, and the latest version of libpng, can be found at the PNG home
+page, <http://www.libpng.org/pub/png/>.
+
+Most users will not have to modify the library significantly; advanced
+users may want to modify it more.  All attempts were made to make it as
+complete as possible, while keeping the code easy to understand.
+Currently, this library only supports C.  Support for other languages
+is being considered.
+
+Libpng has been designed to handle multiple sessions at one time,
+to be easily modifiable, to be portable to the vast majority of
+machines (ANSI, K&R, 16-, 32-, and 64-bit) available, and to be easy
+to use.  The ultimate goal of libpng is to promote the acceptance of
+the PNG file format in whatever way possible.  While there is still
+work to be done (see the TODO file), libpng should cover the
+majority of the needs of its users.
+
+Libpng uses zlib for its compression and decompression of PNG files.
+Further information about zlib, and the latest version of zlib, can
+be found at the zlib home page, <http://www.info-zip.org/pub/infozip/zlib/>.
+The zlib compression utility is a general purpose utility that is
+useful for more than PNG files, and can be used without libpng.
+See the documentation delivered with zlib for more details.
+You can usually find the source files for the zlib utility wherever you
+find the libpng source files.
+
+Libpng is thread safe, provided the threads are using different
+instances of the structures.  Each thread should have its own
+png_struct and png_info instances, and thus its own image.
+Libpng does not protect itself against two threads using the
+same instance of a structure.
+
+II. Structures
+
+There are two main structures that are important to libpng, png_struct
+and png_info.  Both are internal structures that are no longer exposed
+in the libpng interface (as of libpng 1.5.0).
+
+The png_info structure is designed to provide information about the
+PNG file.  At one time, the fields of png_info were intended to be
+directly accessible to the user.  However, this tended to cause problems
+with applications using dynamically loaded libraries, and as a result
+a set of interface functions for png_info (the png_get_*() and png_set_*()
+functions) was developed, and direct access to the png_info fields was
+deprecated..
+
+The png_struct structure is the object used by the library to decode a
+single image.  As of 1.5.0 this structure is also not exposed.
+
+Almost all libpng APIs require a pointer to a png_struct as the first argument.
+Many (in particular the png_set and png_get APIs) also require a pointer
+to png_info as the second argument.  Some application visible macros
+defined in png.h designed for basic data access (reading and writing
+integers in the PNG format) don't take a png_info pointer, but it's almost
+always safe to assume that a (png_struct*) has to be passed to call an API
+function.
+
+You can have more than one png_info structure associated with an image,
+as illustrated in pngtest.c, one for information valid prior to the
+IDAT chunks and another (called "end_info" below) for things after them.
+
+The png.h header file is an invaluable reference for programming with libpng.
+And while I'm on the topic, make sure you include the libpng header file:
+
+#include <png.h>
+
+and also (as of libpng-1.5.0) the zlib header file, if you need it:
+
+#include <zlib.h>
+
+Types
+
+The png.h header file defines a number of integral types used by the
+APIs.  Most of these are fairly obvious; for example types corresponding
+to integers of particular sizes and types for passing color values.
+
+One exception is how non-integral numbers are handled.  For application
+convenience most APIs that take such numbers have C (double) arguments;
+however, internally PNG, and libpng, use 32 bit signed integers and encode
+the value by multiplying by 100,000.  As of libpng 1.5.0 a convenience
+macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
+which is simply (png_int_32).
+
+All APIs that take (double) arguments also have a matching API that
+takes the corresponding fixed point integer arguments.  The fixed point
+API has the same name as the floating point one with "_fixed" appended.
+The actual range of values permitted in the APIs is frequently less than
+the full range of (png_fixed_point) (-21474 to +21474).  When APIs require
+a non-negative argument the type is recorded as png_uint_32 above.  Consult
+the header file and the text below for more information.
+
+Special care must be take with sCAL chunk handling because the chunk itself
+uses non-integral values encoded as strings containing decimal floating point
+numbers.  See the comments in the header file.
+
+Configuration
+
+The main header file function declarations are frequently protected by C
+preprocessing directives of the form:
+
+    #ifdef PNG_feature_SUPPORTED
+    declare-function
+    #endif
+    ...
+    #ifdef PNG_feature_SUPPORTED
+    use-function
+    #endif
+
+The library can be built without support for these APIs, although a
+standard build will have all implemented APIs.  Application programs
+should check the feature macros before using an API for maximum
+portability.  From libpng 1.5.0 the feature macros set during the build
+of libpng are recorded in the header file "pnglibconf.h" and this file
+is always included by png.h.
+
+If you don't need to change the library configuration from the default, skip to
+the next section ("Reading").
+
+Notice that some of the makefiles in the 'scripts' directory and (in 1.5.0) all
+of the build project files in the 'projects' directory simply copy
+scripts/pnglibconf.h.prebuilt to pnglibconf.h.  This means that these build
+systems do not permit easy auto-configuration of the library - they only
+support the default configuration.
+
+The easiest way to make minor changes to the libpng configuration when
+auto-configuration is supported is to add definitions to the command line
+using (typically) CPPFLAGS.  For example:
+
+CPPFLAGS=-DPNG_NO_FLOATING_ARITHMETIC
+
+will change the internal libpng math implementation for gamma correction and
+other arithmetic calculations to fixed point, avoiding the need for fast
+floating point support.  The result can be seen in the generated pnglibconf.h -
+make sure it contains the changed feature macro setting.
+
+If you need to make more extensive configuration changes - more than one or two
+feature macro settings - you can either add -DPNG_USER_CONFIG to the build
+command line and put a list of feature macro settings in pngusr.h or you can set
+DFA_XTRA (a makefile variable) to a file containing the same information in the
+form of 'option' settings.
+
+A. Changing pnglibconf.h
+
+A variety of methods exist to build libpng.  Not all of these support
+reconfiguration of pnglibconf.h.  To reconfigure pnglibconf.h it must either be
+rebuilt from scripts/pnglibconf.dfa using awk or it must be edited by hand.
+
+Hand editing is achieved by copying scripts/pnglibconf.h.prebuilt to
+pnglibconf.h and changing the lines defining the supported features, paying
+very close attention to the 'option' information in scripts/pnglibconf.dfa
+that describes those features and their requirements.  This is easy to get
+wrong.
+
+B. Configuration using DFA_XTRA
+
+Rebuilding from pnglibconf.dfa is easy if a functioning 'awk', or a later
+variant such as 'nawk' or 'gawk', is available.  The configure build will
+automatically find an appropriate awk and build pnglibconf.h.
+The scripts/pnglibconf.mak file contains a set of make rules for doing the
+same thing if configure is not used, and many of the makefiles in the scripts
+directory use this approach.
+
+When rebuilding simply write a new file containing changed options and set
+DFA_XTRA to the name of this file.  This causes the build to append the new file
+to the end of scripts/pnglibconf.dfa.  The pngusr.dfa file should contain lines
+of the following forms:
+
+everything = off
+
+This turns all optional features off.  Include it at the start of pngusr.dfa to
+make it easier to build a minimal configuration.  You will need to turn at least
+some features on afterward to enable either reading or writing code, or both.
+
+option feature on
+option feature off
+
+Enable or disable a single feature.  This will automatically enable other
+features required by a feature that is turned on or disable other features that
+require a feature which is turned off.  Conflicting settings will cause an error
+message to be emitted by awk.
+
+setting feature default value
+
+Changes the default value of setting 'feature' to 'value'.  There are a small
+number of settings listed at the top of pnglibconf.h, they are documented in the
+source code.  Most of these values have performance implications for the library
+but most of them have no visible effect on the API.  Some can also be overridden
+from the API.
+
+This method of building a customized pnglibconf.h is illustrated in
+contrib/pngminim/*.  See the "$(PNGCONF):" target in the makefile and
+pngusr.dfa in these directories.
+
+C. Configuration using PNG_USR_CONFIG
+
+If -DPNG_USR_CONFIG is added to the CFLAGS when pnglibconf.h is built the file
+pngusr.h will automatically be included before the options in
+scripts/pnglibconf.dfa are processed.  Your pngusr.h file should contain only
+macro definitions turning features on or off or setting settings.
+
+Apart from the global setting "everything = off" all the options listed above
+can be set using macros in pngusr.h:
+
+#define PNG_feature_SUPPORTED
+
+is equivalent to:
+
+option feature on
+
+#define PNG_NO_feature
+
+is equivalent to:
+
+option feature off
+
+#define PNG_feature value
+
+is equivalent to:
+
+setting feature default value
+
+Notice that in both cases, pngusr.dfa and pngusr.h, the contents of the
+pngusr file you supply override the contents of scripts/pnglibconf.dfa
+
+If confusing or incomprehensible behavior results it is possible to
+examine the intermediate file pnglibconf.dfn to find the full set of
+dependency information for each setting and option.  Simply locate the
+feature in the file and read the C comments that precede it.
+
+This method is also illustrated in the contrib/pngminim/* makefiles and
+pngusr.h.
+
+III. Reading
+
+We'll now walk you through the possible functions to call when reading
+in a PNG file sequentially, briefly explaining the syntax and purpose
+of each one.  See example.c and png.h for more detail.  While
+progressive reading is covered in the next section, you will still
+need some of the functions discussed in this section to read a PNG
+file.
+
+Setup
+
+You will want to do the I/O initialization(*) before you get into libpng,
+so if it doesn't work, you don't have much to undo.  Of course, you
+will also want to insure that you are, in fact, dealing with a PNG
+file.  Libpng provides a simple check to see if a file is a PNG file.
+To use it, pass in the first 1 to 8 bytes of the file to the function
+png_sig_cmp(), and it will return 0 (false) if the bytes match the
+corresponding bytes of the PNG signature, or nonzero (true) otherwise.
+Of course, the more bytes you pass in, the greater the accuracy of the
+prediction.
+
+If you are intending to keep the file pointer open for use in libpng,
+you must ensure you don't read more than 8 bytes from the beginning
+of the file, and you also have to make a call to png_set_sig_bytes_read()
+with the number of bytes you read from the beginning.  Libpng will
+then only check the bytes (if any) that your program didn't read.
+
+(*): If you are not using the standard I/O functions, you will need
+to replace them with custom functions.  See the discussion under
+Customizing libpng.
+
+
+    FILE *fp = fopen(file_name, "rb");
+    if (!fp)
+    {
+       return (ERROR);
+    }
+
+    fread(header, 1, number, fp);
+    is_png = !png_sig_cmp(header, 0, number);
+
+    if (!is_png)
+    {
+       return (NOT_PNG);
+    }
+
+
+Next, png_struct and png_info need to be allocated and initialized.  In
+order to ensure that the size of these structures is correct even with a
+dynamically linked libpng, there are functions to initialize and
+allocate the structures.  We also pass the library version, optional
+pointers to error handling functions, and a pointer to a data struct for
+use by the error functions, if necessary (the pointer and functions can
+be NULL if the default error handlers are to be used).  See the section
+on Changes to Libpng below regarding the old initialization functions.
+The structure allocation functions quietly return NULL if they fail to
+create the structure, so your application should check for that.
+
+    png_structp png_ptr = png_create_read_struct
+        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
+        user_error_fn, user_warning_fn);
+
+    if (!png_ptr)
+       return (ERROR);
+
+    png_infop info_ptr = png_create_info_struct(png_ptr);
+
+    if (!info_ptr)
+    {
+       png_destroy_read_struct(&png_ptr,
+           (png_infopp)NULL, (png_infopp)NULL);
+       return (ERROR);
+    }
+
+If you want to use your own memory allocation routines,
+use a libpng that was built with PNG_USER_MEM_SUPPORTED defined, and use
+png_create_read_struct_2() instead of png_create_read_struct():
+
+    png_structp png_ptr = png_create_read_struct_2
+        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
+        user_error_fn, user_warning_fn, (png_voidp)
+        user_mem_ptr, user_malloc_fn, user_free_fn);
+
+The error handling routines passed to png_create_read_struct()
+and the memory alloc/free routines passed to png_create_struct_2()
+are only necessary if you are not using the libpng supplied error
+handling and memory alloc/free functions.
+
+When libpng encounters an error, it expects to longjmp back
+to your routine.  Therefore, you will need to call setjmp and pass
+your png_jmpbuf(png_ptr).  If you read the file from different
+routines, you will need to update the longjmp buffer every time you enter
+a new routine that will call a png_*() function.
+
+See your documentation of setjmp/longjmp for your compiler for more
+information on setjmp/longjmp.  See the discussion on libpng error
+handling in the Customizing Libpng section below for more information
+on the libpng error handling.  If an error occurs, and libpng longjmp's
+back to your setjmp, you will want to call png_destroy_read_struct() to
+free any memory.
+
+    if (setjmp(png_jmpbuf(png_ptr)))
+    {
+       png_destroy_read_struct(&png_ptr, &info_ptr,
+           &end_info);
+       fclose(fp);
+       return (ERROR);
+    }
+
+Pass (png_infopp)NULL instead of &end_info if you didn't create
+an end_info structure.
+
+If you would rather avoid the complexity of setjmp/longjmp issues,
+you can compile libpng with PNG_NO_SETJMP, in which case
+errors will result in a call to PNG_ABORT() which defaults to abort().
+
+You can #define PNG_ABORT() to a function that does something
+more useful than abort(), as long as your function does not
+return.
+
+Now you need to set up the input code.  The default for libpng is to
+use the C function fread().  If you use this, you will need to pass a
+valid FILE * in the function png_init_io().  Be sure that the file is
+opened in binary mode.  If you wish to handle reading data in another
+way, you need not call the png_init_io() function, but you must then
+implement the libpng I/O methods discussed in the Customizing Libpng
+section below.
+
+    png_init_io(png_ptr, fp);
+
+If you had previously opened the file and read any of the signature from
+the beginning in order to see if this was a PNG file, you need to let
+libpng know that there are some bytes missing from the start of the file.
+
+    png_set_sig_bytes(png_ptr, number);
+
+You can change the zlib compression buffer size to be used while
+reading compressed data with
+
+    png_set_compression_buffer_size(png_ptr, buffer_size);
+
+where the default size is 8192 bytes.  Note that the buffer size
+is changed immediately and the buffer is reallocated immediately,
+instead of setting a flag to be acted upon later.
+
+If you want CRC errors to be handled in a different manner than
+the default, use
+
+    png_set_crc_action(png_ptr, crit_action, ancil_action);
+
+The values for png_set_crc_action() say how libpng is to handle CRC errors in
+ancillary and critical chunks, and whether to use the data contained
+therein.  Note that it is impossible to "discard" data in a critical
+chunk.
+
+Choices for (int) crit_action are
+   PNG_CRC_DEFAULT      0  error/quit
+   PNG_CRC_ERROR_QUIT   1  error/quit
+   PNG_CRC_WARN_USE     3  warn/use data
+   PNG_CRC_QUIET_USE    4  quiet/use data
+   PNG_CRC_NO_CHANGE    5  use the current value
+
+Choices for (int) ancil_action are
+   PNG_CRC_DEFAULT      0  error/quit
+   PNG_CRC_ERROR_QUIT   1  error/quit
+   PNG_CRC_WARN_DISCARD 2  warn/discard data
+   PNG_CRC_WARN_USE     3  warn/use data
+   PNG_CRC_QUIET_USE    4  quiet/use data
+   PNG_CRC_NO_CHANGE    5  use the current value
+
+Setting up callback code
+
+You can set up a callback function to handle any unknown chunks in the
+input stream. You must supply the function
+
+    read_chunk_callback(png_structp png_ptr,
+         png_unknown_chunkp chunk);
+    {
+       /* The unknown chunk structure contains your
+          chunk data, along with similar data for any other
+          unknown chunks: */
+
+           png_byte name[5];
+           png_byte *data;
+           png_size_t size;
+
+       /* Note that libpng has already taken care of
+          the CRC handling */
+
+       /* put your code here.  Search for your chunk in the
+          unknown chunk structure, process it, and return one
+          of the following: */
+
+       return (-n); /* chunk had an error */
+       return (0); /* did not recognize */
+       return (n); /* success */
+    }
+
+(You can give your function another name that you like instead of
+"read_chunk_callback")
+
+To inform libpng about your function, use
+
+    png_set_read_user_chunk_fn(png_ptr, user_chunk_ptr,
+        read_chunk_callback);
+
+This names not only the callback function, but also a user pointer that
+you can retrieve with
+
+    png_get_user_chunk_ptr(png_ptr);
+
+If you call the png_set_read_user_chunk_fn() function, then all unknown
+chunks will be saved when read, in case your callback function will need
+one or more of them.  This behavior can be changed with the
+png_set_keep_unknown_chunks() function, described below.
+
+At this point, you can set up a callback function that will be
+called after each row has been read, which you can use to control
+a progress meter or the like.  It's demonstrated in pngtest.c.
+You must supply a function
+
+    void read_row_callback(png_structp png_ptr,
+       png_uint_32 row, int pass);
+    {
+      /* put your code here */
+    }
+
+(You can give it another name that you like instead of "read_row_callback")
+
+To inform libpng about your function, use
+
+    png_set_read_status_fn(png_ptr, read_row_callback);
+
+When this function is called the row has already been completely processed and
+the 'row' and 'pass' refer to the next row to be handled.  For the
+non-interlaced case the row that was just handled is simply one less than the
+passed in row number, and pass will always be 0.  For the interlaced case the
+same applies unless the row value is 0, in which case the row just handled was
+the last one from one of the preceding passes.  Because interlacing may skip a
+pass you cannot be sure that the preceding pass is just 'pass-1', if you really
+need to know what the last pass is record (row,pass) from the callback and use
+the last recorded value each time.
+
+As with the user transform you can find the output row using the
+PNG_ROW_FROM_PASS_ROW macro.
+
+Unknown-chunk handling
+
+Now you get to set the way the library processes unknown chunks in the
+input PNG stream. Both known and unknown chunks will be read.  Normal
+behavior is that known chunks will be parsed into information in
+various info_ptr members while unknown chunks will be discarded. This
+behavior can be wasteful if your application will never use some known
+chunk types. To change this, you can call:
+
+    png_set_keep_unknown_chunks(png_ptr, keep,
+        chunk_list, num_chunks);
+    keep       - 0: default unknown chunk handling
+                 1: ignore; do not keep
+                 2: keep only if safe-to-copy
+                 3: keep even if unsafe-to-copy
+
+               You can use these definitions:
+                 PNG_HANDLE_CHUNK_AS_DEFAULT   0
+                 PNG_HANDLE_CHUNK_NEVER        1
+                 PNG_HANDLE_CHUNK_IF_SAFE      2
+                 PNG_HANDLE_CHUNK_ALWAYS       3
+
+    chunk_list - list of chunks affected (a byte string,
+                 five bytes per chunk, NULL or '\0' if
+                 num_chunks is 0)
+
+    num_chunks - number of chunks affected; if 0, all
+                 unknown chunks are affected.  If nonzero,
+                 only the chunks in the list are affected
+
+Unknown chunks declared in this way will be saved as raw data onto a
+list of png_unknown_chunk structures.  If a chunk that is normally
+known to libpng is named in the list, it will be handled as unknown,
+according to the "keep" directive.  If a chunk is named in successive
+instances of png_set_keep_unknown_chunks(), the final instance will
+take precedence.  The IHDR and IEND chunks should not be named in
+chunk_list; if they are, libpng will process them normally anyway.
+If you know that your application will never make use of some particular
+chunks, use PNG_HANDLE_CHUNK_NEVER (or 1) as demonstrated below.
+
+Here is an example of the usage of png_set_keep_unknown_chunks(),
+where the private "vpAg" chunk will later be processed by a user chunk
+callback function:
+
+    png_byte vpAg[5]={118, 112,  65, 103, (png_byte) '\0'};
+
+    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+      png_byte unused_chunks[]=
+      {
+        104,  73,  83,  84, (png_byte) '\0',   /* hIST */
+        105,  84,  88, 116, (png_byte) '\0',   /* iTXt */
+        112,  67,  65,  76, (png_byte) '\0',   /* pCAL */
+        115,  67,  65,  76, (png_byte) '\0',   /* sCAL */
+        115,  80,  76,  84, (png_byte) '\0',   /* sPLT */
+        116,  73,  77,  69, (png_byte) '\0',   /* tIME */
+      };
+    #endif
+
+    ...
+
+    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
+      /* ignore all unknown chunks: */
+      png_set_keep_unknown_chunks(read_ptr, 1, NULL, 0);
+
+      /* except for vpAg: */
+      png_set_keep_unknown_chunks(read_ptr, 2, vpAg, 1);
+
+      /* also ignore unused known chunks: */
+      png_set_keep_unknown_chunks(read_ptr, 1, unused_chunks,
+         (int)sizeof(unused_chunks)/5);
+    #endif
+
+User limits
+
+The PNG specification allows the width and height of an image to be as
+large as 2^31-1 (0x7fffffff), or about 2.147 billion rows and columns.
+Since very few applications really need to process such large images,
+we have imposed an arbitrary 1-million limit on rows and columns.
+Larger images will be rejected immediately with a png_error() call. If
+you wish to change this limit, you can use
+
+   png_set_user_limits(png_ptr, width_max, height_max);
+
+to set your own limits, or use width_max = height_max = 0x7fffffffL
+to allow all valid dimensions (libpng may reject some very large images
+anyway because of potential buffer overflow conditions).
+
+You should put this statement after you create the PNG structure and
+before calling png_read_info(), png_read_png(), or png_process_data().
+
+When writing a PNG datastream, put this statement before calling
+png_write_info() or png_write_png().
+
+If you need to retrieve the limits that are being applied, use
+
+   width_max = png_get_user_width_max(png_ptr);
+   height_max = png_get_user_height_max(png_ptr);
+
+The PNG specification sets no limit on the number of ancillary chunks
+allowed in a PNG datastream.  You can impose a limit on the total number
+of sPLT, tEXt, iTXt, zTXt, and unknown chunks that will be stored, with
+
+   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);
+
+where 0x7fffffffL means unlimited.  You can retrieve this limit with
+
+   chunk_cache_max = png_get_chunk_cache_max(png_ptr);
+
+This limit also applies to the number of buffers that can be allocated
+by png_decompress_chunk() while decompressing iTXt, zTXt, and iCCP chunks.
+
+You can also set a limit on the amount of memory that a compressed chunk
+other than IDAT can occupy, with
+
+   png_set_chunk_malloc_max(png_ptr, user_chunk_malloc_max);
+
+and you can retrieve the limit with
+
+   chunk_malloc_max = png_get_chunk_malloc_max(png_ptr);
+
+Any chunks that would cause either of these limits to be exceeded will
+be ignored.
+
+Information about your system
+
+If you intend to display the PNG or to incorporate it in other image data you
+need to tell libpng information about your display or drawing surface so that
+libpng can convert the values in the image to match the display.
+
+From libpng-1.5.4 this information can be set before reading the PNG file
+header.  In earlier versions png_set_gamma() existed but behaved incorrectly if
+called before the PNG file header had been read and png_set_alpha_mode() did not
+exist.
+
+If you need to support versions prior to libpng-1.5.4 test the version number
+as illustrated below using "PNG_LIBPNG_VER >= 10504" and follow the procedures
+described in the appropriate manual page.
+
+You give libpng the encoding expected by your system expressed as a 'gamma'
+value.  You can also specify a default encoding for the PNG file in
+case the required information is missing from the file.  By default libpng
+assumes that the PNG data matches your system, to keep this default call:
+
+   png_set_gamma(png_ptr, screen_gamma, 1/screen_gamma/*file gamma*/);
+
+or you can use the fixed point equivalent:
+
+   png_set_gamma_fixed(png_ptr, PNG_FP_1*screen_gamma, PNG_FP_1/screen_gamma);
+
+If you don't know the gamma for your system it is probably 2.2 - a good
+approximation to the IEC standard for display systems (sRGB).  If images are
+too contrasty or washed out you got the value wrong - check your system
+documentation!
+
+Many systems permit the system gamma to be changed via a lookup table in the
+display driver, a few systems, including older Macs, change the response by
+default.  As of 1.5.4 three special values are available to handle common
+situations:
+
+   PNG_DEFAULT_sRGB: Indicates that the system conforms to the IEC 61966-2-1
+                     standard.  This matches almost all systems.
+   PNG_GAMMA_MAC_18: Indicates that the system is an older (pre Mac OS 10.6)
+                     Apple Macintosh system with the default settings.
+   PNG_GAMMA_LINEAR: Just the fixed point value for 1.0 - indicates that the
+                     system expects data with no gamma encoding.
+
+You would use the linear (unencoded) value if you need to process the pixel
+values further because this avoids the need to decode and reencode each
+component value whenever arithmetic is performed.  A lot of graphics software
+uses linear values for this reason, often with higher precision component values
+to preserve overall accuracy.
+
+The second thing you may need to tell libpng about is how your system handles
+alpha channel information.  Some, but not all, PNG files contain an alpha
+channel.  To display these files correctly you need to compose the data onto a
+suitable background, as described in the PNG specification.
+
+Libpng only supports composing onto a single color (using png_set_background;
+see below).  Otherwise you must do the composition yourself and, in this case,
+you may need to call png_set_alpha_mode:
+
+#if PNG_LIBPNG_VER >= 10504
+   png_set_alpha_mode(png_ptr, mode, screen_gamma);
+#else
+   png_set_gamma(png_ptr, screen_gamma, 1.0/screen_gamma);
+#endif
+
+The screen_gamma value is the same as the argument to png_set_gamma; however,
+how it affects the output depends on the mode.  png_set_alpha_mode() sets the
+file gamma default to 1/screen_gamma, so normally you don't need to call
+png_set_gamma.  If you need different defaults call png_set_gamma() before
+png_set_alpha_mode() - if you call it after it will override the settings made
+by png_set_alpha_mode().
+
+The mode is as follows:
+
+    PNG_ALPHA_PNG: The data is encoded according to the PNG specification.  Red,
+green and blue, or gray, components are gamma encoded color
+values and are not premultiplied by the alpha value.  The
+alpha value is a linear measure of the contribution of the
+pixel to the corresponding final output pixel.
+
+You should normally use this format if you intend to perform
+color correction on the color values; most, maybe all, color
+correction software has no handling for the alpha channel and,
+anyway, the math to handle pre-multiplied component values is
+unnecessarily complex.
+
+Before you do any arithmetic on the component values you need
+to remove the gamma encoding and multiply out the alpha
+channel.  See the PNG specification for more detail.  It is
+important to note that when an image with an alpha channel is
+scaled, linear encoded, pre-multiplied component values must
+be used!
+
+The remaining modes assume you don't need to do any further color correction or
+that if you do, your color correction software knows all about alpha (it
+probably doesn't!)
+
+    PNG_ALPHA_STANDARD:  The data libpng produces
+is encoded in the standard way
+assumed by most correctly written graphics software.
+The gamma encoding will be removed by libpng and the
+linear component values will be pre-multiplied by the
+alpha channel.
+
+With this format the final image must be re-encoded to
+match the display gamma before the image is displayed.
+If your system doesn't do that, yet still seems to
+perform arithmetic on the pixels without decoding them,
+it is broken - check out the modes below.
+
+With PNG_ALPHA_STANDARD libpng always produces linear
+component values, whatever screen_gamma you supply.  The
+screen_gamma value is, however, used as a default for
+the file gamma if the PNG file has no gamma information.
+
+If you call png_set_gamma() after png_set_alpha_mode() you
+will override the linear encoding.  Instead the
+pre-multiplied pixel values will be gamma encoded but
+the alpha channel will still be linear.  This may
+actually match the requirements of some broken software,
+but it is unlikely.
+
+While linear 8-bit data is often used it has
+insufficient precision for any image with a reasonable
+dynamic range.  To avoid problems, and if your software
+supports it, use png_set_expand_16() to force all
+components to 16 bits.
+
+    PNG_ALPHA_OPTIMIZED: This mode is the same
+as PNG_ALPHA_STANDARD except that
+completely opaque pixels are gamma encoded according to
+the screen_gamma value.  Pixels with alpha less than 1.0
+will still have linear components.
+
+Use this format if you have control over your
+compositing software and so don't do other arithmetic
+(such as scaling) on the data you get from libpng.  Your
+compositing software can simply copy opaque pixels to
+the output but still has linear values for the
+non-opaque pixels.
+
+In normal compositing, where the alpha channel encodes
+partial pixel coverage (as opposed to broad area
+translucency), the inaccuracies of the 8-bit
+representation of non-opaque pixels are irrelevant.
+
+You can also try this format if your software is broken;
+it might look better.
+
+    PNG_ALPHA_BROKEN: This is PNG_ALPHA_STANDARD;
+however, all component values,
+including the alpha channel are gamma encoded.  This is
+an appropriate format to try if your software, or more
+likely hardware, is totally broken, i.e., if it performs
+linear arithmetic directly on gamma encoded values.
+
+In most cases of broken software or hardware the bug in the final display
+manifests as a subtle halo around composited parts of the image.  You may not
+even perceive this as a halo; the composited part of the image may simply appear
+separate from the background, as though it had been cut out of paper and pasted
+on afterward.
+
+If you don't have to deal with bugs in software or hardware, or if you can fix
+them, there are three recommended ways of using png_set_alpha_mode():
+
+   png_set_alpha_mode(png_ptr, PNG_ALPHA_PNG,
+       screen_gamma);
+
+You can do color correction on the result (libpng does not currently
+support color correction internally).  When you handle the alpha channel
+you need to undo the gamma encoding and multiply out the alpha.
+
+   png_set_alpha_mode(png_ptr, PNG_ALPHA_STANDARD,
+       screen_gamma);
+   png_set_expand_16(png_ptr);
+
+If you are using the high level interface, don't call png_set_expand_16();
+instead pass PNG_TRANSFORM_EXPAND_16 to the interface.
+
+With this mode you can't do color correction, but you can do arithmetic,
+including composition and scaling, on the data without further processing.
+
+   png_set_alpha_mode(png_ptr, PNG_ALPHA_OPTIMIZED,
+       screen_gamma);
+
+You can avoid the expansion to 16-bit components with this mode, but you
+lose the ability to scale the image or perform other linear arithmetic.
+All you can do is compose the result onto a matching output.  Since this
+mode is libpng-specific you also need to write your own composition
+software.
+
+If you don't need, or can't handle, the alpha channel you can call
+png_set_background() to remove it by compositing against a fixed color.  Don't
+call png_set_strip_alpha() to do this - it will leave spurious pixel values in
+transparent parts of this image.
+
+   png_set_background(png_ptr, &background_color,
+       PNG_BACKGROUND_GAMMA_SCREEN, 0, 1);
+
+The background_color is an RGB or grayscale value according to the data format
+libpng will produce for you.  Because you don't yet know the format of the PNG
+file, if you call png_set_background at this point you must arrange for the
+format produced by libpng to always have 8-bit or 16-bit components and then
+store the color as an 8-bit or 16-bit color as appropriate.  The color contains
+separate gray and RGB component values, so you can let libpng produce gray or
+RGB output according to the input format, but low bit depth grayscale images
+must always be converted to at least 8-bit format.  (Even though low bit depth
+grayscale images can't have an alpha channel they can have a transparent
+color!)
+
+You set the transforms you need later, either as flags to the high level
+interface or libpng API calls for the low level interface.  For reference the
+settings and API calls required are:
+
+8-bit values:
+   PNG_TRANSFORM_SCALE_16 | PNG_EXPAND
+   png_set_expand(png_ptr); png_set_scale_16(png_ptr);
+
+   If you must get exactly the same inaccurate results
+   produced by default in versions prior to libpng-1.5.4,
+   use PNG_TRANSFORM_STRIP_16 and png_set_strip_16(png_ptr)
+   instead.
+
+16-bit values:
+   PNG_TRANSFORM_EXPAND_16
+   png_set_expand_16(png_ptr);
+
+In either case palette image data will be expanded to RGB.  If you just want
+color data you can add PNG_TRANSFORM_GRAY_TO_RGB or png_set_gray_to_rgb(png_ptr)
+to the list.
+
+Calling png_set_background before the PNG file header is read will not work
+prior to libpng-1.5.4.  Because the failure may result in unexpected warnings or
+errors it is therefore much safer to call png_set_background after the head has
+been read.  Unfortunately this means that prior to libpng-1.5.4 it cannot be
+used with the high level interface.
+
+The high-level read interface
+
+At this point there are two ways to proceed; through the high-level
+read interface, or through a sequence of low-level read operations.
+You can use the high-level interface if (a) you are willing to read
+the entire image into memory, and (b) the input transformations
+you want to do are limited to the following set:
+
+    PNG_TRANSFORM_IDENTITY      No transformation
+    PNG_TRANSFORM_SCALE_16      Strip 16-bit samples to
+                                8-bit accurately
+    PNG_TRANSFORM_STRIP_16      Chop 16-bit samples to
+                                8-bit less accurately
+    PNG_TRANSFORM_STRIP_ALPHA   Discard the alpha channel
+    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit
+                                samples to bytes
+    PNG_TRANSFORM_PACKSWAP      Change order of packed
+                                pixels to LSB first
+    PNG_TRANSFORM_EXPAND        Perform set_expand()
+    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
+    PNG_TRANSFORM_SHIFT         Normalize pixels to the
+                                sBIT depth
+    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA
+                                to BGRA
+    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA
+                                to AG
+    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity
+                                to transparency
+    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
+    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
+                                to RGB (or GA to RGBA)
+    PNG_TRANSFORM_EXPAND_16     Expand samples to 16 bits
+
+(This excludes setting a background color, doing gamma transformation,
+quantizing, and setting filler.)  If this is the case, simply do this:
+
+    png_read_png(png_ptr, info_ptr, png_transforms, NULL)
+
+where png_transforms is an integer containing the bitwise OR of some
+set of transformation flags.  This call is equivalent to png_read_info(),
+followed the set of transformations indicated by the transform mask,
+then png_read_image(), and finally png_read_end().
+
+(The final parameter of this call is not yet used.  Someday it might point
+to transformation parameters required by some future input transform.)
+
+You must use png_transforms and not call any png_set_transform() functions
+when you use png_read_png().
+
+After you have called png_read_png(), you can retrieve the image data
+with
+
+   row_pointers = png_get_rows(png_ptr, info_ptr);
+
+where row_pointers is an array of pointers to the pixel data for each row:
+
+   png_bytep row_pointers[height];
+
+If you know your image size and pixel size ahead of time, you can allocate
+row_pointers prior to calling png_read_png() with
+
+   if (height > PNG_UINT_32_MAX/png_sizeof(png_byte))
+      png_error (png_ptr,
+          "Image is too tall to process in memory");
+
+   if (width > PNG_UINT_32_MAX/pixel_size)
+      png_error (png_ptr,
+          "Image is too wide to process in memory");
+
+   row_pointers = png_malloc(png_ptr,
+       height*png_sizeof(png_bytep));
+
+   for (int i=0; i<height, i++)
+      row_pointers[i]=NULL;  /* security precaution */
+
+   for (int i=0; i<height, i++)
+      row_pointers[i]=png_malloc(png_ptr,
+          width*pixel_size);
+
+   png_set_rows(png_ptr, info_ptr, &row_pointers);
+
+Alternatively you could allocate your image in one big block and define
+row_pointers[i] to point into the proper places in your block.
+
+If you use png_set_rows(), the application is responsible for freeing
+row_pointers (and row_pointers[i], if they were separately allocated).
+
+If you don't allocate row_pointers ahead of time, png_read_png() will
+do it, and it'll be free'ed by libpng when you call png_destroy_*().
+
+The low-level read interface
+
+If you are going the low-level route, you are now ready to read all
+the file information up to the actual image data.  You do this with a
+call to png_read_info().
+
+    png_read_info(png_ptr, info_ptr);
+
+This will process all chunks up to but not including the image data.
+
+This also copies some of the data from the PNG file into the decode structure
+for use in later transformations.  Important information copied in is:
+
+1) The PNG file gamma from the gAMA chunk.  This overwrites the default value
+provided by an earlier call to png_set_gamma or png_set_alpha_mode.
+
+2) Prior to libpng-1.5.4 the background color from a bKGd chunk.  This
+damages the information provided by an earlier call to png_set_background
+resulting in unexpected behavior.  Libpng-1.5.4 no longer does this.
+
+3) The number of significant bits in each component value.  Libpng uses this to
+optimize gamma handling by reducing the internal lookup table sizes.
+
+4) The transparent color information from a tRNS chunk.  This can be modified by
+a later call to png_set_tRNS.
+
+Querying the info structure
+
+Functions are used to get the information from the info_ptr once it
+has been read.  Note that these fields may not be completely filled
+in until png_read_end() has read the chunk data following the image.
+
+    png_get_IHDR(png_ptr, info_ptr, &width, &height,
+       &bit_depth, &color_type, &interlace_type,
+       &compression_type, &filter_method);
+
+    width          - holds the width of the image
+                     in pixels (up to 2^31).
+
+    height         - holds the height of the image
+                     in pixels (up to 2^31).
+
+    bit_depth      - holds the bit depth of one of the
+                     image channels.  (valid values are
+                     1, 2, 4, 8, 16 and depend also on
+                     the color_type.  See also
+                     significant bits (sBIT) below).
+
+    color_type     - describes which color/alpha channels
+                         are present.
+                     PNG_COLOR_TYPE_GRAY
+                        (bit depths 1, 2, 4, 8, 16)
+                     PNG_COLOR_TYPE_GRAY_ALPHA
+                        (bit depths 8, 16)
+                     PNG_COLOR_TYPE_PALETTE
+                        (bit depths 1, 2, 4, 8)
+                     PNG_COLOR_TYPE_RGB
+                        (bit_depths 8, 16)
+                     PNG_COLOR_TYPE_RGB_ALPHA
+                        (bit_depths 8, 16)
+
+                     PNG_COLOR_MASK_PALETTE
+                     PNG_COLOR_MASK_COLOR
+                     PNG_COLOR_MASK_ALPHA
+
+    interlace_type - (PNG_INTERLACE_NONE or
+                     PNG_INTERLACE_ADAM7)
+
+    compression_type - (must be PNG_COMPRESSION_TYPE_BASE
+                     for PNG 1.0)
+
+    filter_method  - (must be PNG_FILTER_TYPE_BASE
+                     for PNG 1.0, and can also be
+                     PNG_INTRAPIXEL_DIFFERENCING if
+                     the PNG datastream is embedded in
+                     a MNG-1.0 datastream)
+
+    Any or all of interlace_type, compression_type, or
+    filter_method can be NULL if you are
+    not interested in their values.
+
+    Note that png_get_IHDR() returns 32-bit data into
+    the application's width and height variables.
+    This is an unsafe situation if these are 16-bit
+    variables.  In such situations, the
+    png_get_image_width() and png_get_image_height()
+    functions described below are safer.
+
+    width            = png_get_image_width(png_ptr,
+                         info_ptr);
+
+    height           = png_get_image_height(png_ptr,
+                         info_ptr);
+
+    bit_depth        = png_get_bit_depth(png_ptr,
+                         info_ptr);
+
+    color_type       = png_get_color_type(png_ptr,
+                         info_ptr);
+
+    interlace_type   = png_get_interlace_type(png_ptr,
+                         info_ptr);
+
+    compression_type = png_get_compression_type(png_ptr,
+                         info_ptr);
+
+    filter_method    = png_get_filter_type(png_ptr,
+                         info_ptr);
+
+    channels = png_get_channels(png_ptr, info_ptr);
+
+    channels       - number of channels of info for the
+                     color type (valid values are 1 (GRAY,
+                     PALETTE), 2 (GRAY_ALPHA), 3 (RGB),
+                     4 (RGB_ALPHA or RGB + filler byte))
+
+    rowbytes = png_get_rowbytes(png_ptr, info_ptr);
+
+    rowbytes       - number of bytes needed to hold a row
+
+    signature = png_get_signature(png_ptr, info_ptr);
+
+    signature      - holds the signature read from the
+                     file (if any).  The data is kept in
+                     the same offset it would be if the
+                     whole signature were read (i.e. if an
+                     application had already read in 4
+                     bytes of signature before starting
+                     libpng, the remaining 4 bytes would
+                     be in signature[4] through signature[7]
+                     (see png_set_sig_bytes())).
+
+These are also important, but their validity depends on whether the chunk
+has been read.  The png_get_valid(png_ptr, info_ptr, PNG_INFO_<chunk>) and
+png_get_<chunk>(png_ptr, info_ptr, ...) functions return non-zero if the
+data has been read, or zero if it is missing.  The parameters to the
+png_get_<chunk> are set directly if they are simple data types, or a
+pointer into the info_ptr is returned for any complex types.
+
+The colorspace data from gAMA, cHRM, sRGB, iCCP, and sBIT chunks
+is simply returned to give the application information about how the
+image was encoded.  Libpng itself only does transformations using the file
+gamma when combining semitransparent pixels with the background color.
+
+    png_get_PLTE(png_ptr, info_ptr, &palette,
+                     &num_palette);
+
+    palette        - the palette for the file
+                     (array of png_color)
+
+    num_palette    - number of entries in the palette
+
+    png_get_gAMA(png_ptr, info_ptr, &file_gamma);
+    png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);
+
+    file_gamma     - the gamma at which the file was
+                     written (PNG_INFO_gAMA)
+
+    int_file_gamma - 100,000 times the gamma at which the
+                     file is written
+
+    png_get_cHRM(png_ptr, info_ptr,  &white_x, &white_y, &red_x, &red_y,
+                     &green_x, &green_y, &blue_x, &blue_y)
+    png_get_cHRM_XYZ(png_ptr, info_ptr, &red_X, &red_Y, &red_Z, &green_X,
+                     &green_Y, &green_Z, &blue_X, &blue_Y, &blue_Z)
+    png_get_cHRM_fixed(png_ptr, info_ptr, &int_white_x, &int_white_y,
+                     &int_red_x, &int_red_y, &int_green_x, &int_green_y,
+                     &int_blue_x, &int_blue_y)
+    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &int_red_X, &int_red_Y,
+                     &int_red_Z, &int_green_X, &int_green_Y, &int_green_Z,
+                     &int_blue_X, &int_blue_Y, &int_blue_Z)
+
+    {white,red,green,blue}_{x,y}
+                     A color space encoding specified using the chromaticities
+                     of the end points and the white point. (PNG_INFO_cHRM)
+
+    {red,green,blue}_{X,Y,Z}
+                     A color space encoding specified using the encoding end
+                     points - the CIE tristimulus specification of the intended
+                     color of the red, green and blue channels in the PNG RGB
+                     data.  The white point is simply the sum of the three end
+                     points. (PNG_INFO_cHRM)
+
+    png_get_sRGB(png_ptr, info_ptr, &srgb_intent);
+
+    file_srgb_intent - the rendering intent (PNG_INFO_sRGB)
+                     The presence of the sRGB chunk
+                     means that the pixel data is in the
+                     sRGB color space.  This chunk also
+                     implies specific values of gAMA and
+                     cHRM.
+
+    png_get_iCCP(png_ptr, info_ptr, &name,
+       &compression_type, &profile, &proflen);
+
+    name             - The profile name.
+
+    compression_type - The compression type; always
+                       PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
+                       You may give NULL to this argument to
+                       ignore it.
+
+    profile          - International Color Consortium color
+                       profile data. May contain NULs.
+
+    proflen          - length of profile data in bytes.
+
+    png_get_sBIT(png_ptr, info_ptr, &sig_bit);
+
+    sig_bit        - the number of significant bits for
+                     (PNG_INFO_sBIT) each of the gray,
+                     red, green, and blue channels,
+                     whichever are appropriate for the
+                     given color type (png_color_16)
+
+    png_get_tRNS(png_ptr, info_ptr, &trans_alpha,
+                     &num_trans, &trans_color);
+
+    trans_alpha    - array of alpha (transparency)
+                     entries for palette (PNG_INFO_tRNS)
+
+    num_trans      - number of transparent entries
+                     (PNG_INFO_tRNS)
+
+    trans_color    - graylevel or color sample values of
+                     the single transparent color for
+                     non-paletted images (PNG_INFO_tRNS)
+
+    png_get_hIST(png_ptr, info_ptr, &hist);
+                     (PNG_INFO_hIST)
+
+    hist           - histogram of palette (array of
+                     png_uint_16)
+
+    png_get_tIME(png_ptr, info_ptr, &mod_time);
+
+    mod_time       - time image was last modified
+                    (PNG_VALID_tIME)
+
+    png_get_bKGD(png_ptr, info_ptr, &background);
+
+    background     - background color (of type
+                     png_color_16p) (PNG_VALID_bKGD)
+                     valid 16-bit red, green and blue
+                     values, regardless of color_type
+
+    num_comments   = png_get_text(png_ptr, info_ptr,
+                     &text_ptr, &num_text);
+
+    num_comments   - number of comments
+
+    text_ptr       - array of png_text holding image
+                     comments
+
+    text_ptr[i].compression - type of compression used
+                 on "text" PNG_TEXT_COMPRESSION_NONE
+                           PNG_TEXT_COMPRESSION_zTXt
+                           PNG_ITXT_COMPRESSION_NONE
+                           PNG_ITXT_COMPRESSION_zTXt
+
+    text_ptr[i].key   - keyword for comment.  Must contain
+                         1-79 characters.
+
+    text_ptr[i].text  - text comments for current
+                         keyword.  Can be empty.
+
+    text_ptr[i].text_length - length of text string,
+                 after decompression, 0 for iTXt
+
+    text_ptr[i].itxt_length - length of itxt string,
+                 after decompression, 0 for tEXt/zTXt
+
+    text_ptr[i].lang  - language of comment (empty
+                         string for unknown).
+
+    text_ptr[i].lang_key  - keyword in UTF-8
+                         (empty string for unknown).
+
+    Note that the itxt_length, lang, and lang_key
+    members of the text_ptr structure only exist when the
+    library is built with iTXt chunk support.  Prior to
+    libpng-1.4.0 the library was built by default without
+    iTXt support. Also note that when iTXt is supported,
+    they contain NULL pointers when the "compression"
+    field contains PNG_TEXT_COMPRESSION_NONE or
+    PNG_TEXT_COMPRESSION_zTXt.
+
+    num_text       - number of comments (same as
+                     num_comments; you can put NULL here
+                     to avoid the duplication)
+
+    Note while png_set_text() will accept text, language,
+    and translated keywords that can be NULL pointers, the
+    structure returned by png_get_text will always contain
+    regular zero-terminated C strings.  They might be
+    empty strings but they will never be NULL pointers.
+
+    num_spalettes = png_get_sPLT(png_ptr, info_ptr,
+       &palette_ptr);
+
+    num_spalettes  - number of sPLT chunks read.
+
+    palette_ptr    - array of palette structures holding
+                     contents of one or more sPLT chunks
+                     read.
+
+    png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
+       &unit_type);
+
+    offset_x       - positive offset from the left edge
+                     of the screen (can be negative)
+
+    offset_y       - positive offset from the top edge
+                     of the screen (can be negative)
+
+    unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
+
+    png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
+       &unit_type);
+
+    res_x          - pixels/unit physical resolution in
+                     x direction
+
+    res_y          - pixels/unit physical resolution in
+                     x direction
+
+    unit_type      - PNG_RESOLUTION_UNKNOWN,
+                     PNG_RESOLUTION_METER
+
+    png_get_sCAL(png_ptr, info_ptr, &unit, &width,
+       &height)
+
+    unit        - physical scale units (an integer)
+
+    width       - width of a pixel in physical scale units
+
+    height      - height of a pixel in physical scale units
+                 (width and height are doubles)
+
+    png_get_sCAL_s(png_ptr, info_ptr, &unit, &width,
+       &height)
+
+    unit        - physical scale units (an integer)
+
+    width       - width of a pixel in physical scale units
+                  (expressed as a string)
+
+    height      - height of a pixel in physical scale units
+                 (width and height are strings like "2.54")
+
+    num_unknown_chunks = png_get_unknown_chunks(png_ptr,
+       info_ptr, &unknowns)
+
+    unknowns          - array of png_unknown_chunk
+                        structures holding unknown chunks
+
+    unknowns[i].name  - name of unknown chunk
+
+    unknowns[i].data  - data of unknown chunk
+
+    unknowns[i].size  - size of unknown chunk's data
+
+    unknowns[i].location - position of chunk in file
+
+    The value of "i" corresponds to the order in which the
+    chunks were read from the PNG file or inserted with the
+    png_set_unknown_chunks() function.
+
+    The value of "location" is a bitwise "or" of
+
+         PNG_HAVE_IHDR  (0x01)
+         PNG_HAVE_PLTE  (0x02)
+         PNG_AFTER_IDAT (0x08)
+
+The data from the pHYs chunk can be retrieved in several convenient
+forms:
+
+    res_x = png_get_x_pixels_per_meter(png_ptr,
+       info_ptr)
+
+    res_y = png_get_y_pixels_per_meter(png_ptr,
+       info_ptr)
+
+    res_x_and_y = png_get_pixels_per_meter(png_ptr,
+       info_ptr)
+
+    res_x = png_get_x_pixels_per_inch(png_ptr,
+       info_ptr)
+
+    res_y = png_get_y_pixels_per_inch(png_ptr,
+       info_ptr)
+
+    res_x_and_y = png_get_pixels_per_inch(png_ptr,
+       info_ptr)
+
+    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
+       info_ptr)
+
+    Each of these returns 0 [signifying "unknown"] if
+       the data is not present or if res_x is 0;
+       res_x_and_y is 0 if res_x != res_y
+
+    Note that because of the way the resolutions are
+       stored internally, the inch conversions won't
+       come out to exactly even number.  For example,
+       72 dpi is stored as 0.28346 pixels/meter, and
+       when this is retrieved it is 71.9988 dpi, so
+       be sure to round the returned value appropriately
+       if you want to display a reasonable-looking result.
+
+The data from the oFFs chunk can be retrieved in several convenient
+forms:
+
+    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
+
+    y_offset = png_get_y_offset_microns(png_ptr, info_ptr);
+
+    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
+
+    y_offset = png_get_y_offset_inches(png_ptr, info_ptr);
+
+    Each of these returns 0 [signifying "unknown" if both
+       x and y are 0] if the data is not present or if the
+       chunk is present but the unit is the pixel.  The
+       remark about inexact inch conversions applies here
+       as well, because a value in inches can't always be
+       converted to microns and back without some loss
+       of precision.
+
+For more information, see the
+PNG specification for chunk contents.  Be careful with trusting
+rowbytes, as some of the transformations could increase the space
+needed to hold a row (expand, filler, gray_to_rgb, etc.).
+See png_read_update_info(), below.
+
+A quick word about text_ptr and num_text.  PNG stores comments in
+keyword/text pairs, one pair per chunk, with no limit on the number
+of text chunks, and a 2^31 byte limit on their size.  While there are
+suggested keywords, there is no requirement to restrict the use to these
+strings.  It is strongly suggested that keywords and text be sensible
+to humans (that's the point), so don't use abbreviations.  Non-printing
+symbols are not allowed.  See the PNG specification for more details.
+There is also no requirement to have text after the keyword.
+
+Keywords should be limited to 79 Latin-1 characters without leading or
+trailing spaces, but non-consecutive spaces are allowed within the
+keyword.  It is possible to have the same keyword any number of times.
+The text_ptr is an array of png_text structures, each holding a
+pointer to a language string, a pointer to a keyword and a pointer to
+a text string.  The text string, language code, and translated
+keyword may be empty or NULL pointers.  The keyword/text
+pairs are put into the array in the order that they are received.
+However, some or all of the text chunks may be after the image, so, to
+make sure you have read all the text chunks, don't mess with these
+until after you read the stuff after the image.  This will be
+mentioned again below in the discussion that goes with png_read_end().
+
+Input transformations
+
+After you've read the header information, you can set up the library
+to handle any special transformations of the image data.  The various
+ways to transform the data will be described in the order that they
+should occur.  This is important, as some of these change the color
+type and/or bit depth of the data, and some others only work on
+certain color types and bit depths.
+
+Transformations you request are ignored if they don't have any meaning for a
+particular input data format.  However some transformations can have an effect
+as a result of a previous transformation.  If you specify a contradictory set of
+transformations, for example both adding and removing the alpha channel, you
+cannot predict the final result.
+
+The color used for the transparency values should be supplied in the same
+format/depth as the current image data.  It is stored in the same format/depth
+as the image data in a tRNS chunk, so this is what libpng expects for this data.
+
+The color used for the background value depends on the need_expand argument as
+described below.
+
+Data will be decoded into the supplied row buffers packed into bytes
+unless the library has been told to transform it into another format.
+For example, 4 bit/pixel paletted or grayscale data will be returned
+2 pixels/byte with the leftmost pixel in the high-order bits of the
+byte, unless png_set_packing() is called.  8-bit RGB data will be stored
+in RGB RGB RGB format unless png_set_filler() or png_set_add_alpha()
+is called to insert filler bytes, either before or after each RGB triplet.
+16-bit RGB data will be returned RRGGBB RRGGBB, with the most significant
+byte of the color value first, unless png_set_scale_16() is called to
+transform it to regular RGB RGB triplets, or png_set_filler() or
+png_set_add alpha() is called to insert filler bytes, either before or
+after each RRGGBB triplet.  Similarly, 8-bit or 16-bit grayscale data can
+be modified with png_set_filler(), png_set_add_alpha(), png_set_strip_16(),
+or png_set_scale_16().
+
+The following code transforms grayscale images of less than 8 to 8 bits,
+changes paletted images to RGB, and adds a full alpha channel if there is
+transparency information in a tRNS chunk.  This is most useful on
+grayscale images with bit depths of 2 or 4 or if there is a multiple-image
+viewing application that wishes to treat all images in the same way.
+
+    if (color_type == PNG_COLOR_TYPE_PALETTE)
+        png_set_palette_to_rgb(png_ptr);
+
+    if (png_get_valid(png_ptr, info_ptr,
+        PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);
+
+    if (color_type == PNG_COLOR_TYPE_GRAY &&
+        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
+
+The first two functions are actually aliases for png_set_expand(), added
+in libpng version 1.0.4, with the function names expanded to improve code
+readability.  In some future version they may actually do different
+things.
+
+As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
+added.  It expands the sample depth without changing tRNS to alpha.
+
+As of libpng version 1.5.2, png_set_expand_16() was added.  It behaves as
+png_set_expand(); however, the resultant channels have 16 bits rather than 8.
+Use this when the output color or gray channels are made linear to avoid fairly
+severe accuracy loss.
+
+   if (bit_depth < 16)
+      png_set_expand_16(png_ptr);
+
+PNG can have files with 16 bits per channel.  If you only can handle
+8 bits per channel, this will strip the pixels down to 8-bit.
+
+    if (bit_depth == 16)
+#if PNG_LIBPNG_VER >= 10504
+       png_set_scale_16(png_ptr);
+#else
+       png_set_strip_16(png_ptr);
+#endif
+
+(The more accurate "png_set_scale_16()" API became available in libpng version
+1.5.4).
+
+If you need to process the alpha channel on the image separately from the image
+data (for example if you convert it to a bitmap mask) it is possible to have
+libpng strip the channel leaving just RGB or gray data:
+
+    if (color_type & PNG_COLOR_MASK_ALPHA)
+       png_set_strip_alpha(png_ptr);
+
+If you strip the alpha channel you need to find some other way of dealing with
+the information.  If, instead, you want to convert the image to an opaque
+version with no alpha channel use png_set_background; see below.
+
+As of libpng version 1.5.2, almost all useful expansions are supported, the
+major ommissions are conversion of grayscale to indexed images (which can be
+done trivially in the application) and conversion of indexed to grayscale (which
+can be done by a trivial manipulation of the palette.)
+
+In the following table, the 01 means grayscale with depth<8, 31 means
+indexed with depth<8, other numerals represent the color type, "T" means
+the tRNS chunk is present, A means an alpha channel is present, and O
+means tRNS or alpha is present but all pixels in the image are opaque.
+
+  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O
+   TO
+   01    -  [G]  -   -   -   -   -   -   -   -   -   -   -   -   -
+   31   [Q]  Q  [Q] [Q] [Q]  Q   Q   Q   Q   Q   Q  [Q] [Q]  Q   Q
+    0    1   G   +   .   .   G   G   G   G   G   G   B   B  GB  GB
+   0T    lt  Gt  t   +   .   Gt  G   G   Gt  G   G   Bt  Bt GBt GBt
+   0O    lt  Gt  t   .   +   Gt  Gt  G   Gt  Gt  G   Bt  Bt GBt GBt
+    2    C   P   C   C   C   +   .   .   C   -   -  CB  CB   B   B
+   2T    Ct  -   Ct  C   C   t   +   t   -   -   -  CBt CBt  Bt  Bt
+   2O    Ct  -   Ct  C   C   t   t   +   -   -   -  CBt CBt  Bt  Bt
+    3   [Q]  p  [Q] [Q] [Q]  Q   Q   Q   +   .   .  [Q] [Q]  Q   Q
+   3T   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   +   t  [Qt][Qt] Qt  Qt
+   3O   [Qt] p  [Qt][Q] [Q]  Qt  Qt  Qt  t   t   +  [Qt][Qt] Qt  Qt
+   4A    lA  G   A   T   T   GA  GT  GT  GA  GT  GT  +   BA  G  GBA
+   4O    lA GBA  A   T   T   GA  GT  GT  GA  GT  GT  BA  +  GBA  G
+   6A    CA  PA  CA  C   C   A   T  tT   PA  P   P   C  CBA  +   BA
+   6O    CA PBA  CA  C   C   A  tT   T   PA  P   P  CBA  C   BA  +
+
+Within the matrix,
+     "+" identifies entries where 'from' and 'to' are the same.
+     "-" means the transformation is not supported.
+     "." means nothing is necessary (a tRNS chunk can just be ignored).
+     "t" means the transformation is obtained by png_set_tRNS.
+     "A" means the transformation is obtained by png_set_add_alpha().
+     "X" means the transformation is obtained by png_set_expand().
+     "1" means the transformation is obtained by
+         png_set_expand_gray_1_2_4_to_8() (and by png_set_expand() if there
+         is no transparency in the original or the final format).
+     "C" means the transformation is obtained by png_set_gray_to_rgb().
+     "G" means the transformation is obtained by png_set_rgb_to_gray().
+     "P" means the transformation is obtained by
+         png_set_expand_palette_to_rgb().
+     "p" means the transformation is obtained by png_set_packing().
+     "Q" means the transformation is obtained by png_set_quantize().
+     "T" means the transformation is obtained by png_set_tRNS_to_alpha().
+     "B" means the transformation is obtained by png_set_background(), or
+         png_strip_alpha().
+
+When an entry has multiple transforms listed all are required to cause the
+right overall transformation.  When two transforms are separated by a comma
+either will do the job.  When transforms are enclosed in [] the transform should
+do the job but this is currently unimplemented - a different format will result
+if the suggested transformations are used.
+
+In PNG files, the alpha channel in an image
+is the level of opacity.  If you need the alpha channel in an image to
+be the level of transparency instead of opacity, you can invert the
+alpha channel (or the tRNS chunk data) after it's read, so that 0 is
+fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit
+images) is fully transparent, with
+
+    png_set_invert_alpha(png_ptr);
+
+PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
+they can, resulting in, for example, 8 pixels per byte for 1 bit
+files.  This code expands to 1 pixel per byte without changing the
+values of the pixels:
+
+    if (bit_depth < 8)
+       png_set_packing(png_ptr);
+
+PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
+stored in a PNG image have been "scaled" or "shifted" up to the next
+higher possible bit depth (e.g. from 5 bits/sample in the range [0,31]
+to 8 bits/sample in the range [0, 255]).  However, it is also possible
+to convert the PNG pixel data back to the original bit depth of the
+image.  This call reduces the pixels back down to the original bit depth:
+
+    png_color_8p sig_bit;
+
+    if (png_get_sBIT(png_ptr, info_ptr, &sig_bit))
+       png_set_shift(png_ptr, sig_bit);
+
+PNG files store 3-color pixels in red, green, blue order.  This code
+changes the storage of the pixels to blue, green, red:
+
+    if (color_type == PNG_COLOR_TYPE_RGB ||
+        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+       png_set_bgr(png_ptr);
+
+PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them
+into 4 or 8 bytes for windowing systems that need them in this format:
+
+    if (color_type == PNG_COLOR_TYPE_RGB)
+       png_set_filler(png_ptr, filler, PNG_FILLER_BEFORE);
+
+where "filler" is the 8 or 16-bit number to fill with, and the location is
+either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether
+you want the filler before the RGB or after.  This transformation
+does not affect images that already have full alpha channels.  To add an
+opaque alpha channel, use filler=0xff or 0xffff and PNG_FILLER_AFTER which
+will generate RGBA pixels.
+
+Note that png_set_filler() does not change the color type.  If you want
+to do that, you can add a true alpha channel with
+
+    if (color_type == PNG_COLOR_TYPE_RGB ||
+       color_type == PNG_COLOR_TYPE_GRAY)
+       png_set_add_alpha(png_ptr, filler, PNG_FILLER_AFTER);
+
+where "filler" contains the alpha value to assign to each pixel.
+This function was added in libpng-1.2.7.
+
+If you are reading an image with an alpha channel, and you need the
+data as ARGB instead of the normal PNG format RGBA:
+
+    if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+       png_set_swap_alpha(png_ptr);
+
+For some uses, you may want a grayscale image to be represented as
+RGB.  This code will do that conversion:
+
+    if (color_type == PNG_COLOR_TYPE_GRAY ||
+        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+       png_set_gray_to_rgb(png_ptr);
+
+Conversely, you can convert an RGB or RGBA image to grayscale or grayscale
+with alpha.
+
+    if (color_type == PNG_COLOR_TYPE_RGB ||
+        color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+       png_set_rgb_to_gray(png_ptr, error_action, double red_weight,
+          double green_weight);
+
+    error_action = 1: silently do the conversion
+
+    error_action = 2: issue a warning if the original
+                      image has any pixel where
+                      red != green or red != blue
+
+    error_action = 3: issue an error and abort the
+                      conversion if the original
+                      image has any pixel where
+                      red != green or red != blue
+
+    red_weight:       weight of red component
+
+    green_weight:     weight of green component
+                      If either weight is negative, default
+                      weights are used.
+
+In the corresponding fixed point API the red_weight and green_weight values are
+simply scaled by 100,000:
+
+    png_set_rgb_to_gray(png_ptr, error_action, png_fixed_point red_weight,
+       png_fixed_point green_weight);
+
+If you have set error_action = 1 or 2, you can
+later check whether the image really was gray, after processing
+the image rows, with the png_get_rgb_to_gray_status(png_ptr) function.
+It will return a png_byte that is zero if the image was gray or
+1 if there were any non-gray pixels.  Background and sBIT data
+will be silently converted to grayscale, using the green channel
+data for sBIT, regardless of the error_action setting.
+
+The default values come from the PNG file cHRM chunk if present; otherwise, the
+defaults correspond to the ITU-R recommendation 709, and also the sRGB color
+space, as recommended in the Charles Poynton's Colour FAQ,
+<http://www.poynton.com/>, in section 9:
+
+   <http://www.poynton.com/notes/colour_and_gamma/ColorFAQ.html#RTFToC9>
+
+    Y = 0.2126 * R + 0.7152 * G + 0.0722 * B
+
+Previous versions of this document, 1998 through 2002, recommended a slightly
+different formula:
+
+    Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
+
+Libpng uses an integer approximation:
+
+    Y = (6968 * R + 23434 * G + 2366 * B)/32768
+
+The calculation is done in a linear colorspace, if the image gamma
+can be determined.
+
+The png_set_background() function has been described already; it tells libpng to
+composite images with alpha or simple transparency against the supplied
+background color.  For compatibility with versions of libpng earlier than
+libpng-1.5.4 it is recommended that you call the function after reading the file
+header, even if you don't want to use the color in a bKGD chunk, if one exists.
+
+If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid),
+you may use this color, or supply another color more suitable for
+the current display (e.g., the background color from a web page).  You
+need to tell libpng how the color is represented, both the format of the
+component values in the color (the number of bits) and the gamma encoding of the
+color.  The function takes two arguments, background_gamma_mode and need_expand
+to convey this information; however, only two combinations are likely to be
+useful:
+
+    png_color_16 my_background;
+    png_color_16p image_background;
+
+    if (png_get_bKGD(png_ptr, info_ptr, &image_background))
+       png_set_background(png_ptr, image_background,
+           PNG_BACKGROUND_GAMMA_FILE, 1/*needs to be expanded*/, 1);
+    else
+       png_set_background(png_ptr, &my_background,
+           PNG_BACKGROUND_GAMMA_SCREEN, 0/*do not expand*/, 1);
+
+The second call was described above - my_background is in the format of the
+final, display, output produced by libpng.  Because you now know the format of
+the PNG it is possible to avoid the need to choose either 8-bit or 16-bit
+output and to retain palette images (the palette colors will be modified
+appropriately and the tRNS chunk removed.)  However, if you are doing this,
+take great care not to ask for transformations without checking first that
+they apply!
+
+In the first call the background color has the original bit depth and color type
+of the PNG file.  So, for palette images the color is supplied as a palette
+index and for low bit greyscale images the color is a reduced bit value in
+image_background->gray.
+
+If you didn't call png_set_gamma() before reading the file header, for example
+if you need your code to remain compatible with older versions of libpng prior
+to libpng-1.5.4, this is the place to call it.
+
+Do not call it if you called png_set_alpha_mode(); doing so will damage the
+settings put in place by png_set_alpha_mode().  (If png_set_alpha_mode() is
+supported then you can certainly do png_set_gamma() before reading the PNG
+header.)
+
+This API unconditionally sets the screen and file gamma values, so it will
+override the value in the PNG file unless it is called before the PNG file
+reading starts.  For this reason you must always call it with the PNG file
+value when you call it in this position:
+
+   if (png_get_gAMA(png_ptr, info_ptr, &file_gamma))
+      png_set_gamma(png_ptr, screen_gamma, file_gamma);
+
+   else
+      png_set_gamma(png_ptr, screen_gamma, 0.45455);
+
+If you need to reduce an RGB file to a paletted file, or if a paletted
+file has more entries then will fit on your screen, png_set_quantize()
+will do that.  Note that this is a simple match quantization that merely
+finds the closest color available.  This should work fairly well with
+optimized palettes, but fairly badly with linear color cubes.  If you
+pass a palette that is larger than maximum_colors, the file will
+reduce the number of colors in the palette so it will fit into
+maximum_colors.  If there is a histogram, libpng will use it to make
+more intelligent choices when reducing the palette.  If there is no
+histogram, it may not do as good a job.
+
+   if (color_type & PNG_COLOR_MASK_COLOR)
+   {
+      if (png_get_valid(png_ptr, info_ptr,
+          PNG_INFO_PLTE))
+      {
+         png_uint_16p histogram = NULL;
+
+         png_get_hIST(png_ptr, info_ptr,
+             &histogram);
+         png_set_quantize(png_ptr, palette, num_palette,
+            max_screen_colors, histogram, 1);
+      }
+
+      else
+      {
+         png_color std_color_cube[MAX_SCREEN_COLORS] =
+            { ... colors ... };
+
+         png_set_quantize(png_ptr, std_color_cube,
+            MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,
+            NULL,0);
+      }
+   }
+
+PNG files describe monochrome as black being zero and white being one.
+The following code will reverse this (make black be one and white be
+zero):
+
+   if (bit_depth == 1 && color_type == PNG_COLOR_TYPE_GRAY)
+      png_set_invert_mono(png_ptr);
+
+This function can also be used to invert grayscale and gray-alpha images:
+
+   if (color_type == PNG_COLOR_TYPE_GRAY ||
+       color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+      png_set_invert_mono(png_ptr);
+
+PNG files store 16-bit pixels in network byte order (big-endian,
+ie. most significant bits first).  This code changes the storage to the
+other way (little-endian, i.e. least significant bits first, the
+way PCs store them):
+
+    if (bit_depth == 16)
+       png_set_swap(png_ptr);
+
+If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
+need to change the order the pixels are packed into bytes, you can use:
+
+    if (bit_depth < 8)
+       png_set_packswap(png_ptr);
+
+Finally, you can write your own transformation function if none of
+the existing ones meets your needs.  This is done by setting a callback
+with
+
+    png_set_read_user_transform_fn(png_ptr,
+        read_transform_fn);
+
+You must supply the function
+
+    void read_transform_fn(png_structp png_ptr, png_row_infop
+        row_info, png_bytep data)
+
+See pngtest.c for a working example.  Your function will be called
+after all of the other transformations have been processed.  Take care with
+interlaced images if you do the interlace yourself - the width of the row is the
+width in 'row_info', not the overall image width.
+
+If supported, libpng provides two information routines that you can use to find
+where you are in processing the image:
+
+   png_get_current_pass_number(png_structp png_ptr);
+   png_get_current_row_number(png_structp png_ptr);
+
+Don't try using these outside a transform callback - firstly they are only
+supported if user transforms are supported, secondly they may well return
+unexpected results unless the row is actually being processed at the moment they
+are called.
+
+With interlaced
+images the value returned is the row in the input sub-image image.  Use
+PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
+find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
+
+The discussion of interlace handling above contains more information on how to
+use these values.
+
+You can also set up a pointer to a user structure for use by your
+callback function, and you can inform libpng that your transform
+function will change the number of channels or bit depth with the
+function
+
+    png_set_user_transform_info(png_ptr, user_ptr,
+        user_depth, user_channels);
+
+The user's application, not libpng, is responsible for allocating and
+freeing any memory required for the user structure.
+
+You can retrieve the pointer via the function
+png_get_user_transform_ptr().  For example:
+
+    voidp read_user_transform_ptr =
+        png_get_user_transform_ptr(png_ptr);
+
+The last thing to handle is interlacing; this is covered in detail below,
+but you must call the function here if you want libpng to handle expansion
+of the interlaced image.
+
+    number_of_passes = png_set_interlace_handling(png_ptr);
+
+After setting the transformations, libpng can update your png_info
+structure to reflect any transformations you've requested with this
+call.
+
+    png_read_update_info(png_ptr, info_ptr);
+
+This is most useful to update the info structure's rowbytes
+field so you can use it to allocate your image memory.  This function
+will also update your palette with the correct screen_gamma and
+background if these have been given with the calls above.  You may
+only call png_read_update_info() once with a particular info_ptr.
+
+After you call png_read_update_info(), you can allocate any
+memory you need to hold the image.  The row data is simply
+raw byte data for all forms of images.  As the actual allocation
+varies among applications, no example will be given.  If you
+are allocating one large chunk, you will need to build an
+array of pointers to each row, as it will be needed for some
+of the functions below.
+
+Remember: Before you call png_read_update_info(), the png_get_*()
+functions return the values corresponding to the original PNG image.
+After you call png_read_update_info the values refer to the image
+that libpng will output.  Consequently you must call all the png_set_
+functions before you call png_read_update_info().  This is particularly
+important for png_set_interlace_handling() - if you are going to call
+png_read_update_info() you must call png_set_interlace_handling() before
+it unless you want to receive interlaced output.
+
+Reading image data
+
+After you've allocated memory, you can read the image data.
+The simplest way to do this is in one function call.  If you are
+allocating enough memory to hold the whole image, you can just
+call png_read_image() and libpng will read in all the image data
+and put it in the memory area supplied.  You will need to pass in
+an array of pointers to each row.
+
+This function automatically handles interlacing, so you don't
+need to call png_set_interlace_handling() (unless you call
+png_read_update_info()) or call this function multiple times, or any
+of that other stuff necessary with png_read_rows().
+
+   png_read_image(png_ptr, row_pointers);
+
+where row_pointers is:
+
+   png_bytep row_pointers[height];
+
+You can point to void or char or whatever you use for pixels.
+
+If you don't want to read in the whole image at once, you can
+use png_read_rows() instead.  If there is no interlacing (check
+interlace_type == PNG_INTERLACE_NONE), this is simple:
+
+    png_read_rows(png_ptr, row_pointers, NULL,
+        number_of_rows);
+
+where row_pointers is the same as in the png_read_image() call.
+
+If you are doing this just one row at a time, you can do this with
+a single row_pointer instead of an array of row_pointers:
+
+    png_bytep row_pointer = row;
+    png_read_row(png_ptr, row_pointer, NULL);
+
+If the file is interlaced (interlace_type != 0 in the IHDR chunk), things
+get somewhat harder.  The only current (PNG Specification version 1.2)
+interlacing type for PNG is (interlace_type == PNG_INTERLACE_ADAM7);
+a somewhat complicated 2D interlace scheme, known as Adam7, that
+breaks down an image into seven smaller images of varying size, based
+on an 8x8 grid.  This number is defined (from libpng 1.5) as
+PNG_INTERLACE_ADAM7_PASSES in png.h
+
+libpng can fill out those images or it can give them to you "as is".
+It is almost always better to have libpng handle the interlacing for you.
+If you want the images filled out, there are two ways to do that.  The one
+mentioned in the PNG specification is to expand each pixel to cover
+those pixels that have not been read yet (the "rectangle" method).
+This results in a blocky image for the first pass, which gradually
+smooths out as more pixels are read.  The other method is the "sparkle"
+method, where pixels are drawn only in their final locations, with the
+rest of the image remaining whatever colors they were initialized to
+before the start of the read.  The first method usually looks better,
+but tends to be slower, as there are more pixels to put in the rows.
+
+If, as is likely, you want libpng to expand the images, call this before
+calling png_start_read_image() or png_read_update_info():
+
+    if (interlace_type == PNG_INTERLACE_ADAM7)
+       number_of_passes
+           = png_set_interlace_handling(png_ptr);
+
+This will return the number of passes needed.  Currently, this is seven,
+but may change if another interlace type is added.  This function can be
+called even if the file is not interlaced, where it will return one pass.
+You then need to read the whole image 'number_of_passes' times.  Each time
+will distribute the pixels from the current pass to the correct place in
+the output image, so you need to supply the same rows to png_read_rows in
+each pass.
+
+If you are not going to display the image after each pass, but are
+going to wait until the entire image is read in, use the sparkle
+effect.  This effect is faster and the end result of either method
+is exactly the same.  If you are planning on displaying the image
+after each pass, the "rectangle" effect is generally considered the
+better looking one.
+
+If you only want the "sparkle" effect, just call png_read_rows() as
+normal, with the third parameter NULL.  Make sure you make pass over
+the image number_of_passes times, and you don't change the data in the
+rows between calls.  You can change the locations of the data, just
+not the data.  Each pass only writes the pixels appropriate for that
+pass, and assumes the data from previous passes is still valid.
+
+    png_read_rows(png_ptr, row_pointers, NULL,
+        number_of_rows);
+
+If you only want the first effect (the rectangles), do the same as
+before except pass the row buffer in the third parameter, and leave
+the second parameter NULL.
+
+    png_read_rows(png_ptr, NULL, row_pointers,
+        number_of_rows);
+
+If you don't want libpng to handle the interlacing details, just call
+png_read_rows() PNG_INTERLACE_ADAM7_PASSES times to read in all the images.
+Each of the images is a valid image by itself; however, you will almost
+certainly need to distribute the pixels from each sub-image to the
+correct place.  This is where everything gets very tricky.
+
+If you want to retrieve the separate images you must pass the correct
+number of rows to each successive call of png_read_rows().  The calculation
+gets pretty complicated for small images, where some sub-images may
+not even exist because either their width or height ends up zero.
+libpng provides two macros to help you in 1.5 and later versions:
+
+   png_uint_32 width = PNG_PASS_COLS(image_width, pass_number);
+   png_uint_32 height = PNG_PASS_ROWS(image_height, pass_number);
+
+Respectively these tell you the width and height of the sub-image
+corresponding to the numbered pass.  'pass' is in in the range 0 to 6 -
+this can be confusing because the specification refers to the same passes
+as 1 to 7!  Be careful, you must check both the width and height before
+calling png_read_rows() and not call it for that pass if either is zero.
+
+You can, of course, read each sub-image row by row.  If you want to
+produce optimal code to make a pixel-by-pixel transformation of an
+interlaced image this is the best approach; read each row of each pass,
+transform it, and write it out to a new interlaced image.
+
+If you want to de-interlace the image yourself libpng provides further
+macros to help that tell you where to place the pixels in the output image.
+Because the interlacing scheme is rectangular - sub-image pixels are always
+arranged on a rectangular grid - all you need to know for each pass is the
+starting column and row in the output image of the first pixel plus the
+spacing between each pixel.  As of libpng 1.5 there are four macros to
+retrieve this information:
+
+   png_uint_32 x = PNG_PASS_START_COL(pass);
+   png_uint_32 y = PNG_PASS_START_ROW(pass);
+   png_uint_32 xStep = 1U << PNG_PASS_COL_SHIFT(pass);
+   png_uint_32 yStep = 1U << PNG_PASS_ROW_SHIFT(pass);
+
+These allow you to write the obvious loop:
+
+   png_uint_32 input_y = 0;
+   png_uint_32 output_y = PNG_PASS_START_ROW(pass);
+
+   while (output_y < output_image_height)
+   {
+      png_uint_32 input_x = 0;
+      png_uint_32 output_x = PNG_PASS_START_COL(pass);
+
+      while (output_x < output_image_width)
+      {
+         image[output_y][output_x] =
+             subimage[pass][input_y][input_x++];
+
+         output_x += xStep;
+      }
+
+      ++input_y;
+      output_y += yStep;
+   }
+
+Notice that the steps between successive output rows and columns are
+returned as shifts.  This is possible because the pixels in the subimages
+are always a power of 2 apart - 1, 2, 4 or 8 pixels - in the original
+image.  In practice you may need to directly calculate the output coordinate
+given an input coordinate.  libpng provides two further macros for this
+purpose:
+
+   png_uint_32 output_x = PNG_COL_FROM_PASS_COL(input_x, pass);
+   png_uint_32 output_y = PNG_ROW_FROM_PASS_ROW(input_y, pass);
+
+Finally a pair of macros are provided to tell you if a particular image
+row or column appears in a given pass:
+
+   int col_in_pass = PNG_COL_IN_INTERLACE_PASS(output_x, pass);
+   int row_in_pass = PNG_ROW_IN_INTERLACE_PASS(output_y, pass);
+
+Bear in mind that you will probably also need to check the width and height
+of the pass in addition to the above to be sure the pass even exists!
+
+With any luck you are convinced by now that you don't want to do your own
+interlace handling.  In reality normally the only good reason for doing this
+is if you are processing PNG files on a pixel-by-pixel basis and don't want
+to load the whole file into memory when it is interlaced.
+
+libpng includes a test program, pngvalid, that illustrates reading and
+writing of interlaced images.  If you can't get interlacing to work in your
+code and don't want to leave it to libpng (the recommended approach), see
+how pngvalid.c does it.
+
+Finishing a sequential read
+
+After you are finished reading the image through the
+low-level interface, you can finish reading the file.  If you are
+interested in comments or time, which may be stored either before or
+after the image data, you should pass the separate png_info struct if
+you want to keep the comments from before and after the image
+separate.
+
+    png_infop end_info = png_create_info_struct(png_ptr);
+
+    if (!end_info)
+    {
+       png_destroy_read_struct(&png_ptr, &info_ptr,
+           (png_infopp)NULL);
+       return (ERROR);
+    }
+
+   png_read_end(png_ptr, end_info);
+
+If you are not interested, you should still call png_read_end()
+but you can pass NULL, avoiding the need to create an end_info structure.
+
+   png_read_end(png_ptr, (png_infop)NULL);
+
+If you don't call png_read_end(), then your file pointer will be
+left pointing to the first chunk after the last IDAT, which is probably
+not what you want if you expect to read something beyond the end of
+the PNG datastream.
+
+When you are done, you can free all memory allocated by libpng like this:
+
+   png_destroy_read_struct(&png_ptr, &info_ptr,
+       &end_info);
+
+or, if you didn't create an end_info structure,
+
+   png_destroy_read_struct(&png_ptr, &info_ptr,
+       (png_infopp)NULL);
+
+It is also possible to individually free the info_ptr members that
+point to libpng-allocated storage with the following function:
+
+    png_free_data(png_ptr, info_ptr, mask, seq)
+
+    mask - identifies data to be freed, a mask
+           containing the bitwise OR of one or
+           more of
+             PNG_FREE_PLTE, PNG_FREE_TRNS,
+             PNG_FREE_HIST, PNG_FREE_ICCP,
+             PNG_FREE_PCAL, PNG_FREE_ROWS,
+             PNG_FREE_SCAL, PNG_FREE_SPLT,
+             PNG_FREE_TEXT, PNG_FREE_UNKN,
+           or simply PNG_FREE_ALL
+
+    seq  - sequence number of item to be freed
+           (-1 for all items)
+
+This function may be safely called when the relevant storage has
+already been freed, or has not yet been allocated, or was allocated
+by the user and not by libpng,  and will in those cases do nothing.
+The "seq" parameter is ignored if only one item of the selected data
+type, such as PLTE, is allowed.  If "seq" is not -1, and multiple items
+are allowed for the data type identified in the mask, such as text or
+sPLT, only the n'th item in the structure is freed, where n is "seq".
+
+The default behavior is only to free data that was allocated internally
+by libpng.  This can be changed, so that libpng will not free the data,
+or so that it will free data that was allocated by the user with png_malloc()
+or png_zalloc() and passed in via a png_set_*() function, with
+
+    png_data_freer(png_ptr, info_ptr, freer, mask)
+
+    freer  - one of
+               PNG_DESTROY_WILL_FREE_DATA
+               PNG_SET_WILL_FREE_DATA
+               PNG_USER_WILL_FREE_DATA
+
+    mask   - which data elements are affected
+             same choices as in png_free_data()
+
+This function only affects data that has already been allocated.
+You can call this function after reading the PNG data but before calling
+any png_set_*() functions, to control whether the user or the png_set_*()
+function is responsible for freeing any existing data that might be present,
+and again after the png_set_*() functions to control whether the user
+or png_destroy_*() is supposed to free the data.  When the user assumes
+responsibility for libpng-allocated data, the application must use
+png_free() to free it, and when the user transfers responsibility to libpng
+for data that the user has allocated, the user must have used png_malloc()
+or png_zalloc() to allocate it.
+
+If you allocated your row_pointers in a single block, as suggested above in
+the description of the high level read interface, you must not transfer
+responsibility for freeing it to the png_set_rows or png_read_destroy function,
+because they would also try to free the individual row_pointers[i].
+
+If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
+separately, do not transfer responsibility for freeing text_ptr to libpng,
+because when libpng fills a png_text structure it combines these members with
+the key member, and png_free_data() will free only text_ptr.key.  Similarly,
+if you transfer responsibility for free'ing text_ptr from libpng to your
+application, your application must not separately free those members.
+
+The png_free_data() function will turn off the "valid" flag for anything
+it frees.  If you need to turn the flag off for a chunk that was freed by
+your application instead of by libpng, you can use
+
+    png_set_invalid(png_ptr, info_ptr, mask);
+
+    mask - identifies the chunks to be made invalid,
+           containing the bitwise OR of one or
+           more of
+             PNG_INFO_gAMA, PNG_INFO_sBIT,
+             PNG_INFO_cHRM, PNG_INFO_PLTE,
+             PNG_INFO_tRNS, PNG_INFO_bKGD,
+             PNG_INFO_hIST, PNG_INFO_pHYs,
+             PNG_INFO_oFFs, PNG_INFO_tIME,
+             PNG_INFO_pCAL, PNG_INFO_sRGB,
+             PNG_INFO_iCCP, PNG_INFO_sPLT,
+             PNG_INFO_sCAL, PNG_INFO_IDAT
+
+For a more compact example of reading a PNG image, see the file example.c.
+
+Reading PNG files progressively
+
+The progressive reader is slightly different then the non-progressive
+reader.  Instead of calling png_read_info(), png_read_rows(), and
+png_read_end(), you make one call to png_process_data(), which calls
+callbacks when it has the info, a row, or the end of the image.  You
+set up these callbacks with png_set_progressive_read_fn().  You don't
+have to worry about the input/output functions of libpng, as you are
+giving the library the data directly in png_process_data().  I will
+assume that you have read the section on reading PNG files above,
+so I will only highlight the differences (although I will show
+all of the code).
+
+png_structp png_ptr;
+png_infop info_ptr;
+
+ /*  An example code fragment of how you would
+     initialize the progressive reader in your
+     application. */
+ int
+ initialize_png_reader()
+ {
+    png_ptr = png_create_read_struct
+        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
+         user_error_fn, user_warning_fn);
+
+    if (!png_ptr)
+        return (ERROR);
+
+    info_ptr = png_create_info_struct(png_ptr);
+
+    if (!info_ptr)
+    {
+       png_destroy_read_struct(&png_ptr,
+          (png_infopp)NULL, (png_infopp)NULL);
+       return (ERROR);
+    }
+
+    if (setjmp(png_jmpbuf(png_ptr)))
+    {
+       png_destroy_read_struct(&png_ptr, &info_ptr,
+          (png_infopp)NULL);
+       return (ERROR);
+    }
+
+    /* This one's new.  You can provide functions
+       to be called when the header info is valid,
+       when each row is completed, and when the image
+       is finished.  If you aren't using all functions,
+       you can specify NULL parameters.  Even when all
+       three functions are NULL, you need to call
+       png_set_progressive_read_fn().  You can use
+       any struct as the user_ptr (cast to a void pointer
+       for the function call), and retrieve the pointer
+       from inside the callbacks using the function
+
+          png_get_progressive_ptr(png_ptr);
+
+       which will return a void pointer, which you have
+       to cast appropriately.
+     */
+    png_set_progressive_read_fn(png_ptr, (void *)user_ptr,
+        info_callback, row_callback, end_callback);
+
+    return 0;
+ }
+
+ /* A code fragment that you call as you receive blocks
+   of data */
+ int
+ process_data(png_bytep buffer, png_uint_32 length)
+ {
+    if (setjmp(png_jmpbuf(png_ptr)))
+    {
+       png_destroy_read_struct(&png_ptr, &info_ptr,
+           (png_infopp)NULL);
+       return (ERROR);
+    }
+
+    /* This one's new also.  Simply give it a chunk
+       of data from the file stream (in order, of
+       course).  On machines with segmented memory
+       models machines, don't give it any more than
+       64K.  The library seems to run fine with sizes
+       of 4K. Although you can give it much less if
+       necessary (I assume you can give it chunks of
+       1 byte, I haven't tried less then 256 bytes
+       yet).  When this function returns, you may
+       want to display any rows that were generated
+       in the row callback if you don't already do
+       so there.
+     */
+    png_process_data(png_ptr, info_ptr, buffer, length);
+
+    /* At this point you can call png_process_data_skip if
+       you want to handle data the library will skip yourself;
+       it simply returns the number of bytes to skip (and stops
+       libpng skipping that number of bytes on the next
+       png_process_data call).
+    return 0;
+ }
+
+ /* This function is called (as set by
+    png_set_progressive_read_fn() above) when enough data
+    has been supplied so all of the header has been
+    read.
+ */
+ void
+ info_callback(png_structp png_ptr, png_infop info)
+ {
+    /* Do any setup here, including setting any of
+       the transformations mentioned in the Reading
+       PNG files section.  For now, you _must_ call
+       either png_start_read_image() or
+       png_read_update_info() after all the
+       transformations are set (even if you don't set
+       any).  You may start getting rows before
+       png_process_data() returns, so this is your
+       last chance to prepare for that.
+
+       This is where you turn on interlace handling,
+       assuming you don't want to do it yourself.
+
+       If you need to you can stop the processing of
+       your original input data at this point by calling
+       png_process_data_pause.  This returns the number
+       of unprocessed bytes from the last png_process_data
+       call - it is up to you to ensure that the next call
+       sees these bytes again.  If you don't want to bother
+       with this you can get libpng to cache the unread
+       bytes by setting the 'save' parameter (see png.h) but
+       then libpng will have to copy the data internally.
+     */
+ }
+
+ /* This function is called when each row of image
+    data is complete */
+ void
+ row_callback(png_structp png_ptr, png_bytep new_row,
+    png_uint_32 row_num, int pass)
+ {
+    /* If the image is interlaced, and you turned
+       on the interlace handler, this function will
+       be called for every row in every pass.  Some
+       of these rows will not be changed from the
+       previous pass.  When the row is not changed,
+       the new_row variable will be NULL.  The rows
+       and passes are called in order, so you don't
+       really need the row_num and pass, but I'm
+       supplying them because it may make your life
+       easier.
+
+       If you did not turn on interlace handling then
+       the callback is called for each row of each
+       sub-image when the image is interlaced.  In this
+       case 'row_num' is the row in the sub-image, not
+       the row in the output image as it is in all other
+       cases.
+
+       For the non-NULL rows of interlaced images when
+       you have switched on libpng interlace handling,
+       you must call png_progressive_combine_row()
+       passing in the row and the old row.  You can
+       call this function for NULL rows (it will just
+       return) and for non-interlaced images (it just
+       does the memcpy for you) if it will make the
+       code easier.  Thus, you can just do this for
+       all cases if you switch on interlace handling;
+     */
+
+        png_progressive_combine_row(png_ptr, old_row,
+          new_row);
+
+    /* where old_row is what was displayed for
+       previously for the row.  Note that the first
+       pass (pass == 0, really) will completely cover
+       the old row, so the rows do not have to be
+       initialized.  After the first pass (and only
+       for interlaced images), you will have to pass
+       the current row, and the function will combine
+       the old row and the new row.
+
+       You can also call png_process_data_pause in this
+       callback - see above.
+    */
+ }
+
+ void
+ end_callback(png_structp png_ptr, png_infop info)
+ {
+    /* This function is called after the whole image
+       has been read, including any chunks after the
+       image (up to and including the IEND).  You
+       will usually have the same info chunk as you
+       had in the header, although some data may have
+       been added to the comments and time fields.
+
+       Most people won't do much here, perhaps setting
+       a flag that marks the image as finished.
+     */
+ }
+
+
+
+IV. Writing
+
+Much of this is very similar to reading.  However, everything of
+importance is repeated here, so you won't have to constantly look
+back up in the reading section to understand writing.
+
+Setup
+
+You will want to do the I/O initialization before you get into libpng,
+so if it doesn't work, you don't have anything to undo. If you are not
+using the standard I/O functions, you will need to replace them with
+custom writing functions.  See the discussion under Customizing libpng.
+
+    FILE *fp = fopen(file_name, "wb");
+
+    if (!fp)
+       return (ERROR);
+
+Next, png_struct and png_info need to be allocated and initialized.
+As these can be both relatively large, you may not want to store these
+on the stack, unless you have stack space to spare.  Of course, you
+will want to check if they return NULL.  If you are also reading,
+you won't want to name your read structure and your write structure
+both "png_ptr"; you can call them anything you like, such as
+"read_ptr" and "write_ptr".  Look at pngtest.c, for example.
+
+    png_structp png_ptr = png_create_write_struct
+       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
+        user_error_fn, user_warning_fn);
+
+    if (!png_ptr)
+       return (ERROR);
+
+    png_infop info_ptr = png_create_info_struct(png_ptr);
+    if (!info_ptr)
+    {
+       png_destroy_write_struct(&png_ptr,
+           (png_infopp)NULL);
+       return (ERROR);
+    }
+
+If you want to use your own memory allocation routines,
+define PNG_USER_MEM_SUPPORTED and use
+png_create_write_struct_2() instead of png_create_write_struct():
+
+    png_structp png_ptr = png_create_write_struct_2
+       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,
+        user_error_fn, user_warning_fn, (png_voidp)
+        user_mem_ptr, user_malloc_fn, user_free_fn);
+
+After you have these structures, you will need to set up the
+error handling.  When libpng encounters an error, it expects to
+longjmp() back to your routine.  Therefore, you will need to call
+setjmp() and pass the png_jmpbuf(png_ptr).  If you
+write the file from different routines, you will need to update
+the png_jmpbuf(png_ptr) every time you enter a new routine that will
+call a png_*() function.  See your documentation of setjmp/longjmp
+for your compiler for more information on setjmp/longjmp.  See
+the discussion on libpng error handling in the Customizing Libpng
+section below for more information on the libpng error handling.
+
+    if (setjmp(png_jmpbuf(png_ptr)))
+    {
+    png_destroy_write_struct(&png_ptr, &info_ptr);
+       fclose(fp);
+       return (ERROR);
+    }
+    ...
+    return;
+
+If you would rather avoid the complexity of setjmp/longjmp issues,
+you can compile libpng with PNG_NO_SETJMP, in which case
+errors will result in a call to PNG_ABORT() which defaults to abort().
+
+You can #define PNG_ABORT() to a function that does something
+more useful than abort(), as long as your function does not
+return.
+
+Now you need to set up the output code.  The default for libpng is to
+use the C function fwrite().  If you use this, you will need to pass a
+valid FILE * in the function png_init_io().  Be sure that the file is
+opened in binary mode.  Again, if you wish to handle writing data in
+another way, see the discussion on libpng I/O handling in the Customizing
+Libpng section below.
+
+    png_init_io(png_ptr, fp);
+
+If you are embedding your PNG into a datastream such as MNG, and don't
+want libpng to write the 8-byte signature, or if you have already
+written the signature in your application, use
+
+    png_set_sig_bytes(png_ptr, 8);
+
+to inform libpng that it should not write a signature.
+
+Write callbacks
+
+At this point, you can set up a callback function that will be
+called after each row has been written, which you can use to control
+a progress meter or the like.  It's demonstrated in pngtest.c.
+You must supply a function
+
+    void write_row_callback(png_structp png_ptr, png_uint_32 row,
+       int pass);
+    {
+      /* put your code here */
+    }
+
+(You can give it another name that you like instead of "write_row_callback")
+
+To inform libpng about your function, use
+
+    png_set_write_status_fn(png_ptr, write_row_callback);
+
+When this function is called the row has already been completely processed and
+it has also been written out.  The 'row' and 'pass' refer to the next row to be
+handled.  For the
+non-interlaced case the row that was just handled is simply one less than the
+passed in row number, and pass will always be 0.  For the interlaced case the
+same applies unless the row value is 0, in which case the row just handled was
+the last one from one of the preceding passes.  Because interlacing may skip a
+pass you cannot be sure that the preceding pass is just 'pass-1', if you really
+need to know what the last pass is record (row,pass) from the callback and use
+the last recorded value each time.
+
+As with the user transform you can find the output row using the
+PNG_ROW_FROM_PASS_ROW macro.
+
+You now have the option of modifying how the compression library will
+run.  The following functions are mainly for testing, but may be useful
+in some cases, like if you need to write PNG files extremely fast and
+are willing to give up some compression, or if you want to get the
+maximum possible compression at the expense of slower writing.  If you
+have no special needs in this area, let the library do what it wants by
+not calling this function at all, as it has been tuned to deliver a good
+speed/compression ratio. The second parameter to png_set_filter() is
+the filter method, for which the only valid values are 0 (as of the
+July 1999 PNG specification, version 1.2) or 64 (if you are writing
+a PNG datastream that is to be embedded in a MNG datastream).  The third
+parameter is a flag that indicates which filter type(s) are to be tested
+for each scanline.  See the PNG specification for details on the specific
+filter types.
+
+
+    /* turn on or off filtering, and/or choose
+       specific filters.  You can use either a single
+       PNG_FILTER_VALUE_NAME or the bitwise OR of one
+       or more PNG_FILTER_NAME masks.
+     */
+    png_set_filter(png_ptr, 0,
+       PNG_FILTER_NONE  | PNG_FILTER_VALUE_NONE |
+       PNG_FILTER_SUB   | PNG_FILTER_VALUE_SUB  |
+       PNG_FILTER_UP    | PNG_FILTER_VALUE_UP   |
+       PNG_FILTER_AVG   | PNG_FILTER_VALUE_AVG  |
+       PNG_FILTER_PAETH | PNG_FILTER_VALUE_PAETH|
+       PNG_ALL_FILTERS);
+
+If an application wants to start and stop using particular filters during
+compression, it should start out with all of the filters (to ensure that
+the previous row of pixels will be stored in case it's needed later),
+and then add and remove them after the start of compression.
+
+If you are writing a PNG datastream that is to be embedded in a MNG
+datastream, the second parameter can be either 0 or 64.
+
+The png_set_compression_*() functions interface to the zlib compression
+library, and should mostly be ignored unless you really know what you are
+doing.  The only generally useful call is png_set_compression_level()
+which changes how much time zlib spends on trying to compress the image
+data.  See the Compression Library (zlib.h and algorithm.txt, distributed
+with zlib) for details on the compression levels.
+
+    #include zlib.h
+
+    /* Set the zlib compression level */
+    png_set_compression_level(png_ptr,
+        Z_BEST_COMPRESSION);
+
+    /* Set other zlib parameters for compressing IDAT */
+    png_set_compression_mem_level(png_ptr, 8);
+    png_set_compression_strategy(png_ptr,
+        Z_DEFAULT_STRATEGY);
+    png_set_compression_window_bits(png_ptr, 15);
+    png_set_compression_method(png_ptr, 8);
+    png_set_compression_buffer_size(png_ptr, 8192)
+
+    /* Set zlib parameters for text compression
+     * If you don't call these, the parameters
+     * fall back on those defined for IDAT chunks
+     */
+    png_set_text_compression_mem_level(png_ptr, 8);
+    png_set_text_compression_strategy(png_ptr,
+        Z_DEFAULT_STRATEGY);
+    png_set_text_compression_window_bits(png_ptr, 15);
+    png_set_text_compression_method(png_ptr, 8);
+
+Setting the contents of info for output
+
+You now need to fill in the png_info structure with all the data you
+wish to write before the actual image.  Note that the only thing you
+are allowed to write after the image is the text chunks and the time
+chunk (as of PNG Specification 1.2, anyway).  See png_write_end() and
+the latest PNG specification for more information on that.  If you
+wish to write them before the image, fill them in now, and flag that
+data as being valid.  If you want to wait until after the data, don't
+fill them until png_write_end().  For all the fields in png_info and
+their data types, see png.h.  For explanations of what the fields
+contain, see the PNG specification.
+
+Some of the more important parts of the png_info are:
+
+    png_set_IHDR(png_ptr, info_ptr, width, height,
+       bit_depth, color_type, interlace_type,
+       compression_type, filter_method)
+
+    width          - holds the width of the image
+                     in pixels (up to 2^31).
+
+    height         - holds the height of the image
+                     in pixels (up to 2^31).
+
+    bit_depth      - holds the bit depth of one of the
+                     image channels.
+                     (valid values are 1, 2, 4, 8, 16
+                     and depend also on the
+                     color_type.  See also significant
+                     bits (sBIT) below).
+
+    color_type     - describes which color/alpha
+                     channels are present.
+                     PNG_COLOR_TYPE_GRAY
+                        (bit depths 1, 2, 4, 8, 16)
+                     PNG_COLOR_TYPE_GRAY_ALPHA
+                        (bit depths 8, 16)
+                     PNG_COLOR_TYPE_PALETTE
+                        (bit depths 1, 2, 4, 8)
+                     PNG_COLOR_TYPE_RGB
+                        (bit_depths 8, 16)
+                     PNG_COLOR_TYPE_RGB_ALPHA
+                        (bit_depths 8, 16)
+
+                     PNG_COLOR_MASK_PALETTE
+                     PNG_COLOR_MASK_COLOR
+                     PNG_COLOR_MASK_ALPHA
+
+    interlace_type - PNG_INTERLACE_NONE or
+                     PNG_INTERLACE_ADAM7
+
+    compression_type - (must be
+                     PNG_COMPRESSION_TYPE_DEFAULT)
+
+    filter_method  - (must be PNG_FILTER_TYPE_DEFAULT
+                     or, if you are writing a PNG to
+                     be embedded in a MNG datastream,
+                     can also be
+                     PNG_INTRAPIXEL_DIFFERENCING)
+
+If you call png_set_IHDR(), the call must appear before any of the
+other png_set_*() functions, because they might require access to some of
+the IHDR settings.  The remaining png_set_*() functions can be called
+in any order.
+
+If you wish, you can reset the compression_type, interlace_type, or
+filter_method later by calling png_set_IHDR() again; if you do this, the
+width, height, bit_depth, and color_type must be the same in each call.
+
+    png_set_PLTE(png_ptr, info_ptr, palette,
+       num_palette);
+
+    palette        - the palette for the file
+                     (array of png_color)
+    num_palette    - number of entries in the palette
+
+    png_set_gAMA(png_ptr, info_ptr, file_gamma);
+    png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
+
+    file_gamma     - the gamma at which the image was
+                     created (PNG_INFO_gAMA)
+
+    int_file_gamma - 100,000 times the gamma at which
+                     the image was created
+
+    png_set_cHRM(png_ptr, info_ptr,  white_x, white_y, red_x, red_y,
+                     green_x, green_y, blue_x, blue_y)
+    png_set_cHRM_XYZ(png_ptr, info_ptr, red_X, red_Y, red_Z, green_X,
+                     green_Y, green_Z, blue_X, blue_Y, blue_Z)
+    png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y,
+                     int_red_x, int_red_y, int_green_x, int_green_y,
+                     int_blue_x, int_blue_y)
+    png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, int_red_X, int_red_Y,
+                     int_red_Z, int_green_X, int_green_Y, int_green_Z,
+                     int_blue_X, int_blue_Y, int_blue_Z)
+
+    {white,red,green,blue}_{x,y}
+                     A color space encoding specified using the chromaticities
+                     of the end points and the white point.
+
+    {red,green,blue}_{X,Y,Z}
+                     A color space encoding specified using the encoding end
+                     points - the CIE tristimulus specification of the intended
+                     color of the red, green and blue channels in the PNG RGB
+                     data.  The white point is simply the sum of the three end
+                     points.
+
+    png_set_sRGB(png_ptr, info_ptr, srgb_intent);
+
+    srgb_intent    - the rendering intent
+                     (PNG_INFO_sRGB) The presence of
+                     the sRGB chunk means that the pixel
+                     data is in the sRGB color space.
+                     This chunk also implies specific
+                     values of gAMA and cHRM.  Rendering
+                     intent is the CSS-1 property that
+                     has been defined by the International
+                     Color Consortium
+                     (http://www.color.org).
+                     It can be one of
+                     PNG_sRGB_INTENT_SATURATION,
+                     PNG_sRGB_INTENT_PERCEPTUAL,
+                     PNG_sRGB_INTENT_ABSOLUTE, or
+                     PNG_sRGB_INTENT_RELATIVE.
+
+
+    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,
+       srgb_intent);
+
+    srgb_intent    - the rendering intent
+                     (PNG_INFO_sRGB) The presence of the
+                     sRGB chunk means that the pixel
+                     data is in the sRGB color space.
+                     This function also causes gAMA and
+                     cHRM chunks with the specific values
+                     that are consistent with sRGB to be
+                     written.
+
+    png_set_iCCP(png_ptr, info_ptr, name, compression_type,
+                       profile, proflen);
+
+    name             - The profile name.
+
+    compression_type - The compression type; always
+                       PNG_COMPRESSION_TYPE_BASE for PNG 1.0.
+                       You may give NULL to this argument to
+                       ignore it.
+
+    profile          - International Color Consortium color
+                       profile data. May contain NULs.
+
+    proflen          - length of profile data in bytes.
+
+    png_set_sBIT(png_ptr, info_ptr, sig_bit);
+
+    sig_bit        - the number of significant bits for
+                     (PNG_INFO_sBIT) each of the gray, red,
+                     green, and blue channels, whichever are
+                     appropriate for the given color type
+                     (png_color_16)
+
+    png_set_tRNS(png_ptr, info_ptr, trans_alpha,
+       num_trans, trans_color);
+
+    trans_alpha    - array of alpha (transparency)
+                     entries for palette (PNG_INFO_tRNS)
+
+    num_trans      - number of transparent entries
+                     (PNG_INFO_tRNS)
+
+    trans_color    - graylevel or color sample values
+                     (in order red, green, blue) of the
+                     single transparent color for
+                     non-paletted images (PNG_INFO_tRNS)
+
+    png_set_hIST(png_ptr, info_ptr, hist);
+
+    hist           - histogram of palette (array of
+                     png_uint_16) (PNG_INFO_hIST)
+
+    png_set_tIME(png_ptr, info_ptr, mod_time);
+
+    mod_time       - time image was last modified
+                     (PNG_VALID_tIME)
+
+    png_set_bKGD(png_ptr, info_ptr, background);
+
+    background     - background color (of type
+                     png_color_16p) (PNG_VALID_bKGD)
+
+    png_set_text(png_ptr, info_ptr, text_ptr, num_text);
+
+    text_ptr       - array of png_text holding image
+                     comments
+
+    text_ptr[i].compression - type of compression used
+                 on "text" PNG_TEXT_COMPRESSION_NONE
+                           PNG_TEXT_COMPRESSION_zTXt
+                           PNG_ITXT_COMPRESSION_NONE
+                           PNG_ITXT_COMPRESSION_zTXt
+    text_ptr[i].key   - keyword for comment.  Must contain
+                 1-79 characters.
+    text_ptr[i].text  - text comments for current
+                         keyword.  Can be NULL or empty.
+    text_ptr[i].text_length - length of text string,
+                 after decompression, 0 for iTXt
+    text_ptr[i].itxt_length - length of itxt string,
+                 after decompression, 0 for tEXt/zTXt
+    text_ptr[i].lang  - language of comment (NULL or
+                         empty for unknown).
+    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
+                         or empty for unknown).
+
+    Note that the itxt_length, lang, and lang_key
+    members of the text_ptr structure only exist when the
+    library is built with iTXt chunk support.  Prior to
+    libpng-1.4.0 the library was built by default without
+    iTXt support. Also note that when iTXt is supported,
+    they contain NULL pointers when the "compression"
+    field contains PNG_TEXT_COMPRESSION_NONE or
+    PNG_TEXT_COMPRESSION_zTXt.
+
+    num_text       - number of comments
+
+    png_set_sPLT(png_ptr, info_ptr, &palette_ptr,
+       num_spalettes);
+
+    palette_ptr    - array of png_sPLT_struct structures
+                     to be added to the list of palettes
+                     in the info structure.
+    num_spalettes  - number of palette structures to be
+                     added.
+
+    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
+        unit_type);
+
+    offset_x  - positive offset from the left
+                     edge of the screen
+
+    offset_y  - positive offset from the top
+                     edge of the screen
+
+    unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER
+
+    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
+        unit_type);
+
+    res_x       - pixels/unit physical resolution
+                  in x direction
+
+    res_y       - pixels/unit physical resolution
+                  in y direction
+
+    unit_type   - PNG_RESOLUTION_UNKNOWN,
+                  PNG_RESOLUTION_METER
+
+    png_set_sCAL(png_ptr, info_ptr, unit, width, height)
+
+    unit        - physical scale units (an integer)
+
+    width       - width of a pixel in physical scale units
+
+    height      - height of a pixel in physical scale units
+                  (width and height are doubles)
+
+    png_set_sCAL_s(png_ptr, info_ptr, unit, width, height)
+
+    unit        - physical scale units (an integer)
+
+    width       - width of a pixel in physical scale units
+                  expressed as a string
+
+    height      - height of a pixel in physical scale units
+                 (width and height are strings like "2.54")
+
+    png_set_unknown_chunks(png_ptr, info_ptr, &unknowns,
+       num_unknowns)
+
+    unknowns          - array of png_unknown_chunk
+                        structures holding unknown chunks
+    unknowns[i].name  - name of unknown chunk
+    unknowns[i].data  - data of unknown chunk
+    unknowns[i].size  - size of unknown chunk's data
+    unknowns[i].location - position to write chunk in file
+                           0: do not write chunk
+                           PNG_HAVE_IHDR: before PLTE
+                           PNG_HAVE_PLTE: before IDAT
+                           PNG_AFTER_IDAT: after IDAT
+
+The "location" member is set automatically according to
+what part of the output file has already been written.
+You can change its value after calling png_set_unknown_chunks()
+as demonstrated in pngtest.c.  Within each of the "locations",
+the chunks are sequenced according to their position in the
+structure (that is, the value of "i", which is the order in which
+the chunk was either read from the input file or defined with
+png_set_unknown_chunks).
+
+A quick word about text and num_text.  text is an array of png_text
+structures.  num_text is the number of valid structures in the array.
+Each png_text structure holds a language code, a keyword, a text value,
+and a compression type.
+
+The compression types have the same valid numbers as the compression
+types of the image data.  Currently, the only valid number is zero.
+However, you can store text either compressed or uncompressed, unlike
+images, which always have to be compressed.  So if you don't want the
+text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
+Because tEXt and zTXt chunks don't have a language field, if you
+specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt
+any language code or translated keyword will not be written out.
+
+Until text gets around a few hundred bytes, it is not worth compressing it.
+After the text has been written out to the file, the compression type
+is set to PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR,
+so that it isn't written out again at the end (in case you are calling
+png_write_end() with the same struct).
+
+The keywords that are given in the PNG Specification are:
+
+    Title            Short (one line) title or
+                     caption for image
+
+    Author           Name of image's creator
+
+    Description      Description of image (possibly long)
+
+    Copyright        Copyright notice
+
+    Creation Time    Time of original image creation
+                     (usually RFC 1123 format, see below)
+
+    Software         Software used to create the image
+
+    Disclaimer       Legal disclaimer
+
+    Warning          Warning of nature of content
+
+    Source           Device used to create the image
+
+    Comment          Miscellaneous comment; conversion
+                     from other image format
+
+The keyword-text pairs work like this.  Keywords should be short
+simple descriptions of what the comment is about.  Some typical
+keywords are found in the PNG specification, as is some recommendations
+on keywords.  You can repeat keywords in a file.  You can even write
+some text before the image and some after.  For example, you may want
+to put a description of the image before the image, but leave the
+disclaimer until after, so viewers working over modem connections
+don't have to wait for the disclaimer to go over the modem before
+they start seeing the image.  Finally, keywords should be full
+words, not abbreviations.  Keywords and text are in the ISO 8859-1
+(Latin-1) character set (a superset of regular ASCII) and can not
+contain NUL characters, and should not contain control or other
+unprintable characters.  To make the comments widely readable, stick
+with basic ASCII, and avoid machine specific character set extensions
+like the IBM-PC character set.  The keyword must be present, but
+you can leave off the text string on non-compressed pairs.
+Compressed pairs must have a text string, as only the text string
+is compressed anyway, so the compression would be meaningless.
+
+PNG supports modification time via the png_time structure.  Two
+conversion routines are provided, png_convert_from_time_t() for
+time_t and png_convert_from_struct_tm() for struct tm.  The
+time_t routine uses gmtime().  You don't have to use either of
+these, but if you wish to fill in the png_time structure directly,
+you should provide the time in universal time (GMT) if possible
+instead of your local time.  Note that the year number is the full
+year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and
+that months start with 1.
+
+If you want to store the time of the original image creation, you should
+use a plain tEXt chunk with the "Creation Time" keyword.  This is
+necessary because the "creation time" of a PNG image is somewhat vague,
+depending on whether you mean the PNG file, the time the image was
+created in a non-PNG format, a still photo from which the image was
+scanned, or possibly the subject matter itself.  In order to facilitate
+machine-readable dates, it is recommended that the "Creation Time"
+tEXt chunk use RFC 1123 format dates (e.g. "22 May 1997 18:07:10 GMT"),
+although this isn't a requirement.  Unlike the tIME chunk, the
+"Creation Time" tEXt chunk is not expected to be automatically changed
+by the software.  To facilitate the use of RFC 1123 dates, a function
+png_convert_to_rfc1123(png_timep) is provided to convert from PNG
+time to an RFC 1123 format string.
+
+Writing unknown chunks
+
+You can use the png_set_unknown_chunks function to queue up chunks
+for writing.  You give it a chunk name, raw data, and a size; that's
+all there is to it.  The chunks will be written by the next following
+png_write_info_before_PLTE, png_write_info, or png_write_end function.
+Any chunks previously read into the info structure's unknown-chunk
+list will also be written out in a sequence that satisfies the PNG
+specification's ordering rules.
+
+The high-level write interface
+
+At this point there are two ways to proceed; through the high-level
+write interface, or through a sequence of low-level write operations.
+You can use the high-level interface if your image data is present
+in the info structure.  All defined output
+transformations are permitted, enabled by the following masks.
+
+    PNG_TRANSFORM_IDENTITY      No transformation
+    PNG_TRANSFORM_PACKING       Pack 1, 2 and 4-bit samples
+    PNG_TRANSFORM_PACKSWAP      Change order of packed
+                                pixels to LSB first
+    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images
+    PNG_TRANSFORM_SHIFT         Normalize pixels to the
+                                sBIT depth
+    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA
+                                to BGRA
+    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA
+                                to AG
+    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity
+                                to transparency
+    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples
+    PNG_TRANSFORM_STRIP_FILLER        Strip out filler
+                                      bytes (deprecated).
+    PNG_TRANSFORM_STRIP_FILLER_BEFORE Strip out leading
+                                      filler bytes
+    PNG_TRANSFORM_STRIP_FILLER_AFTER  Strip out trailing
+                                      filler bytes
+
+If you have valid image data in the info structure (you can use
+png_set_rows() to put image data in the info structure), simply do this:
+
+    png_write_png(png_ptr, info_ptr, png_transforms, NULL)
+
+where png_transforms is an integer containing the bitwise OR of some set of
+transformation flags.  This call is equivalent to png_write_info(),
+followed the set of transformations indicated by the transform mask,
+then png_write_image(), and finally png_write_end().
+
+(The final parameter of this call is not yet used.  Someday it might point
+to transformation parameters required by some future output transform.)
+
+You must use png_transforms and not call any png_set_transform() functions
+when you use png_write_png().
+
+The low-level write interface
+
+If you are going the low-level route instead, you are now ready to
+write all the file information up to the actual image data.  You do
+this with a call to png_write_info().
+
+    png_write_info(png_ptr, info_ptr);
+
+Note that there is one transformation you may need to do before
+png_write_info().  In PNG files, the alpha channel in an image is the
+level of opacity.  If your data is supplied as a level of transparency,
+you can invert the alpha channel before you write it, so that 0 is
+fully transparent and 255 (in 8-bit or paletted images) or 65535
+(in 16-bit images) is fully opaque, with
+
+    png_set_invert_alpha(png_ptr);
+
+This must appear before png_write_info() instead of later with the
+other transformations because in the case of paletted images the tRNS
+chunk data has to be inverted before the tRNS chunk is written.  If
+your image is not a paletted image, the tRNS data (which in such cases
+represents a single color to be rendered as transparent) won't need to
+be changed, and you can safely do this transformation after your
+png_write_info() call.
+
+If you need to write a private chunk that you want to appear before
+the PLTE chunk when PLTE is present, you can write the PNG info in
+two steps, and insert code to write your own chunk between them:
+
+    png_write_info_before_PLTE(png_ptr, info_ptr);
+    png_set_unknown_chunks(png_ptr, info_ptr, ...);
+    png_write_info(png_ptr, info_ptr);
+
+After you've written the file information, you can set up the library
+to handle any special transformations of the image data.  The various
+ways to transform the data will be described in the order that they
+should occur.  This is important, as some of these change the color
+type and/or bit depth of the data, and some others only work on
+certain color types and bit depths.  Even though each transformation
+checks to see if it has data that it can do something with, you should
+make sure to only enable a transformation if it will be valid for the
+data.  For example, don't swap red and blue on grayscale data.
+
+PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells
+the library to strip input data that has 4 or 8 bytes per pixel down
+to 3 or 6 bytes (or strip 2 or 4-byte grayscale+filler data to 1 or 2
+bytes per pixel).
+
+    png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
+
+where the 0 is unused, and the location is either PNG_FILLER_BEFORE or
+PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
+is stored XRGB or RGBX.
+
+PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
+they can, resulting in, for example, 8 pixels per byte for 1 bit files.
+If the data is supplied at 1 pixel per byte, use this code, which will
+correctly pack the pixels into a single byte:
+
+    png_set_packing(png_ptr);
+
+PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  If your
+data is of another bit depth, you can write an sBIT chunk into the
+file so that decoders can recover the original data if desired.
+
+    /* Set the true bit depth of the image data */
+    if (color_type & PNG_COLOR_MASK_COLOR)
+    {
+       sig_bit.red = true_bit_depth;
+       sig_bit.green = true_bit_depth;
+       sig_bit.blue = true_bit_depth;
+    }
+
+    else
+    {
+       sig_bit.gray = true_bit_depth;
+    }
+
+    if (color_type & PNG_COLOR_MASK_ALPHA)
+    {
+       sig_bit.alpha = true_bit_depth;
+    }
+
+    png_set_sBIT(png_ptr, info_ptr, &sig_bit);
+
+If the data is stored in the row buffer in a bit depth other than
+one supported by PNG (e.g. 3 bit data in the range 0-7 for a 4-bit PNG),
+this will scale the values to appear to be the correct bit depth as
+is required by PNG.
+
+    png_set_shift(png_ptr, &sig_bit);
+
+PNG files store 16-bit pixels in network byte order (big-endian,
+ie. most significant bits first).  This code would be used if they are
+supplied the other way (little-endian, i.e. least significant bits
+first, the way PCs store them):
+
+    if (bit_depth > 8)
+       png_set_swap(png_ptr);
+
+If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
+need to change the order the pixels are packed into bytes, you can use:
+
+    if (bit_depth < 8)
+       png_set_packswap(png_ptr);
+
+PNG files store 3 color pixels in red, green, blue order.  This code
+would be used if they are supplied as blue, green, red:
+
+    png_set_bgr(png_ptr);
+
+PNG files describe monochrome as black being zero and white being
+one. This code would be used if the pixels are supplied with this reversed
+(black being one and white being zero):
+
+    png_set_invert_mono(png_ptr);
+
+Finally, you can write your own transformation function if none of
+the existing ones meets your needs.  This is done by setting a callback
+with
+
+    png_set_write_user_transform_fn(png_ptr,
+       write_transform_fn);
+
+You must supply the function
+
+    void write_transform_fn(png_structp png_ptr, png_row_infop
+       row_info, png_bytep data)
+
+See pngtest.c for a working example.  Your function will be called
+before any of the other transformations are processed.  If supported
+libpng also supplies an information routine that may be called from
+your callback:
+
+   png_get_current_row_number(png_ptr);
+   png_get_current_pass_number(png_ptr);
+
+This returns the current row passed to the transform.  With interlaced
+images the value returned is the row in the input sub-image image.  Use
+PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
+find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
+
+The discussion of interlace handling above contains more information on how to
+use these values.
+
+You can also set up a pointer to a user structure for use by your
+callback function.
+
+    png_set_user_transform_info(png_ptr, user_ptr, 0, 0);
+
+The user_channels and user_depth parameters of this function are ignored
+when writing; you can set them to zero as shown.
+
+You can retrieve the pointer via the function png_get_user_transform_ptr().
+For example:
+
+    voidp write_user_transform_ptr =
+       png_get_user_transform_ptr(png_ptr);
+
+It is possible to have libpng flush any pending output, either manually,
+or automatically after a certain number of lines have been written.  To
+flush the output stream a single time call:
+
+    png_write_flush(png_ptr);
+
+and to have libpng flush the output stream periodically after a certain
+number of scanlines have been written, call:
+
+    png_set_flush(png_ptr, nrows);
+
+Note that the distance between rows is from the last time png_write_flush()
+was called, or the first row of the image if it has never been called.
+So if you write 50 lines, and then png_set_flush 25, it will flush the
+output on the next scanline, and every 25 lines thereafter, unless
+png_write_flush() is called before 25 more lines have been written.
+If nrows is too small (less than about 10 lines for a 640 pixel wide
+RGB image) the image compression may decrease noticeably (although this
+may be acceptable for real-time applications).  Infrequent flushing will
+only degrade the compression performance by a few percent over images
+that do not use flushing.
+
+Writing the image data
+
+That's it for the transformations.  Now you can write the image data.
+The simplest way to do this is in one function call.  If you have the
+whole image in memory, you can just call png_write_image() and libpng
+will write the image.  You will need to pass in an array of pointers to
+each row.  This function automatically handles interlacing, so you don't
+need to call png_set_interlace_handling() or call this function multiple
+times, or any of that other stuff necessary with png_write_rows().
+
+    png_write_image(png_ptr, row_pointers);
+
+where row_pointers is:
+
+    png_byte *row_pointers[height];
+
+You can point to void or char or whatever you use for pixels.
+
+If you don't want to write the whole image at once, you can
+use png_write_rows() instead.  If the file is not interlaced,
+this is simple:
+
+    png_write_rows(png_ptr, row_pointers,
+       number_of_rows);
+
+row_pointers is the same as in the png_write_image() call.
+
+If you are just writing one row at a time, you can do this with
+a single row_pointer instead of an array of row_pointers:
+
+    png_bytep row_pointer = row;
+
+    png_write_row(png_ptr, row_pointer);
+
+When the file is interlaced, things can get a good deal more complicated.
+The only currently (as of the PNG Specification version 1.2, dated July
+1999) defined interlacing scheme for PNG files is the "Adam7" interlace
+scheme, that breaks down an image into seven smaller images of varying
+size.  libpng will build these images for you, or you can do them
+yourself.  If you want to build them yourself, see the PNG specification
+for details of which pixels to write when.
+
+If you don't want libpng to handle the interlacing details, just
+use png_set_interlace_handling() and call png_write_rows() the
+correct number of times to write all the sub-images
+(png_set_interlace_handling() returns the number of sub-images.)
+
+If you want libpng to build the sub-images, call this before you start
+writing any rows:
+
+    number_of_passes = png_set_interlace_handling(png_ptr);
+
+This will return the number of passes needed.  Currently, this is seven,
+but may change if another interlace type is added.
+
+Then write the complete image number_of_passes times.
+
+    png_write_rows(png_ptr, row_pointers, number_of_rows);
+
+Think carefully before you write an interlaced image.  Typically code that
+reads such images reads all the image data into memory, uncompressed, before
+doing any processing.  Only code that can display an image on the fly can
+take advantage of the interlacing and even then the image has to be exactly
+the correct size for the output device, because scaling an image requires
+adjacent pixels and these are not available until all the passes have been
+read.
+
+If you do write an interlaced image you will hardly ever need to handle
+the interlacing yourself.  Call png_set_interlace_handling() and use the
+approach described above.
+
+The only time it is conceivable that you will really need to write an
+interlaced image pass-by-pass is when you have read one pass by pass and
+made some pixel-by-pixel transformation to it, as described in the read
+code above.  In this case use the PNG_PASS_ROWS and PNG_PASS_COLS macros
+to determine the size of each sub-image in turn and simply write the rows
+you obtained from the read code.
+
+Finishing a sequential write
+
+After you are finished writing the image, you should finish writing
+the file.  If you are interested in writing comments or time, you should
+pass an appropriately filled png_info pointer.  If you are not interested,
+you can pass NULL.
+
+    png_write_end(png_ptr, info_ptr);
+
+When you are done, you can free all memory used by libpng like this:
+
+    png_destroy_write_struct(&png_ptr, &info_ptr);
+
+It is also possible to individually free the info_ptr members that
+point to libpng-allocated storage with the following function:
+
+    png_free_data(png_ptr, info_ptr, mask, seq)
+
+    mask  - identifies data to be freed, a mask
+            containing the bitwise OR of one or
+            more of
+              PNG_FREE_PLTE, PNG_FREE_TRNS,
+              PNG_FREE_HIST, PNG_FREE_ICCP,
+              PNG_FREE_PCAL, PNG_FREE_ROWS,
+              PNG_FREE_SCAL, PNG_FREE_SPLT,
+              PNG_FREE_TEXT, PNG_FREE_UNKN,
+            or simply PNG_FREE_ALL
+
+    seq   - sequence number of item to be freed
+            (-1 for all items)
+
+This function may be safely called when the relevant storage has
+already been freed, or has not yet been allocated, or was allocated
+by the user  and not by libpng,  and will in those cases do nothing.
+The "seq" parameter is ignored if only one item of the selected data
+type, such as PLTE, is allowed.  If "seq" is not -1, and multiple items
+are allowed for the data type identified in the mask, such as text or
+sPLT, only the n'th item in the structure is freed, where n is "seq".
+
+If you allocated data such as a palette that you passed in to libpng
+with png_set_*, you must not free it until just before the call to
+png_destroy_write_struct().
+
+The default behavior is only to free data that was allocated internally
+by libpng.  This can be changed, so that libpng will not free the data,
+or so that it will free data that was allocated by the user with png_malloc()
+or png_zalloc() and passed in via a png_set_*() function, with
+
+    png_data_freer(png_ptr, info_ptr, freer, mask)
+
+    freer  - one of
+               PNG_DESTROY_WILL_FREE_DATA
+               PNG_SET_WILL_FREE_DATA
+               PNG_USER_WILL_FREE_DATA
+
+    mask   - which data elements are affected
+             same choices as in png_free_data()
+
+For example, to transfer responsibility for some data from a read structure
+to a write structure, you could use
+
+    png_data_freer(read_ptr, read_info_ptr,
+       PNG_USER_WILL_FREE_DATA,
+       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
+
+    png_data_freer(write_ptr, write_info_ptr,
+       PNG_DESTROY_WILL_FREE_DATA,
+       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)
+
+thereby briefly reassigning responsibility for freeing to the user but
+immediately afterwards reassigning it once more to the write_destroy
+function.  Having done this, it would then be safe to destroy the read
+structure and continue to use the PLTE, tRNS, and hIST data in the write
+structure.
+
+This function only affects data that has already been allocated.
+You can call this function before calling after the png_set_*() functions
+to control whether the user or png_destroy_*() is supposed to free the data.
+When the user assumes responsibility for libpng-allocated data, the
+application must use
+png_free() to free it, and when the user transfers responsibility to libpng
+for data that the user has allocated, the user must have used png_malloc()
+or png_zalloc() to allocate it.
+
+If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
+separately, do not transfer responsibility for freeing text_ptr to libpng,
+because when libpng fills a png_text structure it combines these members with
+the key member, and png_free_data() will free only text_ptr.key.  Similarly,
+if you transfer responsibility for free'ing text_ptr from libpng to your
+application, your application must not separately free those members.
+For a more compact example of writing a PNG image, see the file example.c.
+
+V. Modifying/Customizing libpng:
+
+There are two issues here.  The first is changing how libpng does
+standard things like memory allocation, input/output, and error handling.
+The second deals with more complicated things like adding new chunks,
+adding new transformations, and generally changing how libpng works.
+Both of those are compile-time issues; that is, they are generally
+determined at the time the code is written, and there is rarely a need
+to provide the user with a means of changing them.
+
+Memory allocation, input/output, and error handling
+
+All of the memory allocation, input/output, and error handling in libpng
+goes through callbacks that are user-settable.  The default routines are
+in pngmem.c, pngrio.c, pngwio.c, and pngerror.c, respectively.  To change
+these functions, call the appropriate png_set_*_fn() function.
+
+Memory allocation is done through the functions png_malloc(), png_calloc(),
+and png_free().  These currently just call the standard C functions.
+png_calloc() calls png_malloc() and then clears the newly
+allocated memory to zero.  There is limited support for certain systems
+with segmented memory architectures and the types of pointers declared by
+png.h match this; you will have to use appropriate pointers in your
+application.  Since it is
+unlikely that the method of handling memory allocation on a platform
+will change between applications, these functions must be modified in
+the library at compile time.  If you prefer to use a different method
+of allocating and freeing data, you can use png_create_read_struct_2() or
+png_create_write_struct_2() to register your own functions as described
+above.  These functions also provide a void pointer that can be retrieved
+via
+
+    mem_ptr=png_get_mem_ptr(png_ptr);
+
+Your replacement memory functions must have prototypes as follows:
+
+    png_voidp malloc_fn(png_structp png_ptr,
+       png_alloc_size_t size);
+
+    void free_fn(png_structp png_ptr, png_voidp ptr);
+
+Your malloc_fn() must return NULL in case of failure.  The png_malloc()
+function will normally call png_error() if it receives a NULL from the
+system memory allocator or from your replacement malloc_fn().
+
+Your free_fn() will never be called with a NULL ptr, since libpng's
+png_free() checks for NULL before calling free_fn().
+
+Input/Output in libpng is done through png_read() and png_write(),
+which currently just call fread() and fwrite().  The FILE * is stored in
+png_struct and is initialized via png_init_io().  If you wish to change
+the method of I/O, the library supplies callbacks that you can set
+through the function png_set_read_fn() and png_set_write_fn() at run
+time, instead of calling the png_init_io() function.  These functions
+also provide a void pointer that can be retrieved via the function
+png_get_io_ptr().  For example:
+
+    png_set_read_fn(png_structp read_ptr,
+        voidp read_io_ptr, png_rw_ptr read_data_fn)
+
+    png_set_write_fn(png_structp write_ptr,
+        voidp write_io_ptr, png_rw_ptr write_data_fn,
+        png_flush_ptr output_flush_fn);
+
+    voidp read_io_ptr = png_get_io_ptr(read_ptr);
+    voidp write_io_ptr = png_get_io_ptr(write_ptr);
+
+The replacement I/O functions must have prototypes as follows:
+
+    void user_read_data(png_structp png_ptr,
+        png_bytep data, png_size_t length);
+
+    void user_write_data(png_structp png_ptr,
+        png_bytep data, png_size_t length);
+
+    void user_flush_data(png_structp png_ptr);
+
+The user_read_data() function is responsible for detecting and
+handling end-of-data errors.
+
+Supplying NULL for the read, write, or flush functions sets them back
+to using the default C stream functions, which expect the io_ptr to
+point to a standard *FILE structure.  It is probably a mistake
+to use NULL for one of write_data_fn and output_flush_fn but not both
+of them, unless you have built libpng with PNG_NO_WRITE_FLUSH defined.
+It is an error to read from a write stream, and vice versa.
+
+Error handling in libpng is done through png_error() and png_warning().
+Errors handled through png_error() are fatal, meaning that png_error()
+should never return to its caller.  Currently, this is handled via
+setjmp() and longjmp() (unless you have compiled libpng with
+PNG_NO_SETJMP, in which case it is handled via PNG_ABORT()),
+but you could change this to do things like exit() if you should wish,
+as long as your function does not return.
+
+On non-fatal errors, png_warning() is called
+to print a warning message, and then control returns to the calling code.
+By default png_error() and png_warning() print a message on stderr via
+fprintf() unless the library is compiled with PNG_NO_CONSOLE_IO defined
+(because you don't want the messages) or PNG_NO_STDIO defined (because
+fprintf() isn't available).  If you wish to change the behavior of the error
+functions, you will need to set up your own message callbacks.  These
+functions are normally supplied at the time that the png_struct is created.
+It is also possible to redirect errors and warnings to your own replacement
+functions after png_create_*_struct() has been called by calling:
+
+    png_set_error_fn(png_structp png_ptr,
+        png_voidp error_ptr, png_error_ptr error_fn,
+        png_error_ptr warning_fn);
+
+    png_voidp error_ptr = png_get_error_ptr(png_ptr);
+
+If NULL is supplied for either error_fn or warning_fn, then the libpng
+default function will be used, calling fprintf() and/or longjmp() if a
+problem is encountered.  The replacement error functions should have
+parameters as follows:
+
+    void user_error_fn(png_structp png_ptr,
+        png_const_charp error_msg);
+
+    void user_warning_fn(png_structp png_ptr,
+        png_const_charp warning_msg);
+
+The motivation behind using setjmp() and longjmp() is the C++ throw and
+catch exception handling methods.  This makes the code much easier to write,
+as there is no need to check every return code of every function call.
+However, there are some uncertainties about the status of local variables
+after a longjmp, so the user may want to be careful about doing anything
+after setjmp returns non-zero besides returning itself.  Consult your
+compiler documentation for more details.  For an alternative approach, you
+may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net),
+which is illustrated in pngvalid.c and in contrib/visupng.
+
+Custom chunks
+
+If you need to read or write custom chunks, you may need to get deeper
+into the libpng code.  The library now has mechanisms for storing
+and writing chunks of unknown type; you can even declare callbacks
+for custom chunks.  However, this may not be good enough if the
+library code itself needs to know about interactions between your
+chunk and existing `intrinsic' chunks.
+
+If you need to write a new intrinsic chunk, first read the PNG
+specification. Acquire a first level of understanding of how it works.
+Pay particular attention to the sections that describe chunk names,
+and look at how other chunks were designed, so you can do things
+similarly.  Second, check out the sections of libpng that read and
+write chunks.  Try to find a chunk that is similar to yours and use
+it as a template.  More details can be found in the comments inside
+the code.  It is best to handle private or unknown chunks in a generic method,
+via callback functions, instead of by modifying libpng functions. This
+is illustrated in pngtest.c, which uses a callback function to handle a
+private "vpAg" chunk and the new "sTER" chunk, which are both unknown to
+libpng.
+
+If you wish to write your own transformation for the data, look through
+the part of the code that does the transformations, and check out some of
+the simpler ones to get an idea of how they work.  Try to find a similar
+transformation to the one you want to add and copy off of it.  More details
+can be found in the comments inside the code itself.
+
+Configuring for 16-bit platforms
+
+You will want to look into zconf.h to tell zlib (and thus libpng) that
+it cannot allocate more then 64K at a time.  Even if you can, the memory
+won't be accessible.  So limit zlib and libpng to 64K by defining MAXSEG_64K.
+
+Configuring for DOS
+
+For DOS users who only have access to the lower 640K, you will
+have to limit zlib's memory usage via a png_set_compression_mem_level()
+call.  See zlib.h or zconf.h in the zlib library for more information.
+
+Configuring for Medium Model
+
+Libpng's support for medium model has been tested on most of the popular
+compilers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets
+defined, and FAR gets defined to far in pngconf.h, and you should be
+all set.  Everything in the library (except for zlib's structure) is
+expecting far data.  You must use the typedefs with the p or pp on
+the end for pointers (or at least look at them and be careful).  Make
+note that the rows of data are defined as png_bytepp, which is
+an "unsigned char far * far *".
+
+Configuring for gui/windowing platforms:
+
+You will need to write new error and warning functions that use the GUI
+interface, as described previously, and set them to be the error and
+warning functions at the time that png_create_*_struct() is called,
+in order to have them available during the structure initialization.
+They can be changed later via png_set_error_fn().  On some compilers,
+you may also have to change the memory allocators (png_malloc, etc.).
+
+Configuring for compiler xxx:
+
+All includes for libpng are in pngconf.h.  If you need to add, change
+or delete an include, this is the place to do it.
+The includes that are not needed outside libpng are placed in pngpriv.h,
+which is only used by the routines inside libpng itself.
+The files in libpng proper only include pngpriv.h and png.h, which
+in turn includes pngconf.h and, as of libpng-1.5.0, pnglibconf.h.
+As of libpng-1.5.0, pngpriv.h also includes three other private header
+files, pngstruct.h, pnginfo.h, and pngdebug.h, which contain material
+that previously appeared in the public headers.
+
+Configuring zlib:
+
+There are special functions to configure the compression.  Perhaps the
+most useful one changes the compression level, which currently uses
+input compression values in the range 0 - 9.  The library normally
+uses the default compression level (Z_DEFAULT_COMPRESSION = 6).  Tests
+have shown that for a large majority of images, compression values in
+the range 3-6 compress nearly as well as higher levels, and do so much
+faster.  For online applications it may be desirable to have maximum speed
+(Z_BEST_SPEED = 1).  With versions of zlib after v0.99, you can also
+specify no compression (Z_NO_COMPRESSION = 0), but this would create
+files larger than just storing the raw bitmap.  You can specify the
+compression level by calling:
+
+    #include zlib.h
+    png_set_compression_level(png_ptr, level);
+
+Another useful one is to reduce the memory level used by the library.
+The memory level defaults to 8, but it can be lowered if you are
+short on memory (running DOS, for example, where you only have 640K).
+Note that the memory level does have an effect on compression; among
+other things, lower levels will result in sections of incompressible
+data being emitted in smaller stored blocks, with a correspondingly
+larger relative overhead of up to 15% in the worst case.
+
+    #include zlib.h
+    png_set_compression_mem_level(png_ptr, level);
+
+The other functions are for configuring zlib.  They are not recommended
+for normal use and may result in writing an invalid PNG file.  See
+zlib.h for more information on what these mean.
+
+    #include zlib.h
+    png_set_compression_strategy(png_ptr,
+        strategy);
+
+    png_set_compression_window_bits(png_ptr,
+        window_bits);
+
+    png_set_compression_method(png_ptr, method);
+
+    png_set_compression_buffer_size(png_ptr, size);
+
+As of libpng version 1.5.4, additional APIs became
+available to set these separately for non-IDAT
+compressed chunks such as zTXt, iTXt, and iCCP:
+
+    #include zlib.h
+    #if PNG_LIBPNG_VER >= 10504
+    png_set_text_compression_level(png_ptr, level);
+
+    png_set_text_compression_mem_level(png_ptr, level);
+
+    png_set_text_compression_strategy(png_ptr,
+        strategy);
+
+    png_set_text_compression_window_bits(png_ptr,
+        window_bits);
+
+    png_set_text_compression_method(png_ptr, method);
+    #endif
+
+Controlling row filtering
+
+If you want to control whether libpng uses filtering or not, which
+filters are used, and how it goes about picking row filters, you
+can call one of these functions.  The selection and configuration
+of row filters can have a significant impact on the size and
+encoding speed and a somewhat lesser impact on the decoding speed
+of an image.  Filtering is enabled by default for RGB and grayscale
+images (with and without alpha), but not for paletted images nor
+for any images with bit depths less than 8 bits/pixel.
+
+The 'method' parameter sets the main filtering method, which is
+currently only '0' in the PNG 1.2 specification.  The 'filters'
+parameter sets which filter(s), if any, should be used for each
+scanline.  Possible values are PNG_ALL_FILTERS and PNG_NO_FILTERS
+to turn filtering on and off, respectively.
+
+Individual filter types are PNG_FILTER_NONE, PNG_FILTER_SUB,
+PNG_FILTER_UP, PNG_FILTER_AVG, PNG_FILTER_PAETH, which can be bitwise
+ORed together with '|' to specify one or more filters to use.
+These filters are described in more detail in the PNG specification.
+If you intend to change the filter type during the course of writing
+the image, you should start with flags set for all of the filters
+you intend to use so that libpng can initialize its internal
+structures appropriately for all of the filter types.  (Note that this
+means the first row must always be adaptively filtered, because libpng
+currently does not allocate the filter buffers until png_write_row()
+is called for the first time.)
+
+    filters = PNG_FILTER_NONE | PNG_FILTER_SUB
+              PNG_FILTER_UP | PNG_FILTER_AVG |
+              PNG_FILTER_PAETH | PNG_ALL_FILTERS;
+
+    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,
+       filters);
+              The second parameter can also be
+              PNG_INTRAPIXEL_DIFFERENCING if you are
+              writing a PNG to be embedded in a MNG
+              datastream.  This parameter must be the
+              same as the value of filter_method used
+              in png_set_IHDR().
+
+It is also possible to influence how libpng chooses from among the
+available filters.  This is done in one or both of two ways - by
+telling it how important it is to keep the same filter for successive
+rows, and by telling it the relative computational costs of the filters.
+
+    double weights[3] = {1.5, 1.3, 1.1},
+       costs[PNG_FILTER_VALUE_LAST] =
+       {1.0, 1.3, 1.3, 1.5, 1.7};
+
+    png_set_filter_heuristics(png_ptr,
+       PNG_FILTER_HEURISTIC_WEIGHTED, 3,
+       weights, costs);
+
+The weights are multiplying factors that indicate to libpng that the
+row filter should be the same for successive rows unless another row filter
+is that many times better than the previous filter.  In the above example,
+if the previous 3 filters were SUB, SUB, NONE, the SUB filter could have a
+"sum of absolute differences" 1.5 x 1.3 times higher than other filters
+and still be chosen, while the NONE filter could have a sum 1.1 times
+higher than other filters and still be chosen.  Unspecified weights are
+taken to be 1.0, and the specified weights should probably be declining
+like those above in order to emphasize recent filters over older filters.
+
+The filter costs specify for each filter type a relative decoding cost
+to be considered when selecting row filters.  This means that filters
+with higher costs are less likely to be chosen over filters with lower
+costs, unless their "sum of absolute differences" is that much smaller.
+The costs do not necessarily reflect the exact computational speeds of
+the various filters, since this would unduly influence the final image
+size.
+
+Note that the numbers above were invented purely for this example and
+are given only to help explain the function usage.  Little testing has
+been done to find optimum values for either the costs or the weights.
+
+Removing unwanted object code
+
+There are a bunch of #define's in pngconf.h that control what parts of
+libpng are compiled.  All the defines end in _SUPPORTED.  If you are
+never going to use a capability, you can change the #define to #undef
+before recompiling libpng and save yourself code and data space, or
+you can turn off individual capabilities with defines that begin with
+PNG_NO_.
+
+In libpng-1.5.0 and later, the #define's are in pnglibconf.h instead.
+
+You can also turn all of the transforms and ancillary chunk capabilities
+off en masse with compiler directives that define
+PNG_NO_READ[or WRITE]_TRANSFORMS, or PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS,
+or all four,
+along with directives to turn on any of the capabilities that you do
+want.  The PNG_NO_READ[or WRITE]_TRANSFORMS directives disable the extra
+transformations but still leave the library fully capable of reading
+and writing PNG files with all known public chunks. Use of the
+PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS directive produces a library
+that is incapable of reading or writing ancillary chunks.  If you are
+not using the progressive reading capability, you can turn that off
+with PNG_NO_PROGRESSIVE_READ (don't confuse this with the INTERLACING
+capability, which you'll still have).
+
+All the reading and writing specific code are in separate files, so the
+linker should only grab the files it needs.  However, if you want to
+make sure, or if you are building a stand alone library, all the
+reading files start with "pngr" and all the writing files start with "pngw".
+The files that don't match either (like png.c, pngtrans.c, etc.)
+are used for both reading and writing, and always need to be included.
+The progressive reader is in pngpread.c
+
+If you are creating or distributing a dynamically linked library (a .so
+or DLL file), you should not remove or disable any parts of the library,
+as this will cause applications linked with different versions of the
+library to fail if they call functions not available in your library.
+The size of the library itself should not be an issue, because only
+those sections that are actually used will be loaded into memory.
+
+Requesting debug printout
+
+The macro definition PNG_DEBUG can be used to request debugging
+printout.  Set it to an integer value in the range 0 to 3.  Higher
+numbers result in increasing amounts of debugging information.  The
+information is printed to the "stderr" file, unless another file
+name is specified in the PNG_DEBUG_FILE macro definition.
+
+When PNG_DEBUG > 0, the following functions (macros) become available:
+
+   png_debug(level, message)
+   png_debug1(level, message, p1)
+   png_debug2(level, message, p1, p2)
+
+in which "level" is compared to PNG_DEBUG to decide whether to print
+the message, "message" is the formatted string to be printed,
+and p1 and p2 are parameters that are to be embedded in the string
+according to printf-style formatting directives.  For example,
+
+   png_debug1(2, "foo=%d\n", foo);
+
+is expanded to
+
+   if (PNG_DEBUG > 2)
+      fprintf(PNG_DEBUG_FILE, "foo=%d\n", foo);
+
+When PNG_DEBUG is defined but is zero, the macros aren't defined, but you
+can still use PNG_DEBUG to control your own debugging:
+
+   #ifdef PNG_DEBUG
+       fprintf(stderr, ...
+   #endif
+
+When PNG_DEBUG = 1, the macros are defined, but only png_debug statements
+having level = 0 will be printed.  There aren't any such statements in
+this version of libpng, but if you insert some they will be printed.
+
+VI.  MNG support
+
+The MNG specification (available at http://www.libpng.org/pub/mng) allows
+certain extensions to PNG for PNG images that are embedded in MNG datastreams.
+Libpng can support some of these extensions.  To enable them, use the
+png_permit_mng_features() function:
+
+   feature_set = png_permit_mng_features(png_ptr, mask)
+
+   mask is a png_uint_32 containing the bitwise OR of the
+        features you want to enable.  These include
+        PNG_FLAG_MNG_EMPTY_PLTE
+        PNG_FLAG_MNG_FILTER_64
+        PNG_ALL_MNG_FEATURES
+
+   feature_set is a png_uint_32 that is the bitwise AND of
+      your mask with the set of MNG features that is
+      supported by the version of libpng that you are using.
+
+It is an error to use this function when reading or writing a standalone
+PNG file with the PNG 8-byte signature.  The PNG datastream must be wrapped
+in a MNG datastream.  As a minimum, it must have the MNG 8-byte signature
+and the MHDR and MEND chunks.  Libpng does not provide support for these
+or any other MNG chunks; your application must provide its own support for
+them.  You may wish to consider using libmng (available at
+http://www.libmng.com) instead.
+
+VII.  Changes to Libpng from version 0.88
+
+It should be noted that versions of libpng later than 0.96 are not
+distributed by the original libpng author, Guy Schalnat, nor by
+Andreas Dilger, who had taken over from Guy during 1996 and 1997, and
+distributed versions 0.89 through 0.96, but rather by another member
+of the original PNG Group, Glenn Randers-Pehrson.  Guy and Andreas are
+still alive and well, but they have moved on to other things.
+
+The old libpng functions png_read_init(), png_write_init(),
+png_info_init(), png_read_destroy(), and png_write_destroy() have been
+moved to PNG_INTERNAL in version 0.95 to discourage their use.  These
+functions will be removed from libpng version 1.4.0.
+
+The preferred method of creating and initializing the libpng structures is
+via the png_create_read_struct(), png_create_write_struct(), and
+png_create_info_struct() because they isolate the size of the structures
+from the application, allow version error checking, and also allow the
+use of custom error handling routines during the initialization, which
+the old functions do not.  The functions png_read_destroy() and
+png_write_destroy() do not actually free the memory that libpng
+allocated for these structs, but just reset the data structures, so they
+can be used instead of png_destroy_read_struct() and
+png_destroy_write_struct() if you feel there is too much system overhead
+allocating and freeing the png_struct for each image read.
+
+Setting the error callbacks via png_set_message_fn() before
+png_read_init() as was suggested in libpng-0.88 is no longer supported
+because this caused applications that do not use custom error functions
+to fail if the png_ptr was not initialized to zero.  It is still possible
+to set the error callbacks AFTER png_read_init(), or to change them with
+png_set_error_fn(), which is essentially the same function, but with a new
+name to force compilation errors with applications that try to use the old
+method.
+
+Starting with version 1.0.7, you can find out which version of the library
+you are using at run-time:
+
+   png_uint_32 libpng_vn = png_access_version_number();
+
+The number libpng_vn is constructed from the major version, minor
+version with leading zero, and release number with leading zero,
+(e.g., libpng_vn for version 1.0.7 is 10007).
+
+Note that this function does not take a png_ptr, so you can call it
+before you've created one.
+
+You can also check which version of png.h you used when compiling your
+application:
+
+   png_uint_32 application_vn = PNG_LIBPNG_VER;
+
+VIII.  Changes to Libpng from version 1.0.x to 1.2.x
+
+Support for user memory management was enabled by default.  To
+accomplish this, the functions png_create_read_struct_2(),
+png_create_write_struct_2(), png_set_mem_fn(), png_get_mem_ptr(),
+png_malloc_default(), and png_free_default() were added.
+
+Support for the iTXt chunk has been enabled by default as of
+version 1.2.41.
+
+Support for certain MNG features was enabled.
+
+Support for numbered error messages was added.  However, we never got
+around to actually numbering the error messages.  The function
+png_set_strip_error_numbers() was added (Note: the prototype for this
+function was inadvertently removed from png.h in PNG_NO_ASSEMBLER_CODE
+builds of libpng-1.2.15.  It was restored in libpng-1.2.36).
+
+The png_malloc_warn() function was added at libpng-1.2.3.  This issues
+a png_warning and returns NULL instead of aborting when it fails to
+acquire the requested memory allocation.
+
+Support for setting user limits on image width and height was enabled
+by default.  The functions png_set_user_limits(), png_get_user_width_max(),
+and png_get_user_height_max() were added at libpng-1.2.6.
+
+The png_set_add_alpha() function was added at libpng-1.2.7.
+
+The function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9.
+Unlike png_set_gray_1_2_4_to_8(), the new function does not expand the
+tRNS chunk to alpha. The png_set_gray_1_2_4_to_8() function is
+deprecated.
+
+A number of macro definitions in support of runtime selection of
+assembler code features (especially Intel MMX code support) were
+added at libpng-1.2.0:
+
+    PNG_ASM_FLAG_MMX_SUPPORT_COMPILED
+    PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU
+    PNG_ASM_FLAG_MMX_READ_COMBINE_ROW
+    PNG_ASM_FLAG_MMX_READ_INTERLACE
+    PNG_ASM_FLAG_MMX_READ_FILTER_SUB
+    PNG_ASM_FLAG_MMX_READ_FILTER_UP
+    PNG_ASM_FLAG_MMX_READ_FILTER_AVG
+    PNG_ASM_FLAG_MMX_READ_FILTER_PAETH
+    PNG_ASM_FLAGS_INITIALIZED
+    PNG_MMX_READ_FLAGS
+    PNG_MMX_FLAGS
+    PNG_MMX_WRITE_FLAGS
+    PNG_MMX_FLAGS
+
+We added the following functions in support of runtime
+selection of assembler code features:
+
+    png_get_mmx_flagmask()
+    png_set_mmx_thresholds()
+    png_get_asm_flags()
+    png_get_mmx_bitdepth_threshold()
+    png_get_mmx_rowbytes_threshold()
+    png_set_asm_flags()
+
+We replaced all of these functions with simple stubs in libpng-1.2.20,
+when the Intel assembler code was removed due to a licensing issue.
+
+These macros are deprecated:
+
+    PNG_READ_TRANSFORMS_NOT_SUPPORTED
+    PNG_PROGRESSIVE_READ_NOT_SUPPORTED
+    PNG_NO_SEQUENTIAL_READ_SUPPORTED
+    PNG_WRITE_TRANSFORMS_NOT_SUPPORTED
+    PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED
+    PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED
+
+They have been replaced, respectively, by:
+
+    PNG_NO_READ_TRANSFORMS
+    PNG_NO_PROGRESSIVE_READ
+    PNG_NO_SEQUENTIAL_READ
+    PNG_NO_WRITE_TRANSFORMS
+    PNG_NO_READ_ANCILLARY_CHUNKS
+    PNG_NO_WRITE_ANCILLARY_CHUNKS
+
+PNG_MAX_UINT was replaced with PNG_UINT_31_MAX.  It has been
+deprecated since libpng-1.0.16 and libpng-1.2.6.
+
+The function
+    png_check_sig(sig, num)
+was replaced with
+    !png_sig_cmp(sig, 0, num)
+It has been deprecated since libpng-0.90.
+
+The function
+    png_set_gray_1_2_4_to_8()
+which also expands tRNS to alpha was replaced with
+    png_set_expand_gray_1_2_4_to_8()
+which does not. It has been deprecated since libpng-1.0.18 and 1.2.9.
+
+IX.  Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
+
+Private libpng prototypes and macro definitions were moved from
+png.h and pngconf.h into a new pngpriv.h header file.
+
+Functions png_set_benign_errors(), png_benign_error(), and
+png_chunk_benign_error() were added.
+
+Support for setting the maximum amount of memory that the application
+will allocate for reading chunks was added, as a security measure.
+The functions png_set_chunk_cache_max() and png_get_chunk_cache_max()
+were added to the library.
+
+We implemented support for I/O states by adding png_ptr member io_state
+and functions png_get_io_chunk_name() and png_get_io_state() in pngget.c
+
+We added PNG_TRANSFORM_GRAY_TO_RGB to the available high-level
+input transforms.
+
+Checking for and reporting of errors in the IHDR chunk is more thorough.
+
+Support for global arrays was removed, to improve thread safety.
+
+Some obsolete/deprecated macros and functions have been removed.
+
+Typecasted NULL definitions such as
+   #define png_voidp_NULL            (png_voidp)NULL
+were eliminated.  If you used these in your application, just use
+NULL instead.
+
+The png_struct and info_struct members "trans" and "trans_values" were
+changed to "trans_alpha" and "trans_color", respectively.
+
+The obsolete, unused pnggccrd.c and pngvcrd.c files and related makefiles
+were removed.
+
+The PNG_1_0_X and PNG_1_2_X macros were eliminated.
+
+The PNG_LEGACY_SUPPORTED macro was eliminated.
+
+Many WIN32_WCE #ifdefs were removed.
+
+The functions png_read_init(info_ptr), png_write_init(info_ptr),
+png_info_init(info_ptr), png_read_destroy(), and png_write_destroy()
+have been removed.  They have been deprecated since libpng-0.95.
+
+The png_permit_empty_plte() was removed. It has been deprecated
+since libpng-1.0.9.  Use png_permit_mng_features() instead.
+
+We removed the obsolete stub functions png_get_mmx_flagmask(),
+png_set_mmx_thresholds(), png_get_asm_flags(),
+png_get_mmx_bitdepth_threshold(), png_get_mmx_rowbytes_threshold(),
+png_set_asm_flags(), and png_mmx_supported()
+
+We removed the obsolete png_check_sig(), png_memcpy_check(), and
+png_memset_check() functions.  Instead use !png_sig_cmp(), memcpy(),
+and memset(), respectively.
+
+The function png_set_gray_1_2_4_to_8() was removed. It has been
+deprecated since libpng-1.0.18 and 1.2.9, when it was replaced with
+png_set_expand_gray_1_2_4_to_8() because the former function also
+expanded any tRNS chunk to an alpha channel.
+
+Macros for png_get_uint_16, png_get_uint_32, and png_get_int_32
+were added and are used by default instead of the corresponding
+functions. Unfortunately,
+from libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
+function) incorrectly returned a value of type png_uint_32.
+
+We changed the prototype for png_malloc() from
+    png_malloc(png_structp png_ptr, png_uint_32 size)
+to
+    png_malloc(png_structp png_ptr, png_alloc_size_t size)
+
+This also applies to the prototype for the user replacement malloc_fn().
+
+The png_calloc() function was added and is used in place of
+of "png_malloc(); memset();" except in the case in png_read_png()
+where the array consists of pointers; in this case a "for" loop is used
+after the png_malloc() to set the pointers to NULL, to give robust.
+behavior in case the application runs out of memory part-way through
+the process.
+
+We changed the prototypes of png_get_compression_buffer_size() and
+png_set_compression_buffer_size() to work with png_size_t instead of
+png_uint_32.
+
+Support for numbered error messages was removed by default, since we
+never got around to actually numbering the error messages. The function
+png_set_strip_error_numbers() was removed from the library by default.
+
+The png_zalloc() and png_zfree() functions are no longer exported.
+The png_zalloc() function no longer zeroes out the memory that it
+allocates.
+
+Support for dithering was disabled by default in libpng-1.4.0, because
+it has not been well tested and doesn't actually "dither".
+The code was not
+removed, however, and could be enabled by building libpng with
+PNG_READ_DITHER_SUPPORTED defined.  In libpng-1.4.2, this support
+was reenabled, but the function was renamed png_set_quantize() to
+reflect more accurately what it actually does.  At the same time,
+the PNG_DITHER_[RED,GREEN_BLUE]_BITS macros were also renamed to
+PNG_QUANTIZE_[RED,GREEN,BLUE]_BITS, and PNG_READ_DITHER_SUPPORTED
+was renamed to PNG_READ_QUANTIZE_SUPPORTED.
+
+We removed the trailing '.' from the warning and error messages.
+
+X.  Changes to Libpng from version 1.4.x to 1.5.x
+
+From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
+function) incorrectly returned a value of type png_uint_32.
+
+Checking for invalid palette index on read or write was added at libpng
+1.5.10.  When an invalid index is found, libpng issues a benign error.
+This is enabled by default but can be disabled in each png_ptr with
+
+   png_set_check_for_invalid_index(png_ptr, allowed);
+
+      allowed  - one of
+                 0: disable
+                 1: enable
+
+A. Changes that affect users of libpng
+
+There are no substantial API changes between the non-deprecated parts of
+the 1.4.5 API and the 1.5.0 API; however, the ability to directly access
+the main libpng control structures, png_struct and png_info, deprecated
+in earlier versions of libpng, has been completely removed from
+libpng 1.5.
+
+We no longer include zlib.h in png.h.  Applications that need access
+to information in zlib.h will need to add the '#include "zlib.h"'
+directive.  It does not matter whether it is placed prior to or after
+the '"#include png.h"' directive.
+
+We moved the png_strcpy(), png_strncpy(), png_strlen(), png_memcpy(),
+png_memcmp(), png_sprintf, and png_memcpy() macros into a private
+header file (pngpriv.h) that is not accessible to applications.
+
+In png_get_iCCP, the type of "profile" was changed from png_charpp
+to png_bytepp, and in png_set_iCCP, from png_charp to png_const_bytep.
+
+There are changes of form in png.h, including new and changed macros to
+declare parts of the API.  Some API functions with arguments that are
+pointers to data not modified within the function have been corrected to
+declare these arguments with PNG_CONST.
+
+Much of the internal use of C macros to control the library build has also
+changed and some of this is visible in the exported header files, in
+particular the use of macros to control data and API elements visible
+during application compilation may require significant revision to
+application code.  (It is extremely rare for an application to do this.)
+
+Any program that compiled against libpng 1.4 and did not use deprecated
+features or access internal library structures should compile and work
+against libpng 1.5, except for the change in the prototype for
+png_get_iCCP() and png_set_iCCP() API functions mentioned above.
+
+libpng 1.5.0 adds PNG_ PASS macros to help in the reading and writing of
+interlaced images.  The macros return the number of rows and columns in
+each pass and information that can be used to de-interlace and (if
+absolutely necessary) interlace an image.
+
+libpng 1.5.0 adds an API png_longjmp(png_ptr, value).  This API calls
+the application-provided png_longjmp_ptr on the internal, but application
+initialized, longjmp buffer.  It is provided as a convenience to avoid
+the need to use the png_jmpbuf macro, which had the unnecessary side
+effect of resetting the internal png_longjmp_ptr value.
+
+libpng 1.5.0 includes a complete fixed point API.  By default this is
+present along with the corresponding floating point API.  In general the
+fixed point API is faster and smaller than the floating point one because
+the PNG file format used fixed point, not floating point.  This applies
+even if the library uses floating point in internal calculations.  A new
+macro, PNG_FLOATING_ARITHMETIC_SUPPORTED, reveals whether the library
+uses floating point arithmetic (the default) or fixed point arithmetic
+internally for performance critical calculations such as gamma correction.
+In some cases, the gamma calculations may produce slightly different
+results.  This has changed the results in png_rgb_to_gray and in alpha
+composition (png_set_background for example). This applies even if the
+original image was already linear (gamma == 1.0) and, therefore, it is
+not necessary to linearize the image.  This is because libpng has *not*
+been changed to optimize that case correctly, yet.
+
+Fixed point support for the sCAL chunk comes with an important caveat;
+the sCAL specification uses a decimal encoding of floating point values
+and the accuracy of PNG fixed point values is insufficient for
+representation of these values. Consequently a "string" API
+(png_get_sCAL_s and png_set_sCAL_s) is the only reliable way of reading
+arbitrary sCAL chunks in the absence of either the floating point API or
+internal floating point calculations.
+
+Applications no longer need to include the optional distribution header
+file pngusr.h or define the corresponding macros during application
+build in order to see the correct variant of the libpng API.  From 1.5.0
+application code can check for the corresponding _SUPPORTED macro:
+
+#ifdef PNG_INCH_CONVERSIONS_SUPPORTED
+   /* code that uses the inch conversion APIs. */
+#endif
+
+This macro will only be defined if the inch conversion functions have been
+compiled into libpng.  The full set of macros, and whether or not support
+has been compiled in, are available in the header file pnglibconf.h.
+This header file is specific to the libpng build.  Notice that prior to
+1.5.0 the _SUPPORTED macros would always have the default definition unless
+reset by pngusr.h or by explicit settings on the compiler command line.
+These settings may produce compiler warnings or errors in 1.5.0 because
+of macro redefinition.
+
+From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
+function) incorrectly returned a value of type png_uint_32.  libpng 1.5.0
+is consistent with the implementation in 1.4.5 and 1.2.x (where the macro
+did not exist.)
+
+Applications can now choose whether to use these macros or to call the
+corresponding function by defining PNG_USE_READ_MACROS or
+PNG_NO_USE_READ_MACROS before including png.h.  Notice that this is
+only supported from 1.5.0 -defining PNG_NO_USE_READ_MACROS prior to 1.5.0
+will lead to a link failure.
+
+Prior to libpng-1.5.4, the zlib compressor used the same set of parameters
+when compressing the IDAT data and textual data such as zTXt and iCCP.
+In libpng-1.5.4 we reinitialized the zlib stream for each type of data.
+We added five png_set_text_*() functions for setting the parameters to
+use with textual data.
+
+Prior to libpng-1.5.4, the PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
+option was off by default, and slightly inaccurate scaling occurred.
+This option can no longer be turned off, and the choice of accurate
+or inaccurate 16-to-8 scaling is by using the new png_set_scale_16_to_8()
+API for accurate scaling or the old png_set_strip_16_to_8() API for simple
+chopping.
+
+Prior to libpng-1.5.4, the png_set_user_limits() function could only be
+used to reduce the width and height limits from the value of
+PNG_USER_WIDTH_MAX and PNG_USER_HEIGHT_MAX, although this document said
+that it could be used to override them.  Now this function will reduce or
+increase the limits.
+
+Starting in libpng-1.5.10, the user limits can be set en masse with the
+configuration option PNG_SAFE_LIMITS_SUPPORTED.  If this option is enabled,
+a set of "safe" limits is applied in pngpriv.h.  These can be overridden by
+application calls to png_set_user_limits(), png_set_user_chunk_cache_max(),
+and/or png_set_user_malloc_max() that increase or decrease the limits.  Also,
+in libpng-1.5.10 the default width and height limits were increased
+from 1,000,000 to 0x7ffffff (i.e., made unlimited).  Therefore, the
+limits are now
+                               default      safe
+   png_user_width_max        0x7fffffff    1,000,000
+   png_user_height_max       0x7fffffff    1,000,000
+   png_user_chunk_cache_max  0 (unlimited)   128
+   png_user_chunk_malloc_max 0 (unlimited) 8,000,000
+
+B. Changes to the build and configuration of libpng
+
+Details of internal changes to the library code can be found in the CHANGES
+file and in the GIT repository logs.  These will be of no concern to the vast
+majority of library users or builders; however, the few who configure libpng
+to a non-default feature set may need to change how this is done.
+
+There should be no need for library builders to alter build scripts if
+these use the distributed build support - configure or the makefiles -
+however, users of the makefiles may care to update their build scripts
+to build pnglibconf.h where the corresponding makefile does not do so.
+
+Building libpng with a non-default configuration has changed completely.
+The old method using pngusr.h should still work correctly even though the
+way pngusr.h is used in the build has been changed; however, library
+builders will probably want to examine the changes to take advantage of
+new capabilities and to simplify their build system.
+
+B.1 Specific changes to library configuration capabilities
+
+The library now supports a complete fixed point implementation and can
+thus be used on systems that have no floating point support or very
+limited or slow support.  Previously gamma correction, an essential part
+of complete PNG support, required reasonably fast floating point.
+
+As part of this the choice of internal implementation has been made
+independent of the choice of fixed versus floating point APIs and all the
+missing fixed point APIs have been implemented.
+
+The exact mechanism used to control attributes of API functions has
+changed.  A single set of operating system independent macro definitions
+is used and operating system specific directives are defined in
+pnglibconf.h
+
+As part of this the mechanism used to choose procedure call standards on
+those systems that allow a choice has been changed.  At present this only
+affects certain Microsoft (DOS, Windows) and IBM (OS/2) operating systems
+running on Intel processors.  As before, PNGAPI is defined where required
+to control the exported API functions; however, two new macros, PNGCBAPI
+and PNGCAPI, are used instead for callback functions (PNGCBAPI) and
+(PNGCAPI) for functions that must match a C library prototype (currently
+only png_longjmp_ptr, which must match the C longjmp function.)  The new
+approach is documented in pngconf.h
+
+Despite these changes, libpng 1.5.0 only supports the native C function
+calling standard on those platforms tested so far (__cdecl on Microsoft
+Windows).  This is because the support requirements for alternative
+calling conventions seem to no longer exist.  Developers who find it
+necessary to set PNG_API_RULE to 1 should advise the mailing list
+(png-mng-implement) of this and library builders who use Openwatcom and
+therefore set PNG_API_RULE to 2 should also contact the mailing list.
+
+A new test program, pngvalid, is provided in addition to pngtest.
+pngvalid validates the arithmetic accuracy of the gamma correction
+calculations and includes a number of validations of the file format.
+A subset of the full range of tests is run when "make check" is done
+(in the 'configure' build.)  pngvalid also allows total allocated memory
+usage to be evaluated and performs additional memory overwrite validation.
+
+Many changes to individual feature macros have been made. The following
+are the changes most likely to be noticed by library builders who
+configure libpng:
+
+1) All feature macros now have consistent naming:
+
+#define PNG_NO_feature turns the feature off
+#define PNG_feature_SUPPORTED turns the feature on
+
+pnglibconf.h contains one line for each feature macro which is either:
+
+#define PNG_feature_SUPPORTED
+
+if the feature is supported or:
+
+/*#undef PNG_feature_SUPPORTED*/
+
+if it is not.  Library code consistently checks for the 'SUPPORTED' macro.
+It does not, and libpng applications should not, check for the 'NO' macro
+which will not normally be defined even if the feature is not supported.
+The 'NO' macros are only used internally for setting or not setting the
+corresponding 'SUPPORTED' macros.
+
+Compatibility with the old names is provided as follows:
+
+PNG_INCH_CONVERSIONS turns on PNG_INCH_CONVERSIONS_SUPPORTED
+
+And the following definitions disable the corresponding feature:
+
+PNG_SETJMP_NOT_SUPPORTED disables SETJMP
+PNG_READ_TRANSFORMS_NOT_SUPPORTED disables READ_TRANSFORMS
+PNG_NO_READ_COMPOSITED_NODIV disables READ_COMPOSITE_NODIV
+PNG_WRITE_TRANSFORMS_NOT_SUPPORTED disables WRITE_TRANSFORMS
+PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED disables READ_ANCILLARY_CHUNKS
+PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED disables WRITE_ANCILLARY_CHUNKS
+
+Library builders should remove use of the above, inconsistent, names.
+
+2) Warning and error message formatting was previously conditional on
+the STDIO feature. The library has been changed to use the
+CONSOLE_IO feature instead. This means that if CONSOLE_IO is disabled
+the library no longer uses the printf(3) functions, even though the
+default read/write implementations use (FILE) style stdio.h functions.
+
+3) Three feature macros now control the fixed/floating point decisions:
+
+PNG_FLOATING_POINT_SUPPORTED enables the floating point APIs
+
+PNG_FIXED_POINT_SUPPORTED enables the fixed point APIs; however, in
+practice these are normally required internally anyway (because the PNG
+file format is fixed point), therefore in most cases PNG_NO_FIXED_POINT
+merely stops the function from being exported.
+
+PNG_FLOATING_ARITHMETIC_SUPPORTED chooses between the internal floating
+point implementation or the fixed point one.  Typically the fixed point
+implementation is larger and slower than the floating point implementation
+on a system that supports floating point; however, it may be faster on a
+system which lacks floating point hardware and therefore uses a software
+emulation.
+
+4) Added PNG_{READ,WRITE}_INT_FUNCTIONS_SUPPORTED.  This allows the
+functions to read and write ints to be disabled independently of
+PNG_USE_READ_MACROS, which allows libpng to be built with the functions
+even though the default is to use the macros - this allows applications
+to choose at app buildtime whether or not to use macros (previously
+impossible because the functions weren't in the default build.)
+
+B.2 Changes to the configuration mechanism
+
+Prior to libpng-1.5.0 library builders who needed to configure libpng
+had either to modify the exported pngconf.h header file to add system
+specific configuration or had to write feature selection macros into
+pngusr.h and cause this to be included into pngconf.h by defining
+PNG_USER_CONFIG. The latter mechanism had the disadvantage that an
+application built without PNG_USER_CONFIG defined would see the
+unmodified, default, libpng API and thus would probably fail to link.
+
+These mechanisms still work in the configure build and in any makefile
+build that builds pnglibconf.h, although the feature selection macros
+have changed somewhat as described above.  In 1.5.0, however, pngusr.h is
+processed only once, when the exported header file pnglibconf.h is built.
+pngconf.h no longer includes pngusr.h, therefore pngusr.h is ignored after the
+build of pnglibconf.h and it is never included in an application build.
+
+The rarely used alternative of adding a list of feature macros to the
+CFLAGS setting in the build also still works; however, the macros will be
+copied to pnglibconf.h and this may produce macro redefinition warnings
+when the individual C files are compiled.
+
+All configuration now only works if pnglibconf.h is built from
+scripts/pnglibconf.dfa.  This requires the program awk.  Brian Kernighan
+(the original author of awk) maintains C source code of that awk and this
+and all known later implementations (often called by subtly different
+names - nawk and gawk for example) are adequate to build pnglibconf.h.
+The Sun Microsystems (now Oracle) program 'awk' is an earlier version
+and does not work; this may also apply to other systems that have a
+functioning awk called 'nawk'.
+
+Configuration options are now documented in scripts/pnglibconf.dfa.  This
+file also includes dependency information that ensures a configuration is
+consistent; that is, if a feature is switched off dependent features are
+also removed.  As a recommended alternative to using feature macros in
+pngusr.h a system builder may also define equivalent options in pngusr.dfa
+(or, indeed, any file) and add that to the configuration by setting
+DFA_XTRA to the file name.  The makefiles in contrib/pngminim illustrate
+how to do this, and a case where pngusr.h is still required.
+
+XI. Detecting libpng
+
+The png_get_io_ptr() function has been present since libpng-0.88, has never
+changed, and is unaffected by conditional compilation macros.  It is the
+best choice for use in configure scripts for detecting the presence of any
+libpng version since 0.88.  In an autoconf "configure.in" you could use
+
+    AC_CHECK_LIB(png, png_get_io_ptr, ...
+
+XII. Source code repository
+
+Since about February 2009, version 1.2.34, libpng has been under "git" source
+control.  The git repository was built from old libpng-x.y.z.tar.gz files
+going back to version 0.70.  You can access the git repository (read only)
+at
+
+    git://libpng.git.sourceforge.net/gitroot/libpng
+
+or you can browse it via "gitweb" at
+
+    http://libpng.git.sourceforge.net/git/gitweb.cgi?p=libpng
+
+Patches can be sent to glennrp at users.sourceforge.net or to
+png-mng-implement at lists.sourceforge.net or you can upload them to
+the libpng bug tracker at
+
+    http://libpng.sourceforge.net
+
+We also accept patches built from the tar or zip distributions, and
+simple verbal discriptions of bug fixes, reported either to the
+SourceForge bug tracker, to the png-mng-implement at lists.sf.net
+mailing list, or directly to glennrp.
+
+XIII. Coding style
+
+Our coding style is similar to the "Allman" style, with curly
+braces on separate lines:
+
+    if (condition)
+    {
+       action;
+    }
+
+    else if (another condition)
+    {
+       another action;
+    }
+
+The braces can be omitted from simple one-line actions:
+
+    if (condition)
+       return (0);
+
+We use 3-space indentation, except for continued statements which
+are usually indented the same as the first line of the statement
+plus four more spaces.
+
+For macro definitions we use 2-space indentation, always leaving the "#"
+in the first column.
+
+    #ifndef PNG_NO_FEATURE
+    #  ifndef PNG_FEATURE_SUPPORTED
+    #    define PNG_FEATURE_SUPPORTED
+    #  endif
+    #endif
+
+Comments appear with the leading "/*" at the same indentation as
+the statement that follows the comment:
+
+    /* Single-line comment */
+    statement;
+
+    /* This is a multiple-line
+     * comment.
+     */
+    statement;
+
+Very short comments can be placed after the end of the statement
+to which they pertain:
+
+    statement;    /* comment */
+
+We don't use C++ style ("//") comments. We have, however,
+used them in the past in some now-abandoned MMX assembler
+code.
+
+Functions and their curly braces are not indented, and
+exported functions are marked with PNGAPI:
+
+ /* This is a public function that is visible to
+  * application programmers. It does thus-and-so.
+  */
+ void PNGAPI
+ png_exported_function(png_ptr, png_info, foo)
+ {
+    body;
+ }
+
+The prototypes for all exported functions appear in png.h,
+above the comment that says
+
+    /* Maintainer: Put new public prototypes here ... */
+
+We mark all non-exported functions with "/* PRIVATE */"":
+
+ void /* PRIVATE */
+ png_non_exported_function(png_ptr, png_info, foo)
+ {
+    body;
+ }
+
+The prototypes for non-exported functions (except for those in
+pngtest) appear in
+pngpriv.h
+above the comment that says
+
+  /* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
+
+To avoid polluting the global namespace, the names of all exported
+functions and variables begin with "png_", and all publicly visible C
+preprocessor macros begin with "PNG".  We request that applications that
+use libpng *not* begin any of their own symbols with either of these strings.
+
+We put a space after each comma and after each semicolon
+in "for" statements, and we put spaces before and after each
+C binary operator and after "for" or "while", and before
+"?".  We don't put a space between a typecast and the expression
+being cast, nor do we put one between a function name and the
+left parenthesis that follows it:
+
+    for (i = 2; i > 0; --i)
+       y[i] = a(x) + (int)b;
+
+We prefer #ifdef and #ifndef to #if defined() and if !defined()
+when there is only one macro being tested.
+
+We prefer to express integers that are used as bit masks in hex format,
+with an even number of lower-case hex digits (e.g., 0x00, 0xff, 0x0100).
+
+We do not use the TAB character for indentation in the C sources.
+
+Lines do not exceed 80 characters.
+
+Other rules can be inferred by inspecting the libpng source.
+
+XIV. Y2K Compliance in libpng
+
+July 11, 2012
+
+Since the PNG Development group is an ad-hoc body, we can't make
+an official declaration.
+
+This is your unofficial assurance that libpng from version 0.71 and
+upward through 1.5.12 are Y2K compliant.  It is my belief that earlier
+versions were also Y2K compliant.
+
+Libpng only has two year fields.  One is a 2-byte unsigned integer that
+will hold years up to 65535.  The other holds the date in text
+format, and will hold years up to 9999.
+
+The integer is
+    "png_uint_16 year" in png_time_struct.
+
+The string is
+    "char time_buffer[29]" in png_struct.  This will no
+longer be used in libpng-1.6.x and will be removed from libpng-1.7.0.
+
+There are seven time-related functions:
+
+    png_convert_to_rfc_1123() in png.c
+      (formerly png_convert_to_rfc_1152() in error)
+    png_convert_from_struct_tm() in pngwrite.c, called
+      in pngwrite.c
+    png_convert_from_time_t() in pngwrite.c
+    png_get_tIME() in pngget.c
+    png_handle_tIME() in pngrutil.c, called in pngread.c
+    png_set_tIME() in pngset.c
+    png_write_tIME() in pngwutil.c, called in pngwrite.c
+
+All appear to handle dates properly in a Y2K environment.  The
+png_convert_from_time_t() function calls gmtime() to convert from system
+clock time, which returns (year - 1900), which we properly convert to
+the full 4-digit year.  There is a possibility that applications using
+libpng are not passing 4-digit years into the png_convert_to_rfc_1123()
+function, or that they are incorrectly passing only a 2-digit year
+instead of "year - 1900" into the png_convert_from_struct_tm() function,
+but this is not under our control.  The libpng documentation has always
+stated that it works with 4-digit years, and the APIs have been
+documented as such.
+
+The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
+integer to hold the year, and can hold years as large as 65535.
+
+zlib, upon which libpng depends, is also Y2K compliant.  It contains
+no date-related code.
+
+
+   Glenn Randers-Pehrson
+   libpng maintainer
+   PNG Development Group
diff -urN a/media/libpng/png.c b/media/libpng/png.c
--- a/media/libpng/png.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/png.c	2012-07-13 12:40:57 +0800
@@ -1,2870 +1,2874 @@
-
-/* png.c - location for general purpose libpng functions
- *
- * Last changed in libpng 1.5.7 [December 15, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#include "pngpriv.h"
-
-/* Generate a compiler error if there is an old png.h in the search path. */
-typedef png_libpng_version_1_5_9 Your_png_h_is_not_version_1_5_9;
-
-/* Tells libpng that we have already handled the first "num_bytes" bytes
- * of the PNG file signature.  If the PNG data is embedded into another
- * stream we can set num_bytes = 8 so that libpng will not attempt to read
- * or write any of the magic bytes before it starts on the IHDR.
- */
-
-#ifdef PNG_READ_SUPPORTED
-void PNGAPI
-png_set_sig_bytes(png_structp png_ptr, int num_bytes)
-{
-   png_debug(1, "in png_set_sig_bytes");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (num_bytes > 8)
-      png_error(png_ptr, "Too many bytes for PNG signature");
-
-   png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
-}
-
-/* Checks whether the supplied bytes match the PNG signature.  We allow
- * checking less than the full 8-byte signature so that those apps that
- * already read the first few bytes of a file to determine the file type
- * can simply check the remaining bytes for extra assurance.  Returns
- * an integer less than, equal to, or greater than zero if sig is found,
- * respectively, to be less than, to match, or be greater than the correct
- * PNG signature (this is the same behavior as strcmp, memcmp, etc).
- */
-int PNGAPI
-png_sig_cmp(png_const_bytep sig, png_size_t start, png_size_t num_to_check)
-{
-   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
-
-   if (num_to_check > 8)
-      num_to_check = 8;
-
-   else if (num_to_check < 1)
-      return (-1);
-
-   if (start > 7)
-      return (-1);
-
-   if (start + num_to_check > 8)
-      num_to_check = 8 - start;
-
-   return ((int)(png_memcmp(&sig[start], &png_signature[start], num_to_check)));
-}
-
-#endif /* PNG_READ_SUPPORTED */
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-/* Function to allocate memory for zlib */
-PNG_FUNCTION(voidpf /* PRIVATE */,
-png_zalloc,(voidpf png_ptr, uInt items, uInt size),PNG_ALLOCATED)
-{
-   png_voidp ptr;
-   png_structp p=(png_structp)png_ptr;
-   png_uint_32 save_flags=p->flags;
-   png_alloc_size_t num_bytes;
-
-   if (png_ptr == NULL)
-      return (NULL);
-
-   if (items > PNG_UINT_32_MAX/size)
-   {
-     png_warning (p, "Potential overflow in png_zalloc()");
-     return (NULL);
-   }
-   num_bytes = (png_alloc_size_t)items * size;
-
-   p->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
-   ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);
-   p->flags=save_flags;
-
-   return ((voidpf)ptr);
-}
-
-/* Function to free memory for zlib */
-void /* PRIVATE */
-png_zfree(voidpf png_ptr, voidpf ptr)
-{
-   png_free((png_structp)png_ptr, (png_voidp)ptr);
-}
-
-/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
- * in case CRC is > 32 bits to leave the top bits 0.
- */
-void /* PRIVATE */
-png_reset_crc(png_structp png_ptr)
-{
-   /* The cast is safe because the crc is a 32 bit value. */
-   png_ptr->crc = (png_uint_32)crc32(0, Z_NULL, 0);
-}
-
-/* Calculate the CRC over a section of data.  We can only pass as
- * much data to this routine as the largest single buffer size.  We
- * also check that this data will actually be used before going to the
- * trouble of calculating it.
- */
-void /* PRIVATE */
-png_calculate_crc(png_structp png_ptr, png_const_bytep ptr, png_size_t length)
-{
-   int need_crc = 1;
-
-   if (PNG_CHUNK_ANCILLIARY(png_ptr->chunk_name))
-   {
-      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
-          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
-         need_crc = 0;
-   }
-
-   else /* critical */
-   {
-      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
-         need_crc = 0;
-   }
-
-   /* 'uLong' is defined as unsigned long, this means that on some systems it is
-    * a 64 bit value.  crc32, however, returns 32 bits so the following cast is
-    * safe.  'uInt' may be no more than 16 bits, so it is necessary to perform a
-    * loop here.
-    */
-   if (need_crc && length > 0)
-   {
-      uLong crc = png_ptr->crc; /* Should never issue a warning */
-
-      do
-      {
-         uInt safeLength = (uInt)length;
-         if (safeLength == 0)
-            safeLength = (uInt)-1; /* evil, but safe */
-
-         crc = crc32(crc, ptr, safeLength);
-
-         /* The following should never issue compiler warnings, if they do the
-          * target system has characteristics that will probably violate other
-          * assumptions within the libpng code.
-          */
-         ptr += safeLength;
-         length -= safeLength;
-      }
-      while (length > 0);
-
-      /* And the following is always safe because the crc is only 32 bits. */
-      png_ptr->crc = (png_uint_32)crc;
-   }
-}
-
-/* Check a user supplied version number, called from both read and write
- * functions that create a png_struct
- */
-int
-png_user_version_check(png_structp png_ptr, png_const_charp user_png_ver)
-{
-   if (user_png_ver)
-   {
-      int i = 0;
-
-      do
-      {
-         if (user_png_ver[i] != png_libpng_ver[i])
-            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-      } while (png_libpng_ver[i++]);
-   }
-
-   else
-      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
-
-   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
-   {
-     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
-      * we must recompile any applications that use any older library version.
-      * For versions after libpng 1.0, we will be compatible, so we need
-      * only check the first digit.
-      */
-      if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
-          (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
-          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
-      {
-#ifdef PNG_WARNINGS_SUPPORTED
-         size_t pos = 0;
-         char m[128];
-
-         pos = png_safecat(m, sizeof m, pos, "Application built with libpng-");
-         pos = png_safecat(m, sizeof m, pos, user_png_ver);
-         pos = png_safecat(m, sizeof m, pos, " but running with ");
-         pos = png_safecat(m, sizeof m, pos, png_libpng_ver);
-
-         png_warning(png_ptr, m);
-#endif
-
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-         png_ptr->flags = 0;
-#endif
-
-         return 0;
-      }
-   }
-
-   /* Success return. */
-   return 1;
-}
-
-/* Allocate the memory for an info_struct for the application.  We don't
- * really need the png_ptr, but it could potentially be useful in the
- * future.  This should be used in favour of malloc(png_sizeof(png_info))
- * and png_info_init() so that applications that want to use a shared
- * libpng don't have to be recompiled if png_info changes size.
- */
-PNG_FUNCTION(png_infop,PNGAPI
-png_create_info_struct,(png_structp png_ptr),PNG_ALLOCATED)
-{
-   png_infop info_ptr;
-
-   png_debug(1, "in png_create_info_struct");
-
-   if (png_ptr == NULL)
-      return (NULL);
-
-#ifdef PNG_USER_MEM_SUPPORTED
-   info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,
-      png_ptr->malloc_fn, png_ptr->mem_ptr);
-#else
-   info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
-#endif
-   if (info_ptr != NULL)
-      png_info_init_3(&info_ptr, png_sizeof(png_info));
-
-   return (info_ptr);
-}
-
-/* This function frees the memory associated with a single info struct.
- * Normally, one would use either png_destroy_read_struct() or
- * png_destroy_write_struct() to free an info struct, but this may be
- * useful for some applications.
- */
-void PNGAPI
-png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
-{
-   png_infop info_ptr = NULL;
-
-   png_debug(1, "in png_destroy_info_struct");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (info_ptr_ptr != NULL)
-      info_ptr = *info_ptr_ptr;
-
-   if (info_ptr != NULL)
-   {
-      png_info_destroy(png_ptr, info_ptr);
-
-#ifdef PNG_USER_MEM_SUPPORTED
-      png_destroy_struct_2((png_voidp)info_ptr, png_ptr->free_fn,
-          png_ptr->mem_ptr);
-#else
-      png_destroy_struct((png_voidp)info_ptr);
-#endif
-      *info_ptr_ptr = NULL;
-   }
-}
-
-/* Initialize the info structure.  This is now an internal function (0.89)
- * and applications using it are urged to use png_create_info_struct()
- * instead.
- */
-
-void PNGAPI
-png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
-{
-   png_infop info_ptr = *ptr_ptr;
-
-   png_debug(1, "in png_info_init_3");
-
-   if (info_ptr == NULL)
-      return;
-
-   if (png_sizeof(png_info) > png_info_struct_size)
-   {
-      png_destroy_struct(info_ptr);
-      info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
-      *ptr_ptr = info_ptr;
-   }
-
-   /* Set everything to 0 */
-   png_memset(info_ptr, 0, png_sizeof(png_info));
-}
-
-void PNGAPI
-png_data_freer(png_structp png_ptr, png_infop info_ptr,
-   int freer, png_uint_32 mask)
-{
-   png_debug(1, "in png_data_freer");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-   if (freer == PNG_DESTROY_WILL_FREE_DATA)
-      info_ptr->free_me |= mask;
-
-   else if (freer == PNG_USER_WILL_FREE_DATA)
-      info_ptr->free_me &= ~mask;
-
-   else
-      png_warning(png_ptr,
-         "Unknown freer parameter in png_data_freer");
-}
-
-void PNGAPI
-png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
-   int num)
-{
-   png_debug(1, "in png_free_data");
-
-   if (png_ptr == NULL || info_ptr == NULL)
-      return;
-
-#ifdef PNG_TEXT_SUPPORTED
-   /* Free text item num or (if num == -1) all text items */
-   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
-   {
-      if (num != -1)
-      {
-         if (info_ptr->text && info_ptr->text[num].key)
-         {
-            png_free(png_ptr, info_ptr->text[num].key);
-            info_ptr->text[num].key = NULL;
-         }
-      }
-
-      else
-      {
-         int i;
-         for (i = 0; i < info_ptr->num_text; i++)
-             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
-         png_free(png_ptr, info_ptr->text);
-         info_ptr->text = NULL;
-         info_ptr->num_text=0;
-      }
-   }
-#endif
-
-#ifdef PNG_tRNS_SUPPORTED
-   /* Free any tRNS entry */
-   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->trans_alpha);
-      info_ptr->trans_alpha = NULL;
-      info_ptr->valid &= ~PNG_INFO_tRNS;
-   }
-#endif
-
-#ifdef PNG_sCAL_SUPPORTED
-   /* Free any sCAL entry */
-   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->scal_s_width);
-      png_free(png_ptr, info_ptr->scal_s_height);
-      info_ptr->scal_s_width = NULL;
-      info_ptr->scal_s_height = NULL;
-      info_ptr->valid &= ~PNG_INFO_sCAL;
-   }
-#endif
-
-#ifdef PNG_pCAL_SUPPORTED
-   /* Free any pCAL entry */
-   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->pcal_purpose);
-      png_free(png_ptr, info_ptr->pcal_units);
-      info_ptr->pcal_purpose = NULL;
-      info_ptr->pcal_units = NULL;
-      if (info_ptr->pcal_params != NULL)
-         {
-            int i;
-            for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
-            {
-               png_free(png_ptr, info_ptr->pcal_params[i]);
-               info_ptr->pcal_params[i] = NULL;
-            }
-            png_free(png_ptr, info_ptr->pcal_params);
-            info_ptr->pcal_params = NULL;
-         }
-      info_ptr->valid &= ~PNG_INFO_pCAL;
-   }
-#endif
-
-#ifdef PNG_iCCP_SUPPORTED
-   /* Free any iCCP entry */
-   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->iccp_name);
-      png_free(png_ptr, info_ptr->iccp_profile);
-      info_ptr->iccp_name = NULL;
-      info_ptr->iccp_profile = NULL;
-      info_ptr->valid &= ~PNG_INFO_iCCP;
-   }
-#endif
-
-#ifdef PNG_sPLT_SUPPORTED
-   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
-   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
-   {
-      if (num != -1)
-      {
-         if (info_ptr->splt_palettes)
-         {
-            png_free(png_ptr, info_ptr->splt_palettes[num].name);
-            png_free(png_ptr, info_ptr->splt_palettes[num].entries);
-            info_ptr->splt_palettes[num].name = NULL;
-            info_ptr->splt_palettes[num].entries = NULL;
-         }
-      }
-
-      else
-      {
-         if (info_ptr->splt_palettes_num)
-         {
-            int i;
-            for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
-               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);
-
-            png_free(png_ptr, info_ptr->splt_palettes);
-            info_ptr->splt_palettes = NULL;
-            info_ptr->splt_palettes_num = 0;
-         }
-         info_ptr->valid &= ~PNG_INFO_sPLT;
-      }
-   }
-#endif
-
-#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
-   if (png_ptr->unknown_chunk.data)
-   {
-      png_free(png_ptr, png_ptr->unknown_chunk.data);
-      png_ptr->unknown_chunk.data = NULL;
-   }
-
-   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
-   {
-      if (num != -1)
-      {
-          if (info_ptr->unknown_chunks)
-          {
-             png_free(png_ptr, info_ptr->unknown_chunks[num].data);
-             info_ptr->unknown_chunks[num].data = NULL;
-          }
-      }
-
-      else
-      {
-         int i;
-
-         if (info_ptr->unknown_chunks_num)
-         {
-            for (i = 0; i < info_ptr->unknown_chunks_num; i++)
-               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);
-
-            png_free(png_ptr, info_ptr->unknown_chunks);
-            info_ptr->unknown_chunks = NULL;
-            info_ptr->unknown_chunks_num = 0;
-         }
-      }
-   }
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
-   /* Free any hIST entry */
-   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
-   {
-      png_free(png_ptr, info_ptr->hist);
-      info_ptr->hist = NULL;
-      info_ptr->valid &= ~PNG_INFO_hIST;
-   }
-#endif
-
-   /* Free any PLTE entry that was internally allocated */
-   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
-   {
-      png_zfree(png_ptr, info_ptr->palette);
-      info_ptr->palette = NULL;
-      info_ptr->valid &= ~PNG_INFO_PLTE;
-      info_ptr->num_palette = 0;
-   }
-
-#ifdef PNG_INFO_IMAGE_SUPPORTED
-   /* Free any image bits attached to the info structure */
-   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
-   {
-      if (info_ptr->row_pointers)
-      {
-         int row;
-         for (row = 0; row < (int)info_ptr->height; row++)
-         {
-            png_free(png_ptr, info_ptr->row_pointers[row]);
-            info_ptr->row_pointers[row] = NULL;
-         }
-         png_free(png_ptr, info_ptr->row_pointers);
-         info_ptr->row_pointers = NULL;
-      }
-      info_ptr->valid &= ~PNG_INFO_IDAT;
-   }
-#endif
-
-   if (num != -1)
-      mask &= ~PNG_FREE_MUL;
-
-   info_ptr->free_me &= ~mask;
-}
-
-/* This is an internal routine to free any memory that the info struct is
- * pointing to before re-using it or freeing the struct itself.  Recall
- * that png_free() checks for NULL pointers for us.
- */
-void /* PRIVATE */
-png_info_destroy(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_info_destroy");
-
-   png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-   if (png_ptr->num_chunk_list)
-   {
-      png_free(png_ptr, png_ptr->chunk_list);
-      png_ptr->chunk_list = NULL;
-      png_ptr->num_chunk_list = 0;
-   }
-#endif
-
-   png_info_init_3(&info_ptr, png_sizeof(png_info));
-}
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
-
-/* This function returns a pointer to the io_ptr associated with the user
- * functions.  The application should free any memory associated with this
- * pointer before png_write_destroy() or png_read_destroy() are called.
- */
-png_voidp PNGAPI
-png_get_io_ptr(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return (NULL);
-
-   return (png_ptr->io_ptr);
-}
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-#  ifdef PNG_STDIO_SUPPORTED
-/* Initialize the default input/output functions for the PNG file.  If you
- * use your own read or write routines, you can call either png_set_read_fn()
- * or png_set_write_fn() instead of png_init_io().  If you have defined
- * PNG_NO_STDIO or otherwise disabled PNG_STDIO_SUPPORTED, you must use a
- * function of your own because "FILE *" isn't necessarily available.
- */
-void PNGAPI
-png_init_io(png_structp png_ptr, png_FILE_p fp)
-{
-   png_debug(1, "in png_init_io");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->io_ptr = (png_voidp)fp;
-}
-#  endif
-
-#  ifdef PNG_TIME_RFC1123_SUPPORTED
-/* Convert the supplied time into an RFC 1123 string suitable for use in
- * a "Creation Time" or other text-based time string.
- */
-png_const_charp PNGAPI
-png_convert_to_rfc1123(png_structp png_ptr, png_const_timep ptime)
-{
-   static PNG_CONST char short_months[12][4] =
-        {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
-         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
-
-   if (png_ptr == NULL)
-      return (NULL);
-
-   if (ptime->year > 9999 /* RFC1123 limitation */ ||
-       ptime->month == 0    ||  ptime->month > 12  ||
-       ptime->day   == 0    ||  ptime->day   > 31  ||
-       ptime->hour  > 23    ||  ptime->minute > 59 ||
-       ptime->second > 60)
-   {
-      png_warning(png_ptr, "Ignoring invalid time value");
-      return (NULL);
-   }
-
-   {
-      size_t pos = 0;
-      char number_buf[5]; /* enough for a four-digit year */
-
-#     define APPEND_STRING(string)\
-         pos = png_safecat(png_ptr->time_buffer, sizeof png_ptr->time_buffer,\
-            pos, (string))
-#     define APPEND_NUMBER(format, value)\
-         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
-#     define APPEND(ch)\
-         if (pos < (sizeof png_ptr->time_buffer)-1)\
-            png_ptr->time_buffer[pos++] = (ch)
-
-      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);
-      APPEND(' ');
-      APPEND_STRING(short_months[(ptime->month - 1)]);
-      APPEND(' ');
-      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);
-      APPEND(' ');
-      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);
-      APPEND(':');
-      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);
-      APPEND(':');
-      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);
-      APPEND_STRING(" +0000"); /* This reliably terminates the buffer */
-
-#     undef APPEND
-#     undef APPEND_NUMBER
-#     undef APPEND_STRING
-   }
-
-   return png_ptr->time_buffer;
-}
-#  endif /* PNG_TIME_RFC1123_SUPPORTED */
-
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
-
-png_const_charp PNGAPI
-png_get_copyright(png_const_structp png_ptr)
-{
-   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
-#ifdef PNG_STRING_COPYRIGHT
-   return PNG_STRING_COPYRIGHT
-#else
-#  ifdef __STDC__
-   return PNG_STRING_NEWLINE \
-     "libpng version 1.5.9 - February 18, 2012" PNG_STRING_NEWLINE \
-     "Copyright (c) 1998-2011 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
-     "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
-     "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
-     PNG_STRING_NEWLINE;
-#  else
-      return "libpng version 1.5.9 - February 18, 2012\
-      Copyright (c) 1998-2011 Glenn Randers-Pehrson\
-      Copyright (c) 1996-1997 Andreas Dilger\
-      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.";
-#  endif
-#endif
-}
-
-/* The following return the library version as a short string in the
- * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
- * used with your application, print out PNG_LIBPNG_VER_STRING, which
- * is defined in png.h.
- * Note: now there is no difference between png_get_libpng_ver() and
- * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,
- * it is guaranteed that png.c uses the correct version of png.h.
- */
-png_const_charp PNGAPI
-png_get_libpng_ver(png_const_structp png_ptr)
-{
-   /* Version of *.c files used when building libpng */
-   return png_get_header_ver(png_ptr);
-}
-
-png_const_charp PNGAPI
-png_get_header_ver(png_const_structp png_ptr)
-{
-   /* Version of *.h files used when building libpng */
-   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
-   return PNG_LIBPNG_VER_STRING;
-}
-
-png_const_charp PNGAPI
-png_get_header_version(png_const_structp png_ptr)
-{
-   /* Returns longer string containing both version and date */
-   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
-#ifdef __STDC__
-   return PNG_HEADER_VERSION_STRING
-#  ifndef PNG_READ_SUPPORTED
-   "     (NO READ SUPPORT)"
-#  endif
-   PNG_STRING_NEWLINE;
-#else
-   return PNG_HEADER_VERSION_STRING;
-#endif
-}
-
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
-int PNGAPI
-png_handle_as_unknown(png_structp png_ptr, png_const_bytep chunk_name)
-{
-   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
-   png_const_bytep p, p_end;
-
-   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list <= 0)
-      return PNG_HANDLE_CHUNK_AS_DEFAULT;
-
-   p_end = png_ptr->chunk_list;
-   p = p_end + png_ptr->num_chunk_list*5; /* beyond end */
-
-   /* The code is the fifth byte after each four byte string.  Historically this
-    * code was always searched from the end of the list, so it should continue
-    * to do so in case there are duplicated entries.
-    */
-   do /* num_chunk_list > 0, so at least one */
-   {
-      p -= 5;
-      if (!png_memcmp(chunk_name, p, 4))
-         return p[4];
-   }
-   while (p > p_end);
-
-   return PNG_HANDLE_CHUNK_AS_DEFAULT;
-}
-
-int /* PRIVATE */
-png_chunk_unknown_handling(png_structp png_ptr, png_uint_32 chunk_name)
-{
-   png_byte chunk_string[5];
-
-   PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);
-   return png_handle_as_unknown(png_ptr, chunk_string);
-}
-#endif
-
-#ifdef PNG_READ_SUPPORTED
-/* This function, added to libpng-1.0.6g, is untested. */
-int PNGAPI
-png_reset_zstream(png_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return Z_STREAM_ERROR;
-
-   return (inflateReset(&png_ptr->zstream));
-}
-#endif /* PNG_READ_SUPPORTED */
-
-/* This function was added to libpng-1.0.7 */
-png_uint_32 PNGAPI
-png_access_version_number(void)
-{
-   /* Version of *.c files used when building libpng */
-   return((png_uint_32)PNG_LIBPNG_VER);
-}
-
-
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-/* png_convert_size: a PNGAPI but no longer in png.h, so deleted
- * at libpng 1.5.5!
- */
-
-/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
-#  ifdef PNG_CHECK_cHRM_SUPPORTED
-
-int /* PRIVATE */
-png_check_cHRM_fixed(png_structp png_ptr,
-   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
-   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
-   png_fixed_point blue_x, png_fixed_point blue_y)
-{
-   int ret = 1;
-   unsigned long xy_hi,xy_lo,yx_hi,yx_lo;
-
-   png_debug(1, "in function png_check_cHRM_fixed");
-
-   if (png_ptr == NULL)
-      return 0;
-
-   /* (x,y,z) values are first limited to 0..100000 (PNG_FP_1), the white
-    * y must also be greater than 0.  To test for the upper limit calculate
-    * (PNG_FP_1-y) - x must be <= to this for z to be >= 0 (and the expression
-    * cannot overflow.)  At this point we know x and y are >= 0 and (x+y) is
-    * <= PNG_FP_1.  The previous test on PNG_MAX_UINT_31 is removed because it
-    * pointless (and it produces compiler warnings!)
-    */
-   if (white_x < 0 || white_y <= 0 ||
-         red_x < 0 ||   red_y <  0 ||
-       green_x < 0 || green_y <  0 ||
-        blue_x < 0 ||  blue_y <  0)
-   {
-      png_warning(png_ptr,
-        "Ignoring attempt to set negative chromaticity value");
-      ret = 0;
-   }
-   /* And (x+y) must be <= PNG_FP_1 (so z is >= 0) */
-   if (white_x > PNG_FP_1 - white_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM white point");
-      ret = 0;
-   }
-
-   if (red_x > PNG_FP_1 - red_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM red point");
-      ret = 0;
-   }
-
-   if (green_x > PNG_FP_1 - green_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM green point");
-      ret = 0;
-   }
-
-   if (blue_x > PNG_FP_1 - blue_y)
-   {
-      png_warning(png_ptr, "Invalid cHRM blue point");
-      ret = 0;
-   }
-
-   png_64bit_product(green_x - red_x, blue_y - red_y, &xy_hi, &xy_lo);
-   png_64bit_product(green_y - red_y, blue_x - red_x, &yx_hi, &yx_lo);
-
-   if (xy_hi == yx_hi && xy_lo == yx_lo)
-   {
-      png_warning(png_ptr,
-         "Ignoring attempt to set cHRM RGB triangle with zero area");
-      ret = 0;
-   }
-
-   return ret;
-}
-#  endif /* PNG_CHECK_cHRM_SUPPORTED */
-
-#ifdef PNG_cHRM_SUPPORTED
-/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for
- * cHRM, as opposed to using chromaticities.  These internal APIs return
- * non-zero on a parameter error.  The X, Y and Z values are required to be
- * positive and less than 1.0.
- */
-int png_xy_from_XYZ(png_xy *xy, png_XYZ XYZ)
-{
-   png_int_32 d, dwhite, whiteX, whiteY;
-
-   d = XYZ.redX + XYZ.redY + XYZ.redZ;
-   if (!png_muldiv(&xy->redx, XYZ.redX, PNG_FP_1, d)) return 1;
-   if (!png_muldiv(&xy->redy, XYZ.redY, PNG_FP_1, d)) return 1;
-   dwhite = d;
-   whiteX = XYZ.redX;
-   whiteY = XYZ.redY;
-
-   d = XYZ.greenX + XYZ.greenY + XYZ.greenZ;
-   if (!png_muldiv(&xy->greenx, XYZ.greenX, PNG_FP_1, d)) return 1;
-   if (!png_muldiv(&xy->greeny, XYZ.greenY, PNG_FP_1, d)) return 1;
-   dwhite += d;
-   whiteX += XYZ.greenX;
-   whiteY += XYZ.greenY;
-
-   d = XYZ.blueX + XYZ.blueY + XYZ.blueZ;
-   if (!png_muldiv(&xy->bluex, XYZ.blueX, PNG_FP_1, d)) return 1;
-   if (!png_muldiv(&xy->bluey, XYZ.blueY, PNG_FP_1, d)) return 1;
-   dwhite += d;
-   whiteX += XYZ.blueX;
-   whiteY += XYZ.blueY;
-
-   /* The reference white is simply the same of the end-point (X,Y,Z) vectors,
-    * thus:
-    */
-   if (!png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite)) return 1;
-   if (!png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite)) return 1;
-
-   return 0;
-}
-
-int png_XYZ_from_xy(png_XYZ *XYZ, png_xy xy)
-{
-   png_fixed_point red_inverse, green_inverse, blue_scale;
-   png_fixed_point left, right, denominator;
-
-   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically
-    * have end points with 0 tristimulus values (these are impossible end
-    * points, but they are used to cover the possible colors.)
-    */
-   if (xy.redx < 0 || xy.redx > PNG_FP_1) return 1;
-   if (xy.redy < 0 || xy.redy > PNG_FP_1-xy.redx) return 1;
-   if (xy.greenx < 0 || xy.greenx > PNG_FP_1) return 1;
-   if (xy.greeny < 0 || xy.greeny > PNG_FP_1-xy.greenx) return 1;
-   if (xy.bluex < 0 || xy.bluex > PNG_FP_1) return 1;
-   if (xy.bluey < 0 || xy.bluey > PNG_FP_1-xy.bluex) return 1;
-   if (xy.whitex < 0 || xy.whitex > PNG_FP_1) return 1;
-   if (xy.whitey < 0 || xy.whitey > PNG_FP_1-xy.whitex) return 1;
-
-   /* The reverse calculation is more difficult because the original tristimulus
-    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8
-    * derived values were recorded in the cHRM chunk;
-    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and
-    * therefore an arbitrary ninth value has to be introduced to undo the
-    * original transformations.
-    *
-    * Think of the original end-points as points in (X,Y,Z) space.  The
-    * chromaticity values (c) have the property:
-    *
-    *           C
-    *   c = ---------
-    *       X + Y + Z
-    *
-    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the
-    * three chromaticity values (x,y,z) for each end-point obey the
-    * relationship:
-    *
-    *   x + y + z = 1
-    *
-    * This describes the plane in (X,Y,Z) space that intersects each axis at the
-    * value 1.0; call this the chromaticity plane.  Thus the chromaticity
-    * calculation has scaled each end-point so that it is on the x+y+z=1 plane
-    * and chromaticity is the intersection of the vector from the origin to the
-    * (X,Y,Z) value with the chromaticity plane.
-    *
-    * To fully invert the chromaticity calculation we would need the three
-    * end-point scale factors, (red-scale, green-scale, blue-scale), but these
-    * were not recorded.  Instead we calculated the reference white (X,Y,Z) and
-    * recorded the chromaticity of this.  The reference white (X,Y,Z) would have
-    * given all three of the scale factors since:
-    *
-    *    color-C = color-c * color-scale
-    *    white-C = red-C + green-C + blue-C
-    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
-    *
-    * But cHRM records only white-x and white-y, so we have lost the white scale
-    * factor:
-    *
-    *    white-C = white-c*white-scale
-    *
-    * To handle this the inverse transformation makes an arbitrary assumption
-    * about white-scale:
-    *
-    *    Assume: white-Y = 1.0
-    *    Hence:  white-scale = 1/white-y
-    *    Or:     red-Y + green-Y + blue-Y = 1.0
-    *
-    * Notice the last statement of the assumption gives an equation in three of
-    * the nine values we want to calculate.  8 more equations come from the
-    * above routine as summarised at the top above (the chromaticity
-    * calculation):
-    *
-    *    Given: color-x = color-X / (color-X + color-Y + color-Z)
-    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0
-    *
-    * This is 9 simultaneous equations in the 9 variables "color-C" and can be
-    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix
-    * determinants, however this is not as bad as it seems because only 28 of
-    * the total of 90 terms in the various matrices are non-zero.  Nevertheless
-    * Cramer's rule is notoriously numerically unstable because the determinant
-    * calculation involves the difference of large, but similar, numbers.  It is
-    * difficult to be sure that the calculation is stable for real world values
-    * and it is certain that it becomes unstable where the end points are close
-    * together.
-    *
-    * So this code uses the perhaps slighly less optimal but more understandable
-    * and totally obvious approach of calculating color-scale.
-    *
-    * This algorithm depends on the precision in white-scale and that is
-    * (1/white-y), so we can immediately see that as white-y approaches 0 the
-    * accuracy inherent in the cHRM chunk drops off substantially.
-    *
-    * libpng arithmetic: a simple invertion of the above equations
-    * ------------------------------------------------------------
-    *
-    *    white_scale = 1/white-y
-    *    white-X = white-x * white-scale
-    *    white-Y = 1.0
-    *    white-Z = (1 - white-x - white-y) * white_scale
-    *
-    *    white-C = red-C + green-C + blue-C
-    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
-    *
-    * This gives us three equations in (red-scale,green-scale,blue-scale) where
-    * all the coefficients are now known:
-    *
-    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale
-    *       = white-x/white-y
-    *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1
-    *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale
-    *       = (1 - white-x - white-y)/white-y
-    *
-    * In the last equation color-z is (1 - color-x - color-y) so we can add all
-    * three equations together to get an alternative third:
-    *
-    *    red-scale + green-scale + blue-scale = 1/white-y = white-scale
-    *
-    * So now we have a Cramer's rule solution where the determinants are just
-    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve
-    * multiplication of three coefficients so we can't guarantee to avoid
-    * overflow in the libpng fixed point representation.  Using Cramer's rule in
-    * floating point is probably a good choice here, but it's not an option for
-    * fixed point.  Instead proceed to simplify the first two equations by
-    * eliminating what is likely to be the largest value, blue-scale:
-    *
-    *    blue-scale = white-scale - red-scale - green-scale
-    *
-    * Hence:
-    *
-    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =
-    *                (white-x - blue-x)*white-scale
-    *
-    *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =
-    *                1 - blue-y*white-scale
-    *
-    * And now we can trivially solve for (red-scale,green-scale):
-    *
-    *    green-scale =
-    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale
-    *                -----------------------------------------------------------
-    *                                  green-x - blue-x
-    *
-    *    red-scale =
-    *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale
-    *                ---------------------------------------------------------
-    *                                  red-y - blue-y
-    *
-    * Hence:
-    *
-    *    red-scale =
-    *          ( (green-x - blue-x) * (white-y - blue-y) -
-    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y
-    * -------------------------------------------------------------------------
-    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
-    *
-    *    green-scale =
-    *          ( (red-y - blue-y) * (white-x - blue-x) -
-    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y
-    * -------------------------------------------------------------------------
-    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
-    *
-    * Accuracy:
-    * The input values have 5 decimal digits of accuracy.  The values are all in
-    * the range 0 < value < 1, so simple products are in the same range but may
-    * need up to 10 decimal digits to preserve the original precision and avoid
-    * underflow.  Because we are using a 32-bit signed representation we cannot
-    * match this; the best is a little over 9 decimal digits, less than 10.
-    *
-    * The approach used here is to preserve the maximum precision within the
-    * signed representation.  Because the red-scale calculation above uses the
-    * difference between two products of values that must be in the range -1..+1
-    * it is sufficient to divide the product by 7; ceil(100,000/32767*2).  The
-    * factor is irrelevant in the calculation because it is applied to both
-    * numerator and denominator.
-    *
-    * Note that the values of the differences of the products of the
-    * chromaticities in the above equations tend to be small, for example for
-    * the sRGB chromaticities they are:
-    *
-    * red numerator:    -0.04751
-    * green numerator:  -0.08788
-    * denominator:      -0.2241 (without white-y multiplication)
-    *
-    *  The resultant Y coefficients from the chromaticities of some widely used
-    *  color space definitions are (to 15 decimal places):
-    *
-    *  sRGB
-    *    0.212639005871510 0.715168678767756 0.072192315360734
-    *  Kodak ProPhoto
-    *    0.288071128229293 0.711843217810102 0.000085653960605
-    *  Adobe RGB
-    *    0.297344975250536 0.627363566255466 0.075291458493998
-    *  Adobe Wide Gamut RGB
-    *    0.258728243040113 0.724682314948566 0.016589442011321
-    */
-   /* By the argument, above overflow should be impossible here. The return
-    * value of 2 indicates an internal error to the caller.
-    */
-   if (!png_muldiv(&left, xy.greenx-xy.bluex, xy.redy - xy.bluey, 7)) return 2;
-   if (!png_muldiv(&right, xy.greeny-xy.bluey, xy.redx - xy.bluex, 7)) return 2;
-   denominator = left - right;
-
-   /* Now find the red numerator. */
-   if (!png_muldiv(&left, xy.greenx-xy.bluex, xy.whitey-xy.bluey, 7)) return 2;
-   if (!png_muldiv(&right, xy.greeny-xy.bluey, xy.whitex-xy.bluex, 7)) return 2;
-
-   /* Overflow is possible here and it indicates an extreme set of PNG cHRM
-    * chunk values.  This calculation actually returns the reciprocal of the
-    * scale value because this allows us to delay the multiplication of white-y
-    * into the denominator, which tends to produce a small number.
-    */
-   if (!png_muldiv(&red_inverse, xy.whitey, denominator, left-right) ||
-       red_inverse <= xy.whitey /* r+g+b scales = white scale */)
-      return 1;
-
-   /* Similarly for green_inverse: */
-   if (!png_muldiv(&left, xy.redy-xy.bluey, xy.whitex-xy.bluex, 7)) return 2;
-   if (!png_muldiv(&right, xy.redx-xy.bluex, xy.whitey-xy.bluey, 7)) return 2;
-   if (!png_muldiv(&green_inverse, xy.whitey, denominator, left-right) ||
-       green_inverse <= xy.whitey)
-      return 1;
-
-   /* And the blue scale, the checks above guarantee this can't overflow but it
-    * can still produce 0 for extreme cHRM values.
-    */
-   blue_scale = png_reciprocal(xy.whitey) - png_reciprocal(red_inverse) -
-      png_reciprocal(green_inverse);
-   if (blue_scale <= 0) return 1;
-
-
-   /* And fill in the png_XYZ: */
-   if (!png_muldiv(&XYZ->redX, xy.redx, PNG_FP_1, red_inverse)) return 1;
-   if (!png_muldiv(&XYZ->redY, xy.redy, PNG_FP_1, red_inverse)) return 1;
-   if (!png_muldiv(&XYZ->redZ, PNG_FP_1 - xy.redx - xy.redy, PNG_FP_1,
-      red_inverse))
-      return 1;
-
-   if (!png_muldiv(&XYZ->greenX, xy.greenx, PNG_FP_1, green_inverse)) return 1;
-   if (!png_muldiv(&XYZ->greenY, xy.greeny, PNG_FP_1, green_inverse)) return 1;
-   if (!png_muldiv(&XYZ->greenZ, PNG_FP_1 - xy.greenx - xy.greeny, PNG_FP_1,
-      green_inverse))
-      return 1;
-
-   if (!png_muldiv(&XYZ->blueX, xy.bluex, blue_scale, PNG_FP_1)) return 1;
-   if (!png_muldiv(&XYZ->blueY, xy.bluey, blue_scale, PNG_FP_1)) return 1;
-   if (!png_muldiv(&XYZ->blueZ, PNG_FP_1 - xy.bluex - xy.bluey, blue_scale,
-      PNG_FP_1))
-      return 1;
-
-   return 0; /*success*/
-}
-
-int png_XYZ_from_xy_checked(png_structp png_ptr, png_XYZ *XYZ, png_xy xy)
-{
-   switch (png_XYZ_from_xy(XYZ, xy))
-   {
-      case 0: /* success */
-         return 1;
-
-      case 1:
-         /* The chunk may be technically valid, but we got png_fixed_point
-          * overflow while trying to get XYZ values out of it.  This is
-          * entirely benign - the cHRM chunk is pretty extreme.
-          */
-         png_warning(png_ptr,
-            "extreme cHRM chunk cannot be converted to tristimulus values");
-         break;
-
-      default:
-         /* libpng is broken; this should be a warning but if it happens we
-          * want error reports so for the moment it is an error.
-          */
-         png_error(png_ptr, "internal error in png_XYZ_from_xy");
-         break;
-   }
-
-   /* ERROR RETURN */
-   return 0;
-}
-#endif
-
-void /* PRIVATE */
-png_check_IHDR(png_structp png_ptr,
-   png_uint_32 width, png_uint_32 height, int bit_depth,
-   int color_type, int interlace_type, int compression_type,
-   int filter_type)
-{
-   int error = 0;
-
-   /* Check for width and height valid values */
-   if (width == 0)
-   {
-      png_warning(png_ptr, "Image width is zero in IHDR");
-      error = 1;
-   }
-
-   if (height == 0)
-   {
-      png_warning(png_ptr, "Image height is zero in IHDR");
-      error = 1;
-   }
-
-#  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   if (width > png_ptr->user_width_max)
-
-#  else
-   if (width > PNG_USER_WIDTH_MAX)
-#  endif
-   {
-      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
-      error = 1;
-   }
-
-#  ifdef PNG_SET_USER_LIMITS_SUPPORTED
-   if (height > png_ptr->user_height_max)
-#  else
-   if (height > PNG_USER_HEIGHT_MAX)
-#  endif
-   {
-      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
-      error = 1;
-   }
-
-   if (width > PNG_UINT_31_MAX)
-   {
-      png_warning(png_ptr, "Invalid image width in IHDR");
-      error = 1;
-   }
-
-   if (height > PNG_UINT_31_MAX)
-   {
-      png_warning(png_ptr, "Invalid image height in IHDR");
-      error = 1;
-   }
-
-   if (width > (PNG_UINT_32_MAX
-                 >> 3)      /* 8-byte RGBA pixels */
-                 - 48       /* bigrowbuf hack */
-                 - 1        /* filter byte */
-                 - 7*8      /* rounding of width to multiple of 8 pixels */
-                 - 8)       /* extra max_pixel_depth pad */
-      png_warning(png_ptr, "Width is too large for libpng to process pixels");
-
-   /* Check other values */
-   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
-       bit_depth != 8 && bit_depth != 16)
-   {
-      png_warning(png_ptr, "Invalid bit depth in IHDR");
-      error = 1;
-   }
-
-   if (color_type < 0 || color_type == 1 ||
-       color_type == 5 || color_type > 6)
-   {
-      png_warning(png_ptr, "Invalid color type in IHDR");
-      error = 1;
-   }
-
-   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
-       ((color_type == PNG_COLOR_TYPE_RGB ||
-         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
-         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
-   {
-      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
-      error = 1;
-   }
-
-   if (interlace_type >= PNG_INTERLACE_LAST)
-   {
-      png_warning(png_ptr, "Unknown interlace method in IHDR");
-      error = 1;
-   }
-
-   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
-   {
-      png_warning(png_ptr, "Unknown compression method in IHDR");
-      error = 1;
-   }
-
-#  ifdef PNG_MNG_FEATURES_SUPPORTED
-   /* Accept filter_method 64 (intrapixel differencing) only if
-    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
-    * 2. Libpng did not read a PNG signature (this filter_method is only
-    *    used in PNG datastreams that are embedded in MNG datastreams) and
-    * 3. The application called png_permit_mng_features with a mask that
-    *    included PNG_FLAG_MNG_FILTER_64 and
-    * 4. The filter_method is 64 and
-    * 5. The color_type is RGB or RGBA
-    */
-   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) &&
-       png_ptr->mng_features_permitted)
-      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
-
-   if (filter_type != PNG_FILTER_TYPE_BASE)
-   {
-      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
-          (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
-          ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
-          (color_type == PNG_COLOR_TYPE_RGB ||
-          color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
-      {
-         png_warning(png_ptr, "Unknown filter method in IHDR");
-         error = 1;
-      }
-
-      if (png_ptr->mode & PNG_HAVE_PNG_SIGNATURE)
-      {
-         png_warning(png_ptr, "Invalid filter method in IHDR");
-         error = 1;
-      }
-   }
-
-#  else
-   if (filter_type != PNG_FILTER_TYPE_BASE)
-   {
-      png_warning(png_ptr, "Unknown filter method in IHDR");
-      error = 1;
-   }
-#  endif
-
-   if (error == 1)
-      png_error(png_ptr, "Invalid IHDR data");
-}
-
-#if defined(PNG_sCAL_SUPPORTED) || defined(PNG_pCAL_SUPPORTED)
-/* ASCII to fp functions */
-/* Check an ASCII formated floating point value, see the more detailed
- * comments in pngpriv.h
- */
-/* The following is used internally to preserve the sticky flags */
-#define png_fp_add(state, flags) ((state) |= (flags))
-#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
-
-int /* PRIVATE */
-png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
-   png_size_tp whereami)
-{
-   int state = *statep;
-   png_size_t i = *whereami;
-
-   while (i < size)
-   {
-      int type;
-      /* First find the type of the next character */
-      switch (string[i])
-      {
-      case 43:  type = PNG_FP_SAW_SIGN;                   break;
-      case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;
-      case 46:  type = PNG_FP_SAW_DOT;                    break;
-      case 48:  type = PNG_FP_SAW_DIGIT;                  break;
-      case 49: case 50: case 51: case 52:
-      case 53: case 54: case 55: case 56:
-      case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;
-      case 69:
-      case 101: type = PNG_FP_SAW_E;                      break;
-      default:  goto PNG_FP_End;
-      }
-
-      /* Now deal with this type according to the current
-       * state, the type is arranged to not overlap the
-       * bits of the PNG_FP_STATE.
-       */
-      switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))
-      {
-      case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:
-         if (state & PNG_FP_SAW_ANY)
-            goto PNG_FP_End; /* not a part of the number */
-
-         png_fp_add(state, type);
-         break;
-
-      case PNG_FP_INTEGER + PNG_FP_SAW_DOT:
-         /* Ok as trailer, ok as lead of fraction. */
-         if (state & PNG_FP_SAW_DOT) /* two dots */
-            goto PNG_FP_End;
-
-         else if (state & PNG_FP_SAW_DIGIT) /* trailing dot? */
-            png_fp_add(state, type);
-
-         else
-            png_fp_set(state, PNG_FP_FRACTION | type);
-
-         break;
-
-      case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:
-         if (state & PNG_FP_SAW_DOT) /* delayed fraction */
-            png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);
-
-         png_fp_add(state, type | PNG_FP_WAS_VALID);
-
-         break;
-
-      case PNG_FP_INTEGER + PNG_FP_SAW_E:
-         if ((state & PNG_FP_SAW_DIGIT) == 0)
-            goto PNG_FP_End;
-
-         png_fp_set(state, PNG_FP_EXPONENT);
-
-         break;
-
-   /* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:
-         goto PNG_FP_End; ** no sign in fraction */
-
-   /* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:
-         goto PNG_FP_End; ** Because SAW_DOT is always set */
-
-      case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
-         png_fp_add(state, type | PNG_FP_WAS_VALID);
-         break;
-
-      case PNG_FP_FRACTION + PNG_FP_SAW_E:
-         /* This is correct because the trailing '.' on an
-          * integer is handled above - so we can only get here
-          * with the sequence ".E" (with no preceding digits).
-          */
-         if ((state & PNG_FP_SAW_DIGIT) == 0)
-            goto PNG_FP_End;
-
-         png_fp_set(state, PNG_FP_EXPONENT);
-
-         break;
-
-      case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:
-         if (state & PNG_FP_SAW_ANY)
-            goto PNG_FP_End; /* not a part of the number */
-
-         png_fp_add(state, PNG_FP_SAW_SIGN);
-
-         break;
-
-   /* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:
-         goto PNG_FP_End; */
-
-      case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:
-         png_fp_add(state, PNG_FP_SAW_DIGIT | PNG_FP_WAS_VALID);
-
-         break;
-
-   /* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:
-         goto PNG_FP_End; */
-
-      default: goto PNG_FP_End; /* I.e. break 2 */
-      }
-
-      /* The character seems ok, continue. */
-      ++i;
-   }
-
-PNG_FP_End:
-   /* Here at the end, update the state and return the correct
-    * return code.
-    */
-   *statep = state;
-   *whereami = i;
-
-   return (state & PNG_FP_SAW_DIGIT) != 0;
-}
-
-
-/* The same but for a complete string. */
-int
-png_check_fp_string(png_const_charp string, png_size_t size)
-{
-   int        state=0;
-   png_size_t char_index=0;
-
-   if (png_check_fp_number(string, size, &state, &char_index) &&
-      (char_index == size || string[char_index] == 0))
-      return state /* must be non-zero - see above */;
-
-   return 0; /* i.e. fail */
-}
-#endif /* pCAL or sCAL */
-
-#ifdef PNG_READ_sCAL_SUPPORTED
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-/* Utility used below - a simple accurate power of ten from an integral
- * exponent.
- */
-static double
-png_pow10(int power)
-{
-   int recip = 0;
-   double d = 1;
-
-   /* Handle negative exponent with a reciprocal at the end because
-    * 10 is exact whereas .1 is inexact in base 2
-    */
-   if (power < 0)
-   {
-      if (power < DBL_MIN_10_EXP) return 0;
-      recip = 1, power = -power;
-   }
-
-   if (power > 0)
-   {
-      /* Decompose power bitwise. */
-      double mult = 10;
-      do
-      {
-         if (power & 1) d *= mult;
-         mult *= mult;
-         power >>= 1;
-      }
-      while (power > 0);
-
-      if (recip) d = 1/d;
-   }
-   /* else power is 0 and d is 1 */
-
-   return d;
-}
-
-/* Function to format a floating point value in ASCII with a given
- * precision.
- */
-void /* PRIVATE */
-png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
-    double fp, unsigned int precision)
-{
-   /* We use standard functions from math.h, but not printf because
-    * that would require stdio.  The caller must supply a buffer of
-    * sufficient size or we will png_error.  The tests on size and
-    * the space in ascii[] consumed are indicated below.
-    */
-   if (precision < 1)
-      precision = DBL_DIG;
-
-   /* Enforce the limit of the implementation precision too. */
-   if (precision > DBL_DIG+1)
-      precision = DBL_DIG+1;
-
-   /* Basic sanity checks */
-   if (size >= precision+5) /* See the requirements below. */
-   {
-      if (fp < 0)
-      {
-         fp = -fp;
-         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */
-         --size;
-      }
-
-      if (fp >= DBL_MIN && fp <= DBL_MAX)
-      {
-         int exp_b10;       /* A base 10 exponent */
-         double base;   /* 10^exp_b10 */
-
-         /* First extract a base 10 exponent of the number,
-          * the calculation below rounds down when converting
-          * from base 2 to base 10 (multiply by log10(2) -
-          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
-          * be increased.  Note that the arithmetic shift
-          * performs a floor() unlike C arithmetic - using a
-          * C multiply would break the following for negative
-          * exponents.
-          */
-         (void)frexp(fp, &exp_b10); /* exponent to base 2 */
-
-         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */
-
-         /* Avoid underflow here. */
-         base = png_pow10(exp_b10); /* May underflow */
-
-         while (base < DBL_MIN || base < fp)
-         {
-            /* And this may overflow. */
-            double test = png_pow10(exp_b10+1);
-
-            if (test <= DBL_MAX)
-               ++exp_b10, base = test;
-
-            else
-               break;
-         }
-
-         /* Normalize fp and correct exp_b10, after this fp is in the
-          * range [.1,1) and exp_b10 is both the exponent and the digit
-          * *before* which the decimal point should be inserted
-          * (starting with 0 for the first digit).  Note that this
-          * works even if 10^exp_b10 is out of range because of the
-          * test on DBL_MAX above.
-          */
-         fp /= base;
-         while (fp >= 1) fp /= 10, ++exp_b10;
-
-         /* Because of the code above fp may, at this point, be
-          * less than .1, this is ok because the code below can
-          * handle the leading zeros this generates, so no attempt
-          * is made to correct that here.
-          */
-
-         {
-            int czero, clead, cdigits;
-            char exponent[10];
-
-            /* Allow up to two leading zeros - this will not lengthen
-             * the number compared to using E-n.
-             */
-            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */
-            {
-               czero = -exp_b10; /* PLUS 2 digits: TOTAL 3 */
-               exp_b10 = 0;      /* Dot added below before first output. */
-            }
-            else
-               czero = 0;    /* No zeros to add */
-
-            /* Generate the digit list, stripping trailing zeros and
-             * inserting a '.' before a digit if the exponent is 0.
-             */
-            clead = czero; /* Count of leading zeros */
-            cdigits = 0;   /* Count of digits in list. */
-
-            do
-            {
-               double d;
-
-               fp *= 10;
-               /* Use modf here, not floor and subtract, so that
-                * the separation is done in one step.  At the end
-                * of the loop don't break the number into parts so
-                * that the final digit is rounded.
-                */
-               if (cdigits+czero-clead+1 < (int)precision)
-                  fp = modf(fp, &d);
-
-               else
-               {
-                  d = floor(fp + .5);
-
-                  if (d > 9)
-                  {
-                     /* Rounding up to 10, handle that here. */
-                     if (czero > 0)
-                     {
-                        --czero, d = 1;
-                        if (cdigits == 0) --clead;
-                     }
-                     else
-                     {
-                        while (cdigits > 0 && d > 9)
-                        {
-                           int ch = *--ascii;
-
-                           if (exp_b10 != (-1))
-                              ++exp_b10;
-
-                           else if (ch == 46)
-                           {
-                              ch = *--ascii, ++size;
-                              /* Advance exp_b10 to '1', so that the
-                               * decimal point happens after the
-                               * previous digit.
-                               */
-                              exp_b10 = 1;
-                           }
-
-                           --cdigits;
-                           d = ch - 47;  /* I.e. 1+(ch-48) */
-                        }
-
-                        /* Did we reach the beginning? If so adjust the
-                         * exponent but take into account the leading
-                         * decimal point.
-                         */
-                        if (d > 9)  /* cdigits == 0 */
-                        {
-                           if (exp_b10 == (-1))
-                           {
-                              /* Leading decimal point (plus zeros?), if
-                               * we lose the decimal point here it must
-                               * be reentered below.
-                               */
-                              int ch = *--ascii;
-
-                              if (ch == 46)
-                                 ++size, exp_b10 = 1;
-
-                              /* Else lost a leading zero, so 'exp_b10' is
-                               * still ok at (-1)
-                               */
-                           }
-                           else
-                              ++exp_b10;
-
-                           /* In all cases we output a '1' */
-                           d = 1;
-                        }
-                     }
-                  }
-                  fp = 0; /* Guarantees termination below. */
-               }
-
-               if (d == 0)
-               {
-                  ++czero;
-                  if (cdigits == 0) ++clead;
-               }
-               else
-               {
-                  /* Included embedded zeros in the digit count. */
-                  cdigits += czero - clead;
-                  clead = 0;
-
-                  while (czero > 0)
-                  {
-                     /* exp_b10 == (-1) means we just output the decimal
-                      * place - after the DP don't adjust 'exp_b10' any
-                      * more!
-                      */
-                     if (exp_b10 != (-1))
-                     {
-                        if (exp_b10 == 0) *ascii++ = 46, --size;
-                        /* PLUS 1: TOTAL 4 */
-                        --exp_b10;
-                     }
-                     *ascii++ = 48, --czero;
-                  }
-
-                  if (exp_b10 != (-1))
-                  {
-                     if (exp_b10 == 0) *ascii++ = 46, --size; /* counted
-                                                                 above */
-                     --exp_b10;
-                  }
-                  *ascii++ = (char)(48 + (int)d), ++cdigits;
-               }
-            }
-            while (cdigits+czero-clead < (int)precision && fp > DBL_MIN);
-
-            /* The total output count (max) is now 4+precision */
-
-            /* Check for an exponent, if we don't need one we are
-             * done and just need to terminate the string.  At
-             * this point exp_b10==(-1) is effectively if flag - it got
-             * to '-1' because of the decrement after outputing
-             * the decimal point above (the exponent required is
-             * *not* -1!)
-             */
-            if (exp_b10 >= (-1) && exp_b10 <= 2)
-            {
-               /* The following only happens if we didn't output the
-                * leading zeros above for negative exponent, so this
-                * doest add to the digit requirement.  Note that the
-                * two zeros here can only be output if the two leading
-                * zeros were *not* output, so this doesn't increase
-                * the output count.
-                */
-               while (--exp_b10 >= 0) *ascii++ = 48;
-
-               *ascii = 0;
-
-               /* Total buffer requirement (including the '\0') is
-                * 5+precision - see check at the start.
-                */
-               return;
-            }
-
-            /* Here if an exponent is required, adjust size for
-             * the digits we output but did not count.  The total
-             * digit output here so far is at most 1+precision - no
-             * decimal point and no leading or trailing zeros have
-             * been output.
-             */
-            size -= cdigits;
-
-            *ascii++ = 69, --size;    /* 'E': PLUS 1 TOTAL 2+precision */
-
-            /* The following use of an unsigned temporary avoids ambiguities in
-             * the signed arithmetic on exp_b10 and permits GCC at least to do
-             * better optimization.
-             */
-            {
-               unsigned int uexp_b10;
-
-               if (exp_b10 < 0)
-               {
-                  *ascii++ = 45, --size; /* '-': PLUS 1 TOTAL 3+precision */
-                  uexp_b10 = -exp_b10;
-               }
-
-               else
-                  uexp_b10 = exp_b10;
-
-               cdigits = 0;
-
-               while (uexp_b10 > 0)
-               {
-                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);
-                  uexp_b10 /= 10;
-               }
-            }
-
-            /* Need another size check here for the exponent digits, so
-             * this need not be considered above.
-             */
-            if ((int)size > cdigits)
-            {
-               while (cdigits > 0) *ascii++ = exponent[--cdigits];
-
-               *ascii = 0;
-
-               return;
-            }
-         }
-      }
-      else if (!(fp >= DBL_MIN))
-      {
-         *ascii++ = 48; /* '0' */
-         *ascii = 0;
-         return;
-      }
-      else
-      {
-         *ascii++ = 105; /* 'i' */
-         *ascii++ = 110; /* 'n' */
-         *ascii++ = 102; /* 'f' */
-         *ascii = 0;
-         return;
-      }
-   }
-
-   /* Here on buffer too small. */
-   png_error(png_ptr, "ASCII conversion buffer too small");
-}
-
-#  endif /* FLOATING_POINT */
-
-#  ifdef PNG_FIXED_POINT_SUPPORTED
-/* Function to format a fixed point value in ASCII.
- */
-void /* PRIVATE */
-png_ascii_from_fixed(png_structp png_ptr, png_charp ascii, png_size_t size,
-    png_fixed_point fp)
-{
-   /* Require space for 10 decimal digits, a decimal point, a minus sign and a
-    * trailing \0, 13 characters:
-    */
-   if (size > 12)
-   {
-      png_uint_32 num;
-
-      /* Avoid overflow here on the minimum integer. */
-      if (fp < 0)
-         *ascii++ = 45, --size, num = -fp;
-      else
-         num = fp;
-
-      if (num <= 0x80000000) /* else overflowed */
-      {
-         unsigned int ndigits = 0, first = 16 /* flag value */;
-         char digits[10];
-
-         while (num)
-         {
-            /* Split the low digit off num: */
-            unsigned int tmp = num/10;
-            num -= tmp*10;
-            digits[ndigits++] = (char)(48 + num);
-            /* Record the first non-zero digit, note that this is a number
-             * starting at 1, it's not actually the array index.
-             */
-            if (first == 16 && num > 0)
-               first = ndigits;
-            num = tmp;
-         }
-
-         if (ndigits > 0)
-         {
-            while (ndigits > 5) *ascii++ = digits[--ndigits];
-            /* The remaining digits are fractional digits, ndigits is '5' or
-             * smaller at this point.  It is certainly not zero.  Check for a
-             * non-zero fractional digit:
-             */
-            if (first <= 5)
-            {
-               unsigned int i;
-               *ascii++ = 46; /* decimal point */
-               /* ndigits may be <5 for small numbers, output leading zeros
-                * then ndigits digits to first:
-                */
-               i = 5;
-               while (ndigits < i) *ascii++ = 48, --i;
-               while (ndigits >= first) *ascii++ = digits[--ndigits];
-               /* Don't output the trailing zeros! */
-            }
-         }
-         else
-            *ascii++ = 48;
-
-         /* And null terminate the string: */
-         *ascii = 0;
-         return;
-      }
-   }
-
-   /* Here on buffer too small. */
-   png_error(png_ptr, "ASCII conversion buffer too small");
-}
-#   endif /* FIXED_POINT */
-#endif /* READ_SCAL */
-
-#if defined(PNG_FLOATING_POINT_SUPPORTED) && \
-   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED)
-png_fixed_point
-png_fixed(png_structp png_ptr, double fp, png_const_charp text)
-{
-   double r = floor(100000 * fp + .5);
-
-   if (r > 2147483647. || r < -2147483648.)
-      png_fixed_error(png_ptr, text);
-
-   return (png_fixed_point)r;
-}
-#endif
-
-#if defined(PNG_READ_GAMMA_SUPPORTED) || \
-    defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG__READ_pHYs_SUPPORTED)
-/* muldiv functions */
-/* This API takes signed arguments and rounds the result to the nearest
- * integer (or, for a fixed point number - the standard argument - to
- * the nearest .00001).  Overflow and divide by zero are signalled in
- * the result, a boolean - true on success, false on overflow.
- */
-int
-png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,
-    png_int_32 divisor)
-{
-   /* Return a * times / divisor, rounded. */
-   if (divisor != 0)
-   {
-      if (a == 0 || times == 0)
-      {
-         *res = 0;
-         return 1;
-      }
-      else
-      {
-#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-         double r = a;
-         r *= times;
-         r /= divisor;
-         r = floor(r+.5);
-
-         /* A png_fixed_point is a 32-bit integer. */
-         if (r <= 2147483647. && r >= -2147483648.)
-         {
-            *res = (png_fixed_point)r;
-            return 1;
-         }
-#else
-         int negative = 0;
-         png_uint_32 A, T, D;
-         png_uint_32 s16, s32, s00;
-
-         if (a < 0)
-            negative = 1, A = -a;
-         else
-            A = a;
-
-         if (times < 0)
-            negative = !negative, T = -times;
-         else
-            T = times;
-
-         if (divisor < 0)
-            negative = !negative, D = -divisor;
-         else
-            D = divisor;
-
-         /* Following can't overflow because the arguments only
-          * have 31 bits each, however the result may be 32 bits.
-          */
-         s16 = (A >> 16) * (T & 0xffff) +
-                           (A & 0xffff) * (T >> 16);
-         /* Can't overflow because the a*times bit is only 30
-          * bits at most.
-          */
-         s32 = (A >> 16) * (T >> 16) + (s16 >> 16);
-         s00 = (A & 0xffff) * (T & 0xffff);
-
-         s16 = (s16 & 0xffff) << 16;
-         s00 += s16;
-
-         if (s00 < s16)
-            ++s32; /* carry */
-
-         if (s32 < D) /* else overflow */
-         {
-            /* s32.s00 is now the 64-bit product, do a standard
-             * division, we know that s32 < D, so the maximum
-             * required shift is 31.
-             */
-            int bitshift = 32;
-            png_fixed_point result = 0; /* NOTE: signed */
-
-            while (--bitshift >= 0)
-            {
-               png_uint_32 d32, d00;
-
-               if (bitshift > 0)
-                  d32 = D >> (32-bitshift), d00 = D << bitshift;
-
-               else
-                  d32 = 0, d00 = D;
-
-               if (s32 > d32)
-               {
-                  if (s00 < d00) --s32; /* carry */
-                  s32 -= d32, s00 -= d00, result += 1<<bitshift;
-               }
-
-               else
-                  if (s32 == d32 && s00 >= d00)
-                     s32 = 0, s00 -= d00, result += 1<<bitshift;
-            }
-
-            /* Handle the rounding. */
-            if (s00 >= (D >> 1))
-               ++result;
-
-            if (negative)
-               result = -result;
-
-            /* Check for overflow. */
-            if ((negative && result <= 0) || (!negative && result >= 0))
-            {
-               *res = result;
-               return 1;
-            }
-         }
-#endif
-      }
-   }
-
-   return 0;
-}
-#endif /* READ_GAMMA || INCH_CONVERSIONS */
-
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)
-/* The following is for when the caller doesn't much care about the
- * result.
- */
-png_fixed_point
-png_muldiv_warn(png_structp png_ptr, png_fixed_point a, png_int_32 times,
-    png_int_32 divisor)
-{
-   png_fixed_point result;
-
-   if (png_muldiv(&result, a, times, divisor))
-      return result;
-
-   png_warning(png_ptr, "fixed point overflow ignored");
-   return 0;
-}
-#endif
-
-#ifdef PNG_READ_GAMMA_SUPPORTED /* more fixed point functions for gammma */
-/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
-png_fixed_point
-png_reciprocal(png_fixed_point a)
-{
-#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-   double r = floor(1E10/a+.5);
-
-   if (r <= 2147483647. && r >= -2147483648.)
-      return (png_fixed_point)r;
-#else
-   png_fixed_point res;
-
-   if (png_muldiv(&res, 100000, 100000, a))
-      return res;
-#endif
-
-   return 0; /* error/overflow */
-}
-
-/* A local convenience routine. */
-static png_fixed_point
-png_product2(png_fixed_point a, png_fixed_point b)
-{
-   /* The required result is 1/a * 1/b; the following preserves accuracy. */
-#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-   double r = a * 1E-5;
-   r *= b;
-   r = floor(r+.5);
-
-   if (r <= 2147483647. && r >= -2147483648.)
-      return (png_fixed_point)r;
-#else
-   png_fixed_point res;
-
-   if (png_muldiv(&res, a, b, 100000))
-      return res;
-#endif
-
-   return 0; /* overflow */
-}
-
-/* The inverse of the above. */
-png_fixed_point
-png_reciprocal2(png_fixed_point a, png_fixed_point b)
-{
-   /* The required result is 1/a * 1/b; the following preserves accuracy. */
-#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-   double r = 1E15/a;
-   r /= b;
-   r = floor(r+.5);
-
-   if (r <= 2147483647. && r >= -2147483648.)
-      return (png_fixed_point)r;
-#else
-   /* This may overflow because the range of png_fixed_point isn't symmetric,
-    * but this API is only used for the product of file and screen gamma so it
-    * doesn't matter that the smallest number it can produce is 1/21474, not
-    * 1/100000
-    */
-   png_fixed_point res = png_product2(a, b);
-
-   if (res != 0)
-      return png_reciprocal(res);
-#endif
-
-   return 0; /* overflow */
-}
-#endif /* READ_GAMMA */
-
-#ifdef PNG_CHECK_cHRM_SUPPORTED
-/* Added at libpng version 1.2.34 (Dec 8, 2008) and 1.4.0 (Jan 2,
- * 2010: moved from pngset.c) */
-/*
- *    Multiply two 32-bit numbers, V1 and V2, using 32-bit
- *    arithmetic, to produce a 64-bit result in the HI/LO words.
- *
- *                  A B
- *                x C D
- *               ------
- *              AD || BD
- *        AC || CB || 0
- *
- *    where A and B are the high and low 16-bit words of V1,
- *    C and D are the 16-bit words of V2, AD is the product of
- *    A and D, and X || Y is (X << 16) + Y.
-*/
-
-void /* PRIVATE */
-png_64bit_product (long v1, long v2, unsigned long *hi_product,
-    unsigned long *lo_product)
-{
-   int a, b, c, d;
-   long lo, hi, x, y;
-
-   a = (v1 >> 16) & 0xffff;
-   b = v1 & 0xffff;
-   c = (v2 >> 16) & 0xffff;
-   d = v2 & 0xffff;
-
-   lo = b * d;                   /* BD */
-   x = a * d + c * b;            /* AD + CB */
-   y = ((lo >> 16) & 0xffff) + x;
-
-   lo = (lo & 0xffff) | ((y & 0xffff) << 16);
-   hi = (y >> 16) & 0xffff;
-
-   hi += a * c;                  /* AC */
-
-   *hi_product = (unsigned long)hi;
-   *lo_product = (unsigned long)lo;
-}
-#endif /* CHECK_cHRM */
-
-#ifdef PNG_READ_GAMMA_SUPPORTED /* gamma table code */
-#ifndef PNG_FLOATING_ARITHMETIC_SUPPORTED
-/* Fixed point gamma.
- *
- * To calculate gamma this code implements fast log() and exp() calls using only
- * fixed point arithmetic.  This code has sufficient precision for either 8-bit
- * or 16-bit sample values.
- *
- * The tables used here were calculated using simple 'bc' programs, but C double
- * precision floating point arithmetic would work fine.  The programs are given
- * at the head of each table.
- *
- * 8-bit log table
- *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to
- *   255, so it's the base 2 logarithm of a normalized 8-bit floating point
- *   mantissa.  The numbers are 32-bit fractions.
- */
-static png_uint_32
-png_8bit_l2[128] =
-{
-#  ifdef PNG_DO_BC
-      for (i=128;i<256;++i) { .5 - l(i/255)/l(2)*65536*65536; }
-#  else
-   4270715492U, 4222494797U, 4174646467U, 4127164793U, 4080044201U, 4033279239U,
-   3986864580U, 3940795015U, 3895065449U, 3849670902U, 3804606499U, 3759867474U,
-   3715449162U, 3671346997U, 3627556511U, 3584073329U, 3540893168U, 3498011834U,
-   3455425220U, 3413129301U, 3371120137U, 3329393864U, 3287946700U, 3246774933U,
-   3205874930U, 3165243125U, 3124876025U, 3084770202U, 3044922296U, 3005329011U,
-   2965987113U, 2926893432U, 2888044853U, 2849438323U, 2811070844U, 2772939474U,
-   2735041326U, 2697373562U, 2659933400U, 2622718104U, 2585724991U, 2548951424U,
-   2512394810U, 2476052606U, 2439922311U, 2404001468U, 2368287663U, 2332778523U,
-   2297471715U, 2262364947U, 2227455964U, 2192742551U, 2158222529U, 2123893754U,
-   2089754119U, 2055801552U, 2022034013U, 1988449497U, 1955046031U, 1921821672U,
-   1888774511U, 1855902668U, 1823204291U, 1790677560U, 1758320682U, 1726131893U,
-   1694109454U, 1662251657U, 1630556815U, 1599023271U, 1567649391U, 1536433567U,
-   1505374214U, 1474469770U, 1443718700U, 1413119487U, 1382670639U, 1352370686U,
-   1322218179U, 1292211689U, 1262349810U, 1232631153U, 1203054352U, 1173618059U,
-   1144320946U, 1115161701U, 1086139034U, 1057251672U, 1028498358U, 999877854U,
-   971388940U, 943030410U, 914801076U, 886699767U, 858725327U, 830876614U,
-   803152505U, 775551890U, 748073672U, 720716771U, 693480120U, 666362667U,
-   639363374U, 612481215U, 585715177U, 559064263U, 532527486U, 506103872U,
-   479792461U, 453592303U, 427502463U, 401522014U, 375650043U, 349885648U,
-   324227938U, 298676034U, 273229066U, 247886176U, 222646516U, 197509248U,
-   172473545U, 147538590U, 122703574U, 97967701U, 73330182U, 48790236U,
-   24347096U, 0U
-#  endif
-
-#if 0
-   /* The following are the values for 16-bit tables - these work fine for the
-    * 8-bit conversions but produce very slightly larger errors in the 16-bit
-    * log (about 1.2 as opposed to 0.7 absolute error in the final value).  To
-    * use these all the shifts below must be adjusted appropriately.
-    */
-   65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,
-   57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,
-   50170, 49542, 48918, 48298, 47682, 47070, 46462, 45858, 45257, 44661, 44068,
-   43479, 42894, 42312, 41733, 41159, 40587, 40020, 39455, 38894, 38336, 37782,
-   37230, 36682, 36137, 35595, 35057, 34521, 33988, 33459, 32932, 32408, 31887,
-   31369, 30854, 30341, 29832, 29325, 28820, 28319, 27820, 27324, 26830, 26339,
-   25850, 25364, 24880, 24399, 23920, 23444, 22970, 22499, 22029, 21562, 21098,
-   20636, 20175, 19718, 19262, 18808, 18357, 17908, 17461, 17016, 16573, 16132,
-   15694, 15257, 14822, 14390, 13959, 13530, 13103, 12678, 12255, 11834, 11415,
-   10997, 10582, 10168, 9756, 9346, 8937, 8531, 8126, 7723, 7321, 6921, 6523,
-   6127, 5732, 5339, 4947, 4557, 4169, 3782, 3397, 3014, 2632, 2251, 1872, 1495,
-   1119, 744, 372
-#endif
-};
-
-PNG_STATIC png_int_32
-png_log8bit(unsigned int x)
-{
-   unsigned int lg2 = 0;
-   /* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,
-    * because the log is actually negate that means adding 1.  The final
-    * returned value thus has the range 0 (for 255 input) to 7.994 (for 1
-    * input), return 7.99998 for the overflow (log 0) case - so the result is
-    * always at most 19 bits.
-    */
-   if ((x &= 0xff) == 0)
-      return 0xffffffff;
-
-   if ((x & 0xf0) == 0)
-      lg2  = 4, x <<= 4;
-
-   if ((x & 0xc0) == 0)
-      lg2 += 2, x <<= 2;
-
-   if ((x & 0x80) == 0)
-      lg2 += 1, x <<= 1;
-
-   /* result is at most 19 bits, so this cast is safe: */
-   return (png_int_32)((lg2 << 16) + ((png_8bit_l2[x-128]+32768)>>16));
-}
-
-/* The above gives exact (to 16 binary places) log2 values for 8-bit images,
- * for 16-bit images we use the most significant 8 bits of the 16-bit value to
- * get an approximation then multiply the approximation by a correction factor
- * determined by the remaining up to 8 bits.  This requires an additional step
- * in the 16-bit case.
- *
- * We want log2(value/65535), we have log2(v'/255), where:
- *
- *    value = v' * 256 + v''
- *          = v' * f
- *
- * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128
- * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less
- * than 258.  The final factor also needs to correct for the fact that our 8-bit
- * value is scaled by 255, whereas the 16-bit values must be scaled by 65535.
- *
- * This gives a final formula using a calculated value 'x' which is value/v' and
- * scaling by 65536 to match the above table:
- *
- *   log2(x/257) * 65536
- *
- * Since these numbers are so close to '1' we can use simple linear
- * interpolation between the two end values 256/257 (result -368.61) and 258/257
- * (result 367.179).  The values used below are scaled by a further 64 to give
- * 16-bit precision in the interpolation:
- *
- * Start (256): -23591
- * Zero  (257):      0
- * End   (258):  23499
- */
-PNG_STATIC png_int_32
-png_log16bit(png_uint_32 x)
-{
-   unsigned int lg2 = 0;
-
-   /* As above, but now the input has 16 bits. */
-   if ((x &= 0xffff) == 0)
-      return 0xffffffff;
-
-   if ((x & 0xff00) == 0)
-      lg2  = 8, x <<= 8;
-
-   if ((x & 0xf000) == 0)
-      lg2 += 4, x <<= 4;
-
-   if ((x & 0xc000) == 0)
-      lg2 += 2, x <<= 2;
-
-   if ((x & 0x8000) == 0)
-      lg2 += 1, x <<= 1;
-
-   /* Calculate the base logarithm from the top 8 bits as a 28-bit fractional
-    * value.
-    */
-   lg2 <<= 28;
-   lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;
-
-   /* Now we need to interpolate the factor, this requires a division by the top
-    * 8 bits.  Do this with maximum precision.
-    */
-   x = ((x << 16) + (x >> 9)) / (x >> 8);
-
-   /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,
-    * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly
-    * 16 bits to interpolate to get the low bits of the result.  Round the
-    * answer.  Note that the end point values are scaled by 64 to retain overall
-    * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust
-    * the overall scaling by 6-12.  Round at every step.
-    */
-   x -= 1U << 24;
-
-   if (x <= 65536U) /* <= '257' */
-      lg2 += ((23591U * (65536U-x)) + (1U << (16+6-12-1))) >> (16+6-12);
-
-   else
-      lg2 -= ((23499U * (x-65536U)) + (1U << (16+6-12-1))) >> (16+6-12);
-
-   /* Safe, because the result can't have more than 20 bits: */
-   return (png_int_32)((lg2 + 2048) >> 12);
-}
-
-/* The 'exp()' case must invert the above, taking a 20-bit fixed point
- * logarithmic value and returning a 16 or 8-bit number as appropriate.  In
- * each case only the low 16 bits are relevant - the fraction - since the
- * integer bits (the top 4) simply determine a shift.
- *
- * The worst case is the 16-bit distinction between 65535 and 65534, this
- * requires perhaps spurious accuracy in the decoding of the logarithm to
- * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance
- * of getting this accuracy in practice.
- *
- * To deal with this the following exp() function works out the exponent of the
- * frational part of the logarithm by using an accurate 32-bit value from the
- * top four fractional bits then multiplying in the remaining bits.
- */
-static png_uint_32
-png_32bit_exp[16] =
-{
-#  ifdef PNG_DO_BC
-      for (i=0;i<16;++i) { .5 + e(-i/16*l(2))*2^32; }
-#  else
-   /* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
-   4294967295U, 4112874773U, 3938502376U, 3771522796U, 3611622603U, 3458501653U,
-   3311872529U, 3171459999U, 3037000500U, 2908241642U, 2784941738U, 2666869345U,
-   2553802834U, 2445529972U, 2341847524U, 2242560872U
-#  endif
-};
-
-/* Adjustment table; provided to explain the numbers in the code below. */
-#ifdef PNG_DO_BC
-for (i=11;i>=0;--i){ print i, " ", (1 - e(-(2^i)/65536*l(2))) * 2^(32-i), "\n"}
-   11 44937.64284865548751208448
-   10 45180.98734845585101160448
-    9 45303.31936980687359311872
-    8 45364.65110595323018870784
-    7 45395.35850361789624614912
-    6 45410.72259715102037508096
-    5 45418.40724413220722311168
-    4 45422.25021786898173001728
-    3 45424.17186732298419044352
-    2 45425.13273269940811464704
-    1 45425.61317555035558641664
-    0 45425.85339951654943850496
-#endif
-
-PNG_STATIC png_uint_32
-png_exp(png_fixed_point x)
-{
-   if (x > 0 && x <= 0xfffff) /* Else overflow or zero (underflow) */
-   {
-      /* Obtain a 4-bit approximation */
-      png_uint_32 e = png_32bit_exp[(x >> 12) & 0xf];
-
-      /* Incorporate the low 12 bits - these decrease the returned value by
-       * multiplying by a number less than 1 if the bit is set.  The multiplier
-       * is determined by the above table and the shift. Notice that the values
-       * converge on 45426 and this is used to allow linear interpolation of the
-       * low bits.
-       */
-      if (x & 0x800)
-         e -= (((e >> 16) * 44938U) +  16U) >> 5;
-
-      if (x & 0x400)
-         e -= (((e >> 16) * 45181U) +  32U) >> 6;
-
-      if (x & 0x200)
-         e -= (((e >> 16) * 45303U) +  64U) >> 7;
-
-      if (x & 0x100)
-         e -= (((e >> 16) * 45365U) + 128U) >> 8;
-
-      if (x & 0x080)
-         e -= (((e >> 16) * 45395U) + 256U) >> 9;
-
-      if (x & 0x040)
-         e -= (((e >> 16) * 45410U) + 512U) >> 10;
-
-      /* And handle the low 6 bits in a single block. */
-      e -= (((e >> 16) * 355U * (x & 0x3fU)) + 256U) >> 9;
-
-      /* Handle the upper bits of x. */
-      e >>= x >> 16;
-      return e;
-   }
-
-   /* Check for overflow */
-   if (x <= 0)
-      return png_32bit_exp[0];
-
-   /* Else underflow */
-   return 0;
-}
-
-PNG_STATIC png_byte
-png_exp8bit(png_fixed_point lg2)
-{
-   /* Get a 32-bit value: */
-   png_uint_32 x = png_exp(lg2);
-
-   /* Convert the 32-bit value to 0..255 by multiplying by 256-1, note that the
-    * second, rounding, step can't overflow because of the first, subtraction,
-    * step.
-    */
-   x -= x >> 8;
-   return (png_byte)((x + 0x7fffffU) >> 24);
-}
-
-PNG_STATIC png_uint_16
-png_exp16bit(png_fixed_point lg2)
-{
-   /* Get a 32-bit value: */
-   png_uint_32 x = png_exp(lg2);
-
-   /* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
-   x -= x >> 16;
-   return (png_uint_16)((x + 32767U) >> 16);
-}
-#endif /* FLOATING_ARITHMETIC */
-
-png_byte
-png_gamma_8bit_correct(unsigned int value, png_fixed_point gamma_val)
-{
-   if (value > 0 && value < 255)
-   {
-#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-         double r = floor(255*pow(value/255.,gamma_val*.00001)+.5);
-         return (png_byte)r;
-#     else
-         png_int_32 lg2 = png_log8bit(value);
-         png_fixed_point res;
-
-         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1))
-            return png_exp8bit(res);
-
-         /* Overflow. */
-         value = 0;
-#     endif
-   }
-
-   return (png_byte)value;
-}
-
-png_uint_16
-png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
-{
-   if (value > 0 && value < 65535)
-   {
-#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-         double r = floor(65535*pow(value/65535.,gamma_val*.00001)+.5);
-         return (png_uint_16)r;
-#     else
-         png_int_32 lg2 = png_log16bit(value);
-         png_fixed_point res;
-
-         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1))
-            return png_exp16bit(res);
-
-         /* Overflow. */
-         value = 0;
-#     endif
-   }
-
-   return (png_uint_16)value;
-}
-
-/* This does the right thing based on the bit_depth field of the
- * png_struct, interpreting values as 8-bit or 16-bit.  While the result
- * is nominally a 16-bit value if bit depth is 8 then the result is
- * 8-bit (as are the arguments.)
- */
-png_uint_16 /* PRIVATE */
-png_gamma_correct(png_structp png_ptr, unsigned int value,
-    png_fixed_point gamma_val)
-{
-   if (png_ptr->bit_depth == 8)
-      return png_gamma_8bit_correct(value, gamma_val);
-
-   else
-      return png_gamma_16bit_correct(value, gamma_val);
-}
-
-/* This is the shared test on whether a gamma value is 'significant' - whether
- * it is worth doing gamma correction.
- */
-int /* PRIVATE */
-png_gamma_significant(png_fixed_point gamma_val)
-{
-   return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
-       gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
-}
-
-/* Internal function to build a single 16-bit table - the table consists of
- * 'num' 256-entry subtables, where 'num' is determined by 'shift' - the amount
- * to shift the input values right (or 16-number_of_signifiant_bits).
- *
- * The caller is responsible for ensuring that the table gets cleaned up on
- * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument
- * should be somewhere that will be cleaned.
- */
-static void
-png_build_16bit_table(png_structp png_ptr, png_uint_16pp *ptable,
-   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
-{
-   /* Various values derived from 'shift': */
-   PNG_CONST unsigned int num = 1U << (8U - shift);
-   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
-   PNG_CONST unsigned int max_by_2 = 1U << (15U-shift);
-   unsigned int i;
-
-   png_uint_16pp table = *ptable =
-       (png_uint_16pp)png_calloc(png_ptr, num * png_sizeof(png_uint_16p));
-
-   for (i = 0; i < num; i++)
-   {
-      png_uint_16p sub_table = table[i] =
-          (png_uint_16p)png_malloc(png_ptr, 256 * png_sizeof(png_uint_16));
-
-      /* The 'threshold' test is repeated here because it can arise for one of
-       * the 16-bit tables even if the others don't hit it.
-       */
-      if (png_gamma_significant(gamma_val))
-      {
-         /* The old code would overflow at the end and this would cause the
-          * 'pow' function to return a result >1, resulting in an
-          * arithmetic error.  This code follows the spec exactly; ig is
-          * the recovered input sample, it always has 8-16 bits.
-          *
-          * We want input * 65535/max, rounded, the arithmetic fits in 32
-          * bits (unsigned) so long as max <= 32767.
-          */
-         unsigned int j;
-         for (j = 0; j < 256; j++)
-         {
-            png_uint_32 ig = (j << (8-shift)) + i;
-#           ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
-               /* Inline the 'max' scaling operation: */
-               double d = floor(65535*pow(ig/(double)max, gamma_val*.00001)+.5);
-               sub_table[j] = (png_uint_16)d;
-#           else
-               if (shift)
-                  ig = (ig * 65535U + max_by_2)/max;
-
-               sub_table[j] = png_gamma_16bit_correct(ig, gamma_val);
-#           endif
-         }
-      }
-      else
-      {
-         /* We must still build a table, but do it the fast way. */
-         unsigned int j;
-
-         for (j = 0; j < 256; j++)
-         {
-            png_uint_32 ig = (j << (8-shift)) + i;
-
-            if (shift)
-               ig = (ig * 65535U + max_by_2)/max;
-
-            sub_table[j] = (png_uint_16)ig;
-         }
-      }
-   }
-}
-
-/* NOTE: this function expects the *inverse* of the overall gamma transformation
- * required.
- */
-static void
-png_build_16to8_table(png_structp png_ptr, png_uint_16pp *ptable,
-   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
-{
-   PNG_CONST unsigned int num = 1U << (8U - shift);
-   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
-   unsigned int i;
-   png_uint_32 last;
-
-   png_uint_16pp table = *ptable =
-       (png_uint_16pp)png_calloc(png_ptr, num * png_sizeof(png_uint_16p));
-
-   /* 'num' is the number of tables and also the number of low bits of the
-    * input 16-bit value used to select a table.  Each table is itself indexed
-    * by the high 8 bits of the value.
-    */
-   for (i = 0; i < num; i++)
-      table[i] = (png_uint_16p)png_malloc(png_ptr,
-          256 * png_sizeof(png_uint_16));
-
-   /* 'gamma_val' is set to the reciprocal of the value calculated above, so
-    * pow(out,g) is an *input* value.  'last' is the last input value set.
-    *
-    * In the loop 'i' is used to find output values.  Since the output is
-    * 8-bit there are only 256 possible values.  The tables are set up to
-    * select the closest possible output value for each input by finding
-    * the input value at the boundary between each pair of output values
-    * and filling the table up to that boundary with the lower output
-    * value.
-    *
-    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit
-    * values the code below uses a 16-bit value in i; the values start at
-    * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last
-    * entries are filled with 255).  Start i at 128 and fill all 'last'
-    * table entries <= 'max'
-    */
-   last = 0;
-   for (i = 0; i < 255; ++i) /* 8-bit output value */
-   {
-      /* Find the corresponding maximum input value */
-      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */
-
-      /* Find the boundary value in 16 bits: */
-      png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);
-
-      /* Adjust (round) to (16-shift) bits: */
-      bound = (bound * max + 32768U)/65535U + 1U;
-
-      while (last < bound)
-      {
-         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;
-         last++;
-      }
-   }
-
-   /* And fill in the final entries. */
-   while (last < (num << 8))
-   {
-      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;
-      last++;
-   }
-}
-
-/* Build a single 8-bit table: same as the 16-bit case but much simpler (and
- * typically much faster).  Note that libpng currently does no sBIT processing
- * (apparently contrary to the spec) so a 256-entry table is always generated.
- */
-static void
-png_build_8bit_table(png_structp png_ptr, png_bytepp ptable,
-   PNG_CONST png_fixed_point gamma_val)
-{
-   unsigned int i;
-   png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);
-
-   if (png_gamma_significant(gamma_val)) for (i=0; i<256; i++)
-      table[i] = png_gamma_8bit_correct(i, gamma_val);
-
-   else for (i=0; i<256; ++i)
-      table[i] = (png_byte)i;
-}
-
-/* Used from png_read_destroy and below to release the memory used by the gamma
- * tables.
- */
-void /* PRIVATE */
-png_destroy_gamma_table(png_structp png_ptr)
-{
-   png_free(png_ptr, png_ptr->gamma_table);
-   png_ptr->gamma_table = NULL;
-
-   if (png_ptr->gamma_16_table != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_table[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_table);
-   png_ptr->gamma_16_table = NULL;
-   }
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-   png_free(png_ptr, png_ptr->gamma_from_1);
-   png_ptr->gamma_from_1 = NULL;
-   png_free(png_ptr, png_ptr->gamma_to_1);
-   png_ptr->gamma_to_1 = NULL;
-
-   if (png_ptr->gamma_16_from_1 != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_from_1);
-   png_ptr->gamma_16_from_1 = NULL;
-   }
-   if (png_ptr->gamma_16_to_1 != NULL)
-   {
-      int i;
-      int istop = (1 << (8 - png_ptr->gamma_shift));
-      for (i = 0; i < istop; i++)
-      {
-         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
-      }
-   png_free(png_ptr, png_ptr->gamma_16_to_1);
-   png_ptr->gamma_16_to_1 = NULL;
-   }
-#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
-}
-
-/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
- * tables, we don't make a full table if we are reducing to 8-bit in
- * the future.  Note also how the gamma_16 tables are segmented so that
- * we don't need to allocate > 64K chunks for a full 16-bit table.
- */
-void /* PRIVATE */
-png_build_gamma_table(png_structp png_ptr, int bit_depth)
-{
-  png_debug(1, "in png_build_gamma_table");
-
-  /* Remove any existing table; this copes with multiple calls to
-   * png_read_update_info.  The warning is because building the gamma tables
-   * multiple times is a performance hit - it's harmless but the ability to call
-   * png_read_update_info() multiple times is new in 1.5.6 so it seems sensible
-   * to warn if the app introduces such a hit.
-   */
-  if (png_ptr->gamma_table != NULL || png_ptr->gamma_16_table != NULL)
-  {
-    png_warning(png_ptr, "gamma table being rebuilt");
-    png_destroy_gamma_table(png_ptr);
-  }
-
-  if (bit_depth <= 8)
-  {
-     png_build_8bit_table(png_ptr, &png_ptr->gamma_table,
-         png_ptr->screen_gamma > 0 ?  png_reciprocal2(png_ptr->gamma,
-         png_ptr->screen_gamma) : PNG_FP_1);
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))
-     {
-        png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1,
-            png_reciprocal(png_ptr->gamma));
-
-        png_build_8bit_table(png_ptr, &png_ptr->gamma_from_1,
-            png_ptr->screen_gamma > 0 ?  png_reciprocal(png_ptr->screen_gamma) :
-            png_ptr->gamma/* Probably doing rgb_to_gray */);
-     }
-#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
-  }
-  else
-  {
-     png_byte shift, sig_bit;
-
-     if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
-     {
-        sig_bit = png_ptr->sig_bit.red;
-
-        if (png_ptr->sig_bit.green > sig_bit)
-           sig_bit = png_ptr->sig_bit.green;
-
-        if (png_ptr->sig_bit.blue > sig_bit)
-           sig_bit = png_ptr->sig_bit.blue;
-     }
-     else
-        sig_bit = png_ptr->sig_bit.gray;
-
-     /* 16-bit gamma code uses this equation:
-      *
-      *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]
-      *
-      * Where 'iv' is the input color value and 'ov' is the output value -
-      * pow(iv, gamma).
-      *
-      * Thus the gamma table consists of up to 256 256-entry tables.  The table
-      * is selected by the (8-gamma_shift) most significant of the low 8 bits of
-      * the color value then indexed by the upper 8 bits:
-      *
-      *   table[low bits][high 8 bits]
-      *
-      * So the table 'n' corresponds to all those 'iv' of:
-      *
-      *   <all high 8-bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>
-      *
-      */
-     if (sig_bit > 0 && sig_bit < 16U)
-        shift = (png_byte)(16U - sig_bit); /* shift == insignificant bits */
-
-     else
-        shift = 0; /* keep all 16 bits */
-
-     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))
-     {
-        /* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively
-         * the significant bits in the *input* when the output will
-         * eventually be 8 bits.  By default it is 11.
-         */
-        if (shift < (16U - PNG_MAX_GAMMA_8))
-           shift = (16U - PNG_MAX_GAMMA_8);
-     }
-
-     if (shift > 8U)
-        shift = 8U; /* Guarantees at least one table! */
-
-     png_ptr->gamma_shift = shift;
-
-#ifdef PNG_16BIT_SUPPORTED
-     /* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now
-      * PNG_COMPOSE).  This effectively smashed the background calculation for
-      * 16-bit output because the 8-bit table assumes the result will be reduced
-      * to 8 bits.
-      */
-     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))
-#endif
-         png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,
-         png_ptr->screen_gamma > 0 ? png_product2(png_ptr->gamma,
-         png_ptr->screen_gamma) : PNG_FP_1);
-
-#ifdef PNG_16BIT_SUPPORTED
-     else
-         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,
-         png_ptr->screen_gamma > 0 ? png_reciprocal2(png_ptr->gamma,
-         png_ptr->screen_gamma) : PNG_FP_1);
-#endif
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
-   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
-     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))
-     {
-        png_build_16bit_table(png_ptr, &png_ptr->gamma_16_to_1, shift,
-            png_reciprocal(png_ptr->gamma));
-
-        /* Notice that the '16 from 1' table should be full precision, however
-         * the lookup on this table still uses gamma_shift, so it can't be.
-         * TODO: fix this.
-         */
-        png_build_16bit_table(png_ptr, &png_ptr->gamma_16_from_1, shift,
-            png_ptr->screen_gamma > 0 ? png_reciprocal(png_ptr->screen_gamma) :
-            png_ptr->gamma/* Probably doing rgb_to_gray */);
-     }
-#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
-  }
-}
-#endif /* READ_GAMMA */
-#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
+
+/* png.c - location for general purpose libpng functions
+ *
+ * Last changed in libpng 1.5.11 [June 14, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#include "pngpriv.h"
+
+/* Generate a compiler error if there is an old png.h in the search path. */
+typedef png_libpng_version_1_5_12 Your_png_h_is_not_version_1_5_12;
+
+/* Tells libpng that we have already handled the first "num_bytes" bytes
+ * of the PNG file signature.  If the PNG data is embedded into another
+ * stream we can set num_bytes = 8 so that libpng will not attempt to read
+ * or write any of the magic bytes before it starts on the IHDR.
+ */
+
+#ifdef PNG_READ_SUPPORTED
+void PNGAPI
+png_set_sig_bytes(png_structp png_ptr, int num_bytes)
+{
+   png_debug(1, "in png_set_sig_bytes");
+
+   if (png_ptr == NULL)
+      return;
+
+   if (num_bytes > 8)
+      png_error(png_ptr, "Too many bytes for PNG signature");
+
+   png_ptr->sig_bytes = (png_byte)(num_bytes < 0 ? 0 : num_bytes);
+}
+
+/* Checks whether the supplied bytes match the PNG signature.  We allow
+ * checking less than the full 8-byte signature so that those apps that
+ * already read the first few bytes of a file to determine the file type
+ * can simply check the remaining bytes for extra assurance.  Returns
+ * an integer less than, equal to, or greater than zero if sig is found,
+ * respectively, to be less than, to match, or be greater than the correct
+ * PNG signature (this is the same behavior as strcmp, memcmp, etc).
+ */
+int PNGAPI
+png_sig_cmp(png_const_bytep sig, png_size_t start, png_size_t num_to_check)
+{
+   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
+
+   if (num_to_check > 8)
+      num_to_check = 8;
+
+   else if (num_to_check < 1)
+      return (-1);
+
+   if (start > 7)
+      return (-1);
+
+   if (start + num_to_check > 8)
+      num_to_check = 8 - start;
+
+   return ((int)(png_memcmp(&sig[start], &png_signature[start], num_to_check)));
+}
+
+#endif /* PNG_READ_SUPPORTED */
+
+#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+/* Function to allocate memory for zlib */
+PNG_FUNCTION(voidpf /* PRIVATE */,
+png_zalloc,(voidpf png_ptr, uInt items, uInt size),PNG_ALLOCATED)
+{
+   png_voidp ptr;
+   png_structp p=(png_structp)png_ptr;
+   png_uint_32 save_flags=p->flags;
+   png_alloc_size_t num_bytes;
+
+   if (png_ptr == NULL)
+      return (NULL);
+
+   if (items > PNG_UINT_32_MAX/size)
+   {
+     png_warning (p, "Potential overflow in png_zalloc()");
+     return (NULL);
+   }
+   num_bytes = (png_alloc_size_t)items * size;
+
+   p->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
+   ptr = (png_voidp)png_malloc((png_structp)png_ptr, num_bytes);
+   p->flags=save_flags;
+
+   return ((voidpf)ptr);
+}
+
+/* Function to free memory for zlib */
+void /* PRIVATE */
+png_zfree(voidpf png_ptr, voidpf ptr)
+{
+   png_free((png_structp)png_ptr, (png_voidp)ptr);
+}
+
+/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
+ * in case CRC is > 32 bits to leave the top bits 0.
+ */
+void /* PRIVATE */
+png_reset_crc(png_structp png_ptr)
+{
+   /* The cast is safe because the crc is a 32 bit value. */
+   png_ptr->crc = (png_uint_32)crc32(0, Z_NULL, 0);
+}
+
+/* Calculate the CRC over a section of data.  We can only pass as
+ * much data to this routine as the largest single buffer size.  We
+ * also check that this data will actually be used before going to the
+ * trouble of calculating it.
+ */
+void /* PRIVATE */
+png_calculate_crc(png_structp png_ptr, png_const_bytep ptr, png_size_t length)
+{
+   int need_crc = 1;
+
+   if (PNG_CHUNK_ANCILLIARY(png_ptr->chunk_name))
+   {
+      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
+          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
+         need_crc = 0;
+   }
+
+   else /* critical */
+   {
+      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
+         need_crc = 0;
+   }
+
+   /* 'uLong' is defined as unsigned long, this means that on some systems it is
+    * a 64 bit value.  crc32, however, returns 32 bits so the following cast is
+    * safe.  'uInt' may be no more than 16 bits, so it is necessary to perform a
+    * loop here.
+    */
+   if (need_crc && length > 0)
+   {
+      uLong crc = png_ptr->crc; /* Should never issue a warning */
+
+      do
+      {
+         uInt safeLength = (uInt)length;
+         if (safeLength == 0)
+            safeLength = (uInt)-1; /* evil, but safe */
+
+         crc = crc32(crc, ptr, safeLength);
+
+         /* The following should never issue compiler warnings, if they do the
+          * target system has characteristics that will probably violate other
+          * assumptions within the libpng code.
+          */
+         ptr += safeLength;
+         length -= safeLength;
+      }
+      while (length > 0);
+
+      /* And the following is always safe because the crc is only 32 bits. */
+      png_ptr->crc = (png_uint_32)crc;
+   }
+}
+
+/* Check a user supplied version number, called from both read and write
+ * functions that create a png_struct
+ */
+int
+png_user_version_check(png_structp png_ptr, png_const_charp user_png_ver)
+{
+   if (user_png_ver)
+   {
+      int i = 0;
+
+      do
+      {
+         if (user_png_ver[i] != png_libpng_ver[i])
+            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+      } while (png_libpng_ver[i++]);
+   }
+
+   else
+      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
+
+   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
+   {
+     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
+      * we must recompile any applications that use any older library version.
+      * For versions after libpng 1.0, we will be compatible, so we need
+      * only check the first digit.
+      */
+      if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
+          (user_png_ver[0] == '1' && user_png_ver[2] != png_libpng_ver[2]) ||
+          (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
+      {
+#ifdef PNG_WARNINGS_SUPPORTED
+         size_t pos = 0;
+         char m[128];
+
+         pos = png_safecat(m, sizeof m, pos, "Application built with libpng-");
+         pos = png_safecat(m, sizeof m, pos, user_png_ver);
+         pos = png_safecat(m, sizeof m, pos, " but running with ");
+         pos = png_safecat(m, sizeof m, pos, png_libpng_ver);
+
+         png_warning(png_ptr, m);
+#endif
+
+#ifdef PNG_ERROR_NUMBERS_SUPPORTED
+         png_ptr->flags = 0;
+#endif
+
+         return 0;
+      }
+   }
+
+   /* Success return. */
+   return 1;
+}
+
+/* Allocate the memory for an info_struct for the application.  We don't
+ * really need the png_ptr, but it could potentially be useful in the
+ * future.  This should be used in favour of malloc(png_sizeof(png_info))
+ * and png_info_init() so that applications that want to use a shared
+ * libpng don't have to be recompiled if png_info changes size.
+ */
+PNG_FUNCTION(png_infop,PNGAPI
+png_create_info_struct,(png_structp png_ptr),PNG_ALLOCATED)
+{
+   png_infop info_ptr;
+
+   png_debug(1, "in png_create_info_struct");
+
+   if (png_ptr == NULL)
+      return (NULL);
+
+#ifdef PNG_USER_MEM_SUPPORTED
+   info_ptr = (png_infop)png_create_struct_2(PNG_STRUCT_INFO,
+      png_ptr->malloc_fn, png_ptr->mem_ptr);
+#else
+   info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
+#endif
+   if (info_ptr != NULL)
+      png_info_init_3(&info_ptr, png_sizeof(png_info));
+
+   return (info_ptr);
+}
+
+/* This function frees the memory associated with a single info struct.
+ * Normally, one would use either png_destroy_read_struct() or
+ * png_destroy_write_struct() to free an info struct, but this may be
+ * useful for some applications.
+ */
+void PNGAPI
+png_destroy_info_struct(png_structp png_ptr, png_infopp info_ptr_ptr)
+{
+   png_infop info_ptr = NULL;
+
+   png_debug(1, "in png_destroy_info_struct");
+
+   if (png_ptr == NULL)
+      return;
+
+   if (info_ptr_ptr != NULL)
+      info_ptr = *info_ptr_ptr;
+
+   if (info_ptr != NULL)
+   {
+      png_info_destroy(png_ptr, info_ptr);
+
+#ifdef PNG_USER_MEM_SUPPORTED
+      png_destroy_struct_2((png_voidp)info_ptr, png_ptr->free_fn,
+          png_ptr->mem_ptr);
+#else
+      png_destroy_struct((png_voidp)info_ptr);
+#endif
+      *info_ptr_ptr = NULL;
+   }
+}
+
+/* Initialize the info structure.  This is now an internal function (0.89)
+ * and applications using it are urged to use png_create_info_struct()
+ * instead.
+ */
+
+void PNGAPI
+png_info_init_3(png_infopp ptr_ptr, png_size_t png_info_struct_size)
+{
+   png_infop info_ptr = *ptr_ptr;
+
+   png_debug(1, "in png_info_init_3");
+
+   if (info_ptr == NULL)
+      return;
+
+   if (png_sizeof(png_info) > png_info_struct_size)
+   {
+      png_destroy_struct(info_ptr);
+      info_ptr = (png_infop)png_create_struct(PNG_STRUCT_INFO);
+      *ptr_ptr = info_ptr;
+   }
+
+   /* Set everything to 0 */
+   png_memset(info_ptr, 0, png_sizeof(png_info));
+}
+
+void PNGAPI
+png_data_freer(png_structp png_ptr, png_infop info_ptr,
+   int freer, png_uint_32 mask)
+{
+   png_debug(1, "in png_data_freer");
+
+   if (png_ptr == NULL || info_ptr == NULL)
+      return;
+
+   if (freer == PNG_DESTROY_WILL_FREE_DATA)
+      info_ptr->free_me |= mask;
+
+   else if (freer == PNG_USER_WILL_FREE_DATA)
+      info_ptr->free_me &= ~mask;
+
+   else
+      png_warning(png_ptr,
+         "Unknown freer parameter in png_data_freer");
+}
+
+void PNGAPI
+png_free_data(png_structp png_ptr, png_infop info_ptr, png_uint_32 mask,
+   int num)
+{
+   png_debug(1, "in png_free_data");
+
+   if (png_ptr == NULL || info_ptr == NULL)
+      return;
+
+#ifdef PNG_TEXT_SUPPORTED
+   /* Free text item num or (if num == -1) all text items */
+   if ((mask & PNG_FREE_TEXT) & info_ptr->free_me)
+   {
+      if (num != -1)
+      {
+         if (info_ptr->text && info_ptr->text[num].key)
+         {
+            png_free(png_ptr, info_ptr->text[num].key);
+            info_ptr->text[num].key = NULL;
+         }
+      }
+
+      else
+      {
+         int i;
+         for (i = 0; i < info_ptr->num_text; i++)
+             png_free_data(png_ptr, info_ptr, PNG_FREE_TEXT, i);
+         png_free(png_ptr, info_ptr->text);
+         info_ptr->text = NULL;
+         info_ptr->num_text=0;
+      }
+   }
+#endif
+
+#ifdef PNG_tRNS_SUPPORTED
+   /* Free any tRNS entry */
+   if ((mask & PNG_FREE_TRNS) & info_ptr->free_me)
+   {
+      png_free(png_ptr, info_ptr->trans_alpha);
+      info_ptr->trans_alpha = NULL;
+      info_ptr->valid &= ~PNG_INFO_tRNS;
+   }
+#endif
+
+#ifdef PNG_sCAL_SUPPORTED
+   /* Free any sCAL entry */
+   if ((mask & PNG_FREE_SCAL) & info_ptr->free_me)
+   {
+      png_free(png_ptr, info_ptr->scal_s_width);
+      png_free(png_ptr, info_ptr->scal_s_height);
+      info_ptr->scal_s_width = NULL;
+      info_ptr->scal_s_height = NULL;
+      info_ptr->valid &= ~PNG_INFO_sCAL;
+   }
+#endif
+
+#ifdef PNG_pCAL_SUPPORTED
+   /* Free any pCAL entry */
+   if ((mask & PNG_FREE_PCAL) & info_ptr->free_me)
+   {
+      png_free(png_ptr, info_ptr->pcal_purpose);
+      png_free(png_ptr, info_ptr->pcal_units);
+      info_ptr->pcal_purpose = NULL;
+      info_ptr->pcal_units = NULL;
+      if (info_ptr->pcal_params != NULL)
+         {
+            int i;
+            for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
+            {
+               png_free(png_ptr, info_ptr->pcal_params[i]);
+               info_ptr->pcal_params[i] = NULL;
+            }
+            png_free(png_ptr, info_ptr->pcal_params);
+            info_ptr->pcal_params = NULL;
+         }
+      info_ptr->valid &= ~PNG_INFO_pCAL;
+   }
+#endif
+
+#ifdef PNG_iCCP_SUPPORTED
+   /* Free any iCCP entry */
+   if ((mask & PNG_FREE_ICCP) & info_ptr->free_me)
+   {
+      png_free(png_ptr, info_ptr->iccp_name);
+      png_free(png_ptr, info_ptr->iccp_profile);
+      info_ptr->iccp_name = NULL;
+      info_ptr->iccp_profile = NULL;
+      info_ptr->valid &= ~PNG_INFO_iCCP;
+   }
+#endif
+
+#ifdef PNG_sPLT_SUPPORTED
+   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
+   if ((mask & PNG_FREE_SPLT) & info_ptr->free_me)
+   {
+      if (num != -1)
+      {
+         if (info_ptr->splt_palettes)
+         {
+            png_free(png_ptr, info_ptr->splt_palettes[num].name);
+            png_free(png_ptr, info_ptr->splt_palettes[num].entries);
+            info_ptr->splt_palettes[num].name = NULL;
+            info_ptr->splt_palettes[num].entries = NULL;
+         }
+      }
+
+      else
+      {
+         if (info_ptr->splt_palettes_num)
+         {
+            int i;
+            for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
+               png_free_data(png_ptr, info_ptr, PNG_FREE_SPLT, i);
+
+            png_free(png_ptr, info_ptr->splt_palettes);
+            info_ptr->splt_palettes = NULL;
+            info_ptr->splt_palettes_num = 0;
+         }
+         info_ptr->valid &= ~PNG_INFO_sPLT;
+      }
+   }
+#endif
+
+#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
+   if (png_ptr->unknown_chunk.data)
+   {
+      png_free(png_ptr, png_ptr->unknown_chunk.data);
+      png_ptr->unknown_chunk.data = NULL;
+   }
+
+   if ((mask & PNG_FREE_UNKN) & info_ptr->free_me)
+   {
+      if (num != -1)
+      {
+          if (info_ptr->unknown_chunks)
+          {
+             png_free(png_ptr, info_ptr->unknown_chunks[num].data);
+             info_ptr->unknown_chunks[num].data = NULL;
+          }
+      }
+
+      else
+      {
+         int i;
+
+         if (info_ptr->unknown_chunks_num)
+         {
+            for (i = 0; i < info_ptr->unknown_chunks_num; i++)
+               png_free_data(png_ptr, info_ptr, PNG_FREE_UNKN, i);
+
+            png_free(png_ptr, info_ptr->unknown_chunks);
+            info_ptr->unknown_chunks = NULL;
+            info_ptr->unknown_chunks_num = 0;
+         }
+      }
+   }
+#endif
+
+#ifdef PNG_hIST_SUPPORTED
+   /* Free any hIST entry */
+   if ((mask & PNG_FREE_HIST)  & info_ptr->free_me)
+   {
+      png_free(png_ptr, info_ptr->hist);
+      info_ptr->hist = NULL;
+      info_ptr->valid &= ~PNG_INFO_hIST;
+   }
+#endif
+
+   /* Free any PLTE entry that was internally allocated */
+   if ((mask & PNG_FREE_PLTE) & info_ptr->free_me)
+   {
+      png_zfree(png_ptr, info_ptr->palette);
+      info_ptr->palette = NULL;
+      info_ptr->valid &= ~PNG_INFO_PLTE;
+      info_ptr->num_palette = 0;
+   }
+
+#ifdef PNG_INFO_IMAGE_SUPPORTED
+   /* Free any image bits attached to the info structure */
+   if ((mask & PNG_FREE_ROWS) & info_ptr->free_me)
+   {
+      if (info_ptr->row_pointers)
+      {
+         int row;
+         for (row = 0; row < (int)info_ptr->height; row++)
+         {
+            png_free(png_ptr, info_ptr->row_pointers[row]);
+            info_ptr->row_pointers[row] = NULL;
+         }
+         png_free(png_ptr, info_ptr->row_pointers);
+         info_ptr->row_pointers = NULL;
+      }
+      info_ptr->valid &= ~PNG_INFO_IDAT;
+   }
+#endif
+
+   if (num != -1)
+      mask &= ~PNG_FREE_MUL;
+
+   info_ptr->free_me &= ~mask;
+}
+
+/* This is an internal routine to free any memory that the info struct is
+ * pointing to before re-using it or freeing the struct itself.  Recall
+ * that png_free() checks for NULL pointers for us.
+ */
+void /* PRIVATE */
+png_info_destroy(png_structp png_ptr, png_infop info_ptr)
+{
+   png_debug(1, "in png_info_destroy");
+
+   png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
+
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+   if (png_ptr->num_chunk_list)
+   {
+      png_free(png_ptr, png_ptr->chunk_list);
+      png_ptr->chunk_list = NULL;
+      png_ptr->num_chunk_list = 0;
+   }
+#endif
+
+   png_info_init_3(&info_ptr, png_sizeof(png_info));
+}
+#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
+
+/* This function returns a pointer to the io_ptr associated with the user
+ * functions.  The application should free any memory associated with this
+ * pointer before png_write_destroy() or png_read_destroy() are called.
+ */
+png_voidp PNGAPI
+png_get_io_ptr(png_structp png_ptr)
+{
+   if (png_ptr == NULL)
+      return (NULL);
+
+   return (png_ptr->io_ptr);
+}
+
+#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+#  ifdef PNG_STDIO_SUPPORTED
+/* Initialize the default input/output functions for the PNG file.  If you
+ * use your own read or write routines, you can call either png_set_read_fn()
+ * or png_set_write_fn() instead of png_init_io().  If you have defined
+ * PNG_NO_STDIO or otherwise disabled PNG_STDIO_SUPPORTED, you must use a
+ * function of your own because "FILE *" isn't necessarily available.
+ */
+void PNGAPI
+png_init_io(png_structp png_ptr, png_FILE_p fp)
+{
+   png_debug(1, "in png_init_io");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->io_ptr = (png_voidp)fp;
+}
+#  endif
+
+#  ifdef PNG_TIME_RFC1123_SUPPORTED
+/* Convert the supplied time into an RFC 1123 string suitable for use in
+ * a "Creation Time" or other text-based time string.
+ */
+png_const_charp PNGAPI
+png_convert_to_rfc1123(png_structp png_ptr, png_const_timep ptime)
+{
+   static PNG_CONST char short_months[12][4] =
+        {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
+
+   if (png_ptr == NULL)
+      return (NULL);
+
+   if (ptime->year > 9999 /* RFC1123 limitation */ ||
+       ptime->month == 0    ||  ptime->month > 12  ||
+       ptime->day   == 0    ||  ptime->day   > 31  ||
+       ptime->hour  > 23    ||  ptime->minute > 59 ||
+       ptime->second > 60)
+   {
+      png_warning(png_ptr, "Ignoring invalid time value");
+      return (NULL);
+   }
+
+   {
+      size_t pos = 0;
+      char number_buf[5]; /* enough for a four-digit year */
+
+#     define APPEND_STRING(string)\
+         pos = png_safecat(png_ptr->time_buffer, sizeof png_ptr->time_buffer,\
+            pos, (string))
+#     define APPEND_NUMBER(format, value)\
+         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
+#     define APPEND(ch)\
+         if (pos < (sizeof png_ptr->time_buffer)-1)\
+            png_ptr->time_buffer[pos++] = (ch)
+
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);
+      APPEND(' ');
+      APPEND_STRING(short_months[(ptime->month - 1)]);
+      APPEND(' ');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);
+      APPEND(' ');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);
+      APPEND(':');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);
+      APPEND(':');
+      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);
+      APPEND_STRING(" +0000"); /* This reliably terminates the buffer */
+
+#     undef APPEND
+#     undef APPEND_NUMBER
+#     undef APPEND_STRING
+   }
+
+   return png_ptr->time_buffer;
+}
+#  endif /* PNG_TIME_RFC1123_SUPPORTED */
+
+#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
+
+png_const_charp PNGAPI
+png_get_copyright(png_const_structp png_ptr)
+{
+   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
+#ifdef PNG_STRING_COPYRIGHT
+   return PNG_STRING_COPYRIGHT
+#else
+#  ifdef __STDC__
+   return PNG_STRING_NEWLINE \
+     "libpng version 1.5.12 - July 11, 2012" PNG_STRING_NEWLINE \
+     "Copyright (c) 1998-2012 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
+     "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
+     "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
+     PNG_STRING_NEWLINE;
+#  else
+      return "libpng version 1.5.12 - July 11, 2012\
+      Copyright (c) 1998-2012 Glenn Randers-Pehrson\
+      Copyright (c) 1996-1997 Andreas Dilger\
+      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.";
+#  endif
+#endif
+}
+
+/* The following return the library version as a short string in the
+ * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
+ * used with your application, print out PNG_LIBPNG_VER_STRING, which
+ * is defined in png.h.
+ * Note: now there is no difference between png_get_libpng_ver() and
+ * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,
+ * it is guaranteed that png.c uses the correct version of png.h.
+ */
+png_const_charp PNGAPI
+png_get_libpng_ver(png_const_structp png_ptr)
+{
+   /* Version of *.c files used when building libpng */
+   return png_get_header_ver(png_ptr);
+}
+
+png_const_charp PNGAPI
+png_get_header_ver(png_const_structp png_ptr)
+{
+   /* Version of *.h files used when building libpng */
+   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
+   return PNG_LIBPNG_VER_STRING;
+}
+
+png_const_charp PNGAPI
+png_get_header_version(png_const_structp png_ptr)
+{
+   /* Returns longer string containing both version and date */
+   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
+#ifdef __STDC__
+   return PNG_HEADER_VERSION_STRING
+#  ifndef PNG_READ_SUPPORTED
+   "     (NO READ SUPPORT)"
+#  endif
+   PNG_STRING_NEWLINE;
+#else
+   return PNG_HEADER_VERSION_STRING;
+#endif
+}
+
+#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+int PNGAPI
+png_handle_as_unknown(png_structp png_ptr, png_const_bytep chunk_name)
+{
+   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
+   png_const_bytep p, p_end;
+
+   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list <= 0)
+      return PNG_HANDLE_CHUNK_AS_DEFAULT;
+
+   p_end = png_ptr->chunk_list;
+   p = p_end + png_ptr->num_chunk_list*5; /* beyond end */
+
+   /* The code is the fifth byte after each four byte string.  Historically this
+    * code was always searched from the end of the list, so it should continue
+    * to do so in case there are duplicated entries.
+    */
+   do /* num_chunk_list > 0, so at least one */
+   {
+      p -= 5;
+      if (!png_memcmp(chunk_name, p, 4))
+         return p[4];
+   }
+   while (p > p_end);
+
+   return PNG_HANDLE_CHUNK_AS_DEFAULT;
+}
+
+int /* PRIVATE */
+png_chunk_unknown_handling(png_structp png_ptr, png_uint_32 chunk_name)
+{
+   png_byte chunk_string[5];
+
+   PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);
+   return png_handle_as_unknown(png_ptr, chunk_string);
+}
+#endif
+
+#ifdef PNG_READ_SUPPORTED
+/* This function, added to libpng-1.0.6g, is untested. */
+int PNGAPI
+png_reset_zstream(png_structp png_ptr)
+{
+   if (png_ptr == NULL)
+      return Z_STREAM_ERROR;
+
+   return (inflateReset(&png_ptr->zstream));
+}
+#endif /* PNG_READ_SUPPORTED */
+
+/* This function was added to libpng-1.0.7 */
+png_uint_32 PNGAPI
+png_access_version_number(void)
+{
+   /* Version of *.c files used when building libpng */
+   return((png_uint_32)PNG_LIBPNG_VER);
+}
+
+
+
+#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+/* png_convert_size: a PNGAPI but no longer in png.h, so deleted
+ * at libpng 1.5.5!
+ */
+
+/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
+#  ifdef PNG_CHECK_cHRM_SUPPORTED
+
+int /* PRIVATE */
+png_check_cHRM_fixed(png_structp png_ptr,
+   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
+   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
+   png_fixed_point blue_x, png_fixed_point blue_y)
+{
+   int ret = 1;
+   unsigned long xy_hi,xy_lo,yx_hi,yx_lo;
+
+   png_debug(1, "in function png_check_cHRM_fixed");
+
+   if (png_ptr == NULL)
+      return 0;
+
+   /* (x,y,z) values are first limited to 0..100000 (PNG_FP_1), the white
+    * y must also be greater than 0.  To test for the upper limit calculate
+    * (PNG_FP_1-y) - x must be <= to this for z to be >= 0 (and the expression
+    * cannot overflow.)  At this point we know x and y are >= 0 and (x+y) is
+    * <= PNG_FP_1.  The previous test on PNG_MAX_UINT_31 is removed because it
+    * pointless (and it produces compiler warnings!)
+    */
+   if (white_x < 0 || white_y <= 0 ||
+         red_x < 0 ||   red_y <  0 ||
+       green_x < 0 || green_y <  0 ||
+        blue_x < 0 ||  blue_y <  0)
+   {
+      png_warning(png_ptr,
+        "Ignoring attempt to set negative chromaticity value");
+      ret = 0;
+   }
+   /* And (x+y) must be <= PNG_FP_1 (so z is >= 0) */
+   if (white_x > PNG_FP_1 - white_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM white point");
+      ret = 0;
+   }
+
+   if (red_x > PNG_FP_1 - red_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM red point");
+      ret = 0;
+   }
+
+   if (green_x > PNG_FP_1 - green_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM green point");
+      ret = 0;
+   }
+
+   if (blue_x > PNG_FP_1 - blue_y)
+   {
+      png_warning(png_ptr, "Invalid cHRM blue point");
+      ret = 0;
+   }
+
+   png_64bit_product(green_x - red_x, blue_y - red_y, &xy_hi, &xy_lo);
+   png_64bit_product(green_y - red_y, blue_x - red_x, &yx_hi, &yx_lo);
+
+   if (xy_hi == yx_hi && xy_lo == yx_lo)
+   {
+      png_warning(png_ptr,
+         "Ignoring attempt to set cHRM RGB triangle with zero area");
+      ret = 0;
+   }
+
+   return ret;
+}
+#  endif /* PNG_CHECK_cHRM_SUPPORTED */
+
+#ifdef PNG_cHRM_SUPPORTED
+/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for
+ * cHRM, as opposed to using chromaticities.  These internal APIs return
+ * non-zero on a parameter error.  The X, Y and Z values are required to be
+ * positive and less than 1.0.
+ */
+int png_xy_from_XYZ(png_xy *xy, png_XYZ XYZ)
+{
+   png_int_32 d, dwhite, whiteX, whiteY;
+
+   d = XYZ.redX + XYZ.redY + XYZ.redZ;
+   if (!png_muldiv(&xy->redx, XYZ.redX, PNG_FP_1, d)) return 1;
+   if (!png_muldiv(&xy->redy, XYZ.redY, PNG_FP_1, d)) return 1;
+   dwhite = d;
+   whiteX = XYZ.redX;
+   whiteY = XYZ.redY;
+
+   d = XYZ.greenX + XYZ.greenY + XYZ.greenZ;
+   if (!png_muldiv(&xy->greenx, XYZ.greenX, PNG_FP_1, d)) return 1;
+   if (!png_muldiv(&xy->greeny, XYZ.greenY, PNG_FP_1, d)) return 1;
+   dwhite += d;
+   whiteX += XYZ.greenX;
+   whiteY += XYZ.greenY;
+
+   d = XYZ.blueX + XYZ.blueY + XYZ.blueZ;
+   if (!png_muldiv(&xy->bluex, XYZ.blueX, PNG_FP_1, d)) return 1;
+   if (!png_muldiv(&xy->bluey, XYZ.blueY, PNG_FP_1, d)) return 1;
+   dwhite += d;
+   whiteX += XYZ.blueX;
+   whiteY += XYZ.blueY;
+
+   /* The reference white is simply the same of the end-point (X,Y,Z) vectors,
+    * thus:
+    */
+   if (!png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite)) return 1;
+   if (!png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite)) return 1;
+
+   return 0;
+}
+
+int png_XYZ_from_xy(png_XYZ *XYZ, png_xy xy)
+{
+   png_fixed_point red_inverse, green_inverse, blue_scale;
+   png_fixed_point left, right, denominator;
+
+   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically
+    * have end points with 0 tristimulus values (these are impossible end
+    * points, but they are used to cover the possible colors.)
+    */
+   if (xy.redx < 0 || xy.redx > PNG_FP_1) return 1;
+   if (xy.redy < 0 || xy.redy > PNG_FP_1-xy.redx) return 1;
+   if (xy.greenx < 0 || xy.greenx > PNG_FP_1) return 1;
+   if (xy.greeny < 0 || xy.greeny > PNG_FP_1-xy.greenx) return 1;
+   if (xy.bluex < 0 || xy.bluex > PNG_FP_1) return 1;
+   if (xy.bluey < 0 || xy.bluey > PNG_FP_1-xy.bluex) return 1;
+   if (xy.whitex < 0 || xy.whitex > PNG_FP_1) return 1;
+   if (xy.whitey < 0 || xy.whitey > PNG_FP_1-xy.whitex) return 1;
+
+   /* The reverse calculation is more difficult because the original tristimulus
+    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8
+    * derived values were recorded in the cHRM chunk;
+    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and
+    * therefore an arbitrary ninth value has to be introduced to undo the
+    * original transformations.
+    *
+    * Think of the original end-points as points in (X,Y,Z) space.  The
+    * chromaticity values (c) have the property:
+    *
+    *           C
+    *   c = ---------
+    *       X + Y + Z
+    *
+    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the
+    * three chromaticity values (x,y,z) for each end-point obey the
+    * relationship:
+    *
+    *   x + y + z = 1
+    *
+    * This describes the plane in (X,Y,Z) space that intersects each axis at the
+    * value 1.0; call this the chromaticity plane.  Thus the chromaticity
+    * calculation has scaled each end-point so that it is on the x+y+z=1 plane
+    * and chromaticity is the intersection of the vector from the origin to the
+    * (X,Y,Z) value with the chromaticity plane.
+    *
+    * To fully invert the chromaticity calculation we would need the three
+    * end-point scale factors, (red-scale, green-scale, blue-scale), but these
+    * were not recorded.  Instead we calculated the reference white (X,Y,Z) and
+    * recorded the chromaticity of this.  The reference white (X,Y,Z) would have
+    * given all three of the scale factors since:
+    *
+    *    color-C = color-c * color-scale
+    *    white-C = red-C + green-C + blue-C
+    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
+    *
+    * But cHRM records only white-x and white-y, so we have lost the white scale
+    * factor:
+    *
+    *    white-C = white-c*white-scale
+    *
+    * To handle this the inverse transformation makes an arbitrary assumption
+    * about white-scale:
+    *
+    *    Assume: white-Y = 1.0
+    *    Hence:  white-scale = 1/white-y
+    *    Or:     red-Y + green-Y + blue-Y = 1.0
+    *
+    * Notice the last statement of the assumption gives an equation in three of
+    * the nine values we want to calculate.  8 more equations come from the
+    * above routine as summarised at the top above (the chromaticity
+    * calculation):
+    *
+    *    Given: color-x = color-X / (color-X + color-Y + color-Z)
+    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0
+    *
+    * This is 9 simultaneous equations in the 9 variables "color-C" and can be
+    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix
+    * determinants, however this is not as bad as it seems because only 28 of
+    * the total of 90 terms in the various matrices are non-zero.  Nevertheless
+    * Cramer's rule is notoriously numerically unstable because the determinant
+    * calculation involves the difference of large, but similar, numbers.  It is
+    * difficult to be sure that the calculation is stable for real world values
+    * and it is certain that it becomes unstable where the end points are close
+    * together.
+    *
+    * So this code uses the perhaps slightly less optimal but more
+    * understandable and totally obvious approach of calculating color-scale.
+    *
+    * This algorithm depends on the precision in white-scale and that is
+    * (1/white-y), so we can immediately see that as white-y approaches 0 the
+    * accuracy inherent in the cHRM chunk drops off substantially.
+    *
+    * libpng arithmetic: a simple invertion of the above equations
+    * ------------------------------------------------------------
+    *
+    *    white_scale = 1/white-y
+    *    white-X = white-x * white-scale
+    *    white-Y = 1.0
+    *    white-Z = (1 - white-x - white-y) * white_scale
+    *
+    *    white-C = red-C + green-C + blue-C
+    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
+    *
+    * This gives us three equations in (red-scale,green-scale,blue-scale) where
+    * all the coefficients are now known:
+    *
+    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale
+    *       = white-x/white-y
+    *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1
+    *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale
+    *       = (1 - white-x - white-y)/white-y
+    *
+    * In the last equation color-z is (1 - color-x - color-y) so we can add all
+    * three equations together to get an alternative third:
+    *
+    *    red-scale + green-scale + blue-scale = 1/white-y = white-scale
+    *
+    * So now we have a Cramer's rule solution where the determinants are just
+    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve
+    * multiplication of three coefficients so we can't guarantee to avoid
+    * overflow in the libpng fixed point representation.  Using Cramer's rule in
+    * floating point is probably a good choice here, but it's not an option for
+    * fixed point.  Instead proceed to simplify the first two equations by
+    * eliminating what is likely to be the largest value, blue-scale:
+    *
+    *    blue-scale = white-scale - red-scale - green-scale
+    *
+    * Hence:
+    *
+    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =
+    *                (white-x - blue-x)*white-scale
+    *
+    *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =
+    *                1 - blue-y*white-scale
+    *
+    * And now we can trivially solve for (red-scale,green-scale):
+    *
+    *    green-scale =
+    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale
+    *                -----------------------------------------------------------
+    *                                  green-x - blue-x
+    *
+    *    red-scale =
+    *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale
+    *                ---------------------------------------------------------
+    *                                  red-y - blue-y
+    *
+    * Hence:
+    *
+    *    red-scale =
+    *          ( (green-x - blue-x) * (white-y - blue-y) -
+    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y
+    * -------------------------------------------------------------------------
+    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
+    *
+    *    green-scale =
+    *          ( (red-y - blue-y) * (white-x - blue-x) -
+    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y
+    * -------------------------------------------------------------------------
+    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
+    *
+    * Accuracy:
+    * The input values have 5 decimal digits of accuracy.  The values are all in
+    * the range 0 < value < 1, so simple products are in the same range but may
+    * need up to 10 decimal digits to preserve the original precision and avoid
+    * underflow.  Because we are using a 32-bit signed representation we cannot
+    * match this; the best is a little over 9 decimal digits, less than 10.
+    *
+    * The approach used here is to preserve the maximum precision within the
+    * signed representation.  Because the red-scale calculation above uses the
+    * difference between two products of values that must be in the range -1..+1
+    * it is sufficient to divide the product by 7; ceil(100,000/32767*2).  The
+    * factor is irrelevant in the calculation because it is applied to both
+    * numerator and denominator.
+    *
+    * Note that the values of the differences of the products of the
+    * chromaticities in the above equations tend to be small, for example for
+    * the sRGB chromaticities they are:
+    *
+    * red numerator:    -0.04751
+    * green numerator:  -0.08788
+    * denominator:      -0.2241 (without white-y multiplication)
+    *
+    *  The resultant Y coefficients from the chromaticities of some widely used
+    *  color space definitions are (to 15 decimal places):
+    *
+    *  sRGB
+    *    0.212639005871510 0.715168678767756 0.072192315360734
+    *  Kodak ProPhoto
+    *    0.288071128229293 0.711843217810102 0.000085653960605
+    *  Adobe RGB
+    *    0.297344975250536 0.627363566255466 0.075291458493998
+    *  Adobe Wide Gamut RGB
+    *    0.258728243040113 0.724682314948566 0.016589442011321
+    */
+   /* By the argument, above overflow should be impossible here. The return
+    * value of 2 indicates an internal error to the caller.
+    */
+   if (!png_muldiv(&left, xy.greenx-xy.bluex, xy.redy - xy.bluey, 7)) return 2;
+   if (!png_muldiv(&right, xy.greeny-xy.bluey, xy.redx - xy.bluex, 7)) return 2;
+   denominator = left - right;
+
+   /* Now find the red numerator. */
+   if (!png_muldiv(&left, xy.greenx-xy.bluex, xy.whitey-xy.bluey, 7)) return 2;
+   if (!png_muldiv(&right, xy.greeny-xy.bluey, xy.whitex-xy.bluex, 7)) return 2;
+
+   /* Overflow is possible here and it indicates an extreme set of PNG cHRM
+    * chunk values.  This calculation actually returns the reciprocal of the
+    * scale value because this allows us to delay the multiplication of white-y
+    * into the denominator, which tends to produce a small number.
+    */
+   if (!png_muldiv(&red_inverse, xy.whitey, denominator, left-right) ||
+       red_inverse <= xy.whitey /* r+g+b scales = white scale */)
+      return 1;
+
+   /* Similarly for green_inverse: */
+   if (!png_muldiv(&left, xy.redy-xy.bluey, xy.whitex-xy.bluex, 7)) return 2;
+   if (!png_muldiv(&right, xy.redx-xy.bluex, xy.whitey-xy.bluey, 7)) return 2;
+   if (!png_muldiv(&green_inverse, xy.whitey, denominator, left-right) ||
+       green_inverse <= xy.whitey)
+      return 1;
+
+   /* And the blue scale, the checks above guarantee this can't overflow but it
+    * can still produce 0 for extreme cHRM values.
+    */
+   blue_scale = png_reciprocal(xy.whitey) - png_reciprocal(red_inverse) -
+      png_reciprocal(green_inverse);
+   if (blue_scale <= 0) return 1;
+
+
+   /* And fill in the png_XYZ: */
+   if (!png_muldiv(&XYZ->redX, xy.redx, PNG_FP_1, red_inverse)) return 1;
+   if (!png_muldiv(&XYZ->redY, xy.redy, PNG_FP_1, red_inverse)) return 1;
+   if (!png_muldiv(&XYZ->redZ, PNG_FP_1 - xy.redx - xy.redy, PNG_FP_1,
+      red_inverse))
+      return 1;
+
+   if (!png_muldiv(&XYZ->greenX, xy.greenx, PNG_FP_1, green_inverse)) return 1;
+   if (!png_muldiv(&XYZ->greenY, xy.greeny, PNG_FP_1, green_inverse)) return 1;
+   if (!png_muldiv(&XYZ->greenZ, PNG_FP_1 - xy.greenx - xy.greeny, PNG_FP_1,
+      green_inverse))
+      return 1;
+
+   if (!png_muldiv(&XYZ->blueX, xy.bluex, blue_scale, PNG_FP_1)) return 1;
+   if (!png_muldiv(&XYZ->blueY, xy.bluey, blue_scale, PNG_FP_1)) return 1;
+   if (!png_muldiv(&XYZ->blueZ, PNG_FP_1 - xy.bluex - xy.bluey, blue_scale,
+      PNG_FP_1))
+      return 1;
+
+   return 0; /*success*/
+}
+
+int png_XYZ_from_xy_checked(png_structp png_ptr, png_XYZ *XYZ, png_xy xy)
+{
+   switch (png_XYZ_from_xy(XYZ, xy))
+   {
+      case 0: /* success */
+         return 1;
+
+      case 1:
+         /* The chunk may be technically valid, but we got png_fixed_point
+          * overflow while trying to get XYZ values out of it.  This is
+          * entirely benign - the cHRM chunk is pretty extreme.
+          */
+         png_warning(png_ptr,
+            "extreme cHRM chunk cannot be converted to tristimulus values");
+         break;
+
+      default:
+         /* libpng is broken; this should be a warning but if it happens we
+          * want error reports so for the moment it is an error.
+          */
+         png_error(png_ptr, "internal error in png_XYZ_from_xy");
+         break;
+   }
+
+   /* ERROR RETURN */
+   return 0;
+}
+#endif
+
+void /* PRIVATE */
+png_check_IHDR(png_structp png_ptr,
+   png_uint_32 width, png_uint_32 height, int bit_depth,
+   int color_type, int interlace_type, int compression_type,
+   int filter_type)
+{
+   int error = 0;
+
+   /* Check for width and height valid values */
+   if (width == 0)
+   {
+      png_warning(png_ptr, "Image width is zero in IHDR");
+      error = 1;
+   }
+
+   if (height == 0)
+   {
+      png_warning(png_ptr, "Image height is zero in IHDR");
+      error = 1;
+   }
+
+#  ifdef PNG_SET_USER_LIMITS_SUPPORTED
+   if (width > png_ptr->user_width_max)
+
+#  else
+   if (width > PNG_USER_WIDTH_MAX)
+#  endif
+   {
+      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
+      error = 1;
+   }
+
+#  ifdef PNG_SET_USER_LIMITS_SUPPORTED
+   if (height > png_ptr->user_height_max)
+#  else
+   if (height > PNG_USER_HEIGHT_MAX)
+#  endif
+   {
+      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
+      error = 1;
+   }
+
+   if (width > PNG_UINT_31_MAX)
+   {
+      png_warning(png_ptr, "Invalid image width in IHDR");
+      error = 1;
+   }
+
+   if (height > PNG_UINT_31_MAX)
+   {
+      png_warning(png_ptr, "Invalid image height in IHDR");
+      error = 1;
+   }
+
+   if (width > (PNG_UINT_32_MAX
+                 >> 3)      /* 8-byte RGBA pixels */
+                 - 48       /* bigrowbuf hack */
+                 - 1        /* filter byte */
+                 - 7*8      /* rounding of width to multiple of 8 pixels */
+                 - 8)       /* extra max_pixel_depth pad */
+      png_warning(png_ptr, "Width is too large for libpng to process pixels");
+
+   /* Check other values */
+   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
+       bit_depth != 8 && bit_depth != 16)
+   {
+      png_warning(png_ptr, "Invalid bit depth in IHDR");
+      error = 1;
+   }
+
+   if (color_type < 0 || color_type == 1 ||
+       color_type == 5 || color_type > 6)
+   {
+      png_warning(png_ptr, "Invalid color type in IHDR");
+      error = 1;
+   }
+
+   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
+       ((color_type == PNG_COLOR_TYPE_RGB ||
+         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
+         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
+   {
+      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
+      error = 1;
+   }
+
+   if (interlace_type >= PNG_INTERLACE_LAST)
+   {
+      png_warning(png_ptr, "Unknown interlace method in IHDR");
+      error = 1;
+   }
+
+   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
+   {
+      png_warning(png_ptr, "Unknown compression method in IHDR");
+      error = 1;
+   }
+
+#  ifdef PNG_MNG_FEATURES_SUPPORTED
+   /* Accept filter_method 64 (intrapixel differencing) only if
+    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
+    * 2. Libpng did not read a PNG signature (this filter_method is only
+    *    used in PNG datastreams that are embedded in MNG datastreams) and
+    * 3. The application called png_permit_mng_features with a mask that
+    *    included PNG_FLAG_MNG_FILTER_64 and
+    * 4. The filter_method is 64 and
+    * 5. The color_type is RGB or RGBA
+    */
+   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) &&
+       png_ptr->mng_features_permitted)
+      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");
+
+   if (filter_type != PNG_FILTER_TYPE_BASE)
+   {
+      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
+          (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
+          ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
+          (color_type == PNG_COLOR_TYPE_RGB ||
+          color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
+      {
+         png_warning(png_ptr, "Unknown filter method in IHDR");
+         error = 1;
+      }
+
+      if (png_ptr->mode & PNG_HAVE_PNG_SIGNATURE)
+      {
+         png_warning(png_ptr, "Invalid filter method in IHDR");
+         error = 1;
+      }
+   }
+
+#  else
+   if (filter_type != PNG_FILTER_TYPE_BASE)
+   {
+      png_warning(png_ptr, "Unknown filter method in IHDR");
+      error = 1;
+   }
+#  endif
+
+   if (error == 1)
+      png_error(png_ptr, "Invalid IHDR data");
+}
+
+#if defined(PNG_sCAL_SUPPORTED) || defined(PNG_pCAL_SUPPORTED)
+/* ASCII to fp functions */
+/* Check an ASCII formated floating point value, see the more detailed
+ * comments in pngpriv.h
+ */
+/* The following is used internally to preserve the sticky flags */
+#define png_fp_add(state, flags) ((state) |= (flags))
+#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
+
+int /* PRIVATE */
+png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
+   png_size_tp whereami)
+{
+   int state = *statep;
+   png_size_t i = *whereami;
+
+   while (i < size)
+   {
+      int type;
+      /* First find the type of the next character */
+      switch (string[i])
+      {
+      case 43:  type = PNG_FP_SAW_SIGN;                   break;
+      case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;
+      case 46:  type = PNG_FP_SAW_DOT;                    break;
+      case 48:  type = PNG_FP_SAW_DIGIT;                  break;
+      case 49: case 50: case 51: case 52:
+      case 53: case 54: case 55: case 56:
+      case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;
+      case 69:
+      case 101: type = PNG_FP_SAW_E;                      break;
+      default:  goto PNG_FP_End;
+      }
+
+      /* Now deal with this type according to the current
+       * state, the type is arranged to not overlap the
+       * bits of the PNG_FP_STATE.
+       */
+      switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))
+      {
+      case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:
+         if (state & PNG_FP_SAW_ANY)
+            goto PNG_FP_End; /* not a part of the number */
+
+         png_fp_add(state, type);
+         break;
+
+      case PNG_FP_INTEGER + PNG_FP_SAW_DOT:
+         /* Ok as trailer, ok as lead of fraction. */
+         if (state & PNG_FP_SAW_DOT) /* two dots */
+            goto PNG_FP_End;
+
+         else if (state & PNG_FP_SAW_DIGIT) /* trailing dot? */
+            png_fp_add(state, type);
+
+         else
+            png_fp_set(state, PNG_FP_FRACTION | type);
+
+         break;
+
+      case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:
+         if (state & PNG_FP_SAW_DOT) /* delayed fraction */
+            png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);
+
+         png_fp_add(state, type | PNG_FP_WAS_VALID);
+
+         break;
+
+      case PNG_FP_INTEGER + PNG_FP_SAW_E:
+         if ((state & PNG_FP_SAW_DIGIT) == 0)
+            goto PNG_FP_End;
+
+         png_fp_set(state, PNG_FP_EXPONENT);
+
+         break;
+
+   /* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:
+         goto PNG_FP_End; ** no sign in fraction */
+
+   /* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:
+         goto PNG_FP_End; ** Because SAW_DOT is always set */
+
+      case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
+         png_fp_add(state, type | PNG_FP_WAS_VALID);
+         break;
+
+      case PNG_FP_FRACTION + PNG_FP_SAW_E:
+         /* This is correct because the trailing '.' on an
+          * integer is handled above - so we can only get here
+          * with the sequence ".E" (with no preceding digits).
+          */
+         if ((state & PNG_FP_SAW_DIGIT) == 0)
+            goto PNG_FP_End;
+
+         png_fp_set(state, PNG_FP_EXPONENT);
+
+         break;
+
+      case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:
+         if (state & PNG_FP_SAW_ANY)
+            goto PNG_FP_End; /* not a part of the number */
+
+         png_fp_add(state, PNG_FP_SAW_SIGN);
+
+         break;
+
+   /* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:
+         goto PNG_FP_End; */
+
+      case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:
+         png_fp_add(state, PNG_FP_SAW_DIGIT | PNG_FP_WAS_VALID);
+
+         break;
+
+   /* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:
+         goto PNG_FP_End; */
+
+      default: goto PNG_FP_End; /* I.e. break 2 */
+      }
+
+      /* The character seems ok, continue. */
+      ++i;
+   }
+
+PNG_FP_End:
+   /* Here at the end, update the state and return the correct
+    * return code.
+    */
+   *statep = state;
+   *whereami = i;
+
+   return (state & PNG_FP_SAW_DIGIT) != 0;
+}
+
+
+/* The same but for a complete string. */
+int
+png_check_fp_string(png_const_charp string, png_size_t size)
+{
+   int        state=0;
+   png_size_t char_index=0;
+
+   if (png_check_fp_number(string, size, &state, &char_index) &&
+      (char_index == size || string[char_index] == 0))
+      return state /* must be non-zero - see above */;
+
+   return 0; /* i.e. fail */
+}
+#endif /* pCAL or sCAL */
+
+#ifdef PNG_READ_sCAL_SUPPORTED
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+/* Utility used below - a simple accurate power of ten from an integral
+ * exponent.
+ */
+static double
+png_pow10(int power)
+{
+   int recip = 0;
+   double d = 1.0;
+
+   /* Handle negative exponent with a reciprocal at the end because
+    * 10 is exact whereas .1 is inexact in base 2
+    */
+   if (power < 0)
+   {
+      if (power < DBL_MIN_10_EXP) return 0;
+      recip = 1, power = -power;
+   }
+
+   if (power > 0)
+   {
+      /* Decompose power bitwise. */
+      double mult = 10.0;
+      do
+      {
+         if (power & 1) d *= mult;
+         mult *= mult;
+         power >>= 1;
+      }
+      while (power > 0);
+
+      if (recip) d = 1/d;
+   }
+   /* else power is 0 and d is 1 */
+
+   return d;
+}
+
+/* Function to format a floating point value in ASCII with a given
+ * precision.
+ */
+void /* PRIVATE */
+png_ascii_from_fp(png_structp png_ptr, png_charp ascii, png_size_t size,
+    double fp, unsigned int precision)
+{
+   /* We use standard functions from math.h, but not printf because
+    * that would require stdio.  The caller must supply a buffer of
+    * sufficient size or we will png_error.  The tests on size and
+    * the space in ascii[] consumed are indicated below.
+    */
+   if (precision < 1)
+      precision = DBL_DIG;
+
+   /* Enforce the limit of the implementation precision too. */
+   if (precision > DBL_DIG+1)
+      precision = DBL_DIG+1;
+
+   /* Basic sanity checks */
+   if (size >= precision+5) /* See the requirements below. */
+   {
+      if (fp < 0)
+      {
+         fp = -fp;
+         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */
+         --size;
+      }
+
+      if (fp >= DBL_MIN && fp <= DBL_MAX)
+      {
+         int exp_b10;       /* A base 10 exponent */
+         double base;   /* 10^exp_b10 */
+
+         /* First extract a base 10 exponent of the number,
+          * the calculation below rounds down when converting
+          * from base 2 to base 10 (multiply by log10(2) -
+          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
+          * be increased.  Note that the arithmetic shift
+          * performs a floor() unlike C arithmetic - using a
+          * C multiply would break the following for negative
+          * exponents.
+          */
+         (void)frexp(fp, &exp_b10); /* exponent to base 2 */
+
+         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */
+
+         /* Avoid underflow here. */
+         base = png_pow10(exp_b10); /* May underflow */
+
+         while (base < DBL_MIN || base < fp)
+         {
+            /* And this may overflow. */
+            double test = png_pow10(exp_b10+1);
+
+            if (test <= DBL_MAX)
+               ++exp_b10, base = test;
+
+            else
+               break;
+         }
+
+         /* Normalize fp and correct exp_b10, after this fp is in the
+          * range [.1,1) and exp_b10 is both the exponent and the digit
+          * *before* which the decimal point should be inserted
+          * (starting with 0 for the first digit).  Note that this
+          * works even if 10^exp_b10 is out of range because of the
+          * test on DBL_MAX above.
+          */
+         fp /= base;
+         while (fp >= 1) fp /= 10, ++exp_b10;
+
+         /* Because of the code above fp may, at this point, be
+          * less than .1, this is ok because the code below can
+          * handle the leading zeros this generates, so no attempt
+          * is made to correct that here.
+          */
+
+         {
+            int czero, clead, cdigits;
+            char exponent[10];
+
+            /* Allow up to two leading zeros - this will not lengthen
+             * the number compared to using E-n.
+             */
+            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */
+            {
+               czero = -exp_b10; /* PLUS 2 digits: TOTAL 3 */
+               exp_b10 = 0;      /* Dot added below before first output. */
+            }
+            else
+               czero = 0;    /* No zeros to add */
+
+            /* Generate the digit list, stripping trailing zeros and
+             * inserting a '.' before a digit if the exponent is 0.
+             */
+            clead = czero; /* Count of leading zeros */
+            cdigits = 0;   /* Count of digits in list. */
+
+            do
+            {
+               double d;
+
+               fp *= 10.0;
+
+               /* Use modf here, not floor and subtract, so that
+                * the separation is done in one step.  At the end
+                * of the loop don't break the number into parts so
+                * that the final digit is rounded.
+                */
+               if (cdigits+czero-clead+1 < (int)precision)
+                  fp = modf(fp, &d);
+
+               else
+               {
+                  d = floor(fp + .5);
+
+                  if (d > 9.0)
+                  {
+                     /* Rounding up to 10, handle that here. */
+                     if (czero > 0)
+                     {
+                        --czero, d = 1;
+                        if (cdigits == 0) --clead;
+                     }
+
+                     else
+                     {
+                        while (cdigits > 0 && d > 9.0)
+                        {
+                           int ch = *--ascii;
+
+                           if (exp_b10 != (-1))
+                              ++exp_b10;
+
+                           else if (ch == 46)
+                           {
+                              ch = *--ascii, ++size;
+                              /* Advance exp_b10 to '1', so that the
+                               * decimal point happens after the
+                               * previous digit.
+                               */
+                              exp_b10 = 1;
+                           }
+
+                           --cdigits;
+                           d = ch - 47;  /* I.e. 1+(ch-48) */
+                        }
+
+                        /* Did we reach the beginning? If so adjust the
+                         * exponent but take into account the leading
+                         * decimal point.
+                         */
+                        if (d > 9.0)  /* cdigits == 0 */
+                        {
+                           if (exp_b10 == (-1))
+                           {
+                              /* Leading decimal point (plus zeros?), if
+                               * we lose the decimal point here it must
+                               * be reentered below.
+                               */
+                              int ch = *--ascii;
+
+                              if (ch == 46)
+                                 ++size, exp_b10 = 1;
+
+                              /* Else lost a leading zero, so 'exp_b10' is
+                               * still ok at (-1)
+                               */
+                           }
+                           else
+                              ++exp_b10;
+
+                           /* In all cases we output a '1' */
+                           d = 1.0;
+                        }
+                     }
+                  }
+                  fp = 0; /* Guarantees termination below. */
+               }
+
+               if (d == 0.0)
+               {
+                  ++czero;
+                  if (cdigits == 0) ++clead;
+               }
+
+               else
+               {
+                  /* Included embedded zeros in the digit count. */
+                  cdigits += czero - clead;
+                  clead = 0;
+
+                  while (czero > 0)
+                  {
+                     /* exp_b10 == (-1) means we just output the decimal
+                      * place - after the DP don't adjust 'exp_b10' any
+                      * more!
+                      */
+                     if (exp_b10 != (-1))
+                     {
+                        if (exp_b10 == 0) *ascii++ = 46, --size;
+                        /* PLUS 1: TOTAL 4 */
+                        --exp_b10;
+                     }
+                     *ascii++ = 48, --czero;
+                  }
+
+                  if (exp_b10 != (-1))
+                  {
+                     if (exp_b10 == 0) *ascii++ = 46, --size; /* counted
+                                                                 above */
+                     --exp_b10;
+                  }
+
+                  *ascii++ = (char)(48 + (int)d), ++cdigits;
+               }
+            }
+            while (cdigits+czero-clead < (int)precision && fp > DBL_MIN);
+
+            /* The total output count (max) is now 4+precision */
+
+            /* Check for an exponent, if we don't need one we are
+             * done and just need to terminate the string.  At
+             * this point exp_b10==(-1) is effectively if flag - it got
+             * to '-1' because of the decrement after outputing
+             * the decimal point above (the exponent required is
+             * *not* -1!)
+             */
+            if (exp_b10 >= (-1) && exp_b10 <= 2)
+            {
+               /* The following only happens if we didn't output the
+                * leading zeros above for negative exponent, so this
+                * doest add to the digit requirement.  Note that the
+                * two zeros here can only be output if the two leading
+                * zeros were *not* output, so this doesn't increase
+                * the output count.
+                */
+               while (--exp_b10 >= 0) *ascii++ = 48;
+
+               *ascii = 0;
+
+               /* Total buffer requirement (including the '\0') is
+                * 5+precision - see check at the start.
+                */
+               return;
+            }
+
+            /* Here if an exponent is required, adjust size for
+             * the digits we output but did not count.  The total
+             * digit output here so far is at most 1+precision - no
+             * decimal point and no leading or trailing zeros have
+             * been output.
+             */
+            size -= cdigits;
+
+            *ascii++ = 69, --size;    /* 'E': PLUS 1 TOTAL 2+precision */
+
+            /* The following use of an unsigned temporary avoids ambiguities in
+             * the signed arithmetic on exp_b10 and permits GCC at least to do
+             * better optimization.
+             */
+            {
+               unsigned int uexp_b10;
+
+               if (exp_b10 < 0)
+               {
+                  *ascii++ = 45, --size; /* '-': PLUS 1 TOTAL 3+precision */
+                  uexp_b10 = -exp_b10;
+               }
+
+               else
+                  uexp_b10 = exp_b10;
+
+               cdigits = 0;
+
+               while (uexp_b10 > 0)
+               {
+                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);
+                  uexp_b10 /= 10;
+               }
+            }
+
+            /* Need another size check here for the exponent digits, so
+             * this need not be considered above.
+             */
+            if ((int)size > cdigits)
+            {
+               while (cdigits > 0) *ascii++ = exponent[--cdigits];
+
+               *ascii = 0;
+
+               return;
+            }
+         }
+      }
+      else if (!(fp >= DBL_MIN))
+      {
+         *ascii++ = 48; /* '0' */
+         *ascii = 0;
+         return;
+      }
+      else
+      {
+         *ascii++ = 105; /* 'i' */
+         *ascii++ = 110; /* 'n' */
+         *ascii++ = 102; /* 'f' */
+         *ascii = 0;
+         return;
+      }
+   }
+
+   /* Here on buffer too small. */
+   png_error(png_ptr, "ASCII conversion buffer too small");
+}
+
+#  endif /* FLOATING_POINT */
+
+#  ifdef PNG_FIXED_POINT_SUPPORTED
+/* Function to format a fixed point value in ASCII.
+ */
+void /* PRIVATE */
+png_ascii_from_fixed(png_structp png_ptr, png_charp ascii, png_size_t size,
+    png_fixed_point fp)
+{
+   /* Require space for 10 decimal digits, a decimal point, a minus sign and a
+    * trailing \0, 13 characters:
+    */
+   if (size > 12)
+   {
+      png_uint_32 num;
+
+      /* Avoid overflow here on the minimum integer. */
+      if (fp < 0)
+         *ascii++ = 45, --size, num = -fp;
+      else
+         num = fp;
+
+      if (num <= 0x80000000) /* else overflowed */
+      {
+         unsigned int ndigits = 0, first = 16 /* flag value */;
+         char digits[10];
+
+         while (num)
+         {
+            /* Split the low digit off num: */
+            unsigned int tmp = num/10;
+            num -= tmp*10;
+            digits[ndigits++] = (char)(48 + num);
+            /* Record the first non-zero digit, note that this is a number
+             * starting at 1, it's not actually the array index.
+             */
+            if (first == 16 && num > 0)
+               first = ndigits;
+            num = tmp;
+         }
+
+         if (ndigits > 0)
+         {
+            while (ndigits > 5) *ascii++ = digits[--ndigits];
+            /* The remaining digits are fractional digits, ndigits is '5' or
+             * smaller at this point.  It is certainly not zero.  Check for a
+             * non-zero fractional digit:
+             */
+            if (first <= 5)
+            {
+               unsigned int i;
+               *ascii++ = 46; /* decimal point */
+               /* ndigits may be <5 for small numbers, output leading zeros
+                * then ndigits digits to first:
+                */
+               i = 5;
+               while (ndigits < i) *ascii++ = 48, --i;
+               while (ndigits >= first) *ascii++ = digits[--ndigits];
+               /* Don't output the trailing zeros! */
+            }
+         }
+         else
+            *ascii++ = 48;
+
+         /* And null terminate the string: */
+         *ascii = 0;
+         return;
+      }
+   }
+
+   /* Here on buffer too small. */
+   png_error(png_ptr, "ASCII conversion buffer too small");
+}
+#   endif /* FIXED_POINT */
+#endif /* READ_SCAL */
+
+#if defined(PNG_FLOATING_POINT_SUPPORTED) && \
+   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED)
+png_fixed_point
+png_fixed(png_structp png_ptr, double fp, png_const_charp text)
+{
+   double r = floor(100000 * fp + .5);
+
+   if (r > 2147483647. || r < -2147483648.)
+      png_fixed_error(png_ptr, text);
+
+   return (png_fixed_point)r;
+}
+#endif
+
+#if defined(PNG_READ_GAMMA_SUPPORTED) || \
+    defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG__READ_pHYs_SUPPORTED)
+/* muldiv functions */
+/* This API takes signed arguments and rounds the result to the nearest
+ * integer (or, for a fixed point number - the standard argument - to
+ * the nearest .00001).  Overflow and divide by zero are signalled in
+ * the result, a boolean - true on success, false on overflow.
+ */
+int
+png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,
+    png_int_32 divisor)
+{
+   /* Return a * times / divisor, rounded. */
+   if (divisor != 0)
+   {
+      if (a == 0 || times == 0)
+      {
+         *res = 0;
+         return 1;
+      }
+      else
+      {
+#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
+         double r = a;
+         r *= times;
+         r /= divisor;
+         r = floor(r+.5);
+
+         /* A png_fixed_point is a 32-bit integer. */
+         if (r <= 2147483647. && r >= -2147483648.)
+         {
+            *res = (png_fixed_point)r;
+            return 1;
+         }
+#else
+         int negative = 0;
+         png_uint_32 A, T, D;
+         png_uint_32 s16, s32, s00;
+
+         if (a < 0)
+            negative = 1, A = -a;
+         else
+            A = a;
+
+         if (times < 0)
+            negative = !negative, T = -times;
+         else
+            T = times;
+
+         if (divisor < 0)
+            negative = !negative, D = -divisor;
+         else
+            D = divisor;
+
+         /* Following can't overflow because the arguments only
+          * have 31 bits each, however the result may be 32 bits.
+          */
+         s16 = (A >> 16) * (T & 0xffff) +
+                           (A & 0xffff) * (T >> 16);
+         /* Can't overflow because the a*times bit is only 30
+          * bits at most.
+          */
+         s32 = (A >> 16) * (T >> 16) + (s16 >> 16);
+         s00 = (A & 0xffff) * (T & 0xffff);
+
+         s16 = (s16 & 0xffff) << 16;
+         s00 += s16;
+
+         if (s00 < s16)
+            ++s32; /* carry */
+
+         if (s32 < D) /* else overflow */
+         {
+            /* s32.s00 is now the 64-bit product, do a standard
+             * division, we know that s32 < D, so the maximum
+             * required shift is 31.
+             */
+            int bitshift = 32;
+            png_fixed_point result = 0; /* NOTE: signed */
+
+            while (--bitshift >= 0)
+            {
+               png_uint_32 d32, d00;
+
+               if (bitshift > 0)
+                  d32 = D >> (32-bitshift), d00 = D << bitshift;
+
+               else
+                  d32 = 0, d00 = D;
+
+               if (s32 > d32)
+               {
+                  if (s00 < d00) --s32; /* carry */
+                  s32 -= d32, s00 -= d00, result += 1<<bitshift;
+               }
+
+               else
+                  if (s32 == d32 && s00 >= d00)
+                     s32 = 0, s00 -= d00, result += 1<<bitshift;
+            }
+
+            /* Handle the rounding. */
+            if (s00 >= (D >> 1))
+               ++result;
+
+            if (negative)
+               result = -result;
+
+            /* Check for overflow. */
+            if ((negative && result <= 0) || (!negative && result >= 0))
+            {
+               *res = result;
+               return 1;
+            }
+         }
+#endif
+      }
+   }
+
+   return 0;
+}
+#endif /* READ_GAMMA || INCH_CONVERSIONS */
+
+#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)
+/* The following is for when the caller doesn't much care about the
+ * result.
+ */
+png_fixed_point
+png_muldiv_warn(png_structp png_ptr, png_fixed_point a, png_int_32 times,
+    png_int_32 divisor)
+{
+   png_fixed_point result;
+
+   if (png_muldiv(&result, a, times, divisor))
+      return result;
+
+   png_warning(png_ptr, "fixed point overflow ignored");
+   return 0;
+}
+#endif
+
+#ifdef PNG_READ_GAMMA_SUPPORTED /* more fixed point functions for gamma */
+/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
+png_fixed_point
+png_reciprocal(png_fixed_point a)
+{
+#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
+   double r = floor(1E10/a+.5);
+
+   if (r <= 2147483647. && r >= -2147483648.)
+      return (png_fixed_point)r;
+#else
+   png_fixed_point res;
+
+   if (png_muldiv(&res, 100000, 100000, a))
+      return res;
+#endif
+
+   return 0; /* error/overflow */
+}
+
+/* A local convenience routine. */
+static png_fixed_point
+png_product2(png_fixed_point a, png_fixed_point b)
+{
+   /* The required result is 1/a * 1/b; the following preserves accuracy. */
+#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
+   double r = a * 1E-5;
+   r *= b;
+   r = floor(r+.5);
+
+   if (r <= 2147483647. && r >= -2147483648.)
+      return (png_fixed_point)r;
+#else
+   png_fixed_point res;
+
+   if (png_muldiv(&res, a, b, 100000))
+      return res;
+#endif
+
+   return 0; /* overflow */
+}
+
+/* The inverse of the above. */
+png_fixed_point
+png_reciprocal2(png_fixed_point a, png_fixed_point b)
+{
+   /* The required result is 1/a * 1/b; the following preserves accuracy. */
+#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
+   double r = 1E15/a;
+   r /= b;
+   r = floor(r+.5);
+
+   if (r <= 2147483647. && r >= -2147483648.)
+      return (png_fixed_point)r;
+#else
+   /* This may overflow because the range of png_fixed_point isn't symmetric,
+    * but this API is only used for the product of file and screen gamma so it
+    * doesn't matter that the smallest number it can produce is 1/21474, not
+    * 1/100000
+    */
+   png_fixed_point res = png_product2(a, b);
+
+   if (res != 0)
+      return png_reciprocal(res);
+#endif
+
+   return 0; /* overflow */
+}
+#endif /* READ_GAMMA */
+
+#ifdef PNG_CHECK_cHRM_SUPPORTED
+/* Added at libpng version 1.2.34 (Dec 8, 2008) and 1.4.0 (Jan 2,
+ * 2010: moved from pngset.c) */
+/*
+ *    Multiply two 32-bit numbers, V1 and V2, using 32-bit
+ *    arithmetic, to produce a 64-bit result in the HI/LO words.
+ *
+ *                  A B
+ *                x C D
+ *               ------
+ *              AD || BD
+ *        AC || CB || 0
+ *
+ *    where A and B are the high and low 16-bit words of V1,
+ *    C and D are the 16-bit words of V2, AD is the product of
+ *    A and D, and X || Y is (X << 16) + Y.
+*/
+
+void /* PRIVATE */
+png_64bit_product (long v1, long v2, unsigned long *hi_product,
+    unsigned long *lo_product)
+{
+   int a, b, c, d;
+   long lo, hi, x, y;
+
+   a = (v1 >> 16) & 0xffff;
+   b = v1 & 0xffff;
+   c = (v2 >> 16) & 0xffff;
+   d = v2 & 0xffff;
+
+   lo = b * d;                   /* BD */
+   x = a * d + c * b;            /* AD + CB */
+   y = ((lo >> 16) & 0xffff) + x;
+
+   lo = (lo & 0xffff) | ((y & 0xffff) << 16);
+   hi = (y >> 16) & 0xffff;
+
+   hi += a * c;                  /* AC */
+
+   *hi_product = (unsigned long)hi;
+   *lo_product = (unsigned long)lo;
+}
+#endif /* CHECK_cHRM */
+
+#ifdef PNG_READ_GAMMA_SUPPORTED /* gamma table code */
+#ifndef PNG_FLOATING_ARITHMETIC_SUPPORTED
+/* Fixed point gamma.
+ *
+ * To calculate gamma this code implements fast log() and exp() calls using only
+ * fixed point arithmetic.  This code has sufficient precision for either 8-bit
+ * or 16-bit sample values.
+ *
+ * The tables used here were calculated using simple 'bc' programs, but C double
+ * precision floating point arithmetic would work fine.  The programs are given
+ * at the head of each table.
+ *
+ * 8-bit log table
+ *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to
+ *   255, so it's the base 2 logarithm of a normalized 8-bit floating point
+ *   mantissa.  The numbers are 32-bit fractions.
+ */
+static png_uint_32
+png_8bit_l2[128] =
+{
+#  ifdef PNG_DO_BC
+      for (i=128;i<256;++i) { .5 - l(i/255)/l(2)*65536*65536; }
+#  else
+   4270715492U, 4222494797U, 4174646467U, 4127164793U, 4080044201U, 4033279239U,
+   3986864580U, 3940795015U, 3895065449U, 3849670902U, 3804606499U, 3759867474U,
+   3715449162U, 3671346997U, 3627556511U, 3584073329U, 3540893168U, 3498011834U,
+   3455425220U, 3413129301U, 3371120137U, 3329393864U, 3287946700U, 3246774933U,
+   3205874930U, 3165243125U, 3124876025U, 3084770202U, 3044922296U, 3005329011U,
+   2965987113U, 2926893432U, 2888044853U, 2849438323U, 2811070844U, 2772939474U,
+   2735041326U, 2697373562U, 2659933400U, 2622718104U, 2585724991U, 2548951424U,
+   2512394810U, 2476052606U, 2439922311U, 2404001468U, 2368287663U, 2332778523U,
+   2297471715U, 2262364947U, 2227455964U, 2192742551U, 2158222529U, 2123893754U,
+   2089754119U, 2055801552U, 2022034013U, 1988449497U, 1955046031U, 1921821672U,
+   1888774511U, 1855902668U, 1823204291U, 1790677560U, 1758320682U, 1726131893U,
+   1694109454U, 1662251657U, 1630556815U, 1599023271U, 1567649391U, 1536433567U,
+   1505374214U, 1474469770U, 1443718700U, 1413119487U, 1382670639U, 1352370686U,
+   1322218179U, 1292211689U, 1262349810U, 1232631153U, 1203054352U, 1173618059U,
+   1144320946U, 1115161701U, 1086139034U, 1057251672U, 1028498358U, 999877854U,
+   971388940U, 943030410U, 914801076U, 886699767U, 858725327U, 830876614U,
+   803152505U, 775551890U, 748073672U, 720716771U, 693480120U, 666362667U,
+   639363374U, 612481215U, 585715177U, 559064263U, 532527486U, 506103872U,
+   479792461U, 453592303U, 427502463U, 401522014U, 375650043U, 349885648U,
+   324227938U, 298676034U, 273229066U, 247886176U, 222646516U, 197509248U,
+   172473545U, 147538590U, 122703574U, 97967701U, 73330182U, 48790236U,
+   24347096U, 0U
+#  endif
+
+#if 0
+   /* The following are the values for 16-bit tables - these work fine for the
+    * 8-bit conversions but produce very slightly larger errors in the 16-bit
+    * log (about 1.2 as opposed to 0.7 absolute error in the final value).  To
+    * use these all the shifts below must be adjusted appropriately.
+    */
+   65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,
+   57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,
+   50170, 49542, 48918, 48298, 47682, 47070, 46462, 45858, 45257, 44661, 44068,
+   43479, 42894, 42312, 41733, 41159, 40587, 40020, 39455, 38894, 38336, 37782,
+   37230, 36682, 36137, 35595, 35057, 34521, 33988, 33459, 32932, 32408, 31887,
+   31369, 30854, 30341, 29832, 29325, 28820, 28319, 27820, 27324, 26830, 26339,
+   25850, 25364, 24880, 24399, 23920, 23444, 22970, 22499, 22029, 21562, 21098,
+   20636, 20175, 19718, 19262, 18808, 18357, 17908, 17461, 17016, 16573, 16132,
+   15694, 15257, 14822, 14390, 13959, 13530, 13103, 12678, 12255, 11834, 11415,
+   10997, 10582, 10168, 9756, 9346, 8937, 8531, 8126, 7723, 7321, 6921, 6523,
+   6127, 5732, 5339, 4947, 4557, 4169, 3782, 3397, 3014, 2632, 2251, 1872, 1495,
+   1119, 744, 372
+#endif
+};
+
+PNG_STATIC png_int_32
+png_log8bit(unsigned int x)
+{
+   unsigned int lg2 = 0;
+   /* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,
+    * because the log is actually negate that means adding 1.  The final
+    * returned value thus has the range 0 (for 255 input) to 7.994 (for 1
+    * input), return 7.99998 for the overflow (log 0) case - so the result is
+    * always at most 19 bits.
+    */
+   if ((x &= 0xff) == 0)
+      return 0xffffffff;
+
+   if ((x & 0xf0) == 0)
+      lg2  = 4, x <<= 4;
+
+   if ((x & 0xc0) == 0)
+      lg2 += 2, x <<= 2;
+
+   if ((x & 0x80) == 0)
+      lg2 += 1, x <<= 1;
+
+   /* result is at most 19 bits, so this cast is safe: */
+   return (png_int_32)((lg2 << 16) + ((png_8bit_l2[x-128]+32768)>>16));
+}
+
+/* The above gives exact (to 16 binary places) log2 values for 8-bit images,
+ * for 16-bit images we use the most significant 8 bits of the 16-bit value to
+ * get an approximation then multiply the approximation by a correction factor
+ * determined by the remaining up to 8 bits.  This requires an additional step
+ * in the 16-bit case.
+ *
+ * We want log2(value/65535), we have log2(v'/255), where:
+ *
+ *    value = v' * 256 + v''
+ *          = v' * f
+ *
+ * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128
+ * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less
+ * than 258.  The final factor also needs to correct for the fact that our 8-bit
+ * value is scaled by 255, whereas the 16-bit values must be scaled by 65535.
+ *
+ * This gives a final formula using a calculated value 'x' which is value/v' and
+ * scaling by 65536 to match the above table:
+ *
+ *   log2(x/257) * 65536
+ *
+ * Since these numbers are so close to '1' we can use simple linear
+ * interpolation between the two end values 256/257 (result -368.61) and 258/257
+ * (result 367.179).  The values used below are scaled by a further 64 to give
+ * 16-bit precision in the interpolation:
+ *
+ * Start (256): -23591
+ * Zero  (257):      0
+ * End   (258):  23499
+ */
+PNG_STATIC png_int_32
+png_log16bit(png_uint_32 x)
+{
+   unsigned int lg2 = 0;
+
+   /* As above, but now the input has 16 bits. */
+   if ((x &= 0xffff) == 0)
+      return 0xffffffff;
+
+   if ((x & 0xff00) == 0)
+      lg2  = 8, x <<= 8;
+
+   if ((x & 0xf000) == 0)
+      lg2 += 4, x <<= 4;
+
+   if ((x & 0xc000) == 0)
+      lg2 += 2, x <<= 2;
+
+   if ((x & 0x8000) == 0)
+      lg2 += 1, x <<= 1;
+
+   /* Calculate the base logarithm from the top 8 bits as a 28-bit fractional
+    * value.
+    */
+   lg2 <<= 28;
+   lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;
+
+   /* Now we need to interpolate the factor, this requires a division by the top
+    * 8 bits.  Do this with maximum precision.
+    */
+   x = ((x << 16) + (x >> 9)) / (x >> 8);
+
+   /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,
+    * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly
+    * 16 bits to interpolate to get the low bits of the result.  Round the
+    * answer.  Note that the end point values are scaled by 64 to retain overall
+    * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust
+    * the overall scaling by 6-12.  Round at every step.
+    */
+   x -= 1U << 24;
+
+   if (x <= 65536U) /* <= '257' */
+      lg2 += ((23591U * (65536U-x)) + (1U << (16+6-12-1))) >> (16+6-12);
+
+   else
+      lg2 -= ((23499U * (x-65536U)) + (1U << (16+6-12-1))) >> (16+6-12);
+
+   /* Safe, because the result can't have more than 20 bits: */
+   return (png_int_32)((lg2 + 2048) >> 12);
+}
+
+/* The 'exp()' case must invert the above, taking a 20-bit fixed point
+ * logarithmic value and returning a 16 or 8-bit number as appropriate.  In
+ * each case only the low 16 bits are relevant - the fraction - since the
+ * integer bits (the top 4) simply determine a shift.
+ *
+ * The worst case is the 16-bit distinction between 65535 and 65534, this
+ * requires perhaps spurious accuracy in the decoding of the logarithm to
+ * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance
+ * of getting this accuracy in practice.
+ *
+ * To deal with this the following exp() function works out the exponent of the
+ * frational part of the logarithm by using an accurate 32-bit value from the
+ * top four fractional bits then multiplying in the remaining bits.
+ */
+static png_uint_32
+png_32bit_exp[16] =
+{
+#  ifdef PNG_DO_BC
+      for (i=0;i<16;++i) { .5 + e(-i/16*l(2))*2^32; }
+#  else
+   /* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
+   4294967295U, 4112874773U, 3938502376U, 3771522796U, 3611622603U, 3458501653U,
+   3311872529U, 3171459999U, 3037000500U, 2908241642U, 2784941738U, 2666869345U,
+   2553802834U, 2445529972U, 2341847524U, 2242560872U
+#  endif
+};
+
+/* Adjustment table; provided to explain the numbers in the code below. */
+#ifdef PNG_DO_BC
+for (i=11;i>=0;--i){ print i, " ", (1 - e(-(2^i)/65536*l(2))) * 2^(32-i), "\n"}
+   11 44937.64284865548751208448
+   10 45180.98734845585101160448
+    9 45303.31936980687359311872
+    8 45364.65110595323018870784
+    7 45395.35850361789624614912
+    6 45410.72259715102037508096
+    5 45418.40724413220722311168
+    4 45422.25021786898173001728
+    3 45424.17186732298419044352
+    2 45425.13273269940811464704
+    1 45425.61317555035558641664
+    0 45425.85339951654943850496
+#endif
+
+PNG_STATIC png_uint_32
+png_exp(png_fixed_point x)
+{
+   if (x > 0 && x <= 0xfffff) /* Else overflow or zero (underflow) */
+   {
+      /* Obtain a 4-bit approximation */
+      png_uint_32 e = png_32bit_exp[(x >> 12) & 0xf];
+
+      /* Incorporate the low 12 bits - these decrease the returned value by
+       * multiplying by a number less than 1 if the bit is set.  The multiplier
+       * is determined by the above table and the shift. Notice that the values
+       * converge on 45426 and this is used to allow linear interpolation of the
+       * low bits.
+       */
+      if (x & 0x800)
+         e -= (((e >> 16) * 44938U) +  16U) >> 5;
+
+      if (x & 0x400)
+         e -= (((e >> 16) * 45181U) +  32U) >> 6;
+
+      if (x & 0x200)
+         e -= (((e >> 16) * 45303U) +  64U) >> 7;
+
+      if (x & 0x100)
+         e -= (((e >> 16) * 45365U) + 128U) >> 8;
+
+      if (x & 0x080)
+         e -= (((e >> 16) * 45395U) + 256U) >> 9;
+
+      if (x & 0x040)
+         e -= (((e >> 16) * 45410U) + 512U) >> 10;
+
+      /* And handle the low 6 bits in a single block. */
+      e -= (((e >> 16) * 355U * (x & 0x3fU)) + 256U) >> 9;
+
+      /* Handle the upper bits of x. */
+      e >>= x >> 16;
+      return e;
+   }
+
+   /* Check for overflow */
+   if (x <= 0)
+      return png_32bit_exp[0];
+
+   /* Else underflow */
+   return 0;
+}
+
+PNG_STATIC png_byte
+png_exp8bit(png_fixed_point lg2)
+{
+   /* Get a 32-bit value: */
+   png_uint_32 x = png_exp(lg2);
+
+   /* Convert the 32-bit value to 0..255 by multiplying by 256-1, note that the
+    * second, rounding, step can't overflow because of the first, subtraction,
+    * step.
+    */
+   x -= x >> 8;
+   return (png_byte)((x + 0x7fffffU) >> 24);
+}
+
+PNG_STATIC png_uint_16
+png_exp16bit(png_fixed_point lg2)
+{
+   /* Get a 32-bit value: */
+   png_uint_32 x = png_exp(lg2);
+
+   /* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
+   x -= x >> 16;
+   return (png_uint_16)((x + 32767U) >> 16);
+}
+#endif /* FLOATING_ARITHMETIC */
+
+png_byte
+png_gamma_8bit_correct(unsigned int value, png_fixed_point gamma_val)
+{
+   if (value > 0 && value < 255)
+   {
+#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
+         double r = floor(255*pow(value/255.,gamma_val*.00001)+.5);
+         return (png_byte)r;
+#     else
+         png_int_32 lg2 = png_log8bit(value);
+         png_fixed_point res;
+
+         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1))
+            return png_exp8bit(res);
+
+         /* Overflow. */
+         value = 0;
+#     endif
+   }
+
+   return (png_byte)value;
+}
+
+png_uint_16
+png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
+{
+   if (value > 0 && value < 65535)
+   {
+#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
+         double r = floor(65535*pow(value/65535.,gamma_val*.00001)+.5);
+         return (png_uint_16)r;
+#     else
+         png_int_32 lg2 = png_log16bit(value);
+         png_fixed_point res;
+
+         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1))
+            return png_exp16bit(res);
+
+         /* Overflow. */
+         value = 0;
+#     endif
+   }
+
+   return (png_uint_16)value;
+}
+
+/* This does the right thing based on the bit_depth field of the
+ * png_struct, interpreting values as 8-bit or 16-bit.  While the result
+ * is nominally a 16-bit value if bit depth is 8 then the result is
+ * 8-bit (as are the arguments.)
+ */
+png_uint_16 /* PRIVATE */
+png_gamma_correct(png_structp png_ptr, unsigned int value,
+    png_fixed_point gamma_val)
+{
+   if (png_ptr->bit_depth == 8)
+      return png_gamma_8bit_correct(value, gamma_val);
+
+   else
+      return png_gamma_16bit_correct(value, gamma_val);
+}
+
+/* This is the shared test on whether a gamma value is 'significant' - whether
+ * it is worth doing gamma correction.
+ */
+int /* PRIVATE */
+png_gamma_significant(png_fixed_point gamma_val)
+{
+   return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
+       gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
+}
+
+/* Internal function to build a single 16-bit table - the table consists of
+ * 'num' 256-entry subtables, where 'num' is determined by 'shift' - the amount
+ * to shift the input values right (or 16-number_of_signifiant_bits).
+ *
+ * The caller is responsible for ensuring that the table gets cleaned up on
+ * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument
+ * should be somewhere that will be cleaned.
+ */
+static void
+png_build_16bit_table(png_structp png_ptr, png_uint_16pp *ptable,
+   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
+{
+   /* Various values derived from 'shift': */
+   PNG_CONST unsigned int num = 1U << (8U - shift);
+   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
+   PNG_CONST unsigned int max_by_2 = 1U << (15U-shift);
+   unsigned int i;
+
+   png_uint_16pp table = *ptable =
+       (png_uint_16pp)png_calloc(png_ptr, num * png_sizeof(png_uint_16p));
+
+   for (i = 0; i < num; i++)
+   {
+      png_uint_16p sub_table = table[i] =
+          (png_uint_16p)png_malloc(png_ptr, 256 * png_sizeof(png_uint_16));
+
+      /* The 'threshold' test is repeated here because it can arise for one of
+       * the 16-bit tables even if the others don't hit it.
+       */
+      if (png_gamma_significant(gamma_val))
+      {
+         /* The old code would overflow at the end and this would cause the
+          * 'pow' function to return a result >1, resulting in an
+          * arithmetic error.  This code follows the spec exactly; ig is
+          * the recovered input sample, it always has 8-16 bits.
+          *
+          * We want input * 65535/max, rounded, the arithmetic fits in 32
+          * bits (unsigned) so long as max <= 32767.
+          */
+         unsigned int j;
+         for (j = 0; j < 256; j++)
+         {
+            png_uint_32 ig = (j << (8-shift)) + i;
+#           ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
+               /* Inline the 'max' scaling operation: */
+               double d = floor(65535*pow(ig/(double)max, gamma_val*.00001)+.5);
+               sub_table[j] = (png_uint_16)d;
+#           else
+               if (shift)
+                  ig = (ig * 65535U + max_by_2)/max;
+
+               sub_table[j] = png_gamma_16bit_correct(ig, gamma_val);
+#           endif
+         }
+      }
+      else
+      {
+         /* We must still build a table, but do it the fast way. */
+         unsigned int j;
+
+         for (j = 0; j < 256; j++)
+         {
+            png_uint_32 ig = (j << (8-shift)) + i;
+
+            if (shift)
+               ig = (ig * 65535U + max_by_2)/max;
+
+            sub_table[j] = (png_uint_16)ig;
+         }
+      }
+   }
+}
+
+/* NOTE: this function expects the *inverse* of the overall gamma transformation
+ * required.
+ */
+static void
+png_build_16to8_table(png_structp png_ptr, png_uint_16pp *ptable,
+   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
+{
+   PNG_CONST unsigned int num = 1U << (8U - shift);
+   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
+   unsigned int i;
+   png_uint_32 last;
+
+   png_uint_16pp table = *ptable =
+       (png_uint_16pp)png_calloc(png_ptr, num * png_sizeof(png_uint_16p));
+
+   /* 'num' is the number of tables and also the number of low bits of the
+    * input 16-bit value used to select a table.  Each table is itself indexed
+    * by the high 8 bits of the value.
+    */
+   for (i = 0; i < num; i++)
+      table[i] = (png_uint_16p)png_malloc(png_ptr,
+          256 * png_sizeof(png_uint_16));
+
+   /* 'gamma_val' is set to the reciprocal of the value calculated above, so
+    * pow(out,g) is an *input* value.  'last' is the last input value set.
+    *
+    * In the loop 'i' is used to find output values.  Since the output is
+    * 8-bit there are only 256 possible values.  The tables are set up to
+    * select the closest possible output value for each input by finding
+    * the input value at the boundary between each pair of output values
+    * and filling the table up to that boundary with the lower output
+    * value.
+    *
+    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit
+    * values the code below uses a 16-bit value in i; the values start at
+    * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last
+    * entries are filled with 255).  Start i at 128 and fill all 'last'
+    * table entries <= 'max'
+    */
+   last = 0;
+   for (i = 0; i < 255; ++i) /* 8-bit output value */
+   {
+      /* Find the corresponding maximum input value */
+      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */
+
+      /* Find the boundary value in 16 bits: */
+      png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);
+
+      /* Adjust (round) to (16-shift) bits: */
+      bound = (bound * max + 32768U)/65535U + 1U;
+
+      while (last < bound)
+      {
+         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;
+         last++;
+      }
+   }
+
+   /* And fill in the final entries. */
+   while (last < (num << 8))
+   {
+      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;
+      last++;
+   }
+}
+
+/* Build a single 8-bit table: same as the 16-bit case but much simpler (and
+ * typically much faster).  Note that libpng currently does no sBIT processing
+ * (apparently contrary to the spec) so a 256-entry table is always generated.
+ */
+static void
+png_build_8bit_table(png_structp png_ptr, png_bytepp ptable,
+   PNG_CONST png_fixed_point gamma_val)
+{
+   unsigned int i;
+   png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);
+
+   if (png_gamma_significant(gamma_val)) for (i=0; i<256; i++)
+      table[i] = png_gamma_8bit_correct(i, gamma_val);
+
+   else for (i=0; i<256; ++i)
+      table[i] = (png_byte)i;
+}
+
+/* Used from png_read_destroy and below to release the memory used by the gamma
+ * tables.
+ */
+void /* PRIVATE */
+png_destroy_gamma_table(png_structp png_ptr)
+{
+   png_free(png_ptr, png_ptr->gamma_table);
+   png_ptr->gamma_table = NULL;
+
+   if (png_ptr->gamma_16_table != NULL)
+   {
+      int i;
+      int istop = (1 << (8 - png_ptr->gamma_shift));
+      for (i = 0; i < istop; i++)
+      {
+         png_free(png_ptr, png_ptr->gamma_16_table[i]);
+      }
+   png_free(png_ptr, png_ptr->gamma_16_table);
+   png_ptr->gamma_16_table = NULL;
+   }
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
+   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+   png_free(png_ptr, png_ptr->gamma_from_1);
+   png_ptr->gamma_from_1 = NULL;
+   png_free(png_ptr, png_ptr->gamma_to_1);
+   png_ptr->gamma_to_1 = NULL;
+
+   if (png_ptr->gamma_16_from_1 != NULL)
+   {
+      int i;
+      int istop = (1 << (8 - png_ptr->gamma_shift));
+      for (i = 0; i < istop; i++)
+      {
+         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
+      }
+   png_free(png_ptr, png_ptr->gamma_16_from_1);
+   png_ptr->gamma_16_from_1 = NULL;
+   }
+   if (png_ptr->gamma_16_to_1 != NULL)
+   {
+      int i;
+      int istop = (1 << (8 - png_ptr->gamma_shift));
+      for (i = 0; i < istop; i++)
+      {
+         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
+      }
+   png_free(png_ptr, png_ptr->gamma_16_to_1);
+   png_ptr->gamma_16_to_1 = NULL;
+   }
+#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
+}
+
+/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
+ * tables, we don't make a full table if we are reducing to 8-bit in
+ * the future.  Note also how the gamma_16 tables are segmented so that
+ * we don't need to allocate > 64K chunks for a full 16-bit table.
+ */
+void /* PRIVATE */
+png_build_gamma_table(png_structp png_ptr, int bit_depth)
+{
+  png_debug(1, "in png_build_gamma_table");
+
+  /* Remove any existing table; this copes with multiple calls to
+   * png_read_update_info.  The warning is because building the gamma tables
+   * multiple times is a performance hit - it's harmless but the ability to call
+   * png_read_update_info() multiple times is new in 1.5.6 so it seems sensible
+   * to warn if the app introduces such a hit.
+   */
+  if (png_ptr->gamma_table != NULL || png_ptr->gamma_16_table != NULL)
+  {
+    png_warning(png_ptr, "gamma table being rebuilt");
+    png_destroy_gamma_table(png_ptr);
+  }
+
+  if (bit_depth <= 8)
+  {
+     png_build_8bit_table(png_ptr, &png_ptr->gamma_table,
+         png_ptr->screen_gamma > 0 ?  png_reciprocal2(png_ptr->gamma,
+         png_ptr->screen_gamma) : PNG_FP_1);
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
+   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))
+     {
+        png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1,
+            png_reciprocal(png_ptr->gamma));
+
+        png_build_8bit_table(png_ptr, &png_ptr->gamma_from_1,
+            png_ptr->screen_gamma > 0 ?  png_reciprocal(png_ptr->screen_gamma) :
+            png_ptr->gamma/* Probably doing rgb_to_gray */);
+     }
+#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
+  }
+  else
+  {
+     png_byte shift, sig_bit;
+
+     if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
+     {
+        sig_bit = png_ptr->sig_bit.red;
+
+        if (png_ptr->sig_bit.green > sig_bit)
+           sig_bit = png_ptr->sig_bit.green;
+
+        if (png_ptr->sig_bit.blue > sig_bit)
+           sig_bit = png_ptr->sig_bit.blue;
+     }
+     else
+        sig_bit = png_ptr->sig_bit.gray;
+
+     /* 16-bit gamma code uses this equation:
+      *
+      *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]
+      *
+      * Where 'iv' is the input color value and 'ov' is the output value -
+      * pow(iv, gamma).
+      *
+      * Thus the gamma table consists of up to 256 256-entry tables.  The table
+      * is selected by the (8-gamma_shift) most significant of the low 8 bits of
+      * the color value then indexed by the upper 8 bits:
+      *
+      *   table[low bits][high 8 bits]
+      *
+      * So the table 'n' corresponds to all those 'iv' of:
+      *
+      *   <all high 8-bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>
+      *
+      */
+     if (sig_bit > 0 && sig_bit < 16U)
+        shift = (png_byte)(16U - sig_bit); /* shift == insignificant bits */
+
+     else
+        shift = 0; /* keep all 16 bits */
+
+     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))
+     {
+        /* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively
+         * the significant bits in the *input* when the output will
+         * eventually be 8 bits.  By default it is 11.
+         */
+        if (shift < (16U - PNG_MAX_GAMMA_8))
+           shift = (16U - PNG_MAX_GAMMA_8);
+     }
+
+     if (shift > 8U)
+        shift = 8U; /* Guarantees at least one table! */
+
+     png_ptr->gamma_shift = shift;
+
+#ifdef PNG_16BIT_SUPPORTED
+     /* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now
+      * PNG_COMPOSE).  This effectively smashed the background calculation for
+      * 16-bit output because the 8-bit table assumes the result will be reduced
+      * to 8 bits.
+      */
+     if (png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8))
+#endif
+         png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,
+         png_ptr->screen_gamma > 0 ? png_product2(png_ptr->gamma,
+         png_ptr->screen_gamma) : PNG_FP_1);
+
+#ifdef PNG_16BIT_SUPPORTED
+     else
+         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,
+         png_ptr->screen_gamma > 0 ? png_reciprocal2(png_ptr->gamma,
+         png_ptr->screen_gamma) : PNG_FP_1);
+#endif
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
+   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
+     if (png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY))
+     {
+        png_build_16bit_table(png_ptr, &png_ptr->gamma_16_to_1, shift,
+            png_reciprocal(png_ptr->gamma));
+
+        /* Notice that the '16 from 1' table should be full precision, however
+         * the lookup on this table still uses gamma_shift, so it can't be.
+         * TODO: fix this.
+         */
+        png_build_16bit_table(png_ptr, &png_ptr->gamma_16_from_1, shift,
+            png_ptr->screen_gamma > 0 ? png_reciprocal(png_ptr->screen_gamma) :
+            png_ptr->gamma/* Probably doing rgb_to_gray */);
+     }
+#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
+  }
+}
+#endif /* READ_GAMMA */
+#endif /* defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED) */
diff -urN a/media/libpng/png.h b/media/libpng/png.h
--- a/media/libpng/png.h	2012-07-11 03:33:19 +0800
+++ b/media/libpng/png.h	2012-07-13 12:40:57 +0800
@@ -1,7 +1,7 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.5.9 - February 18, 2012
+ * libpng version 1.5.12 - July 11, 2012
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -11,7 +11,7 @@
  * Authors and maintainers:
  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *   libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *   libpng versions 0.97, January 1998, through 1.5.9 - February 18, 2012: Glenn
+ *   libpng versions 0.97, January 1998, through 1.5.12 - July 11, 2012: Glenn
  *   See also "Contributing Authors", below.
  *
  * Note about libpng version numbers:
@@ -172,6 +172,11 @@
  *    1.5.9beta01-02          15    10509  15.so.15.9[.0]
  *    1.5.9rc01               15    10509  15.so.15.9[.0]
  *    1.5.9                   15    10509  15.so.15.9[.0]
+ *    1.5.10beta01-05         15    10510  15.so.15.10[.0]
+ *    1.5.10                  15    10510  15.so.15.10[.0]
+ *    1.5.11beta01            15    10511  15.so.15.11[.0]
+ *    1.5.11                  15    10511  15.so.15.11[.0]
+ *    1.5.12                  15    10512  15.so.15.12[.0]
  *
  *   Henceforth the source version will match the shared-library major
  *   and minor numbers; the shared-library major version number will be
@@ -181,7 +186,7 @@
  *   to the source version x.y.z (leading zeros in y and z).  Beta versions
  *   were given the previous public release number plus a letter, until
  *   version 1.0.6j; from then on they were given the upcoming public
- *   release number plus "betaNN" or "rcN".
+ *   release number plus "betaNN" or "rcNN".
  *
  *   Binary incompatibility exists only when applications make direct access
  *   to the info_ptr or png_ptr members through png.h, and the compiled
@@ -203,7 +208,7 @@
  *
  * This code is released under the libpng license.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.5.9, February 18, 2012, are
+ * libpng versions 1.2.6, August 15, 2004, through 1.5.12, July 11, 2012, are
  * Copyright (c) 2004, 2006-2012 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.2.5
  * with the following individual added to the list of Contributing Authors:
@@ -315,13 +320,13 @@
  * Y2K compliance in libpng:
  * =========================
  *
- *    February 18, 2012
+ *    July 11, 2012
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.5.9 are Y2K compliant.  It is my belief that
+ *    upward through 1.5.12 are Y2K compliant.  It is my belief that
  *    earlier versions were also Y2K compliant.
  *
  *    Libpng only has two year fields.  One is a 2-byte unsigned integer
@@ -332,7 +337,8 @@
  *        "png_uint_16 year" in png_time_struct.
  *
  *    The string is
- *        "png_char time_buffer" in png_struct
+ *        "char time_buffer[29]" in png_struct.  This will be no
+ *    longer used in libpng-1.6.0 and will be removed from libpng-1.7.0.
  *
  *    There are seven time-related functions:
  *        png.c: png_convert_to_rfc_1123() in png.c
@@ -379,9 +385,9 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.5.9"
+#define PNG_LIBPNG_VER_STRING "1.5.12"
 #define PNG_HEADER_VERSION_STRING \
-     " libpng version 1.5.9 - February 18, 2012\n"
+     " libpng version 1.5.12 - July 11, 2012\n"
 
 #define PNG_LIBPNG_VER_SONUM   15
 #define PNG_LIBPNG_VER_DLLNUM  15
@@ -389,7 +395,7 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   5
-#define PNG_LIBPNG_VER_RELEASE 9
+#define PNG_LIBPNG_VER_RELEASE 12
 
 /* This should match the numeric part of the final component of
  * PNG_LIBPNG_VER_STRING, omitting any leading zero:
@@ -412,7 +418,7 @@
 #define PNG_LIBPNG_BUILD_SPECIAL 32 /* Cannot be OR'ed with
                                        PNG_LIBPNG_BUILD_PRIVATE */
 
-#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_BETA
+#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE
 
 /* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
  * We must not include leading zeros.
@@ -420,12 +426,22 @@
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
  */
-#define PNG_LIBPNG_VER 10509 /* 1.5.9 */
+#define PNG_LIBPNG_VER 10512 /* 1.5.12 */
 
-#ifndef MOZPNGCONF_H
-#   include "mozpngconf.h"
+/* Library configuration: these options cannot be changed after
+ * the library has been built.
+ */
+#ifndef PNGLCONF_H
+    /* If pnglibconf.h is missing, you can
+     * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
+     */
+#   include "pnglibconf.h"
 #endif
 
+#define PNG_APNG_SUPPORTED
+#define PNG_READ_APNG_SUPPORTED
+#define PNG_WRITE_APNG_SUPPORTED
+
 #ifndef PNG_VERSION_INFO_ONLY
 #  ifndef PNG_BUILDING_SYMBOL_TABLE
   /*
@@ -547,7 +563,7 @@
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef char* png_libpng_version_1_5_9;
+typedef char* png_libpng_version_1_5_12;
 
 /* Three color definitions.  The order of the red, green, and blue, (and the
  * exact size) is not important, although the size of the fields need to
@@ -2650,71 +2666,77 @@
       : (png_int_32)png_get_uint_32(buf)))
 #endif
 
+#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+PNG_EXPORT(234, void, png_set_check_for_invalid_index, (png_structp png_ptr,
+    int allowed));
+#endif
+
 #ifdef PNG_APNG_SUPPORTED
-PNG_EXPORT(234, png_uint_32, png_get_acTL, (png_structp png_ptr,
+PNG_EXPORT(235, png_uint_32, png_get_acTL, (png_structp png_ptr,
    png_infop info_ptr, png_uint_32 *num_frames, png_uint_32 *num_plays));
 
-PNG_EXPORT(235, png_uint_32, png_set_acTL, (png_structp png_ptr,
+PNG_EXPORT(236, png_uint_32, png_set_acTL, (png_structp png_ptr,
    png_infop info_ptr, png_uint_32 num_frames, png_uint_32 num_plays));
 
-PNG_EXPORT(236, png_uint_32, png_get_num_frames, (png_structp png_ptr,
+PNG_EXPORT(237, png_uint_32, png_get_num_frames, (png_structp png_ptr,
    png_infop info_ptr));
 
-PNG_EXPORT(237, png_uint_32, png_get_num_plays, (png_structp png_ptr,
+PNG_EXPORT(238, png_uint_32, png_get_num_plays, (png_structp png_ptr,
    png_infop info_ptr));
 
-PNG_EXPORT(238, png_uint_32, png_get_next_frame_fcTL,
+PNG_EXPORT(239, png_uint_32, png_get_next_frame_fcTL,
    (png_structp png_ptr, png_infop info_ptr, png_uint_32 *width,
    png_uint_32 *height, png_uint_32 *x_offset, png_uint_32 *y_offset,
    png_uint_16 *delay_num, png_uint_16 *delay_den, png_byte *dispose_op,
    png_byte *blend_op));
 
-PNG_EXPORT(239, png_uint_32, png_set_next_frame_fcTL,
+PNG_EXPORT(240, png_uint_32, png_set_next_frame_fcTL,
    (png_structp png_ptr, png_infop info_ptr, png_uint_32 width,
    png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset,
    png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
    png_byte blend_op));
 
-PNG_EXPORT(240, png_uint_32, png_get_next_frame_width,
+PNG_EXPORT(241, png_uint_32, png_get_next_frame_width,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(241, png_uint_32, png_get_next_frame_height,
+PNG_EXPORT(242, png_uint_32, png_get_next_frame_height,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(242, png_uint_32, png_get_next_frame_x_offset,
+PNG_EXPORT(243, png_uint_32, png_get_next_frame_x_offset,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(243, png_uint_32, png_get_next_frame_y_offset,
+PNG_EXPORT(244, png_uint_32, png_get_next_frame_y_offset,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(244, png_uint_16, png_get_next_frame_delay_num,
+PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_num,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_den,
+PNG_EXPORT(246, png_uint_16, png_get_next_frame_delay_den,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(246, png_byte, png_get_next_frame_dispose_op,
+PNG_EXPORT(247, png_byte, png_get_next_frame_dispose_op,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(247, png_byte, png_get_next_frame_blend_op,
+PNG_EXPORT(248, png_byte, png_get_next_frame_blend_op,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(248, png_byte, png_get_first_frame_is_hidden,
+PNG_EXPORT(249, png_byte, png_get_first_frame_is_hidden,
    (png_structp png_ptr, png_infop info_ptr));
-PNG_EXPORT(249, png_uint_32, png_set_first_frame_is_hidden,
+PNG_EXPORT(250, png_uint_32, png_set_first_frame_is_hidden,
    (png_structp png_ptr, png_infop info_ptr, png_byte is_hidden));
 
 #ifdef PNG_READ_APNG_SUPPORTED
-PNG_EXPORT(250, void, png_read_frame_head, (png_structp png_ptr,
+PNG_EXPORT(251, void, png_read_frame_head, (png_structp png_ptr,
    png_infop info_ptr));
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-PNG_EXPORT(251, void, png_set_progressive_frame_fn, (png_structp png_ptr,
+PNG_EXPORT(252, void, png_set_progressive_frame_fn, (png_structp png_ptr,
    png_progressive_frame_ptr frame_info_fn,
    png_progressive_frame_ptr frame_end_fn));
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 #endif /* PNG_READ_APNG_SUPPORTED */
 
 #ifdef PNG_WRITE_APNG_SUPPORTED
-PNG_EXPORT(252, void, png_write_frame_head, (png_structp png_ptr,
+PNG_EXPORT(253, void, png_write_frame_head, (png_structp png_ptr,
    png_infop info_ptr, png_bytepp row_pointers,
    png_uint_32 width, png_uint_32 height,
    png_uint_32 x_offset, png_uint_32 y_offset,
    png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
    png_byte blend_op));
 
-PNG_EXPORT(253, void, png_write_frame_tail, (png_structp png_ptr,
+PNG_EXPORT(254, void, png_write_frame_tail, (png_structp png_ptr,
    png_infop info_ptr));
 #endif /* PNG_WRITE_APNG_SUPPORTED */
 #endif /* PNG_APNG_SUPPORTED */
@@ -2729,9 +2751,9 @@
  */
 #ifdef PNG_EXPORT_LAST_ORDINAL
 #ifdef PNG_APNG_SUPPORTED
-  PNG_EXPORT_LAST_ORDINAL(253);
+  PNG_EXPORT_LAST_ORDINAL(254);
 #else
-  PNG_EXPORT_LAST_ORDINAL(233);
+  PNG_EXPORT_LAST_ORDINAL(234);
 #endif /* PNG_APNG_SUPPORTED */
 #endif
 
diff -urN a/media/libpng/pngconf.h b/media/libpng/pngconf.h
--- a/media/libpng/pngconf.h	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngconf.h	2012-07-13 12:40:57 +0800
@@ -1,596 +1,596 @@
-
-/* pngconf.h - machine configurable file for libpng
- *
- * libpng version 1.5.9 - February 18, 2012
- *
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- */
-
-/* Any machine specific code is near the front of this file, so if you
- * are configuring libpng for a machine, you may want to read the section
- * starting here down to where it starts to typedef png_color, png_text,
- * and png_info.
- */
-
-#ifndef PNGCONF_H
-#define PNGCONF_H
-
-#ifndef PNG_BUILDING_SYMBOL_TABLE
-/* PNG_NO_LIMITS_H may be used to turn off the use of the standard C
- * definition file for  machine specific limits, this may impact the
- * correctness of the definitons below (see uses of INT_MAX).
- */
-#  ifndef PNG_NO_LIMITS_H
-#    include <limits.h>
-#  endif
-
-/* For the memory copy APIs (i.e. the standard definitions of these),
- * because this file defines png_memcpy and so on the base APIs must
- * be defined here.
- */
-#  ifdef BSD
-#    include <strings.h>
-#  else
-#    include <string.h>
-#  endif
-
-/* For png_FILE_p - this provides the standard definition of a
- * FILE
- */
-#  ifdef PNG_STDIO_SUPPORTED
-#    include <stdio.h>
-#  endif
-#endif
-
-/* This controls optimization of the reading of 16 and 32 bit values
- * from PNG files.  It can be set on a per-app-file basis - it
- * just changes whether a macro is used to the function is called.
- * The library builder sets the default, if read functions are not
- * built into the library the macro implementation is forced on.
- */
-#ifndef PNG_READ_INT_FUNCTIONS_SUPPORTED
-#  define PNG_USE_READ_MACROS
-#endif
-#if !defined(PNG_NO_USE_READ_MACROS) && !defined(PNG_USE_READ_MACROS)
-#  if PNG_DEFAULT_READ_MACROS
-#    define PNG_USE_READ_MACROS
-#  endif
-#endif
-
-/* COMPILER SPECIFIC OPTIONS.
- *
- * These options are provided so that a variety of difficult compilers
- * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
- * below) but still have compiler specific implementations, others
- * may be changed on a per-file basis when compiling against libpng.
- */
-
-/* The PNGARG macro protects us against machines that don't have function
- * prototypes (ie K&R style headers).  If your compiler does not handle
- * function prototypes, define this macro and use the included ansi2knr.
- * I've always been able to use _NO_PROTO as the indicator, but you may
- * need to drag the empty declaration out in front of here, or change the
- * ifdef to suit your own needs.
- */
-#ifndef PNGARG
-
-#  ifdef OF /* zlib prototype munger */
-#    define PNGARG(arglist) OF(arglist)
-#  else
-
-#    ifdef _NO_PROTO
-#      define PNGARG(arglist) ()
-#    else
-#      define PNGARG(arglist) arglist
-#    endif /* _NO_PROTO */
-
-#  endif /* OF */
-
-#endif /* PNGARG */
-
-/* Function calling conventions.
- * =============================
- * Normally it is not necessary to specify to the compiler how to call
- * a function - it just does it - however on x86 systems derived from
- * Microsoft and Borland C compilers ('IBM PC', 'DOS', 'Windows' systems
- * and some others) there are multiple ways to call a function and the
- * default can be changed on the compiler command line.  For this reason
- * libpng specifies the calling convention of every exported function and
- * every function called via a user supplied function pointer.  This is
- * done in this file by defining the following macros:
- *
- * PNGAPI    Calling convention for exported functions.
- * PNGCBAPI  Calling convention for user provided (callback) functions.
- * PNGCAPI   Calling convention used by the ANSI-C library (required
- *           for longjmp callbacks and sometimes used internally to
- *           specify the calling convention for zlib).
- *
- * These macros should never be overridden.  If it is necessary to
- * change calling convention in a private build this can be done
- * by setting PNG_API_RULE (which defaults to 0) to one of the values
- * below to select the correct 'API' variants.
- *
- * PNG_API_RULE=0 Use PNGCAPI - the 'C' calling convention - throughout.
- *                This is correct in every known environment.
- * PNG_API_RULE=1 Use the operating system convention for PNGAPI and
- *                the 'C' calling convention (from PNGCAPI) for
- *                callbacks (PNGCBAPI).  This is no longer required
- *                in any known environment - if it has to be used
- *                please post an explanation of the problem to the
- *                libpng mailing list.
- *
- * These cases only differ if the operating system does not use the C
- * calling convention, at present this just means the above cases
- * (x86 DOS/Windows sytems) and, even then, this does not apply to
- * Cygwin running on those systems.
- *
- * Note that the value must be defined in pnglibconf.h so that what
- * the application uses to call the library matches the conventions
- * set when building the library.
- */
-
-/* Symbol export
- * =============
- * When building a shared library it is almost always necessary to tell
- * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
- * is used to mark the symbols.  On some systems these symbols can be
- * extracted at link time and need no special processing by the compiler,
- * on other systems the symbols are flagged by the compiler and just
- * the declaration requires a special tag applied (unfortunately) in a
- * compiler dependent way.  Some systems can do either.
- *
- * A small number of older systems also require a symbol from a DLL to
- * be flagged to the program that calls it.  This is a problem because
- * we do not know in the header file included by application code that
- * the symbol will come from a shared library, as opposed to a statically
- * linked one.  For this reason the application must tell us by setting
- * the magic flag PNG_USE_DLL to turn on the special processing before
- * it includes png.h.
- *
- * Four additional macros are used to make this happen:
- *
- * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
- *            the build or imported if PNG_USE_DLL is set - compiler
- *            and system specific.
- *
- * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
- *                       'type', compiler specific.
- *
- * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
- *                make a symbol exported from the DLL.  Not used in the
- *                public header files; see pngpriv.h for how it is used
- *                in the libpng build.
- *
- * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
- *                from a DLL - used to define PNG_IMPEXP when
- *                PNG_USE_DLL is set.
- */
-
-/* System specific discovery.
- * ==========================
- * This code is used at build time to find PNG_IMPEXP, the API settings
- * and PNG_EXPORT_TYPE(), it may also set a macro to indicate the DLL
- * import processing is possible.  On Windows/x86 systems it also sets
- * compiler-specific macros to the values required to change the calling
- * conventions of the various functions.
- */
-#if ( defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
-      defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__) ) &&\
-    ( defined(_X86_) || defined(_X64_) || defined(_M_IX86) ||\
-      defined(_M_X64) || defined(_M_IA64) )
-  /* Windows system (DOS doesn't support DLLs) running on x86/x64.  Includes
-   * builds under Cygwin or MinGW.  Also includes Watcom builds but these need
-   * special treatment because they are not compatible with GCC or Visual C
-   * because of different calling conventions.
-   */
-#  if PNG_API_RULE == 2
-    /* If this line results in an error, either because __watcall is not
-     * understood or because of a redefine just below you cannot use *this*
-     * build of the library with the compiler you are using.  *This* build was
-     * build using Watcom and applications must also be built using Watcom!
-     */
-#    define PNGCAPI __watcall
-#  endif
-
-#  if defined(__GNUC__) || (defined (_MSC_VER) && (_MSC_VER >= 800))
-#    define PNGCAPI __cdecl
-#    if PNG_API_RULE == 1
-#      define PNGAPI __stdcall
-#    endif
-#  else
-    /* An older compiler, or one not detected (erroneously) above,
-     * if necessary override on the command line to get the correct
-     * variants for the compiler.
-     */
-#    ifndef PNGCAPI
-#      define PNGCAPI _cdecl
-#    endif
-#    if PNG_API_RULE == 1 && !defined(PNGAPI)
-#      define PNGAPI _stdcall
-#    endif
-#  endif /* compiler/api */
-  /* NOTE: PNGCBAPI always defaults to PNGCAPI. */
-
-#  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
-   ERROR: PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed
-#  endif
-
-#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
-      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
-    /* older Borland and MSC
-     * compilers used '__export' and required this to be after
-     * the type.
-     */
-#    ifndef PNG_EXPORT_TYPE
-#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
-#    endif
-#    define PNG_DLL_EXPORT __export
-#  else /* newer compiler */
-#    define PNG_DLL_EXPORT __declspec(dllexport)
-#    ifndef PNG_DLL_IMPORT
-#      define PNG_DLL_IMPORT __declspec(dllimport)
-#    endif
-#  endif /* compiler */
-
-#else /* !Windows/x86 */
-#  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
-#    define PNGAPI _System
-#  else /* !Windows/x86 && !OS/2 */
-    /* Use the defaults, or define PNG*API on the command line (but
-     * this will have to be done for every compile!)
-     */
-#  endif /* other system, !OS/2 */
-#endif /* !Windows/x86 */
-
-/* Now do all the defaulting . */
-#ifndef PNGCAPI
-#  define PNGCAPI
-#endif
-#ifndef PNGCBAPI
-#  define PNGCBAPI PNGCAPI
-#endif
-#ifndef PNGAPI
-#  define PNGAPI PNGCAPI
-#endif
-
-/* PNG_IMPEXP may be set on the compilation system command line or (if not set)
- * then in an internal header file when building the library, otherwise (when
- * using the library) it is set here.
- */
-#ifndef PNG_IMPEXP
-#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
-     /* This forces use of a DLL, disallowing static linking */
-#    define PNG_IMPEXP PNG_DLL_IMPORT
-#  endif
-
-#  ifndef PNG_IMPEXP
-#    define PNG_IMPEXP
-#  endif
-#endif
-
-/* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
- * 'attributes' as a storage class - the attributes go at the start of the
- * function definition, and attributes are always appended regardless of the
- * compiler.  This considerably simplifies these macros but may cause problems
- * if any compilers both need function attributes and fail to handle them as
- * a storage class (this is unlikely.)
- */
-#ifndef PNG_FUNCTION
-#  define PNG_FUNCTION(type, name, args, attributes) attributes type name args
-#endif
-
-#ifndef PNG_EXPORT_TYPE
-#  define PNG_EXPORT_TYPE(type) PNG_IMPEXP type
-#endif
-
-   /* The ordinal value is only relevant when preprocessing png.h for symbol
-    * table entries, so we discard it here.  See the .dfn files in the
-    * scripts directory.
-    */
-#ifndef PNG_EXPORTA
-
-#  define PNG_EXPORTA(ordinal, type, name, args, attributes)\
-      PNG_FUNCTION(PNG_EXPORT_TYPE(type),(PNGAPI name),PNGARG(args), \
-        extern attributes)
-#endif
-
-/* ANSI-C (C90) does not permit a macro to be invoked with an empty argument,
- * so make something non-empty to satisfy the requirement:
- */
-#define PNG_EMPTY /*empty list*/
-
-#define PNG_EXPORT(ordinal, type, name, args)\
-   PNG_EXPORTA(ordinal, type, name, args, PNG_EMPTY)
-
-/* Use PNG_REMOVED to comment out a removed interface. */
-#ifndef PNG_REMOVED
-#  define PNG_REMOVED(ordinal, type, name, args, attributes)
-#endif
-
-#ifndef PNG_CALLBACK
-#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)
-#endif
-
-/* Support for compiler specific function attributes.  These are used
- * so that where compiler support is available incorrect use of API
- * functions in png.h will generate compiler warnings.
- *
- * Added at libpng-1.2.41.
- */
-
-#ifndef PNG_NO_PEDANTIC_WARNINGS
-#  ifndef PNG_PEDANTIC_WARNINGS_SUPPORTED
-#    define PNG_PEDANTIC_WARNINGS_SUPPORTED
-#  endif
-#endif
-
-#ifdef PNG_PEDANTIC_WARNINGS_SUPPORTED
-  /* Support for compiler specific function attributes.  These are used
-   * so that where compiler support is available incorrect use of API
-   * functions in png.h will generate compiler warnings.  Added at libpng
-   * version 1.2.41.
-   */
-#  if defined(__GNUC__)
-#    ifndef PNG_USE_RESULT
-#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
-#    endif
-#    ifndef PNG_NORETURN
-#      define PNG_NORETURN   __attribute__((__noreturn__))
-#    endif
-#    ifndef PNG_ALLOCATED
-#      define PNG_ALLOCATED  __attribute__((__malloc__))
-#    endif
-#    ifndef PNG_DEPRECATED
-#      define PNG_DEPRECATED __attribute__((__deprecated__))
-#    endif
-#    ifndef PNG_PRIVATE
-#      if 0 /* Doesn't work so we use deprecated instead*/
-#        define PNG_PRIVATE \
-          __attribute__((warning("This function is not exported by libpng.")))
-#      else
-#        define PNG_PRIVATE \
-          __attribute__((__deprecated__))
-#      endif
-#    endif
-#  endif /* __GNUC__ */
-
-#  if defined(_MSC_VER)  && (_MSC_VER >= 1300)
-#    ifndef PNG_USE_RESULT
-#      define PNG_USE_RESULT /* not supported */
-#    endif
-#    ifndef PNG_NORETURN
-#      define PNG_NORETURN __declspec(noreturn)
-#    endif
-#    ifndef PNG_ALLOCATED
-#      if (_MSC_VER >= 1400)
-#        define PNG_ALLOCATED __declspec(restrict)
-#      endif
-#    endif
-#    ifndef PNG_DEPRECATED
-#      define PNG_DEPRECATED __declspec(deprecated)
-#    endif
-#    ifndef PNG_PRIVATE
-#      define PNG_PRIVATE __declspec(deprecated)
-#    endif
-#  endif /* _MSC_VER */
-#endif /* PNG_PEDANTIC_WARNINGS */
-
-#ifndef PNG_DEPRECATED
-#  define PNG_DEPRECATED  /* Use of this function is deprecated */
-#endif
-#ifndef PNG_USE_RESULT
-#  define PNG_USE_RESULT  /* The result of this function must be checked */
-#endif
-#ifndef PNG_NORETURN
-#  define PNG_NORETURN    /* This function does not return */
-#endif
-#ifndef PNG_ALLOCATED
-#  define PNG_ALLOCATED   /* The result of the function is new memory */
-#endif
-#ifndef PNG_PRIVATE
-#  define PNG_PRIVATE     /* This is a private libpng function */
-#endif
-#ifndef PNG_FP_EXPORT     /* A floating point API. */
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-#     define PNG_FP_EXPORT(ordinal, type, name, args)\
-         PNG_EXPORT(ordinal, type, name, args)
-#  else                   /* No floating point APIs */
-#     define PNG_FP_EXPORT(ordinal, type, name, args)
-#  endif
-#endif
-#ifndef PNG_FIXED_EXPORT  /* A fixed point API. */
-#  ifdef PNG_FIXED_POINT_SUPPORTED
-#     define PNG_FIXED_EXPORT(ordinal, type, name, args)\
-         PNG_EXPORT(ordinal, type, name, args)
-#  else                   /* No fixed point APIs */
-#     define PNG_FIXED_EXPORT(ordinal, type, name, args)
-#  endif
-#endif
-
-/* The following uses const char * instead of char * for error
- * and warning message functions, so some compilers won't complain.
- * If you do not want to use const, define PNG_NO_CONST here.
- *
- * This should not change how the APIs are called, so it can be done
- * on a per-file basis in the application.
- */
-#ifndef PNG_CONST
-#  ifndef PNG_NO_CONST
-#    define PNG_CONST const
-#  else
-#    define PNG_CONST
-#  endif
-#endif
-
-/* Some typedefs to get us started.  These should be safe on most of the
- * common platforms.  The typedefs should be at least as large as the
- * numbers suggest (a png_uint_32 must be at least 32 bits long), but they
- * don't have to be exactly that size.  Some compilers dislike passing
- * unsigned shorts as function parameters, so you may be better off using
- * unsigned int for png_uint_16.
- */
-
-#if defined(INT_MAX) && (INT_MAX > 0x7ffffffeL)
-typedef unsigned int png_uint_32;
-typedef int png_int_32;
-#else
-typedef unsigned long png_uint_32;
-typedef long png_int_32;
-#endif
-typedef unsigned short png_uint_16;
-typedef short png_int_16;
-typedef unsigned char png_byte;
-
-#ifdef PNG_NO_SIZE_T
-typedef unsigned int png_size_t;
-#else
-typedef size_t png_size_t;
-#endif
-#define png_sizeof(x) (sizeof (x))
-
-/* The following is needed for medium model support.  It cannot be in the
- * pngpriv.h header.  Needs modification for other compilers besides
- * MSC.  Model independent support declares all arrays and pointers to be
- * large using the far keyword.  The zlib version used must also support
- * model independent data.  As of version zlib 1.0.4, the necessary changes
- * have been made in zlib.  The USE_FAR_KEYWORD define triggers other
- * changes that are needed. (Tim Wegner)
- */
-
-/* Separate compiler dependencies (problem here is that zlib.h always
- * defines FAR. (SJT)
- */
-#ifdef __BORLANDC__
-#  if defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
-#    define LDATA 1
-#  else
-#    define LDATA 0
-#  endif
-  /* GRR:  why is Cygwin in here?  Cygwin is not Borland C... */
-#  if !defined(__WIN32__) && !defined(__FLAT__) && !defined(__CYGWIN__)
-#    define PNG_MAX_MALLOC_64K /* only used in build */
-#    if (LDATA != 1)
-#      ifndef FAR
-#        define FAR __far
-#      endif
-#      define USE_FAR_KEYWORD
-#    endif   /* LDATA != 1 */
-         /* Possibly useful for moving data out of default segment.
-          * Uncomment it if you want. Could also define FARDATA as
-          * const if your compiler supports it. (SJT)
-#        define FARDATA FAR
-          */
-#  endif  /* __WIN32__, __FLAT__, __CYGWIN__ */
-#endif   /* __BORLANDC__ */
-
-
-/* Suggest testing for specific compiler first before testing for
- * FAR.  The Watcom compiler defines both __MEDIUM__ and M_I86MM,
- * making reliance oncertain keywords suspect. (SJT)
- */
-
-/* MSC Medium model */
-#ifdef FAR
-#  ifdef M_I86MM
-#    define USE_FAR_KEYWORD
-#    define FARDATA FAR
-#    include <dos.h>
-#  endif
-#endif
-
-/* SJT: default case */
-#ifndef FAR
-#  define FAR
-#endif
-
-/* At this point FAR is always defined */
-#ifndef FARDATA
-#  define FARDATA
-#endif
-
-/* Typedef for floating-point numbers that are converted
- * to fixed-point with a multiple of 100,000, e.g., gamma
- */
-typedef png_int_32 png_fixed_point;
-
-/* Add typedefs for pointers */
-typedef void                      FAR * png_voidp;
-typedef PNG_CONST void            FAR * png_const_voidp;
-typedef png_byte                  FAR * png_bytep;
-typedef PNG_CONST png_byte        FAR * png_const_bytep;
-typedef png_uint_32               FAR * png_uint_32p;
-typedef PNG_CONST png_uint_32     FAR * png_const_uint_32p;
-typedef png_int_32                FAR * png_int_32p;
-typedef PNG_CONST png_int_32      FAR * png_const_int_32p;
-typedef png_uint_16               FAR * png_uint_16p;
-typedef PNG_CONST png_uint_16     FAR * png_const_uint_16p;
-typedef png_int_16                FAR * png_int_16p;
-typedef PNG_CONST png_int_16      FAR * png_const_int_16p;
-typedef char                      FAR * png_charp;
-typedef PNG_CONST char            FAR * png_const_charp;
-typedef png_fixed_point           FAR * png_fixed_point_p;
-typedef PNG_CONST png_fixed_point FAR * png_const_fixed_point_p;
-typedef png_size_t                FAR * png_size_tp;
-typedef PNG_CONST png_size_t      FAR * png_const_size_tp;
-
-#ifdef PNG_STDIO_SUPPORTED
-typedef FILE            * png_FILE_p;
-#endif
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-typedef double           FAR * png_doublep;
-typedef PNG_CONST double FAR * png_const_doublep;
-#endif
-
-/* Pointers to pointers; i.e. arrays */
-typedef png_byte        FAR * FAR * png_bytepp;
-typedef png_uint_32     FAR * FAR * png_uint_32pp;
-typedef png_int_32      FAR * FAR * png_int_32pp;
-typedef png_uint_16     FAR * FAR * png_uint_16pp;
-typedef png_int_16      FAR * FAR * png_int_16pp;
-typedef PNG_CONST char  FAR * FAR * png_const_charpp;
-typedef char            FAR * FAR * png_charpp;
-typedef png_fixed_point FAR * FAR * png_fixed_point_pp;
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-typedef double          FAR * FAR * png_doublepp;
-#endif
-
-/* Pointers to pointers to pointers; i.e., pointer to array */
-typedef char            FAR * FAR * FAR * png_charppp;
-
-/* png_alloc_size_t is guaranteed to be no smaller than png_size_t,
- * and no smaller than png_uint_32.  Casts from png_size_t or png_uint_32
- * to png_alloc_size_t are not necessary; in fact, it is recommended
- * not to use them at all so that the compiler can complain when something
- * turns out to be problematic.
- * Casts in the other direction (from png_alloc_size_t to png_size_t or
- * png_uint_32) should be explicitly applied; however, we do not expect
- * to encounter practical situations that require such conversions.
- */
-#if defined(__TURBOC__) && !defined(__FLAT__)
-   typedef unsigned long png_alloc_size_t;
-#else
-#  if defined(_MSC_VER) && defined(MAXSEG_64K)
-     typedef unsigned long    png_alloc_size_t;
-#  else
-     /* This is an attempt to detect an old Windows system where (int) is
-      * actually 16 bits, in that case png_malloc must have an argument with a
-      * bigger size to accomodate the requirements of the library.
-      */
-#    if (defined(_Windows) || defined(_WINDOWS) || defined(_WINDOWS_)) && \
-        (!defined(INT_MAX) || INT_MAX <= 0x7ffffffeL)
-       typedef DWORD         png_alloc_size_t;
-#    else
-       typedef png_size_t    png_alloc_size_t;
-#    endif
-#  endif
-#endif
-
-#endif /* PNGCONF_H */
+
+/* pngconf.h - machine configurable file for libpng
+ *
+ * libpng version 1.5.12 - July 11, 2012
+ *
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
+ */
+
+/* Any machine specific code is near the front of this file, so if you
+ * are configuring libpng for a machine, you may want to read the section
+ * starting here down to where it starts to typedef png_color, png_text,
+ * and png_info.
+ */
+
+#ifndef PNGCONF_H
+#define PNGCONF_H
+
+#ifndef PNG_BUILDING_SYMBOL_TABLE
+/* PNG_NO_LIMITS_H may be used to turn off the use of the standard C
+ * definition file for  machine specific limits, this may impact the
+ * correctness of the definitions below (see uses of INT_MAX).
+ */
+#  ifndef PNG_NO_LIMITS_H
+#    include <limits.h>
+#  endif
+
+/* For the memory copy APIs (i.e. the standard definitions of these),
+ * because this file defines png_memcpy and so on the base APIs must
+ * be defined here.
+ */
+#  ifdef BSD
+#    include <strings.h>
+#  else
+#    include <string.h>
+#  endif
+
+/* For png_FILE_p - this provides the standard definition of a
+ * FILE
+ */
+#  ifdef PNG_STDIO_SUPPORTED
+#    include <stdio.h>
+#  endif
+#endif
+
+/* This controls optimization of the reading of 16 and 32 bit values
+ * from PNG files.  It can be set on a per-app-file basis - it
+ * just changes whether a macro is used when the function is called.
+ * The library builder sets the default; if read functions are not
+ * built into the library the macro implementation is forced on.
+ */
+#ifndef PNG_READ_INT_FUNCTIONS_SUPPORTED
+#  define PNG_USE_READ_MACROS
+#endif
+#if !defined(PNG_NO_USE_READ_MACROS) && !defined(PNG_USE_READ_MACROS)
+#  if PNG_DEFAULT_READ_MACROS
+#    define PNG_USE_READ_MACROS
+#  endif
+#endif
+
+/* COMPILER SPECIFIC OPTIONS.
+ *
+ * These options are provided so that a variety of difficult compilers
+ * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
+ * below) but still have compiler specific implementations, others
+ * may be changed on a per-file basis when compiling against libpng.
+ */
+
+/* The PNGARG macro protects us against machines that don't have function
+ * prototypes (ie K&R style headers).  If your compiler does not handle
+ * function prototypes, define this macro and use the included ansi2knr.
+ * I've always been able to use _NO_PROTO as the indicator, but you may
+ * need to drag the empty declaration out in front of here, or change the
+ * ifdef to suit your own needs.
+ */
+#ifndef PNGARG
+
+#  ifdef OF /* zlib prototype munger */
+#    define PNGARG(arglist) OF(arglist)
+#  else
+
+#    ifdef _NO_PROTO
+#      define PNGARG(arglist) ()
+#    else
+#      define PNGARG(arglist) arglist
+#    endif /* _NO_PROTO */
+
+#  endif /* OF */
+
+#endif /* PNGARG */
+
+/* Function calling conventions.
+ * =============================
+ * Normally it is not necessary to specify to the compiler how to call
+ * a function - it just does it - however on x86 systems derived from
+ * Microsoft and Borland C compilers ('IBM PC', 'DOS', 'Windows' systems
+ * and some others) there are multiple ways to call a function and the
+ * default can be changed on the compiler command line.  For this reason
+ * libpng specifies the calling convention of every exported function and
+ * every function called via a user supplied function pointer.  This is
+ * done in this file by defining the following macros:
+ *
+ * PNGAPI    Calling convention for exported functions.
+ * PNGCBAPI  Calling convention for user provided (callback) functions.
+ * PNGCAPI   Calling convention used by the ANSI-C library (required
+ *           for longjmp callbacks and sometimes used internally to
+ *           specify the calling convention for zlib).
+ *
+ * These macros should never be overridden.  If it is necessary to
+ * change calling convention in a private build this can be done
+ * by setting PNG_API_RULE (which defaults to 0) to one of the values
+ * below to select the correct 'API' variants.
+ *
+ * PNG_API_RULE=0 Use PNGCAPI - the 'C' calling convention - throughout.
+ *                This is correct in every known environment.
+ * PNG_API_RULE=1 Use the operating system convention for PNGAPI and
+ *                the 'C' calling convention (from PNGCAPI) for
+ *                callbacks (PNGCBAPI).  This is no longer required
+ *                in any known environment - if it has to be used
+ *                please post an explanation of the problem to the
+ *                libpng mailing list.
+ *
+ * These cases only differ if the operating system does not use the C
+ * calling convention, at present this just means the above cases
+ * (x86 DOS/Windows sytems) and, even then, this does not apply to
+ * Cygwin running on those systems.
+ *
+ * Note that the value must be defined in pnglibconf.h so that what
+ * the application uses to call the library matches the conventions
+ * set when building the library.
+ */
+
+/* Symbol export
+ * =============
+ * When building a shared library it is almost always necessary to tell
+ * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
+ * is used to mark the symbols.  On some systems these symbols can be
+ * extracted at link time and need no special processing by the compiler,
+ * on other systems the symbols are flagged by the compiler and just
+ * the declaration requires a special tag applied (unfortunately) in a
+ * compiler dependent way.  Some systems can do either.
+ *
+ * A small number of older systems also require a symbol from a DLL to
+ * be flagged to the program that calls it.  This is a problem because
+ * we do not know in the header file included by application code that
+ * the symbol will come from a shared library, as opposed to a statically
+ * linked one.  For this reason the application must tell us by setting
+ * the magic flag PNG_USE_DLL to turn on the special processing before
+ * it includes png.h.
+ *
+ * Four additional macros are used to make this happen:
+ *
+ * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
+ *            the build or imported if PNG_USE_DLL is set - compiler
+ *            and system specific.
+ *
+ * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
+ *                       'type', compiler specific.
+ *
+ * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
+ *                make a symbol exported from the DLL.  Not used in the
+ *                public header files; see pngpriv.h for how it is used
+ *                in the libpng build.
+ *
+ * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
+ *                from a DLL - used to define PNG_IMPEXP when
+ *                PNG_USE_DLL is set.
+ */
+
+/* System specific discovery.
+ * ==========================
+ * This code is used at build time to find PNG_IMPEXP, the API settings
+ * and PNG_EXPORT_TYPE(), it may also set a macro to indicate the DLL
+ * import processing is possible.  On Windows/x86 systems it also sets
+ * compiler-specific macros to the values required to change the calling
+ * conventions of the various functions.
+ */
+#if ( defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
+      defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__) ) &&\
+    ( defined(_X86_) || defined(_X64_) || defined(_M_IX86) ||\
+      defined(_M_X64) || defined(_M_IA64) )
+  /* Windows system (DOS doesn't support DLLs) running on x86/x64.  Includes
+   * builds under Cygwin or MinGW.  Also includes Watcom builds but these need
+   * special treatment because they are not compatible with GCC or Visual C
+   * because of different calling conventions.
+   */
+#  if PNG_API_RULE == 2
+    /* If this line results in an error, either because __watcall is not
+     * understood or because of a redefine just below you cannot use *this*
+     * build of the library with the compiler you are using.  *This* build was
+     * build using Watcom and applications must also be built using Watcom!
+     */
+#    define PNGCAPI __watcall
+#  endif
+
+#  if defined(__GNUC__) || (defined (_MSC_VER) && (_MSC_VER >= 800))
+#    define PNGCAPI __cdecl
+#    if PNG_API_RULE == 1
+#      define PNGAPI __stdcall
+#    endif
+#  else
+    /* An older compiler, or one not detected (erroneously) above,
+     * if necessary override on the command line to get the correct
+     * variants for the compiler.
+     */
+#    ifndef PNGCAPI
+#      define PNGCAPI _cdecl
+#    endif
+#    if PNG_API_RULE == 1 && !defined(PNGAPI)
+#      define PNGAPI _stdcall
+#    endif
+#  endif /* compiler/api */
+  /* NOTE: PNGCBAPI always defaults to PNGCAPI. */
+
+#  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
+   ERROR: PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed
+#  endif
+
+#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
+      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
+    /* older Borland and MSC
+     * compilers used '__export' and required this to be after
+     * the type.
+     */
+#    ifndef PNG_EXPORT_TYPE
+#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
+#    endif
+#    define PNG_DLL_EXPORT __export
+#  else /* newer compiler */
+#    define PNG_DLL_EXPORT __declspec(dllexport)
+#    ifndef PNG_DLL_IMPORT
+#      define PNG_DLL_IMPORT __declspec(dllimport)
+#    endif
+#  endif /* compiler */
+
+#else /* !Windows/x86 */
+#  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
+#    define PNGAPI _System
+#  else /* !Windows/x86 && !OS/2 */
+    /* Use the defaults, or define PNG*API on the command line (but
+     * this will have to be done for every compile!)
+     */
+#  endif /* other system, !OS/2 */
+#endif /* !Windows/x86 */
+
+/* Now do all the defaulting . */
+#ifndef PNGCAPI
+#  define PNGCAPI
+#endif
+#ifndef PNGCBAPI
+#  define PNGCBAPI PNGCAPI
+#endif
+#ifndef PNGAPI
+#  define PNGAPI PNGCAPI
+#endif
+
+/* PNG_IMPEXP may be set on the compilation system command line or (if not set)
+ * then in an internal header file when building the library, otherwise (when
+ * using the library) it is set here.
+ */
+#ifndef PNG_IMPEXP
+#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
+     /* This forces use of a DLL, disallowing static linking */
+#    define PNG_IMPEXP PNG_DLL_IMPORT
+#  endif
+
+#  ifndef PNG_IMPEXP
+#    define PNG_IMPEXP
+#  endif
+#endif
+
+/* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
+ * 'attributes' as a storage class - the attributes go at the start of the
+ * function definition, and attributes are always appended regardless of the
+ * compiler.  This considerably simplifies these macros but may cause problems
+ * if any compilers both need function attributes and fail to handle them as
+ * a storage class (this is unlikely.)
+ */
+#ifndef PNG_FUNCTION
+#  define PNG_FUNCTION(type, name, args, attributes) attributes type name args
+#endif
+
+#ifndef PNG_EXPORT_TYPE
+#  define PNG_EXPORT_TYPE(type) PNG_IMPEXP type
+#endif
+
+   /* The ordinal value is only relevant when preprocessing png.h for symbol
+    * table entries, so we discard it here.  See the .dfn files in the
+    * scripts directory.
+    */
+#ifndef PNG_EXPORTA
+
+#  define PNG_EXPORTA(ordinal, type, name, args, attributes)\
+      PNG_FUNCTION(PNG_EXPORT_TYPE(type),(PNGAPI name),PNGARG(args), \
+        extern attributes)
+#endif
+
+/* ANSI-C (C90) does not permit a macro to be invoked with an empty argument,
+ * so make something non-empty to satisfy the requirement:
+ */
+#define PNG_EMPTY /*empty list*/
+
+#define PNG_EXPORT(ordinal, type, name, args)\
+   PNG_EXPORTA(ordinal, type, name, args, PNG_EMPTY)
+
+/* Use PNG_REMOVED to comment out a removed interface. */
+#ifndef PNG_REMOVED
+#  define PNG_REMOVED(ordinal, type, name, args, attributes)
+#endif
+
+#ifndef PNG_CALLBACK
+#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)
+#endif
+
+/* Support for compiler specific function attributes.  These are used
+ * so that where compiler support is available incorrect use of API
+ * functions in png.h will generate compiler warnings.
+ *
+ * Added at libpng-1.2.41.
+ */
+
+#ifndef PNG_NO_PEDANTIC_WARNINGS
+#  ifndef PNG_PEDANTIC_WARNINGS_SUPPORTED
+#    define PNG_PEDANTIC_WARNINGS_SUPPORTED
+#  endif
+#endif
+
+#ifdef PNG_PEDANTIC_WARNINGS_SUPPORTED
+  /* Support for compiler specific function attributes.  These are used
+   * so that where compiler support is available incorrect use of API
+   * functions in png.h will generate compiler warnings.  Added at libpng
+   * version 1.2.41.
+   */
+#  if defined(__GNUC__)
+#    ifndef PNG_USE_RESULT
+#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
+#    endif
+#    ifndef PNG_NORETURN
+#      define PNG_NORETURN   __attribute__((__noreturn__))
+#    endif
+#    ifndef PNG_ALLOCATED
+#      define PNG_ALLOCATED  __attribute__((__malloc__))
+#    endif
+#    ifndef PNG_DEPRECATED
+#      define PNG_DEPRECATED __attribute__((__deprecated__))
+#    endif
+#    ifndef PNG_PRIVATE
+#      if 0 /* Doesn't work so we use deprecated instead*/
+#        define PNG_PRIVATE \
+          __attribute__((warning("This function is not exported by libpng.")))
+#      else
+#        define PNG_PRIVATE \
+          __attribute__((__deprecated__))
+#      endif
+#    endif
+#  endif /* __GNUC__ */
+
+#  if defined(_MSC_VER)  && (_MSC_VER >= 1300)
+#    ifndef PNG_USE_RESULT
+#      define PNG_USE_RESULT /* not supported */
+#    endif
+#    ifndef PNG_NORETURN
+#      define PNG_NORETURN __declspec(noreturn)
+#    endif
+#    ifndef PNG_ALLOCATED
+#      if (_MSC_VER >= 1400)
+#        define PNG_ALLOCATED __declspec(restrict)
+#      endif
+#    endif
+#    ifndef PNG_DEPRECATED
+#      define PNG_DEPRECATED __declspec(deprecated)
+#    endif
+#    ifndef PNG_PRIVATE
+#      define PNG_PRIVATE __declspec(deprecated)
+#    endif
+#  endif /* _MSC_VER */
+#endif /* PNG_PEDANTIC_WARNINGS */
+
+#ifndef PNG_DEPRECATED
+#  define PNG_DEPRECATED  /* Use of this function is deprecated */
+#endif
+#ifndef PNG_USE_RESULT
+#  define PNG_USE_RESULT  /* The result of this function must be checked */
+#endif
+#ifndef PNG_NORETURN
+#  define PNG_NORETURN    /* This function does not return */
+#endif
+#ifndef PNG_ALLOCATED
+#  define PNG_ALLOCATED   /* The result of the function is new memory */
+#endif
+#ifndef PNG_PRIVATE
+#  define PNG_PRIVATE     /* This is a private libpng function */
+#endif
+#ifndef PNG_FP_EXPORT     /* A floating point API. */
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+#     define PNG_FP_EXPORT(ordinal, type, name, args)\
+         PNG_EXPORT(ordinal, type, name, args)
+#  else                   /* No floating point APIs */
+#     define PNG_FP_EXPORT(ordinal, type, name, args)
+#  endif
+#endif
+#ifndef PNG_FIXED_EXPORT  /* A fixed point API. */
+#  ifdef PNG_FIXED_POINT_SUPPORTED
+#     define PNG_FIXED_EXPORT(ordinal, type, name, args)\
+         PNG_EXPORT(ordinal, type, name, args)
+#  else                   /* No fixed point APIs */
+#     define PNG_FIXED_EXPORT(ordinal, type, name, args)
+#  endif
+#endif
+
+/* The following uses const char * instead of char * for error
+ * and warning message functions, so some compilers won't complain.
+ * If you do not want to use const, define PNG_NO_CONST here.
+ *
+ * This should not change how the APIs are called, so it can be done
+ * on a per-file basis in the application.
+ */
+#ifndef PNG_CONST
+#  ifndef PNG_NO_CONST
+#    define PNG_CONST const
+#  else
+#    define PNG_CONST
+#  endif
+#endif
+
+/* Some typedefs to get us started.  These should be safe on most of the
+ * common platforms.  The typedefs should be at least as large as the
+ * numbers suggest (a png_uint_32 must be at least 32 bits long), but they
+ * don't have to be exactly that size.  Some compilers dislike passing
+ * unsigned shorts as function parameters, so you may be better off using
+ * unsigned int for png_uint_16.
+ */
+
+#if defined(INT_MAX) && (INT_MAX > 0x7ffffffeL)
+typedef unsigned int png_uint_32;
+typedef int png_int_32;
+#else
+typedef unsigned long png_uint_32;
+typedef long png_int_32;
+#endif
+typedef unsigned short png_uint_16;
+typedef short png_int_16;
+typedef unsigned char png_byte;
+
+#ifdef PNG_NO_SIZE_T
+typedef unsigned int png_size_t;
+#else
+typedef size_t png_size_t;
+#endif
+#define png_sizeof(x) (sizeof (x))
+
+/* The following is needed for medium model support.  It cannot be in the
+ * pngpriv.h header.  Needs modification for other compilers besides
+ * MSC.  Model independent support declares all arrays and pointers to be
+ * large using the far keyword.  The zlib version used must also support
+ * model independent data.  As of version zlib 1.0.4, the necessary changes
+ * have been made in zlib.  The USE_FAR_KEYWORD define triggers other
+ * changes that are needed. (Tim Wegner)
+ */
+
+/* Separate compiler dependencies (problem here is that zlib.h always
+ * defines FAR. (SJT)
+ */
+#ifdef __BORLANDC__
+#  if defined(__LARGE__) || defined(__HUGE__) || defined(__COMPACT__)
+#    define LDATA 1
+#  else
+#    define LDATA 0
+#  endif
+  /* GRR:  why is Cygwin in here?  Cygwin is not Borland C... */
+#  if !defined(__WIN32__) && !defined(__FLAT__) && !defined(__CYGWIN__)
+#    define PNG_MAX_MALLOC_64K /* only used in build */
+#    if (LDATA != 1)
+#      ifndef FAR
+#        define FAR __far
+#      endif
+#      define USE_FAR_KEYWORD
+#    endif   /* LDATA != 1 */
+         /* Possibly useful for moving data out of default segment.
+          * Uncomment it if you want. Could also define FARDATA as
+          * const if your compiler supports it. (SJT)
+#        define FARDATA FAR
+          */
+#  endif  /* __WIN32__, __FLAT__, __CYGWIN__ */
+#endif   /* __BORLANDC__ */
+
+
+/* Suggest testing for specific compiler first before testing for
+ * FAR.  The Watcom compiler defines both __MEDIUM__ and M_I86MM,
+ * making reliance oncertain keywords suspect. (SJT)
+ */
+
+/* MSC Medium model */
+#ifdef FAR
+#  ifdef M_I86MM
+#    define USE_FAR_KEYWORD
+#    define FARDATA FAR
+#    include <dos.h>
+#  endif
+#endif
+
+/* SJT: default case */
+#ifndef FAR
+#  define FAR
+#endif
+
+/* At this point FAR is always defined */
+#ifndef FARDATA
+#  define FARDATA
+#endif
+
+/* Typedef for floating-point numbers that are converted
+ * to fixed-point with a multiple of 100,000, e.g., gamma
+ */
+typedef png_int_32 png_fixed_point;
+
+/* Add typedefs for pointers */
+typedef void                      FAR * png_voidp;
+typedef PNG_CONST void            FAR * png_const_voidp;
+typedef png_byte                  FAR * png_bytep;
+typedef PNG_CONST png_byte        FAR * png_const_bytep;
+typedef png_uint_32               FAR * png_uint_32p;
+typedef PNG_CONST png_uint_32     FAR * png_const_uint_32p;
+typedef png_int_32                FAR * png_int_32p;
+typedef PNG_CONST png_int_32      FAR * png_const_int_32p;
+typedef png_uint_16               FAR * png_uint_16p;
+typedef PNG_CONST png_uint_16     FAR * png_const_uint_16p;
+typedef png_int_16                FAR * png_int_16p;
+typedef PNG_CONST png_int_16      FAR * png_const_int_16p;
+typedef char                      FAR * png_charp;
+typedef PNG_CONST char            FAR * png_const_charp;
+typedef png_fixed_point           FAR * png_fixed_point_p;
+typedef PNG_CONST png_fixed_point FAR * png_const_fixed_point_p;
+typedef png_size_t                FAR * png_size_tp;
+typedef PNG_CONST png_size_t      FAR * png_const_size_tp;
+
+#ifdef PNG_STDIO_SUPPORTED
+typedef FILE            * png_FILE_p;
+#endif
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+typedef double           FAR * png_doublep;
+typedef PNG_CONST double FAR * png_const_doublep;
+#endif
+
+/* Pointers to pointers; i.e. arrays */
+typedef png_byte        FAR * FAR * png_bytepp;
+typedef png_uint_32     FAR * FAR * png_uint_32pp;
+typedef png_int_32      FAR * FAR * png_int_32pp;
+typedef png_uint_16     FAR * FAR * png_uint_16pp;
+typedef png_int_16      FAR * FAR * png_int_16pp;
+typedef PNG_CONST char  FAR * FAR * png_const_charpp;
+typedef char            FAR * FAR * png_charpp;
+typedef png_fixed_point FAR * FAR * png_fixed_point_pp;
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+typedef double          FAR * FAR * png_doublepp;
+#endif
+
+/* Pointers to pointers to pointers; i.e., pointer to array */
+typedef char            FAR * FAR * FAR * png_charppp;
+
+/* png_alloc_size_t is guaranteed to be no smaller than png_size_t,
+ * and no smaller than png_uint_32.  Casts from png_size_t or png_uint_32
+ * to png_alloc_size_t are not necessary; in fact, it is recommended
+ * not to use them at all so that the compiler can complain when something
+ * turns out to be problematic.
+ * Casts in the other direction (from png_alloc_size_t to png_size_t or
+ * png_uint_32) should be explicitly applied; however, we do not expect
+ * to encounter practical situations that require such conversions.
+ */
+#if defined(__TURBOC__) && !defined(__FLAT__)
+   typedef unsigned long png_alloc_size_t;
+#else
+#  if defined(_MSC_VER) && defined(MAXSEG_64K)
+     typedef unsigned long    png_alloc_size_t;
+#  else
+     /* This is an attempt to detect an old Windows system where (int) is
+      * actually 16 bits, in that case png_malloc must have an argument with a
+      * bigger size to accomodate the requirements of the library.
+      */
+#    if (defined(_Windows) || defined(_WINDOWS) || defined(_WINDOWS_)) && \
+        (!defined(INT_MAX) || INT_MAX <= 0x7ffffffeL)
+       typedef DWORD         png_alloc_size_t;
+#    else
+       typedef png_size_t    png_alloc_size_t;
+#    endif
+#  endif
+#endif
+
+#endif /* PNGCONF_H */
diff -urN a/media/libpng/pngdebug.h b/media/libpng/pngdebug.h
--- a/media/libpng/pngdebug.h	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngdebug.h	2012-07-13 12:40:57 +0800
@@ -1,157 +1,157 @@
-
-/* pngdebug.h - Debugging macros for libpng, also used in pngtest.c
- *
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * Last changed in libpng 1.5.0 [January 6, 2011]
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-/* Define PNG_DEBUG at compile time for debugging information.  Higher
- * numbers for PNG_DEBUG mean more debugging information.  This has
- * only been added since version 0.95 so it is not implemented throughout
- * libpng yet, but more support will be added as needed.
- *
- * png_debug[1-2]?(level, message ,arg{0-2})
- *   Expands to a statement (either a simple expression or a compound
- *   do..while(0) statement) that outputs a message with parameter
- *   substitution if PNG_DEBUG is defined to 2 or more.  If PNG_DEBUG
- *   is undefined, 0 or 1 every png_debug expands to a simple expression
- *   (actually ((void)0)).
- *
- *   level: level of detail of message, starting at 0.  A level 'n'
- *          message is preceded by 'n' tab characters (not implemented
- *          on Microsoft compilers unless PNG_DEBUG_FILE is also
- *          defined, to allow debug DLL compilation with no standard IO).
- *   message: a printf(3) style text string.  A trailing '\n' is added
- *            to the message.
- *   arg: 0 to 2 arguments for printf(3) style substitution in message.
- */
-#ifndef PNGDEBUG_H
-#define PNGDEBUG_H
-/* These settings control the formatting of messages in png.c and pngerror.c */
-/* Moved to pngdebug.h at 1.5.0 */
-#  ifndef PNG_LITERAL_SHARP
-#    define PNG_LITERAL_SHARP 0x23
-#  endif
-#  ifndef PNG_LITERAL_LEFT_SQUARE_BRACKET
-#    define PNG_LITERAL_LEFT_SQUARE_BRACKET 0x5b
-#  endif
-#  ifndef PNG_LITERAL_RIGHT_SQUARE_BRACKET
-#    define PNG_LITERAL_RIGHT_SQUARE_BRACKET 0x5d
-#  endif
-#  ifndef PNG_STRING_NEWLINE
-#    define PNG_STRING_NEWLINE "\n"
-#  endif
-
-#ifdef PNG_DEBUG
-#  if (PNG_DEBUG > 0)
-#    if !defined(PNG_DEBUG_FILE) && defined(_MSC_VER)
-#      include <crtdbg.h>
-#      if (PNG_DEBUG > 1)
-#        ifndef _DEBUG
-#          define _DEBUG
-#        endif
-#        ifndef png_debug
-#          define png_debug(l,m)  _RPT0(_CRT_WARN,m PNG_STRING_NEWLINE)
-#        endif
-#        ifndef png_debug1
-#          define png_debug1(l,m,p1)  _RPT1(_CRT_WARN,m PNG_STRING_NEWLINE,p1)
-#        endif
-#        ifndef png_debug2
-#          define png_debug2(l,m,p1,p2) \
-             _RPT2(_CRT_WARN,m PNG_STRING_NEWLINE,p1,p2)
-#        endif
-#      endif
-#    else /* PNG_DEBUG_FILE || !_MSC_VER */
-#      ifndef PNG_STDIO_SUPPORTED
-#        include <stdio.h> /* not included yet */
-#      endif
-#      ifndef PNG_DEBUG_FILE
-#        define PNG_DEBUG_FILE stderr
-#      endif /* PNG_DEBUG_FILE */
-
-#      if (PNG_DEBUG > 1)
-/* Note: ["%s"m PNG_STRING_NEWLINE] probably does not work on
- * non-ISO compilers
- */
-#        ifdef __STDC__
-#          ifndef png_debug
-#            define png_debug(l,m) \
-       do { \
-       int num_tabs=l; \
-       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":"")))); \
-       } while (0)
-#          endif
-#          ifndef png_debug1
-#            define png_debug1(l,m,p1) \
-       do { \
-       int num_tabs=l; \
-       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1); \
-       } while (0)
-#          endif
-#          ifndef png_debug2
-#            define png_debug2(l,m,p1,p2) \
-       do { \
-       int num_tabs=l; \
-       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1,p2); \
-       } while (0)
-#          endif
-#        else /* __STDC __ */
-#          ifndef png_debug
-#            define png_debug(l,m) \
-       do { \
-       int num_tabs=l; \
-       char format[256]; \
-       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
-         m,PNG_STRING_NEWLINE); \
-       fprintf(PNG_DEBUG_FILE,format); \
-       } while (0)
-#          endif
-#          ifndef png_debug1
-#            define png_debug1(l,m,p1) \
-       do { \
-       int num_tabs=l; \
-       char format[256]; \
-       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
-         m,PNG_STRING_NEWLINE); \
-       fprintf(PNG_DEBUG_FILE,format,p1); \
-       } while (0)
-#          endif
-#          ifndef png_debug2
-#            define png_debug2(l,m,p1,p2) \
-       do { \
-       int num_tabs=l; \
-       char format[256]; \
-       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
-         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
-         m,PNG_STRING_NEWLINE); \
-       fprintf(PNG_DEBUG_FILE,format,p1,p2); \
-       } while (0)
-#          endif
-#        endif /* __STDC __ */
-#      endif /* (PNG_DEBUG > 1) */
-
-#    endif /* _MSC_VER */
-#  endif /* (PNG_DEBUG > 0) */
-#endif /* PNG_DEBUG */
-#ifndef png_debug
-#  define png_debug(l, m) ((void)0)
-#endif
-#ifndef png_debug1
-#  define png_debug1(l, m, p1) ((void)0)
-#endif
-#ifndef png_debug2
-#  define png_debug2(l, m, p1, p2) ((void)0)
-#endif
-#endif /* PNGDEBUG_H */
+
+/* pngdebug.h - Debugging macros for libpng, also used in pngtest.c
+ *
+ * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * Last changed in libpng 1.5.0 [January 6, 2011]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+/* Define PNG_DEBUG at compile time for debugging information.  Higher
+ * numbers for PNG_DEBUG mean more debugging information.  This has
+ * only been added since version 0.95 so it is not implemented throughout
+ * libpng yet, but more support will be added as needed.
+ *
+ * png_debug[1-2]?(level, message ,arg{0-2})
+ *   Expands to a statement (either a simple expression or a compound
+ *   do..while(0) statement) that outputs a message with parameter
+ *   substitution if PNG_DEBUG is defined to 2 or more.  If PNG_DEBUG
+ *   is undefined, 0 or 1 every png_debug expands to a simple expression
+ *   (actually ((void)0)).
+ *
+ *   level: level of detail of message, starting at 0.  A level 'n'
+ *          message is preceded by 'n' tab characters (not implemented
+ *          on Microsoft compilers unless PNG_DEBUG_FILE is also
+ *          defined, to allow debug DLL compilation with no standard IO).
+ *   message: a printf(3) style text string.  A trailing '\n' is added
+ *            to the message.
+ *   arg: 0 to 2 arguments for printf(3) style substitution in message.
+ */
+#ifndef PNGDEBUG_H
+#define PNGDEBUG_H
+/* These settings control the formatting of messages in png.c and pngerror.c */
+/* Moved to pngdebug.h at 1.5.0 */
+#  ifndef PNG_LITERAL_SHARP
+#    define PNG_LITERAL_SHARP 0x23
+#  endif
+#  ifndef PNG_LITERAL_LEFT_SQUARE_BRACKET
+#    define PNG_LITERAL_LEFT_SQUARE_BRACKET 0x5b
+#  endif
+#  ifndef PNG_LITERAL_RIGHT_SQUARE_BRACKET
+#    define PNG_LITERAL_RIGHT_SQUARE_BRACKET 0x5d
+#  endif
+#  ifndef PNG_STRING_NEWLINE
+#    define PNG_STRING_NEWLINE "\n"
+#  endif
+
+#ifdef PNG_DEBUG
+#  if (PNG_DEBUG > 0)
+#    if !defined(PNG_DEBUG_FILE) && defined(_MSC_VER)
+#      include <crtdbg.h>
+#      if (PNG_DEBUG > 1)
+#        ifndef _DEBUG
+#          define _DEBUG
+#        endif
+#        ifndef png_debug
+#          define png_debug(l,m)  _RPT0(_CRT_WARN,m PNG_STRING_NEWLINE)
+#        endif
+#        ifndef png_debug1
+#          define png_debug1(l,m,p1)  _RPT1(_CRT_WARN,m PNG_STRING_NEWLINE,p1)
+#        endif
+#        ifndef png_debug2
+#          define png_debug2(l,m,p1,p2) \
+             _RPT2(_CRT_WARN,m PNG_STRING_NEWLINE,p1,p2)
+#        endif
+#      endif
+#    else /* PNG_DEBUG_FILE || !_MSC_VER */
+#      ifndef PNG_STDIO_SUPPORTED
+#        include <stdio.h> /* not included yet */
+#      endif
+#      ifndef PNG_DEBUG_FILE
+#        define PNG_DEBUG_FILE stderr
+#      endif /* PNG_DEBUG_FILE */
+
+#      if (PNG_DEBUG > 1)
+/* Note: ["%s"m PNG_STRING_NEWLINE] probably does not work on
+ * non-ISO compilers
+ */
+#        ifdef __STDC__
+#          ifndef png_debug
+#            define png_debug(l,m) \
+       do { \
+       int num_tabs=l; \
+       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":"")))); \
+       } while (0)
+#          endif
+#          ifndef png_debug1
+#            define png_debug1(l,m,p1) \
+       do { \
+       int num_tabs=l; \
+       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1); \
+       } while (0)
+#          endif
+#          ifndef png_debug2
+#            define png_debug2(l,m,p1,p2) \
+       do { \
+       int num_tabs=l; \
+       fprintf(PNG_DEBUG_FILE,"%s"m PNG_STRING_NEWLINE,(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))),p1,p2); \
+       } while (0)
+#          endif
+#        else /* __STDC __ */
+#          ifndef png_debug
+#            define png_debug(l,m) \
+       do { \
+       int num_tabs=l; \
+       char format[256]; \
+       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
+         m,PNG_STRING_NEWLINE); \
+       fprintf(PNG_DEBUG_FILE,format); \
+       } while (0)
+#          endif
+#          ifndef png_debug1
+#            define png_debug1(l,m,p1) \
+       do { \
+       int num_tabs=l; \
+       char format[256]; \
+       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
+         m,PNG_STRING_NEWLINE); \
+       fprintf(PNG_DEBUG_FILE,format,p1); \
+       } while (0)
+#          endif
+#          ifndef png_debug2
+#            define png_debug2(l,m,p1,p2) \
+       do { \
+       int num_tabs=l; \
+       char format[256]; \
+       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
+         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
+         m,PNG_STRING_NEWLINE); \
+       fprintf(PNG_DEBUG_FILE,format,p1,p2); \
+       } while (0)
+#          endif
+#        endif /* __STDC __ */
+#      endif /* (PNG_DEBUG > 1) */
+
+#    endif /* _MSC_VER */
+#  endif /* (PNG_DEBUG > 0) */
+#endif /* PNG_DEBUG */
+#ifndef png_debug
+#  define png_debug(l, m) ((void)0)
+#endif
+#ifndef png_debug1
+#  define png_debug1(l, m, p1) ((void)0)
+#endif
+#ifndef png_debug2
+#  define png_debug2(l, m, p1, p2) ((void)0)
+#endif
+#endif /* PNGDEBUG_H */
diff -urN a/media/libpng/pngerror.c b/media/libpng/pngerror.c
--- a/media/libpng/pngerror.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngerror.c	2012-07-13 12:40:57 +0800
@@ -1,685 +1,685 @@
-
-/* pngerror.c - stub functions for i/o and memory allocation
- *
- * Last changed in libpng 1.5.8 [February 1, 2011]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all error handling.  Users who
- * need special error handling are expected to write replacement functions
- * and use png_set_error_fn() to use those functions.  See the instructions
- * at each function.
- */
-
-#include "pngpriv.h"
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-
-static PNG_FUNCTION(void, png_default_error,PNGARG((png_structp png_ptr,
-    png_const_charp error_message)),PNG_NORETURN);
-
-#ifdef PNG_WARNINGS_SUPPORTED
-static void /* PRIVATE */
-png_default_warning PNGARG((png_structp png_ptr,
-   png_const_charp warning_message));
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-/* This function is called whenever there is a fatal error.  This function
- * should not be changed.  If there is a need to handle errors differently,
- * you should supply a replacement error function and use png_set_error_fn()
- * to replace the error function at run-time.
- */
-#ifdef PNG_ERROR_TEXT_SUPPORTED
-PNG_FUNCTION(void,PNGAPI
-png_error,(png_structp png_ptr, png_const_charp error_message),PNG_NORETURN)
-{
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   char msg[16];
-   if (png_ptr != NULL)
-   {
-      if (png_ptr->flags&
-         (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
-      {
-         if (*error_message == PNG_LITERAL_SHARP)
-         {
-            /* Strip "#nnnn " from beginning of error message. */
-            int offset;
-            for (offset = 1; offset<15; offset++)
-               if (error_message[offset] == ' ')
-                  break;
-
-            if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
-            {
-               int i;
-               for (i = 0; i < offset - 1; i++)
-                  msg[i] = error_message[i + 1];
-               msg[i - 1] = '\0';
-               error_message = msg;
-            }
-
-            else
-               error_message += offset;
-      }
-
-      else
-      {
-         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
-         {
-            msg[0] = '0';
-            msg[1] = '\0';
-            error_message = msg;
-         }
-       }
-     }
-   }
-#endif
-   if (png_ptr != NULL && png_ptr->error_fn != NULL)
-      (*(png_ptr->error_fn))(png_ptr, error_message);
-
-   /* If the custom handler doesn't exist, or if it returns,
-      use the default handler, which will not return. */
-   png_default_error(png_ptr, error_message);
-}
-#else
-PNG_FUNCTION(void,PNGAPI
-png_err,(png_structp png_ptr),PNG_NORETURN)
-{
-   /* Prior to 1.5.2 the error_fn received a NULL pointer, expressed
-    * erroneously as '\0', instead of the empty string "".  This was
-    * apparently an error, introduced in libpng-1.2.20, and png_default_error
-    * will crash in this case.
-    */
-   if (png_ptr != NULL && png_ptr->error_fn != NULL)
-      (*(png_ptr->error_fn))(png_ptr, "");
-
-   /* If the custom handler doesn't exist, or if it returns,
-      use the default handler, which will not return. */
-   png_default_error(png_ptr, "");
-}
-#endif /* PNG_ERROR_TEXT_SUPPORTED */
-
-/* Utility to safely appends strings to a buffer.  This never errors out so
- * error checking is not required in the caller.
- */
-size_t
-png_safecat(png_charp buffer, size_t bufsize, size_t pos,
-   png_const_charp string)
-{
-   if (buffer != NULL && pos < bufsize)
-   {
-      if (string != NULL)
-         while (*string != '\0' && pos < bufsize-1)
-           buffer[pos++] = *string++;
-
-      buffer[pos] = '\0';
-   }
-
-   return pos;
-}
-
-#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_TIME_RFC1123_SUPPORTED)
-/* Utility to dump an unsigned value into a buffer, given a start pointer and
- * and end pointer (which should point just *beyond* the end of the buffer!)
- * Returns the pointer to the start of the formatted string.
- */
-png_charp
-png_format_number(png_const_charp start, png_charp end, int format,
-   png_alloc_size_t number)
-{
-   int count = 0;    /* number of digits output */
-   int mincount = 1; /* minimum number required */
-   int output = 0;   /* digit output (for the fixed point format) */
-
-   *--end = '\0';
-
-   /* This is written so that the loop always runs at least once, even with
-    * number zero.
-    */
-   while (end > start && (number != 0 || count < mincount))
-   {
-
-      static const char digits[] = "0123456789ABCDEF";
-
-      switch (format)
-      {
-         case PNG_NUMBER_FORMAT_fixed:
-            /* Needs five digits (the fraction) */
-            mincount = 5;
-            if (output || number % 10 != 0)
-            {
-               *--end = digits[number % 10];
-               output = 1;
-            }
-            number /= 10;
-            break;
-
-         case PNG_NUMBER_FORMAT_02u:
-            /* Expects at least 2 digits. */
-            mincount = 2;
-            /* fall through */
-
-         case PNG_NUMBER_FORMAT_u:
-            *--end = digits[number % 10];
-            number /= 10;
-            break;
-
-         case PNG_NUMBER_FORMAT_02x:
-            /* This format expects at least two digits */
-            mincount = 2;
-            /* fall through */
-
-         case PNG_NUMBER_FORMAT_x:
-            *--end = digits[number & 0xf];
-            number >>= 4;
-            break;
-
-         default: /* an error */
-            number = 0;
-            break;
-      }
-
-      /* Keep track of the number of digits added */
-      ++count;
-
-      /* Float a fixed number here: */
-      if (format == PNG_NUMBER_FORMAT_fixed) if (count == 5) if (end > start)
-      {
-         /* End of the fraction, but maybe nothing was output?  In that case
-          * drop the decimal point.  If the number is a true zero handle that
-          * here.
-          */
-         if (output)
-            *--end = '.';
-         else if (number == 0) /* and !output */
-            *--end = '0';
-      }
-   }
-
-   return end;
-}
-#endif
-
-#ifdef PNG_WARNINGS_SUPPORTED
-/* This function is called whenever there is a non-fatal error.  This function
- * should not be changed.  If there is a need to handle warnings differently,
- * you should supply a replacement warning function and use
- * png_set_error_fn() to replace the warning function at run-time.
- */
-void PNGAPI
-png_warning(png_structp png_ptr, png_const_charp warning_message)
-{
-   int offset = 0;
-   if (png_ptr != NULL)
-   {
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (png_ptr->flags&
-       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
-#endif
-      {
-         if (*warning_message == PNG_LITERAL_SHARP)
-         {
-            for (offset = 1; offset < 15; offset++)
-               if (warning_message[offset] == ' ')
-                  break;
-         }
-      }
-   }
-   if (png_ptr != NULL && png_ptr->warning_fn != NULL)
-      (*(png_ptr->warning_fn))(png_ptr, warning_message + offset);
-   else
-      png_default_warning(png_ptr, warning_message + offset);
-}
-
-/* These functions support 'formatted' warning messages with up to
- * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter
- * is introduced by @<number>, where 'number' starts at 1.  This follows the
- * standard established by X/Open for internationalizable error messages.
- */
-void
-png_warning_parameter(png_warning_parameters p, int number,
-   png_const_charp string)
-{
-   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)
-      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);
-}
-
-void
-png_warning_parameter_unsigned(png_warning_parameters p, int number, int format,
-   png_alloc_size_t value)
-{
-   char buffer[PNG_NUMBER_BUFFER_SIZE];
-   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));
-}
-
-void
-png_warning_parameter_signed(png_warning_parameters p, int number, int format,
-   png_int_32 value)
-{
-   png_alloc_size_t u;
-   png_charp str;
-   char buffer[PNG_NUMBER_BUFFER_SIZE];
-
-   /* Avoid overflow by doing the negate in a png_alloc_size_t: */
-   u = (png_alloc_size_t)value;
-   if (value < 0)
-      u = ~u + 1;
-
-   str = PNG_FORMAT_NUMBER(buffer, format, u);
-
-   if (value < 0 && str > buffer)
-      *--str = '-';
-
-   png_warning_parameter(p, number, str);
-}
-
-void
-png_formatted_warning(png_structp png_ptr, png_warning_parameters p,
-   png_const_charp message)
-{
-   /* The internal buffer is just 192 bytes - enough for all our messages,
-    * overflow doesn't happen because this code checks!  If someone figures
-    * out how to send us a message longer than 192 bytes, all that will
-    * happen is that the message will be truncated appropriately.
-    */
-   size_t i = 0; /* Index in the msg[] buffer: */
-   char msg[192];
-
-   /* Each iteration through the following loop writes at most one character
-    * to msg[i++] then returns here to validate that there is still space for
-    * the trailing '\0'.  It may (in the case of a parameter) read more than
-    * one character from message[]; it must check for '\0' and continue to the
-    * test if it finds the end of string.
-    */
-   while (i<(sizeof msg)-1 && *message != '\0')
-   {
-      /* '@' at end of string is now just printed (previously it was skipped);
-       * it is an error in the calling code to terminate the string with @.
-       */
-      if (p != NULL && *message == '@' && message[1] != '\0')
-      {
-         int parameter_char = *++message; /* Consume the '@' */
-         static const char valid_parameters[] = "123456789";
-         int parameter = 0;
-
-         /* Search for the parameter digit, the index in the string is the
-          * parameter to use.
-          */
-         while (valid_parameters[parameter] != parameter_char &&
-            valid_parameters[parameter] != '\0')
-            ++parameter;
-
-         /* If the parameter digit is out of range it will just get printed. */
-         if (parameter < PNG_WARNING_PARAMETER_COUNT)
-         {
-            /* Append this parameter */
-            png_const_charp parm = p[parameter];
-            png_const_charp pend = p[parameter] + (sizeof p[parameter]);
-
-            /* No need to copy the trailing '\0' here, but there is no guarantee
-             * that parm[] has been initialized, so there is no guarantee of a
-             * trailing '\0':
-             */
-            while (i<(sizeof msg)-1 && *parm != '\0' && parm < pend)
-               msg[i++] = *parm++;
-
-            /* Consume the parameter digit too: */
-            ++message;
-            continue;
-         }
-
-         /* else not a parameter and there is a character after the @ sign; just
-          * copy that.  This is known not to be '\0' because of the test above.
-          */
-      }
-
-      /* At this point *message can't be '\0', even in the bad parameter case
-       * above where there is a lone '@' at the end of the message string.
-       */
-      msg[i++] = *message++;
-   }
-
-   /* i is always less than (sizeof msg), so: */
-   msg[i] = '\0';
-
-   /* And this is the formatted message, it may be larger than
-    * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these are
-    * not (currently) formatted.
-    */
-   png_warning(png_ptr, msg);
-}
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-#ifdef PNG_BENIGN_ERRORS_SUPPORTED
-void PNGAPI
-png_benign_error(png_structp png_ptr, png_const_charp error_message)
-{
-  if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
-     png_warning(png_ptr, error_message);
-  else
-     png_error(png_ptr, error_message);
-}
-#endif
-
-/* These utilities are used internally to build an error message that relates
- * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
- * this is used to prefix the message.  The message is limited in length
- * to 63 bytes, the name characters are output as hex digits wrapped in []
- * if the character is invalid.
- */
-#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
-static PNG_CONST char png_digit[16] = {
-   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-   'A', 'B', 'C', 'D', 'E', 'F'
-};
-
-#define PNG_MAX_ERROR_TEXT 64
-#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_ERROR_TEXT_SUPPORTED)
-static void /* PRIVATE */
-png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
-    error_message)
-{
-   png_uint_32 chunk_name = png_ptr->chunk_name;
-   int iout = 0, ishift = 24;
-
-   while (ishift >= 0)
-   {
-      int c = (int)(chunk_name >> ishift) & 0xff;
-
-      ishift -= 8;
-      if (isnonalpha(c))
-      {
-         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;
-         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
-         buffer[iout++] = png_digit[c & 0x0f];
-         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;
-      }
-
-      else
-      {
-         buffer[iout++] = (char)c;
-      }
-   }
-
-   if (error_message == NULL)
-      buffer[iout] = '\0';
-
-   else
-   {
-      int iin = 0;
-
-      buffer[iout++] = ':';
-      buffer[iout++] = ' ';
-
-      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0')
-         buffer[iout++] = error_message[iin++];
-
-      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
-      buffer[iout] = '\0';
-   }
-}
-#endif /* PNG_WARNINGS_SUPPORTED || PNG_ERROR_TEXT_SUPPORTED */
-
-#if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)
-PNG_FUNCTION(void,PNGAPI
-png_chunk_error,(png_structp png_ptr, png_const_charp error_message),
-   PNG_NORETURN)
-{
-   char msg[18+PNG_MAX_ERROR_TEXT];
-   if (png_ptr == NULL)
-      png_error(png_ptr, error_message);
-
-   else
-   {
-      png_format_buffer(png_ptr, msg, error_message);
-      png_error(png_ptr, msg);
-   }
-}
-#endif /* PNG_READ_SUPPORTED && PNG_ERROR_TEXT_SUPPORTED */
-
-#ifdef PNG_WARNINGS_SUPPORTED
-void PNGAPI
-png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
-{
-   char msg[18+PNG_MAX_ERROR_TEXT];
-   if (png_ptr == NULL)
-      png_warning(png_ptr, warning_message);
-
-   else
-   {
-      png_format_buffer(png_ptr, msg, warning_message);
-      png_warning(png_ptr, msg);
-   }
-}
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-#ifdef PNG_READ_SUPPORTED
-#ifdef PNG_BENIGN_ERRORS_SUPPORTED
-void PNGAPI
-png_chunk_benign_error(png_structp png_ptr, png_const_charp error_message)
-{
-   if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
-      png_chunk_warning(png_ptr, error_message);
-
-   else
-      png_chunk_error(png_ptr, error_message);
-}
-#endif
-#endif /* PNG_READ_SUPPORTED */
-
-#ifdef PNG_ERROR_TEXT_SUPPORTED
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-PNG_FUNCTION(void,
-png_fixed_error,(png_structp png_ptr, png_const_charp name),PNG_NORETURN)
-{
-#  define fixed_message "fixed point overflow in "
-#  define fixed_message_ln ((sizeof fixed_message)-1)
-   int  iin;
-   char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];
-   png_memcpy(msg, fixed_message, fixed_message_ln);
-   iin = 0;
-   if (name != NULL) while (iin < (PNG_MAX_ERROR_TEXT-1) && name[iin] != 0)
-   {
-      msg[fixed_message_ln + iin] = name[iin];
-      ++iin;
-   }
-   msg[fixed_message_ln + iin] = 0;
-   png_error(png_ptr, msg);
-}
-#endif
-#endif
-
-#ifdef PNG_SETJMP_SUPPORTED
-/* This API only exists if ANSI-C style error handling is used,
- * otherwise it is necessary for png_default_error to be overridden.
- */
-jmp_buf* PNGAPI
-png_set_longjmp_fn(png_structp png_ptr, png_longjmp_ptr longjmp_fn,
-    size_t jmp_buf_size)
-{
-   if (png_ptr == NULL || jmp_buf_size != png_sizeof(jmp_buf))
-      return NULL;
-
-   png_ptr->longjmp_fn = longjmp_fn;
-   return &png_ptr->longjmp_buffer;
-}
-#endif
-
-/* This is the default error handling function.  Note that replacements for
- * this function MUST NOT RETURN, or the program will likely crash.  This
- * function is used by default, or if the program supplies NULL for the
- * error function pointer in png_set_error_fn().
- */
-static PNG_FUNCTION(void /* PRIVATE */,
-png_default_error,(png_structp png_ptr, png_const_charp error_message),
-   PNG_NORETURN)
-{
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   /* Check on NULL only added in 1.5.4 */
-   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)
-   {
-      /* Strip "#nnnn " from beginning of error message. */
-      int offset;
-      char error_number[16];
-      for (offset = 0; offset<15; offset++)
-      {
-         error_number[offset] = error_message[offset + 1];
-         if (error_message[offset] == ' ')
-            break;
-      }
-
-      if ((offset > 1) && (offset < 15))
-      {
-         error_number[offset - 1] = '\0';
-         fprintf(stderr, "libpng error no. %s: %s",
-             error_number, error_message + offset + 1);
-         fprintf(stderr, PNG_STRING_NEWLINE);
-      }
-
-      else
-      {
-         fprintf(stderr, "libpng error: %s, offset=%d",
-             error_message, offset);
-         fprintf(stderr, PNG_STRING_NEWLINE);
-      }
-   }
-   else
-#endif
-   {
-      fprintf(stderr, "libpng error: %s", error_message ? error_message :
-         "undefined");
-      fprintf(stderr, PNG_STRING_NEWLINE);
-   }
-#else
-   PNG_UNUSED(error_message) /* Make compiler happy */
-#endif
-   png_longjmp(png_ptr, 1);
-}
-
-PNG_FUNCTION(void,PNGAPI
-png_longjmp,(png_structp png_ptr, int val),PNG_NORETURN)
-{
-#ifdef PNG_SETJMP_SUPPORTED
-   if (png_ptr && png_ptr->longjmp_fn)
-   {
-#  ifdef USE_FAR_KEYWORD
-      {
-         jmp_buf tmp_jmpbuf;
-         png_memcpy(tmp_jmpbuf, png_ptr->longjmp_buffer, png_sizeof(jmp_buf));
-         png_ptr->longjmp_fn(tmp_jmpbuf, val);
-      }
-
-#  else
-   png_ptr->longjmp_fn(png_ptr->longjmp_buffer, val);
-#  endif
-   }
-#endif
-   /* Here if not setjmp support or if png_ptr is null. */
-   PNG_ABORT();
-}
-
-#ifdef PNG_WARNINGS_SUPPORTED
-/* This function is called when there is a warning, but the library thinks
- * it can continue anyway.  Replacement functions don't have to do anything
- * here if you don't want them to.  In the default configuration, png_ptr is
- * not used, but it is passed in case it may be useful.
- */
-static void /* PRIVATE */
-png_default_warning(png_structp png_ptr, png_const_charp warning_message)
-{
-#ifdef PNG_CONSOLE_IO_SUPPORTED
-#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
-   if (*warning_message == PNG_LITERAL_SHARP)
-   {
-      int offset;
-      char warning_number[16];
-      for (offset = 0; offset < 15; offset++)
-      {
-         warning_number[offset] = warning_message[offset + 1];
-         if (warning_message[offset] == ' ')
-            break;
-      }
-
-      if ((offset > 1) && (offset < 15))
-      {
-         warning_number[offset + 1] = '\0';
-         fprintf(stderr, "libpng warning no. %s: %s",
-             warning_number, warning_message + offset);
-         fprintf(stderr, PNG_STRING_NEWLINE);
-      }
-
-      else
-      {
-         fprintf(stderr, "libpng warning: %s",
-             warning_message);
-         fprintf(stderr, PNG_STRING_NEWLINE);
-      }
-   }
-   else
-#  endif
-
-   {
-      fprintf(stderr, "libpng warning: %s", warning_message);
-      fprintf(stderr, PNG_STRING_NEWLINE);
-   }
-#else
-   PNG_UNUSED(warning_message) /* Make compiler happy */
-#endif
-   PNG_UNUSED(png_ptr) /* Make compiler happy */
-}
-#endif /* PNG_WARNINGS_SUPPORTED */
-
-/* This function is called when the application wants to use another method
- * of handling errors and warnings.  Note that the error function MUST NOT
- * return to the calling routine or serious problems will occur.  The return
- * method used in the default routine calls longjmp(png_ptr->longjmp_buffer, 1)
- */
-void PNGAPI
-png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
-    png_error_ptr error_fn, png_error_ptr warning_fn)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->error_ptr = error_ptr;
-   png_ptr->error_fn = error_fn;
-#ifdef PNG_WARNINGS_SUPPORTED
-   png_ptr->warning_fn = warning_fn;
-#else
-   PNG_UNUSED(warning_fn)
-#endif
-}
-
-
-/* This function returns a pointer to the error_ptr associated with the user
- * functions.  The application should free any memory associated with this
- * pointer before png_write_destroy and png_read_destroy are called.
- */
-png_voidp PNGAPI
-png_get_error_ptr(png_const_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return NULL;
-
-   return ((png_voidp)png_ptr->error_ptr);
-}
-
-
-#ifdef PNG_ERROR_NUMBERS_SUPPORTED
-void PNGAPI
-png_set_strip_error_numbers(png_structp png_ptr, png_uint_32 strip_mode)
-{
-   if (png_ptr != NULL)
-   {
-      png_ptr->flags &=
-         ((~(PNG_FLAG_STRIP_ERROR_NUMBERS |
-         PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
-   }
-}
-#endif
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
+
+/* pngerror.c - stub functions for i/o and memory allocation
+ *
+ * Last changed in libpng 1.5.8 [February 1, 2011]
+ * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
+ * This file provides a location for all error handling.  Users who
+ * need special error handling are expected to write replacement functions
+ * and use png_set_error_fn() to use those functions.  See the instructions
+ * at each function.
+ */
+
+#include "pngpriv.h"
+
+#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+
+static PNG_FUNCTION(void, png_default_error,PNGARG((png_structp png_ptr,
+    png_const_charp error_message)),PNG_NORETURN);
+
+#ifdef PNG_WARNINGS_SUPPORTED
+static void /* PRIVATE */
+png_default_warning PNGARG((png_structp png_ptr,
+   png_const_charp warning_message));
+#endif /* PNG_WARNINGS_SUPPORTED */
+
+/* This function is called whenever there is a fatal error.  This function
+ * should not be changed.  If there is a need to handle errors differently,
+ * you should supply a replacement error function and use png_set_error_fn()
+ * to replace the error function at run-time.
+ */
+#ifdef PNG_ERROR_TEXT_SUPPORTED
+PNG_FUNCTION(void,PNGAPI
+png_error,(png_structp png_ptr, png_const_charp error_message),PNG_NORETURN)
+{
+#ifdef PNG_ERROR_NUMBERS_SUPPORTED
+   char msg[16];
+   if (png_ptr != NULL)
+   {
+      if (png_ptr->flags&
+         (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
+      {
+         if (*error_message == PNG_LITERAL_SHARP)
+         {
+            /* Strip "#nnnn " from beginning of error message. */
+            int offset;
+            for (offset = 1; offset<15; offset++)
+               if (error_message[offset] == ' ')
+                  break;
+
+            if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
+            {
+               int i;
+               for (i = 0; i < offset - 1; i++)
+                  msg[i] = error_message[i + 1];
+               msg[i - 1] = '\0';
+               error_message = msg;
+            }
+
+            else
+               error_message += offset;
+      }
+
+      else
+      {
+         if (png_ptr->flags&PNG_FLAG_STRIP_ERROR_TEXT)
+         {
+            msg[0] = '0';
+            msg[1] = '\0';
+            error_message = msg;
+         }
+       }
+     }
+   }
+#endif
+   if (png_ptr != NULL && png_ptr->error_fn != NULL)
+      (*(png_ptr->error_fn))(png_ptr, error_message);
+
+   /* If the custom handler doesn't exist, or if it returns,
+      use the default handler, which will not return. */
+   png_default_error(png_ptr, error_message);
+}
+#else
+PNG_FUNCTION(void,PNGAPI
+png_err,(png_structp png_ptr),PNG_NORETURN)
+{
+   /* Prior to 1.5.2 the error_fn received a NULL pointer, expressed
+    * erroneously as '\0', instead of the empty string "".  This was
+    * apparently an error, introduced in libpng-1.2.20, and png_default_error
+    * will crash in this case.
+    */
+   if (png_ptr != NULL && png_ptr->error_fn != NULL)
+      (*(png_ptr->error_fn))(png_ptr, "");
+
+   /* If the custom handler doesn't exist, or if it returns,
+      use the default handler, which will not return. */
+   png_default_error(png_ptr, "");
+}
+#endif /* PNG_ERROR_TEXT_SUPPORTED */
+
+/* Utility to safely appends strings to a buffer.  This never errors out so
+ * error checking is not required in the caller.
+ */
+size_t
+png_safecat(png_charp buffer, size_t bufsize, size_t pos,
+   png_const_charp string)
+{
+   if (buffer != NULL && pos < bufsize)
+   {
+      if (string != NULL)
+         while (*string != '\0' && pos < bufsize-1)
+           buffer[pos++] = *string++;
+
+      buffer[pos] = '\0';
+   }
+
+   return pos;
+}
+
+#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_TIME_RFC1123_SUPPORTED)
+/* Utility to dump an unsigned value into a buffer, given a start pointer and
+ * and end pointer (which should point just *beyond* the end of the buffer!)
+ * Returns the pointer to the start of the formatted string.
+ */
+png_charp
+png_format_number(png_const_charp start, png_charp end, int format,
+   png_alloc_size_t number)
+{
+   int count = 0;    /* number of digits output */
+   int mincount = 1; /* minimum number required */
+   int output = 0;   /* digit output (for the fixed point format) */
+
+   *--end = '\0';
+
+   /* This is written so that the loop always runs at least once, even with
+    * number zero.
+    */
+   while (end > start && (number != 0 || count < mincount))
+   {
+
+      static const char digits[] = "0123456789ABCDEF";
+
+      switch (format)
+      {
+         case PNG_NUMBER_FORMAT_fixed:
+            /* Needs five digits (the fraction) */
+            mincount = 5;
+            if (output || number % 10 != 0)
+            {
+               *--end = digits[number % 10];
+               output = 1;
+            }
+            number /= 10;
+            break;
+
+         case PNG_NUMBER_FORMAT_02u:
+            /* Expects at least 2 digits. */
+            mincount = 2;
+            /* fall through */
+
+         case PNG_NUMBER_FORMAT_u:
+            *--end = digits[number % 10];
+            number /= 10;
+            break;
+
+         case PNG_NUMBER_FORMAT_02x:
+            /* This format expects at least two digits */
+            mincount = 2;
+            /* fall through */
+
+         case PNG_NUMBER_FORMAT_x:
+            *--end = digits[number & 0xf];
+            number >>= 4;
+            break;
+
+         default: /* an error */
+            number = 0;
+            break;
+      }
+
+      /* Keep track of the number of digits added */
+      ++count;
+
+      /* Float a fixed number here: */
+      if (format == PNG_NUMBER_FORMAT_fixed) if (count == 5) if (end > start)
+      {
+         /* End of the fraction, but maybe nothing was output?  In that case
+          * drop the decimal point.  If the number is a true zero handle that
+          * here.
+          */
+         if (output)
+            *--end = '.';
+         else if (number == 0) /* and !output */
+            *--end = '0';
+      }
+   }
+
+   return end;
+}
+#endif
+
+#ifdef PNG_WARNINGS_SUPPORTED
+/* This function is called whenever there is a non-fatal error.  This function
+ * should not be changed.  If there is a need to handle warnings differently,
+ * you should supply a replacement warning function and use
+ * png_set_error_fn() to replace the warning function at run-time.
+ */
+void PNGAPI
+png_warning(png_structp png_ptr, png_const_charp warning_message)
+{
+   int offset = 0;
+   if (png_ptr != NULL)
+   {
+#ifdef PNG_ERROR_NUMBERS_SUPPORTED
+   if (png_ptr->flags&
+       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT))
+#endif
+      {
+         if (*warning_message == PNG_LITERAL_SHARP)
+         {
+            for (offset = 1; offset < 15; offset++)
+               if (warning_message[offset] == ' ')
+                  break;
+         }
+      }
+   }
+   if (png_ptr != NULL && png_ptr->warning_fn != NULL)
+      (*(png_ptr->warning_fn))(png_ptr, warning_message + offset);
+   else
+      png_default_warning(png_ptr, warning_message + offset);
+}
+
+/* These functions support 'formatted' warning messages with up to
+ * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter
+ * is introduced by @<number>, where 'number' starts at 1.  This follows the
+ * standard established by X/Open for internationalizable error messages.
+ */
+void
+png_warning_parameter(png_warning_parameters p, int number,
+   png_const_charp string)
+{
+   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)
+      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);
+}
+
+void
+png_warning_parameter_unsigned(png_warning_parameters p, int number, int format,
+   png_alloc_size_t value)
+{
+   char buffer[PNG_NUMBER_BUFFER_SIZE];
+   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));
+}
+
+void
+png_warning_parameter_signed(png_warning_parameters p, int number, int format,
+   png_int_32 value)
+{
+   png_alloc_size_t u;
+   png_charp str;
+   char buffer[PNG_NUMBER_BUFFER_SIZE];
+
+   /* Avoid overflow by doing the negate in a png_alloc_size_t: */
+   u = (png_alloc_size_t)value;
+   if (value < 0)
+      u = ~u + 1;
+
+   str = PNG_FORMAT_NUMBER(buffer, format, u);
+
+   if (value < 0 && str > buffer)
+      *--str = '-';
+
+   png_warning_parameter(p, number, str);
+}
+
+void
+png_formatted_warning(png_structp png_ptr, png_warning_parameters p,
+   png_const_charp message)
+{
+   /* The internal buffer is just 192 bytes - enough for all our messages,
+    * overflow doesn't happen because this code checks!  If someone figures
+    * out how to send us a message longer than 192 bytes, all that will
+    * happen is that the message will be truncated appropriately.
+    */
+   size_t i = 0; /* Index in the msg[] buffer: */
+   char msg[192];
+
+   /* Each iteration through the following loop writes at most one character
+    * to msg[i++] then returns here to validate that there is still space for
+    * the trailing '\0'.  It may (in the case of a parameter) read more than
+    * one character from message[]; it must check for '\0' and continue to the
+    * test if it finds the end of string.
+    */
+   while (i<(sizeof msg)-1 && *message != '\0')
+   {
+      /* '@' at end of string is now just printed (previously it was skipped);
+       * it is an error in the calling code to terminate the string with @.
+       */
+      if (p != NULL && *message == '@' && message[1] != '\0')
+      {
+         int parameter_char = *++message; /* Consume the '@' */
+         static const char valid_parameters[] = "123456789";
+         int parameter = 0;
+
+         /* Search for the parameter digit, the index in the string is the
+          * parameter to use.
+          */
+         while (valid_parameters[parameter] != parameter_char &&
+            valid_parameters[parameter] != '\0')
+            ++parameter;
+
+         /* If the parameter digit is out of range it will just get printed. */
+         if (parameter < PNG_WARNING_PARAMETER_COUNT)
+         {
+            /* Append this parameter */
+            png_const_charp parm = p[parameter];
+            png_const_charp pend = p[parameter] + (sizeof p[parameter]);
+
+            /* No need to copy the trailing '\0' here, but there is no guarantee
+             * that parm[] has been initialized, so there is no guarantee of a
+             * trailing '\0':
+             */
+            while (i<(sizeof msg)-1 && *parm != '\0' && parm < pend)
+               msg[i++] = *parm++;
+
+            /* Consume the parameter digit too: */
+            ++message;
+            continue;
+         }
+
+         /* else not a parameter and there is a character after the @ sign; just
+          * copy that.  This is known not to be '\0' because of the test above.
+          */
+      }
+
+      /* At this point *message can't be '\0', even in the bad parameter case
+       * above where there is a lone '@' at the end of the message string.
+       */
+      msg[i++] = *message++;
+   }
+
+   /* i is always less than (sizeof msg), so: */
+   msg[i] = '\0';
+
+   /* And this is the formatted message, it may be larger than
+    * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these are
+    * not (currently) formatted.
+    */
+   png_warning(png_ptr, msg);
+}
+#endif /* PNG_WARNINGS_SUPPORTED */
+
+#ifdef PNG_BENIGN_ERRORS_SUPPORTED
+void PNGAPI
+png_benign_error(png_structp png_ptr, png_const_charp error_message)
+{
+  if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
+     png_warning(png_ptr, error_message);
+  else
+     png_error(png_ptr, error_message);
+}
+#endif
+
+/* These utilities are used internally to build an error message that relates
+ * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
+ * this is used to prefix the message.  The message is limited in length
+ * to 63 bytes, the name characters are output as hex digits wrapped in []
+ * if the character is invalid.
+ */
+#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
+static PNG_CONST char png_digit[16] = {
+   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
+   'A', 'B', 'C', 'D', 'E', 'F'
+};
+
+#define PNG_MAX_ERROR_TEXT 64
+#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_ERROR_TEXT_SUPPORTED)
+static void /* PRIVATE */
+png_format_buffer(png_structp png_ptr, png_charp buffer, png_const_charp
+    error_message)
+{
+   png_uint_32 chunk_name = png_ptr->chunk_name;
+   int iout = 0, ishift = 24;
+
+   while (ishift >= 0)
+   {
+      int c = (int)(chunk_name >> ishift) & 0xff;
+
+      ishift -= 8;
+      if (isnonalpha(c))
+      {
+         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;
+         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
+         buffer[iout++] = png_digit[c & 0x0f];
+         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;
+      }
+
+      else
+      {
+         buffer[iout++] = (char)c;
+      }
+   }
+
+   if (error_message == NULL)
+      buffer[iout] = '\0';
+
+   else
+   {
+      int iin = 0;
+
+      buffer[iout++] = ':';
+      buffer[iout++] = ' ';
+
+      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0')
+         buffer[iout++] = error_message[iin++];
+
+      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
+      buffer[iout] = '\0';
+   }
+}
+#endif /* PNG_WARNINGS_SUPPORTED || PNG_ERROR_TEXT_SUPPORTED */
+
+#if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)
+PNG_FUNCTION(void,PNGAPI
+png_chunk_error,(png_structp png_ptr, png_const_charp error_message),
+   PNG_NORETURN)
+{
+   char msg[18+PNG_MAX_ERROR_TEXT];
+   if (png_ptr == NULL)
+      png_error(png_ptr, error_message);
+
+   else
+   {
+      png_format_buffer(png_ptr, msg, error_message);
+      png_error(png_ptr, msg);
+   }
+}
+#endif /* PNG_READ_SUPPORTED && PNG_ERROR_TEXT_SUPPORTED */
+
+#ifdef PNG_WARNINGS_SUPPORTED
+void PNGAPI
+png_chunk_warning(png_structp png_ptr, png_const_charp warning_message)
+{
+   char msg[18+PNG_MAX_ERROR_TEXT];
+   if (png_ptr == NULL)
+      png_warning(png_ptr, warning_message);
+
+   else
+   {
+      png_format_buffer(png_ptr, msg, warning_message);
+      png_warning(png_ptr, msg);
+   }
+}
+#endif /* PNG_WARNINGS_SUPPORTED */
+
+#ifdef PNG_READ_SUPPORTED
+#ifdef PNG_BENIGN_ERRORS_SUPPORTED
+void PNGAPI
+png_chunk_benign_error(png_structp png_ptr, png_const_charp error_message)
+{
+   if (png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN)
+      png_chunk_warning(png_ptr, error_message);
+
+   else
+      png_chunk_error(png_ptr, error_message);
+}
+#endif
+#endif /* PNG_READ_SUPPORTED */
+
+#ifdef PNG_ERROR_TEXT_SUPPORTED
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+PNG_FUNCTION(void,
+png_fixed_error,(png_structp png_ptr, png_const_charp name),PNG_NORETURN)
+{
+#  define fixed_message "fixed point overflow in "
+#  define fixed_message_ln ((sizeof fixed_message)-1)
+   int  iin;
+   char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];
+   png_memcpy(msg, fixed_message, fixed_message_ln);
+   iin = 0;
+   if (name != NULL) while (iin < (PNG_MAX_ERROR_TEXT-1) && name[iin] != 0)
+   {
+      msg[fixed_message_ln + iin] = name[iin];
+      ++iin;
+   }
+   msg[fixed_message_ln + iin] = 0;
+   png_error(png_ptr, msg);
+}
+#endif
+#endif
+
+#ifdef PNG_SETJMP_SUPPORTED
+/* This API only exists if ANSI-C style error handling is used,
+ * otherwise it is necessary for png_default_error to be overridden.
+ */
+jmp_buf* PNGAPI
+png_set_longjmp_fn(png_structp png_ptr, png_longjmp_ptr longjmp_fn,
+    size_t jmp_buf_size)
+{
+   if (png_ptr == NULL || jmp_buf_size != png_sizeof(jmp_buf))
+      return NULL;
+
+   png_ptr->longjmp_fn = longjmp_fn;
+   return &png_ptr->longjmp_buffer;
+}
+#endif
+
+/* This is the default error handling function.  Note that replacements for
+ * this function MUST NOT RETURN, or the program will likely crash.  This
+ * function is used by default, or if the program supplies NULL for the
+ * error function pointer in png_set_error_fn().
+ */
+static PNG_FUNCTION(void /* PRIVATE */,
+png_default_error,(png_structp png_ptr, png_const_charp error_message),
+   PNG_NORETURN)
+{
+#ifdef PNG_CONSOLE_IO_SUPPORTED
+#ifdef PNG_ERROR_NUMBERS_SUPPORTED
+   /* Check on NULL only added in 1.5.4 */
+   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)
+   {
+      /* Strip "#nnnn " from beginning of error message. */
+      int offset;
+      char error_number[16];
+      for (offset = 0; offset<15; offset++)
+      {
+         error_number[offset] = error_message[offset + 1];
+         if (error_message[offset] == ' ')
+            break;
+      }
+
+      if ((offset > 1) && (offset < 15))
+      {
+         error_number[offset - 1] = '\0';
+         fprintf(stderr, "libpng error no. %s: %s",
+             error_number, error_message + offset + 1);
+         fprintf(stderr, PNG_STRING_NEWLINE);
+      }
+
+      else
+      {
+         fprintf(stderr, "libpng error: %s, offset=%d",
+             error_message, offset);
+         fprintf(stderr, PNG_STRING_NEWLINE);
+      }
+   }
+   else
+#endif
+   {
+      fprintf(stderr, "libpng error: %s", error_message ? error_message :
+         "undefined");
+      fprintf(stderr, PNG_STRING_NEWLINE);
+   }
+#else
+   PNG_UNUSED(error_message) /* Make compiler happy */
+#endif
+   png_longjmp(png_ptr, 1);
+}
+
+PNG_FUNCTION(void,PNGAPI
+png_longjmp,(png_structp png_ptr, int val),PNG_NORETURN)
+{
+#ifdef PNG_SETJMP_SUPPORTED
+   if (png_ptr && png_ptr->longjmp_fn)
+   {
+#  ifdef USE_FAR_KEYWORD
+      {
+         jmp_buf tmp_jmpbuf;
+         png_memcpy(tmp_jmpbuf, png_ptr->longjmp_buffer, png_sizeof(jmp_buf));
+         png_ptr->longjmp_fn(tmp_jmpbuf, val);
+      }
+
+#  else
+   png_ptr->longjmp_fn(png_ptr->longjmp_buffer, val);
+#  endif
+   }
+#endif
+   /* Here if not setjmp support or if png_ptr is null. */
+   PNG_ABORT();
+}
+
+#ifdef PNG_WARNINGS_SUPPORTED
+/* This function is called when there is a warning, but the library thinks
+ * it can continue anyway.  Replacement functions don't have to do anything
+ * here if you don't want them to.  In the default configuration, png_ptr is
+ * not used, but it is passed in case it may be useful.
+ */
+static void /* PRIVATE */
+png_default_warning(png_structp png_ptr, png_const_charp warning_message)
+{
+#ifdef PNG_CONSOLE_IO_SUPPORTED
+#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
+   if (*warning_message == PNG_LITERAL_SHARP)
+   {
+      int offset;
+      char warning_number[16];
+      for (offset = 0; offset < 15; offset++)
+      {
+         warning_number[offset] = warning_message[offset + 1];
+         if (warning_message[offset] == ' ')
+            break;
+      }
+
+      if ((offset > 1) && (offset < 15))
+      {
+         warning_number[offset + 1] = '\0';
+         fprintf(stderr, "libpng warning no. %s: %s",
+             warning_number, warning_message + offset);
+         fprintf(stderr, PNG_STRING_NEWLINE);
+      }
+
+      else
+      {
+         fprintf(stderr, "libpng warning: %s",
+             warning_message);
+         fprintf(stderr, PNG_STRING_NEWLINE);
+      }
+   }
+   else
+#  endif
+
+   {
+      fprintf(stderr, "libpng warning: %s", warning_message);
+      fprintf(stderr, PNG_STRING_NEWLINE);
+   }
+#else
+   PNG_UNUSED(warning_message) /* Make compiler happy */
+#endif
+   PNG_UNUSED(png_ptr) /* Make compiler happy */
+}
+#endif /* PNG_WARNINGS_SUPPORTED */
+
+/* This function is called when the application wants to use another method
+ * of handling errors and warnings.  Note that the error function MUST NOT
+ * return to the calling routine or serious problems will occur.  The return
+ * method used in the default routine calls longjmp(png_ptr->longjmp_buffer, 1)
+ */
+void PNGAPI
+png_set_error_fn(png_structp png_ptr, png_voidp error_ptr,
+    png_error_ptr error_fn, png_error_ptr warning_fn)
+{
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->error_ptr = error_ptr;
+   png_ptr->error_fn = error_fn;
+#ifdef PNG_WARNINGS_SUPPORTED
+   png_ptr->warning_fn = warning_fn;
+#else
+   PNG_UNUSED(warning_fn)
+#endif
+}
+
+
+/* This function returns a pointer to the error_ptr associated with the user
+ * functions.  The application should free any memory associated with this
+ * pointer before png_write_destroy and png_read_destroy are called.
+ */
+png_voidp PNGAPI
+png_get_error_ptr(png_const_structp png_ptr)
+{
+   if (png_ptr == NULL)
+      return NULL;
+
+   return ((png_voidp)png_ptr->error_ptr);
+}
+
+
+#ifdef PNG_ERROR_NUMBERS_SUPPORTED
+void PNGAPI
+png_set_strip_error_numbers(png_structp png_ptr, png_uint_32 strip_mode)
+{
+   if (png_ptr != NULL)
+   {
+      png_ptr->flags &=
+         ((~(PNG_FLAG_STRIP_ERROR_NUMBERS |
+         PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
+   }
+}
+#endif
+#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -urN a/media/libpng/pnglibconf.h b/media/libpng/pnglibconf.h
--- a/media/libpng/pnglibconf.h	1970-01-01 08:00:00 +0800
+++ b/media/libpng/pnglibconf.h	2012-07-10 21:48:10 +0800
@@ -0,0 +1,186 @@
+
+/* libpng STANDARD API DEFINITION */
+
+/* pnglibconf.h - library build configuration */
+
+/* Libpng 1.5.12 - July 11, 2012 */
+
+/* Copyright (c) 1998-2012 Glenn Randers-Pehrson */
+
+/* This code is released under the libpng license. */
+/* For conditions of distribution and use, see the disclaimer */
+/* and license in png.h */
+
+/* pnglibconf.h */
+/* Derived from: scripts/pnglibconf.dfa */
+/* If you edit this file by hand you must obey the rules expressed in */
+/* pnglibconf.dfa with respect to the dependencies between the following */
+/* symbols.  It is much better to generate a new file using */
+/* scripts/libpngconf.mak */
+
+#ifndef PNGLCONF_H
+#define PNGLCONF_H
+/* settings */
+#define PNG_API_RULE 0
+#define PNG_CALLOC_SUPPORTED
+#define PNG_COST_SHIFT 3
+#define PNG_DEFAULT_READ_MACROS 1
+#define PNG_GAMMA_THRESHOLD_FIXED 5000
+#define PNG_MAX_GAMMA_8 11
+#define PNG_QUANTIZE_BLUE_BITS 5
+#define PNG_QUANTIZE_GREEN_BITS 5
+#define PNG_QUANTIZE_RED_BITS 5
+#define PNG_sCAL_PRECISION 5
+#define PNG_WEIGHT_SHIFT 8
+#define PNG_ZBUF_SIZE 8192
+/* end of settings */
+/* options */
+#define PNG_16BIT_SUPPORTED
+#define PNG_ALIGN_MEMORY_SUPPORTED
+#define PNG_BENIGN_ERRORS_SUPPORTED
+#define PNG_bKGD_SUPPORTED
+#define PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
+#define PNG_CHECK_cHRM_SUPPORTED
+#define PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
+#define PNG_cHRM_SUPPORTED
+#define PNG_CONSOLE_IO_SUPPORTED
+#define PNG_CONVERT_tIME_SUPPORTED
+#define PNG_EASY_ACCESS_SUPPORTED
+/*#undef PNG_ERROR_NUMBERS_SUPPORTED*/
+#define PNG_ERROR_TEXT_SUPPORTED
+#define PNG_FIXED_POINT_SUPPORTED
+#define PNG_FLOATING_ARITHMETIC_SUPPORTED
+#define PNG_FLOATING_POINT_SUPPORTED
+#define PNG_gAMA_SUPPORTED
+#define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
+#define PNG_hIST_SUPPORTED
+#define PNG_iCCP_SUPPORTED
+#define PNG_INCH_CONVERSIONS_SUPPORTED
+#define PNG_INFO_IMAGE_SUPPORTED
+#define PNG_IO_STATE_SUPPORTED
+#define PNG_iTXt_SUPPORTED
+#define PNG_MNG_FEATURES_SUPPORTED
+#define PNG_oFFs_SUPPORTED
+#define PNG_pCAL_SUPPORTED
+#define PNG_pHYs_SUPPORTED
+#define PNG_POINTER_INDEXING_SUPPORTED
+#define PNG_PROGRESSIVE_READ_SUPPORTED
+#define PNG_READ_16BIT_SUPPORTED
+#define PNG_READ_ALPHA_MODE_SUPPORTED
+#define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
+#define PNG_READ_BACKGROUND_SUPPORTED
+#define PNG_READ_BGR_SUPPORTED
+#define PNG_READ_bKGD_SUPPORTED
+#define PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
+#define PNG_READ_cHRM_SUPPORTED
+#define PNG_READ_COMPOSITE_NODIV_SUPPORTED
+#define PNG_READ_COMPRESSED_TEXT_SUPPORTED
+#define PNG_READ_EXPAND_16_SUPPORTED
+#define PNG_READ_EXPAND_SUPPORTED
+#define PNG_READ_FILLER_SUPPORTED
+#define PNG_READ_gAMA_SUPPORTED
+#define PNG_READ_GAMMA_SUPPORTED
+#define PNG_READ_GRAY_TO_RGB_SUPPORTED
+#define PNG_READ_hIST_SUPPORTED
+#define PNG_READ_iCCP_SUPPORTED
+#define PNG_READ_INTERLACING_SUPPORTED
+#define PNG_READ_INT_FUNCTIONS_SUPPORTED
+#define PNG_READ_INVERT_ALPHA_SUPPORTED
+#define PNG_READ_INVERT_SUPPORTED
+#define PNG_READ_iTXt_SUPPORTED
+#define PNG_READ_oFFs_SUPPORTED
+#define PNG_READ_OPT_PLTE_SUPPORTED
+#define PNG_READ_PACK_SUPPORTED
+#define PNG_READ_PACKSWAP_SUPPORTED
+#define PNG_READ_pCAL_SUPPORTED
+#define PNG_READ_pHYs_SUPPORTED
+#define PNG_READ_QUANTIZE_SUPPORTED
+#define PNG_READ_RGB_TO_GRAY_SUPPORTED
+#define PNG_READ_sBIT_SUPPORTED
+#define PNG_READ_SCALE_16_TO_8_SUPPORTED
+#define PNG_READ_sCAL_SUPPORTED
+#define PNG_READ_SHIFT_SUPPORTED
+#define PNG_READ_sPLT_SUPPORTED
+#define PNG_READ_sRGB_SUPPORTED
+#define PNG_READ_STRIP_16_TO_8_SUPPORTED
+#define PNG_READ_STRIP_ALPHA_SUPPORTED
+#define PNG_READ_SUPPORTED
+#define PNG_READ_SWAP_ALPHA_SUPPORTED
+#define PNG_READ_SWAP_SUPPORTED
+#define PNG_READ_tEXt_SUPPORTED
+#define PNG_READ_TEXT_SUPPORTED
+#define PNG_READ_tIME_SUPPORTED
+#define PNG_READ_TRANSFORMS_SUPPORTED
+#define PNG_READ_tRNS_SUPPORTED
+#define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
+#define PNG_READ_USER_CHUNKS_SUPPORTED
+#define PNG_READ_USER_TRANSFORM_SUPPORTED
+#define PNG_READ_zTXt_SUPPORTED
+#define PNG_SAVE_INT_32_SUPPORTED
+#define PNG_sBIT_SUPPORTED
+#define PNG_sCAL_SUPPORTED
+#define PNG_SEQUENTIAL_READ_SUPPORTED
+#define PNG_SET_CHUNK_CACHE_LIMIT_SUPPORTED
+#define PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
+#define PNG_SETJMP_SUPPORTED
+#define PNG_SET_USER_LIMITS_SUPPORTED
+#define PNG_sPLT_SUPPORTED
+#define PNG_sRGB_SUPPORTED
+#define PNG_STDIO_SUPPORTED
+#define PNG_tEXt_SUPPORTED
+#define PNG_TEXT_SUPPORTED
+#define PNG_TIME_RFC1123_SUPPORTED
+#define PNG_tIME_SUPPORTED
+#define PNG_tRNS_SUPPORTED
+#define PNG_UNKNOWN_CHUNKS_SUPPORTED
+#define PNG_USER_CHUNKS_SUPPORTED
+#define PNG_USER_LIMITS_SUPPORTED
+#define PNG_USER_MEM_SUPPORTED
+#define PNG_USER_TRANSFORM_INFO_SUPPORTED
+#define PNG_USER_TRANSFORM_PTR_SUPPORTED
+#define PNG_WARNINGS_SUPPORTED
+#define PNG_WRITE_16BIT_SUPPORTED
+#define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
+#define PNG_WRITE_BGR_SUPPORTED
+#define PNG_WRITE_bKGD_SUPPORTED
+#define PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
+#define PNG_WRITE_cHRM_SUPPORTED
+#define PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
+#define PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
+#define PNG_WRITE_FILLER_SUPPORTED
+#define PNG_WRITE_FILTER_SUPPORTED
+#define PNG_WRITE_FLUSH_SUPPORTED
+#define PNG_WRITE_gAMA_SUPPORTED
+#define PNG_WRITE_hIST_SUPPORTED
+#define PNG_WRITE_iCCP_SUPPORTED
+#define PNG_WRITE_INTERLACING_SUPPORTED
+#define PNG_WRITE_INT_FUNCTIONS_SUPPORTED
+#define PNG_WRITE_INVERT_ALPHA_SUPPORTED
+#define PNG_WRITE_INVERT_SUPPORTED
+#define PNG_WRITE_iTXt_SUPPORTED
+#define PNG_WRITE_oFFs_SUPPORTED
+#define PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
+#define PNG_WRITE_PACK_SUPPORTED
+#define PNG_WRITE_PACKSWAP_SUPPORTED
+#define PNG_WRITE_pCAL_SUPPORTED
+#define PNG_WRITE_pHYs_SUPPORTED
+#define PNG_WRITE_sBIT_SUPPORTED
+#define PNG_WRITE_sCAL_SUPPORTED
+#define PNG_WRITE_SHIFT_SUPPORTED
+#define PNG_WRITE_sPLT_SUPPORTED
+#define PNG_WRITE_sRGB_SUPPORTED
+#define PNG_WRITE_SUPPORTED
+#define PNG_WRITE_SWAP_ALPHA_SUPPORTED
+#define PNG_WRITE_SWAP_SUPPORTED
+#define PNG_WRITE_tEXt_SUPPORTED
+#define PNG_WRITE_TEXT_SUPPORTED
+#define PNG_WRITE_tIME_SUPPORTED
+#define PNG_WRITE_TRANSFORMS_SUPPORTED
+#define PNG_WRITE_tRNS_SUPPORTED
+#define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
+#define PNG_WRITE_USER_TRANSFORM_SUPPORTED
+#define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
+#define PNG_WRITE_zTXt_SUPPORTED
+#define PNG_zTXt_SUPPORTED
+/* end of options */
+#endif /* PNGLCONF_H */
diff -urN a/media/libpng/pngmem.c b/media/libpng/pngmem.c
--- a/media/libpng/pngmem.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngmem.c	2012-07-13 12:40:57 +0800
@@ -1,667 +1,667 @@
-
-/* pngmem.c - stub functions for memory allocation
- *
- * Last changed in libpng 1.5.7 [December 15, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all memory allocation.  Users who
- * need special memory handling are expected to supply replacement
- * functions for png_malloc() and png_free(), and to use
- * png_create_read_struct_2() and png_create_write_struct_2() to
- * identify the replacement functions.
- */
-
-#include "pngpriv.h"
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-
-/* Borland DOS special memory handler */
-#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
-/* If you change this, be sure to change the one in png.h also */
-
-/* Allocate memory for a png_struct.  The malloc and memset can be replaced
-   by a single call to calloc() if this is thought to improve performance. */
-PNG_FUNCTION(png_voidp /* PRIVATE */,
-png_create_struct,(int type),PNG_ALLOCATED)
-{
-#  ifdef PNG_USER_MEM_SUPPORTED
-   return (png_create_struct_2(type, NULL, NULL));
-}
-
-/* Alternate version of png_create_struct, for use with user-defined malloc. */
-PNG_FUNCTION(png_voidp /* PRIVATE */,
-png_create_struct_2,(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr),
-   PNG_ALLOCATED)
-{
-#  endif /* PNG_USER_MEM_SUPPORTED */
-   png_size_t size;
-   png_voidp struct_ptr;
-
-   if (type == PNG_STRUCT_INFO)
-      size = png_sizeof(png_info);
-
-   else if (type == PNG_STRUCT_PNG)
-      size = png_sizeof(png_struct);
-
-   else
-      return (png_get_copyright(NULL));
-
-#  ifdef PNG_USER_MEM_SUPPORTED
-   if (malloc_fn != NULL)
-   {
-      png_struct dummy_struct;
-      memset(&dummy_struct, 0, sizeof dummy_struct);
-      dummy_struct.mem_ptr=mem_ptr;
-      struct_ptr = (*(malloc_fn))(&dummy_struct, (png_alloc_size_t)size);
-   }
-
-   else
-#  endif /* PNG_USER_MEM_SUPPORTED */
-   struct_ptr = (png_voidp)farmalloc(size);
-   if (struct_ptr != NULL)
-      png_memset(struct_ptr, 0, size);
-
-   return (struct_ptr);
-}
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct(png_voidp struct_ptr)
-{
-#  ifdef PNG_USER_MEM_SUPPORTED
-   png_destroy_struct_2(struct_ptr, NULL, NULL);
-}
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
-    png_voidp mem_ptr)
-{
-#  endif
-   if (struct_ptr != NULL)
-   {
-#  ifdef PNG_USER_MEM_SUPPORTED
-      if (free_fn != NULL)
-      {
-         png_struct dummy_struct;
-         memset(&dummy_struct, 0, sizeof dummy_struct);
-         dummy_struct.mem_ptr=mem_ptr;
-         (*(free_fn))(&dummy_struct, struct_ptr);
-         return;
-      }
-
-#  endif /* PNG_USER_MEM_SUPPORTED */
-      farfree (struct_ptr);
-   }
-}
-
-/* Allocate memory.  For reasonable files, size should never exceed
- * 64K.  However, zlib may allocate more then 64K if you don't tell
- * it not to.  See zconf.h and png.h for more information. zlib does
- * need to allocate exactly 64K, so whatever you call here must
- * have the ability to do that.
- *
- * Borland seems to have a problem in DOS mode for exactly 64K.
- * It gives you a segment with an offset of 8 (perhaps to store its
- * memory stuff).  zlib doesn't like this at all, so we have to
- * detect and deal with it.  This code should not be needed in
- * Windows or OS/2 modes, and only in 16 bit mode.  This code has
- * been updated by Alexander Lehmann for version 0.89 to waste less
- * memory.
- *
- * Note that we can't use png_size_t for the "size" declaration,
- * since on some systems a png_size_t is a 16-bit quantity, and as a
- * result, we would be truncating potentially larger memory requests
- * (which should cause a fatal error) and introducing major problems.
- */
-PNG_FUNCTION(png_voidp,PNGAPI
-png_calloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-{
-   png_voidp ret;
-
-   ret = (png_malloc(png_ptr, size));
-
-   if (ret != NULL)
-      png_memset(ret,0,(png_size_t)size);
-
-   return (ret);
-}
-
-PNG_FUNCTION(png_voidp,PNGAPI
-png_malloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-{
-   png_voidp ret;
-
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-#  ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr->malloc_fn != NULL)
-      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, size));
-
-   else
-      ret = (png_malloc_default(png_ptr, size));
-
-   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-       png_error(png_ptr, "Out of memory");
-
-   return (ret);
-}
-
-PNG_FUNCTION(png_voidp,PNGAPI
-png_malloc_default,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-{
-   png_voidp ret;
-#  endif /* PNG_USER_MEM_SUPPORTED */
-
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-#  ifdef PNG_MAX_MALLOC_64K
-   if (size > (png_uint_32)65536L)
-   {
-      png_warning(png_ptr, "Cannot Allocate > 64K");
-      ret = NULL;
-   }
-
-   else
-#  endif
-
-   if (size != (size_t)size)
-      ret = NULL;
-
-   else if (size == (png_uint_32)65536L)
-   {
-      if (png_ptr->offset_table == NULL)
-      {
-         /* Try to see if we need to do any of this fancy stuff */
-         ret = farmalloc(size);
-         if (ret == NULL || ((png_size_t)ret & 0xffff))
-         {
-            int num_blocks;
-            png_uint_32 total_size;
-            png_bytep table;
-            int i, mem_level, window_bits;
-            png_byte huge * hptr;
-            int window_bits
-
-            if (ret != NULL)
-            {
-               farfree(ret);
-               ret = NULL;
-            }
-
-            window_bits =
-                png_ptr->zlib_window_bits >= png_ptr->zlib_text_window_bits ?
-                png_ptr->zlib_window_bits : png_ptr->zlib_text_window_bits;
-
-            if (window_bits > 14)
-               num_blocks = (int)(1 << (window_bits - 14));
-
-            else
-               num_blocks = 1;
-
-            mem_level =
-                png_ptr->zlib_mem_level >= png_ptr->zlib_text_mem_level ?
-                png_ptr->zlib_mem_level : png_ptr->zlib_text_mem_level;
-
-            if (mem_level >= 7)
-               num_blocks += (int)(1 << (mem_level - 7));
-
-            else
-               num_blocks++;
-
-            total_size = ((png_uint_32)65536L) * (png_uint_32)num_blocks+16;
-
-            table = farmalloc(total_size);
-
-            if (table == NULL)
-            {
-#  ifndef PNG_USER_MEM_SUPPORTED
-               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr, "Out Of Memory"); /* Note "O", "M" */
-
-               else
-                  png_warning(png_ptr, "Out Of Memory");
-#  endif
-               return (NULL);
-            }
-
-            if ((png_size_t)table & 0xfff0)
-            {
-#  ifndef PNG_USER_MEM_SUPPORTED
-               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr,
-                    "Farmalloc didn't return normalized pointer");
-
-               else
-                  png_warning(png_ptr,
-                    "Farmalloc didn't return normalized pointer");
-#  endif
-               return (NULL);
-            }
-
-            png_ptr->offset_table = table;
-            png_ptr->offset_table_ptr = farmalloc(num_blocks *
-               png_sizeof(png_bytep));
-
-            if (png_ptr->offset_table_ptr == NULL)
-            {
-#  ifndef PNG_USER_MEM_SUPPORTED
-               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-                  png_error(png_ptr, "Out Of memory"); /* Note "O", "m" */
-
-               else
-                  png_warning(png_ptr, "Out Of memory");
-#  endif
-               return (NULL);
-            }
-
-            hptr = (png_byte huge *)table;
-            if ((png_size_t)hptr & 0xf)
-            {
-               hptr = (png_byte huge *)((long)(hptr) & 0xfffffff0L);
-               hptr = hptr + 16L;  /* "hptr += 16L" fails on Turbo C++ 3.0 */
-            }
-
-            for (i = 0; i < num_blocks; i++)
-            {
-               png_ptr->offset_table_ptr[i] = (png_bytep)hptr;
-               hptr = hptr + (png_uint_32)65536L;  /* "+=" fails on TC++3.0 */
-            }
-
-            png_ptr->offset_table_number = num_blocks;
-            png_ptr->offset_table_count = 0;
-            png_ptr->offset_table_count_free = 0;
-         }
-      }
-
-      if (png_ptr->offset_table_count >= png_ptr->offset_table_number)
-      {
-#  ifndef PNG_USER_MEM_SUPPORTED
-         if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-            png_error(png_ptr, "Out of Memory"); /* Note "O" and "M" */
-
-         else
-            png_warning(png_ptr, "Out of Memory");
-#  endif
-         return (NULL);
-      }
-
-      ret = png_ptr->offset_table_ptr[png_ptr->offset_table_count++];
-   }
-
-   else
-      ret = farmalloc(size);
-
-#  ifndef PNG_USER_MEM_SUPPORTED
-   if (ret == NULL)
-   {
-      if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-         png_error(png_ptr, "Out of memory"); /* Note "o" and "m" */
-
-      else
-         png_warning(png_ptr, "Out of memory"); /* Note "o" and "m" */
-   }
-#  endif
-
-   return (ret);
-}
-
-/* Free a pointer allocated by png_malloc().  In the default
- * configuration, png_ptr is not used, but is passed in case it
- * is needed.  If ptr is NULL, return without taking any action.
- */
-void PNGAPI
-png_free(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-#  ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr->free_fn != NULL)
-   {
-      (*(png_ptr->free_fn))(png_ptr, ptr);
-      return;
-   }
-
-   else
-      png_free_default(png_ptr, ptr);
-}
-
-void PNGAPI
-png_free_default(png_structp png_ptr, png_voidp ptr)
-{
-#  endif /* PNG_USER_MEM_SUPPORTED */
-
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-   if (png_ptr->offset_table != NULL)
-   {
-      int i;
-
-      for (i = 0; i < png_ptr->offset_table_count; i++)
-      {
-         if (ptr == png_ptr->offset_table_ptr[i])
-         {
-            ptr = NULL;
-            png_ptr->offset_table_count_free++;
-            break;
-         }
-      }
-      if (png_ptr->offset_table_count_free == png_ptr->offset_table_count)
-      {
-         farfree(png_ptr->offset_table);
-         farfree(png_ptr->offset_table_ptr);
-         png_ptr->offset_table = NULL;
-         png_ptr->offset_table_ptr = NULL;
-      }
-   }
-
-   if (ptr != NULL)
-      farfree(ptr);
-}
-
-#else /* Not the Borland DOS special memory handler */
-
-/* Allocate memory for a png_struct or a png_info.  The malloc and
-   memset can be replaced by a single call to calloc() if this is thought
-   to improve performance noticably. */
-PNG_FUNCTION(png_voidp /* PRIVATE */,
-png_create_struct,(int type),PNG_ALLOCATED)
-{
-#  ifdef PNG_USER_MEM_SUPPORTED
-   return (png_create_struct_2(type, NULL, NULL));
-}
-
-/* Allocate memory for a png_struct or a png_info.  The malloc and
-   memset can be replaced by a single call to calloc() if this is thought
-   to improve performance noticably. */
-PNG_FUNCTION(png_voidp /* PRIVATE */,
-png_create_struct_2,(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr),
-   PNG_ALLOCATED)
-{
-#  endif /* PNG_USER_MEM_SUPPORTED */
-   png_size_t size;
-   png_voidp struct_ptr;
-
-   if (type == PNG_STRUCT_INFO)
-      size = png_sizeof(png_info);
-
-   else if (type == PNG_STRUCT_PNG)
-      size = png_sizeof(png_struct);
-
-   else
-      return (NULL);
-
-#  ifdef PNG_USER_MEM_SUPPORTED
-   if (malloc_fn != NULL)
-   {
-      png_struct dummy_struct;
-      png_structp png_ptr = &dummy_struct;
-      png_ptr->mem_ptr=mem_ptr;
-      struct_ptr = (*(malloc_fn))(png_ptr, size);
-
-      if (struct_ptr != NULL)
-         png_memset(struct_ptr, 0, size);
-
-      return (struct_ptr);
-   }
-#  endif /* PNG_USER_MEM_SUPPORTED */
-
-#  if defined(__TURBOC__) && !defined(__FLAT__)
-   struct_ptr = (png_voidp)farmalloc(size);
-#  else
-#    if defined(_MSC_VER) && defined(MAXSEG_64K)
-   struct_ptr = (png_voidp)halloc(size, 1);
-#    else
-   struct_ptr = (png_voidp)malloc(size);
-#    endif
-#  endif
-
-   if (struct_ptr != NULL)
-      png_memset(struct_ptr, 0, size);
-
-   return (struct_ptr);
-}
-
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct(png_voidp struct_ptr)
-{
-#  ifdef PNG_USER_MEM_SUPPORTED
-   png_destroy_struct_2(struct_ptr, NULL, NULL);
-}
-
-/* Free memory allocated by a png_create_struct() call */
-void /* PRIVATE */
-png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
-    png_voidp mem_ptr)
-{
-#  endif /* PNG_USER_MEM_SUPPORTED */
-   if (struct_ptr != NULL)
-   {
-#  ifdef PNG_USER_MEM_SUPPORTED
-      if (free_fn != NULL)
-      {
-         png_struct dummy_struct;
-         png_structp png_ptr = &dummy_struct;
-         png_ptr->mem_ptr=mem_ptr;
-         (*(free_fn))(png_ptr, struct_ptr);
-         return;
-      }
-#  endif /* PNG_USER_MEM_SUPPORTED */
-#  if defined(__TURBOC__) && !defined(__FLAT__)
-      farfree(struct_ptr);
-
-#  else
-#    if defined(_MSC_VER) && defined(MAXSEG_64K)
-      hfree(struct_ptr);
-
-#    else
-      free(struct_ptr);
-
-#    endif
-#  endif
-   }
-}
-
-/* Allocate memory.  For reasonable files, size should never exceed
- * 64K.  However, zlib may allocate more then 64K if you don't tell
- * it not to.  See zconf.h and png.h for more information.  zlib does
- * need to allocate exactly 64K, so whatever you call here must
- * have the ability to do that.
- */
-
-PNG_FUNCTION(png_voidp,PNGAPI
-png_calloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-{
-   png_voidp ret;
-
-   ret = (png_malloc(png_ptr, size));
-
-   if (ret != NULL)
-      png_memset(ret,0,(png_size_t)size);
-
-   return (ret);
-}
-
-PNG_FUNCTION(png_voidp,PNGAPI
-png_malloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-{
-   png_voidp ret;
-
-#  ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-   if (png_ptr->malloc_fn != NULL)
-      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
-
-   else
-      ret = (png_malloc_default(png_ptr, size));
-
-   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-       png_error(png_ptr, "Out of Memory");
-
-   return (ret);
-}
-
-PNG_FUNCTION(png_voidp,PNGAPI
-png_malloc_default,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-{
-   png_voidp ret;
-#  endif /* PNG_USER_MEM_SUPPORTED */
-
-   if (png_ptr == NULL || size == 0)
-      return (NULL);
-
-#  ifdef PNG_MAX_MALLOC_64K
-   if (size > (png_uint_32)65536L)
-   {
-#    ifndef PNG_USER_MEM_SUPPORTED
-      if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-         png_error(png_ptr, "Cannot Allocate > 64K");
-
-      else
-#    endif
-         return NULL;
-   }
-#  endif
-
-   /* Check for overflow */
-#  if defined(__TURBOC__) && !defined(__FLAT__)
-
-   if (size != (unsigned long)size)
-      ret = NULL;
-
-   else
-      ret = farmalloc(size);
-
-#  else
-#    if defined(_MSC_VER) && defined(MAXSEG_64K)
-   if (size != (unsigned long)size)
-      ret = NULL;
-
-   else
-      ret = halloc(size, 1);
-
-#    else
-   if (size != (size_t)size)
-      ret = NULL;
-
-   else
-      ret = malloc((size_t)size);
-#    endif
-#  endif
-
-#  ifndef PNG_USER_MEM_SUPPORTED
-   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
-      png_error(png_ptr, "Out of Memory");
-#  endif
-
-   return (ret);
-}
-
-/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
- * without taking any action.
- */
-void PNGAPI
-png_free(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-#  ifdef PNG_USER_MEM_SUPPORTED
-   if (png_ptr->free_fn != NULL)
-   {
-      (*(png_ptr->free_fn))(png_ptr, ptr);
-      return;
-   }
-
-   else
-      png_free_default(png_ptr, ptr);
-}
-
-void PNGAPI
-png_free_default(png_structp png_ptr, png_voidp ptr)
-{
-   if (png_ptr == NULL || ptr == NULL)
-      return;
-
-#  endif /* PNG_USER_MEM_SUPPORTED */
-
-#  if defined(__TURBOC__) && !defined(__FLAT__)
-   farfree(ptr);
-
-#  else
-#    if defined(_MSC_VER) && defined(MAXSEG_64K)
-   hfree(ptr);
-
-#    else
-   free(ptr);
-
-#    endif
-#  endif
-}
-#endif /* Not Borland DOS special memory handler */
-
-/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
- * function will set up png_malloc() to issue a png_warning and return NULL
- * instead of issuing a png_error, if it fails to allocate the requested
- * memory.
- */
-PNG_FUNCTION(png_voidp,PNGAPI
-png_malloc_warn,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
-{
-   png_voidp ptr;
-   png_uint_32 save_flags;
-   if (png_ptr == NULL)
-      return (NULL);
-
-   save_flags = png_ptr->flags;
-   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
-   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
-   png_ptr->flags=save_flags;
-   return(ptr);
-}
-
-
-#ifdef PNG_USER_MEM_SUPPORTED
-/* This function is called when the application wants to use another method
- * of allocating and freeing memory.
- */
-void PNGAPI
-png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
-  malloc_fn, png_free_ptr free_fn)
-{
-   if (png_ptr != NULL)
-   {
-      png_ptr->mem_ptr = mem_ptr;
-      png_ptr->malloc_fn = malloc_fn;
-      png_ptr->free_fn = free_fn;
-   }
-}
-
-/* This function returns a pointer to the mem_ptr associated with the user
- * functions.  The application should free any memory associated with this
- * pointer before png_write_destroy and png_read_destroy are called.
- */
-png_voidp PNGAPI
-png_get_mem_ptr(png_const_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return (NULL);
-
-   return ((png_voidp)png_ptr->mem_ptr);
-}
-#endif /* PNG_USER_MEM_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
+
+/* pngmem.c - stub functions for memory allocation
+ *
+ * Last changed in libpng 1.5.7 [December 15, 2011]
+ * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
+ * This file provides a location for all memory allocation.  Users who
+ * need special memory handling are expected to supply replacement
+ * functions for png_malloc() and png_free(), and to use
+ * png_create_read_struct_2() and png_create_write_struct_2() to
+ * identify the replacement functions.
+ */
+
+#include "pngpriv.h"
+
+#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+
+/* Borland DOS special memory handler */
+#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
+/* If you change this, be sure to change the one in png.h also */
+
+/* Allocate memory for a png_struct.  The malloc and memset can be replaced
+   by a single call to calloc() if this is thought to improve performance. */
+PNG_FUNCTION(png_voidp /* PRIVATE */,
+png_create_struct,(int type),PNG_ALLOCATED)
+{
+#  ifdef PNG_USER_MEM_SUPPORTED
+   return (png_create_struct_2(type, NULL, NULL));
+}
+
+/* Alternate version of png_create_struct, for use with user-defined malloc. */
+PNG_FUNCTION(png_voidp /* PRIVATE */,
+png_create_struct_2,(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr),
+   PNG_ALLOCATED)
+{
+#  endif /* PNG_USER_MEM_SUPPORTED */
+   png_size_t size;
+   png_voidp struct_ptr;
+
+   if (type == PNG_STRUCT_INFO)
+      size = png_sizeof(png_info);
+
+   else if (type == PNG_STRUCT_PNG)
+      size = png_sizeof(png_struct);
+
+   else
+      return (png_get_copyright(NULL));
+
+#  ifdef PNG_USER_MEM_SUPPORTED
+   if (malloc_fn != NULL)
+   {
+      png_struct dummy_struct;
+      memset(&dummy_struct, 0, sizeof dummy_struct);
+      dummy_struct.mem_ptr=mem_ptr;
+      struct_ptr = (*(malloc_fn))(&dummy_struct, (png_alloc_size_t)size);
+   }
+
+   else
+#  endif /* PNG_USER_MEM_SUPPORTED */
+   struct_ptr = (png_voidp)farmalloc(size);
+   if (struct_ptr != NULL)
+      png_memset(struct_ptr, 0, size);
+
+   return (struct_ptr);
+}
+
+/* Free memory allocated by a png_create_struct() call */
+void /* PRIVATE */
+png_destroy_struct(png_voidp struct_ptr)
+{
+#  ifdef PNG_USER_MEM_SUPPORTED
+   png_destroy_struct_2(struct_ptr, NULL, NULL);
+}
+
+/* Free memory allocated by a png_create_struct() call */
+void /* PRIVATE */
+png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
+    png_voidp mem_ptr)
+{
+#  endif
+   if (struct_ptr != NULL)
+   {
+#  ifdef PNG_USER_MEM_SUPPORTED
+      if (free_fn != NULL)
+      {
+         png_struct dummy_struct;
+         memset(&dummy_struct, 0, sizeof dummy_struct);
+         dummy_struct.mem_ptr=mem_ptr;
+         (*(free_fn))(&dummy_struct, struct_ptr);
+         return;
+      }
+
+#  endif /* PNG_USER_MEM_SUPPORTED */
+      farfree (struct_ptr);
+   }
+}
+
+/* Allocate memory.  For reasonable files, size should never exceed
+ * 64K.  However, zlib may allocate more then 64K if you don't tell
+ * it not to.  See zconf.h and png.h for more information. zlib does
+ * need to allocate exactly 64K, so whatever you call here must
+ * have the ability to do that.
+ *
+ * Borland seems to have a problem in DOS mode for exactly 64K.
+ * It gives you a segment with an offset of 8 (perhaps to store its
+ * memory stuff).  zlib doesn't like this at all, so we have to
+ * detect and deal with it.  This code should not be needed in
+ * Windows or OS/2 modes, and only in 16 bit mode.  This code has
+ * been updated by Alexander Lehmann for version 0.89 to waste less
+ * memory.
+ *
+ * Note that we can't use png_size_t for the "size" declaration,
+ * since on some systems a png_size_t is a 16-bit quantity, and as a
+ * result, we would be truncating potentially larger memory requests
+ * (which should cause a fatal error) and introducing major problems.
+ */
+PNG_FUNCTION(png_voidp,PNGAPI
+png_calloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
+{
+   png_voidp ret;
+
+   ret = (png_malloc(png_ptr, size));
+
+   if (ret != NULL)
+      png_memset(ret,0,(png_size_t)size);
+
+   return (ret);
+}
+
+PNG_FUNCTION(png_voidp,PNGAPI
+png_malloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
+{
+   png_voidp ret;
+
+   if (png_ptr == NULL || size == 0)
+      return (NULL);
+
+#  ifdef PNG_USER_MEM_SUPPORTED
+   if (png_ptr->malloc_fn != NULL)
+      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, size));
+
+   else
+      ret = (png_malloc_default(png_ptr, size));
+
+   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+       png_error(png_ptr, "Out of memory");
+
+   return (ret);
+}
+
+PNG_FUNCTION(png_voidp,PNGAPI
+png_malloc_default,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
+{
+   png_voidp ret;
+#  endif /* PNG_USER_MEM_SUPPORTED */
+
+   if (png_ptr == NULL || size == 0)
+      return (NULL);
+
+#  ifdef PNG_MAX_MALLOC_64K
+   if (size > (png_uint_32)65536L)
+   {
+      png_warning(png_ptr, "Cannot Allocate > 64K");
+      ret = NULL;
+   }
+
+   else
+#  endif
+
+   if (size != (size_t)size)
+      ret = NULL;
+
+   else if (size == (png_uint_32)65536L)
+   {
+      if (png_ptr->offset_table == NULL)
+      {
+         /* Try to see if we need to do any of this fancy stuff */
+         ret = farmalloc(size);
+         if (ret == NULL || ((png_size_t)ret & 0xffff))
+         {
+            int num_blocks;
+            png_uint_32 total_size;
+            png_bytep table;
+            int i, mem_level, window_bits;
+            png_byte huge * hptr;
+            int window_bits
+
+            if (ret != NULL)
+            {
+               farfree(ret);
+               ret = NULL;
+            }
+
+            window_bits =
+                png_ptr->zlib_window_bits >= png_ptr->zlib_text_window_bits ?
+                png_ptr->zlib_window_bits : png_ptr->zlib_text_window_bits;
+
+            if (window_bits > 14)
+               num_blocks = (int)(1 << (window_bits - 14));
+
+            else
+               num_blocks = 1;
+
+            mem_level =
+                png_ptr->zlib_mem_level >= png_ptr->zlib_text_mem_level ?
+                png_ptr->zlib_mem_level : png_ptr->zlib_text_mem_level;
+
+            if (mem_level >= 7)
+               num_blocks += (int)(1 << (mem_level - 7));
+
+            else
+               num_blocks++;
+
+            total_size = ((png_uint_32)65536L) * (png_uint_32)num_blocks+16;
+
+            table = farmalloc(total_size);
+
+            if (table == NULL)
+            {
+#  ifndef PNG_USER_MEM_SUPPORTED
+               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+                  png_error(png_ptr, "Out Of Memory"); /* Note "O", "M" */
+
+               else
+                  png_warning(png_ptr, "Out Of Memory");
+#  endif
+               return (NULL);
+            }
+
+            if ((png_size_t)table & 0xfff0)
+            {
+#  ifndef PNG_USER_MEM_SUPPORTED
+               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+                  png_error(png_ptr,
+                    "Farmalloc didn't return normalized pointer");
+
+               else
+                  png_warning(png_ptr,
+                    "Farmalloc didn't return normalized pointer");
+#  endif
+               return (NULL);
+            }
+
+            png_ptr->offset_table = table;
+            png_ptr->offset_table_ptr = farmalloc(num_blocks *
+               png_sizeof(png_bytep));
+
+            if (png_ptr->offset_table_ptr == NULL)
+            {
+#  ifndef PNG_USER_MEM_SUPPORTED
+               if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+                  png_error(png_ptr, "Out Of memory"); /* Note "O", "m" */
+
+               else
+                  png_warning(png_ptr, "Out Of memory");
+#  endif
+               return (NULL);
+            }
+
+            hptr = (png_byte huge *)table;
+            if ((png_size_t)hptr & 0xf)
+            {
+               hptr = (png_byte huge *)((long)(hptr) & 0xfffffff0L);
+               hptr = hptr + 16L;  /* "hptr += 16L" fails on Turbo C++ 3.0 */
+            }
+
+            for (i = 0; i < num_blocks; i++)
+            {
+               png_ptr->offset_table_ptr[i] = (png_bytep)hptr;
+               hptr = hptr + (png_uint_32)65536L;  /* "+=" fails on TC++3.0 */
+            }
+
+            png_ptr->offset_table_number = num_blocks;
+            png_ptr->offset_table_count = 0;
+            png_ptr->offset_table_count_free = 0;
+         }
+      }
+
+      if (png_ptr->offset_table_count >= png_ptr->offset_table_number)
+      {
+#  ifndef PNG_USER_MEM_SUPPORTED
+         if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+            png_error(png_ptr, "Out of Memory"); /* Note "O" and "M" */
+
+         else
+            png_warning(png_ptr, "Out of Memory");
+#  endif
+         return (NULL);
+      }
+
+      ret = png_ptr->offset_table_ptr[png_ptr->offset_table_count++];
+   }
+
+   else
+      ret = farmalloc(size);
+
+#  ifndef PNG_USER_MEM_SUPPORTED
+   if (ret == NULL)
+   {
+      if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+         png_error(png_ptr, "Out of memory"); /* Note "o" and "m" */
+
+      else
+         png_warning(png_ptr, "Out of memory"); /* Note "o" and "m" */
+   }
+#  endif
+
+   return (ret);
+}
+
+/* Free a pointer allocated by png_malloc().  In the default
+ * configuration, png_ptr is not used, but is passed in case it
+ * is needed.  If ptr is NULL, return without taking any action.
+ */
+void PNGAPI
+png_free(png_structp png_ptr, png_voidp ptr)
+{
+   if (png_ptr == NULL || ptr == NULL)
+      return;
+
+#  ifdef PNG_USER_MEM_SUPPORTED
+   if (png_ptr->free_fn != NULL)
+   {
+      (*(png_ptr->free_fn))(png_ptr, ptr);
+      return;
+   }
+
+   else
+      png_free_default(png_ptr, ptr);
+}
+
+void PNGAPI
+png_free_default(png_structp png_ptr, png_voidp ptr)
+{
+#  endif /* PNG_USER_MEM_SUPPORTED */
+
+   if (png_ptr == NULL || ptr == NULL)
+      return;
+
+   if (png_ptr->offset_table != NULL)
+   {
+      int i;
+
+      for (i = 0; i < png_ptr->offset_table_count; i++)
+      {
+         if (ptr == png_ptr->offset_table_ptr[i])
+         {
+            ptr = NULL;
+            png_ptr->offset_table_count_free++;
+            break;
+         }
+      }
+      if (png_ptr->offset_table_count_free == png_ptr->offset_table_count)
+      {
+         farfree(png_ptr->offset_table);
+         farfree(png_ptr->offset_table_ptr);
+         png_ptr->offset_table = NULL;
+         png_ptr->offset_table_ptr = NULL;
+      }
+   }
+
+   if (ptr != NULL)
+      farfree(ptr);
+}
+
+#else /* Not the Borland DOS special memory handler */
+
+/* Allocate memory for a png_struct or a png_info.  The malloc and
+   memset can be replaced by a single call to calloc() if this is thought
+   to improve performance noticably. */
+PNG_FUNCTION(png_voidp /* PRIVATE */,
+png_create_struct,(int type),PNG_ALLOCATED)
+{
+#  ifdef PNG_USER_MEM_SUPPORTED
+   return (png_create_struct_2(type, NULL, NULL));
+}
+
+/* Allocate memory for a png_struct or a png_info.  The malloc and
+   memset can be replaced by a single call to calloc() if this is thought
+   to improve performance noticably. */
+PNG_FUNCTION(png_voidp /* PRIVATE */,
+png_create_struct_2,(int type, png_malloc_ptr malloc_fn, png_voidp mem_ptr),
+   PNG_ALLOCATED)
+{
+#  endif /* PNG_USER_MEM_SUPPORTED */
+   png_size_t size;
+   png_voidp struct_ptr;
+
+   if (type == PNG_STRUCT_INFO)
+      size = png_sizeof(png_info);
+
+   else if (type == PNG_STRUCT_PNG)
+      size = png_sizeof(png_struct);
+
+   else
+      return (NULL);
+
+#  ifdef PNG_USER_MEM_SUPPORTED
+   if (malloc_fn != NULL)
+   {
+      png_struct dummy_struct;
+      png_structp png_ptr = &dummy_struct;
+      png_ptr->mem_ptr=mem_ptr;
+      struct_ptr = (*(malloc_fn))(png_ptr, size);
+
+      if (struct_ptr != NULL)
+         png_memset(struct_ptr, 0, size);
+
+      return (struct_ptr);
+   }
+#  endif /* PNG_USER_MEM_SUPPORTED */
+
+#  if defined(__TURBOC__) && !defined(__FLAT__)
+   struct_ptr = (png_voidp)farmalloc(size);
+#  else
+#    if defined(_MSC_VER) && defined(MAXSEG_64K)
+   struct_ptr = (png_voidp)halloc(size, 1);
+#    else
+   struct_ptr = (png_voidp)malloc(size);
+#    endif
+#  endif
+
+   if (struct_ptr != NULL)
+      png_memset(struct_ptr, 0, size);
+
+   return (struct_ptr);
+}
+
+
+/* Free memory allocated by a png_create_struct() call */
+void /* PRIVATE */
+png_destroy_struct(png_voidp struct_ptr)
+{
+#  ifdef PNG_USER_MEM_SUPPORTED
+   png_destroy_struct_2(struct_ptr, NULL, NULL);
+}
+
+/* Free memory allocated by a png_create_struct() call */
+void /* PRIVATE */
+png_destroy_struct_2(png_voidp struct_ptr, png_free_ptr free_fn,
+    png_voidp mem_ptr)
+{
+#  endif /* PNG_USER_MEM_SUPPORTED */
+   if (struct_ptr != NULL)
+   {
+#  ifdef PNG_USER_MEM_SUPPORTED
+      if (free_fn != NULL)
+      {
+         png_struct dummy_struct;
+         png_structp png_ptr = &dummy_struct;
+         png_ptr->mem_ptr=mem_ptr;
+         (*(free_fn))(png_ptr, struct_ptr);
+         return;
+      }
+#  endif /* PNG_USER_MEM_SUPPORTED */
+#  if defined(__TURBOC__) && !defined(__FLAT__)
+      farfree(struct_ptr);
+
+#  else
+#    if defined(_MSC_VER) && defined(MAXSEG_64K)
+      hfree(struct_ptr);
+
+#    else
+      free(struct_ptr);
+
+#    endif
+#  endif
+   }
+}
+
+/* Allocate memory.  For reasonable files, size should never exceed
+ * 64K.  However, zlib may allocate more then 64K if you don't tell
+ * it not to.  See zconf.h and png.h for more information.  zlib does
+ * need to allocate exactly 64K, so whatever you call here must
+ * have the ability to do that.
+ */
+
+PNG_FUNCTION(png_voidp,PNGAPI
+png_calloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
+{
+   png_voidp ret;
+
+   ret = (png_malloc(png_ptr, size));
+
+   if (ret != NULL)
+      png_memset(ret,0,(png_size_t)size);
+
+   return (ret);
+}
+
+PNG_FUNCTION(png_voidp,PNGAPI
+png_malloc,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
+{
+   png_voidp ret;
+
+#  ifdef PNG_USER_MEM_SUPPORTED
+   if (png_ptr == NULL || size == 0)
+      return (NULL);
+
+   if (png_ptr->malloc_fn != NULL)
+      ret = ((png_voidp)(*(png_ptr->malloc_fn))(png_ptr, (png_size_t)size));
+
+   else
+      ret = (png_malloc_default(png_ptr, size));
+
+   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+       png_error(png_ptr, "Out of Memory");
+
+   return (ret);
+}
+
+PNG_FUNCTION(png_voidp,PNGAPI
+png_malloc_default,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
+{
+   png_voidp ret;
+#  endif /* PNG_USER_MEM_SUPPORTED */
+
+   if (png_ptr == NULL || size == 0)
+      return (NULL);
+
+#  ifdef PNG_MAX_MALLOC_64K
+   if (size > (png_uint_32)65536L)
+   {
+#    ifndef PNG_USER_MEM_SUPPORTED
+      if ((png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+         png_error(png_ptr, "Cannot Allocate > 64K");
+
+      else
+#    endif
+         return NULL;
+   }
+#  endif
+
+   /* Check for overflow */
+#  if defined(__TURBOC__) && !defined(__FLAT__)
+
+   if (size != (unsigned long)size)
+      ret = NULL;
+
+   else
+      ret = farmalloc(size);
+
+#  else
+#    if defined(_MSC_VER) && defined(MAXSEG_64K)
+   if (size != (unsigned long)size)
+      ret = NULL;
+
+   else
+      ret = halloc(size, 1);
+
+#    else
+   if (size != (size_t)size)
+      ret = NULL;
+
+   else
+      ret = malloc((size_t)size);
+#    endif
+#  endif
+
+#  ifndef PNG_USER_MEM_SUPPORTED
+   if (ret == NULL && (png_ptr->flags&PNG_FLAG_MALLOC_NULL_MEM_OK) == 0)
+      png_error(png_ptr, "Out of Memory");
+#  endif
+
+   return (ret);
+}
+
+/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
+ * without taking any action.
+ */
+void PNGAPI
+png_free(png_structp png_ptr, png_voidp ptr)
+{
+   if (png_ptr == NULL || ptr == NULL)
+      return;
+
+#  ifdef PNG_USER_MEM_SUPPORTED
+   if (png_ptr->free_fn != NULL)
+   {
+      (*(png_ptr->free_fn))(png_ptr, ptr);
+      return;
+   }
+
+   else
+      png_free_default(png_ptr, ptr);
+}
+
+void PNGAPI
+png_free_default(png_structp png_ptr, png_voidp ptr)
+{
+   if (png_ptr == NULL || ptr == NULL)
+      return;
+
+#  endif /* PNG_USER_MEM_SUPPORTED */
+
+#  if defined(__TURBOC__) && !defined(__FLAT__)
+   farfree(ptr);
+
+#  else
+#    if defined(_MSC_VER) && defined(MAXSEG_64K)
+   hfree(ptr);
+
+#    else
+   free(ptr);
+
+#    endif
+#  endif
+}
+#endif /* Not Borland DOS special memory handler */
+
+/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
+ * function will set up png_malloc() to issue a png_warning and return NULL
+ * instead of issuing a png_error, if it fails to allocate the requested
+ * memory.
+ */
+PNG_FUNCTION(png_voidp,PNGAPI
+png_malloc_warn,(png_structp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
+{
+   png_voidp ptr;
+   png_uint_32 save_flags;
+   if (png_ptr == NULL)
+      return (NULL);
+
+   save_flags = png_ptr->flags;
+   png_ptr->flags|=PNG_FLAG_MALLOC_NULL_MEM_OK;
+   ptr = (png_voidp)png_malloc((png_structp)png_ptr, size);
+   png_ptr->flags=save_flags;
+   return(ptr);
+}
+
+
+#ifdef PNG_USER_MEM_SUPPORTED
+/* This function is called when the application wants to use another method
+ * of allocating and freeing memory.
+ */
+void PNGAPI
+png_set_mem_fn(png_structp png_ptr, png_voidp mem_ptr, png_malloc_ptr
+  malloc_fn, png_free_ptr free_fn)
+{
+   if (png_ptr != NULL)
+   {
+      png_ptr->mem_ptr = mem_ptr;
+      png_ptr->malloc_fn = malloc_fn;
+      png_ptr->free_fn = free_fn;
+   }
+}
+
+/* This function returns a pointer to the mem_ptr associated with the user
+ * functions.  The application should free any memory associated with this
+ * pointer before png_write_destroy and png_read_destroy are called.
+ */
+png_voidp PNGAPI
+png_get_mem_ptr(png_const_structp png_ptr)
+{
+   if (png_ptr == NULL)
+      return (NULL);
+
+   return ((png_voidp)png_ptr->mem_ptr);
+}
+#endif /* PNG_USER_MEM_SUPPORTED */
+#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -urN a/media/libpng/pngpread.c b/media/libpng/pngpread.c
--- a/media/libpng/pngpread.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngpread.c	2012-07-13 12:40:57 +0800
@@ -1,8 +1,8 @@
 
 /* pngpread.c - read a png file in push mode
  *
- * Last changed in libpng 1.5.9 [February 18, 2012]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.11 [June 14, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -128,30 +128,6 @@
          break;
       }
 
-#ifdef PNG_READ_tEXt_SUPPORTED
-      case PNG_READ_tEXt_MODE:
-      {
-         png_push_read_tEXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
-#ifdef PNG_READ_zTXt_SUPPORTED
-      case PNG_READ_zTXt_MODE:
-      {
-         png_push_read_zTXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
-#ifdef PNG_READ_iTXt_SUPPORTED
-      case PNG_READ_iTXt_MODE:
-      {
-         png_push_read_iTXt(png_ptr, info_ptr);
-         break;
-      }
-
-#endif
       case PNG_SKIP_MODE:
       {
          png_push_crc_finish(png_ptr);
@@ -176,7 +152,7 @@
 png_push_read_sig(png_structp png_ptr, png_infop info_ptr)
 {
    png_size_t num_checked = png_ptr->sig_bytes,
-             num_to_check = 8 - num_checked;
+       num_to_check = 8 - num_checked;
 
    if (png_ptr->buffer_size < num_to_check)
    {
@@ -196,6 +172,7 @@
       else
          png_error(png_ptr, "PNG file corrupted by ASCII conversion");
    }
+
    else
    {
       if (png_ptr->sig_bytes >= 8)
@@ -408,8 +385,8 @@
             png_error(png_ptr, "Missing PLTE before IDAT");
       }
    }
-
 #endif
+
    else if (chunk_name == png_PLTE)
    {
       if (png_ptr->push_length + 4 > png_ptr->buffer_size)
@@ -650,7 +627,7 @@
          return;
       }
 
-      png_push_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
    }
 
 #endif
@@ -663,7 +640,7 @@
          return;
       }
 
-      png_push_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
    }
 
 #endif
@@ -676,7 +653,7 @@
          return;
       }
 
-      png_push_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
    }
 
 #endif
@@ -710,7 +687,7 @@
          png_push_save_buffer(png_ptr);
          return;
       }
-      png_push_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
+      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length);
    }
 
    png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
@@ -750,6 +727,7 @@
       png_ptr->save_buffer_size -= save_size;
       png_ptr->save_buffer_ptr += save_size;
    }
+
    if (png_ptr->skip_length && png_ptr->current_buffer_size)
    {
       png_size_t save_size = png_ptr->current_buffer_size;
@@ -771,6 +749,7 @@
       png_ptr->current_buffer_size -= save_size;
       png_ptr->current_buffer_ptr += save_size;
    }
+
    if (!png_ptr->skip_length)
    {
       if (png_ptr->buffer_size < 4)
@@ -793,6 +772,7 @@
       return;
 
    ptr = buffer;
+
    if (png_ptr->save_buffer_size)
    {
       png_size_t save_size;
@@ -810,6 +790,7 @@
       png_ptr->save_buffer_size -= save_size;
       png_ptr->save_buffer_ptr += save_size;
    }
+
    if (length && png_ptr->current_buffer_size)
    {
       png_size_t save_size;
@@ -839,6 +820,7 @@
          png_bytep dp;
 
          istop = png_ptr->save_buffer_size;
+
          for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;
              i < istop; i++, sp++, dp++)
          {
@@ -846,6 +828,7 @@
          }
       }
    }
+
    if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >
        png_ptr->save_buffer_max)
    {
@@ -872,6 +855,7 @@
       png_free(png_ptr, old_buffer);
       png_ptr->save_buffer_max = new_max;
    }
+
    if (png_ptr->current_buffer_size)
    {
       png_memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,
@@ -879,6 +863,7 @@
       png_ptr->save_buffer_size += png_ptr->current_buffer_size;
       png_ptr->current_buffer_size = 0;
    }
+
    png_ptr->save_buffer_ptr = png_ptr->save_buffer;
    png_ptr->buffer_size = 0;
 }
@@ -1031,6 +1016,7 @@
       png_ptr->current_buffer_size -= save_size;
       png_ptr->current_buffer_ptr += save_size;
    }
+
    if (!png_ptr->idat_size)
    {
       if (png_ptr->buffer_size < 4)
@@ -1053,6 +1039,15 @@
    if (!(buffer_length > 0) || buffer == NULL)
       png_error(png_ptr, "No IDAT data (internal error)");
 
+#ifdef PNG_READ_APNG_SUPPORTED
+   /* If the app is not APNG-aware, decode only the first frame */
+   if (!(png_ptr->apng_flags & PNG_APNG_APP) && png_ptr->num_frames_read > 0)
+   {
+     png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
+     return;
+   }
+#endif
+
    /* This routine must process all the data it has been given
     * before returning, calling the row callback as required to
     * handle the uncompressed results.
@@ -1444,521 +1439,6 @@
 #endif /* PNG_READ_INTERLACING_SUPPORTED */
 }
 
-#ifdef PNG_READ_tEXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-    length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-      {
-         PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-         png_error(png_ptr, "Out of place tEXt");
-         /* NOT REACHED */
-      }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr, length + 1);
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_tEXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_tEXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#ifdef PNG_MAX_MALLOC_64K
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* Empty loop */ ;
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr, png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
-      text_ptr->key = key;
-      text_ptr->itxt_length = 0;
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-      png_ptr->current_text = NULL;
-
-      if (ret)
-         png_warning(png_ptr, "Insufficient memory to store text chunk");
-   }
-}
-#endif
-
-#ifdef PNG_READ_zTXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-   length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-   {
-      PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-      png_error(png_ptr, "Out of place zTXt");
-      /* NOT REACHED */
-   }
-
-#ifdef PNG_MAX_MALLOC_64K
-   /* We can't handle zTXt chunks > 64K, since we don't have enough space
-    * to be able to store the uncompressed data.  Actually, the threshold
-    * is probably around 32K, but it isn't as definite as 64K is.
-    */
-   if (length > (png_uint_32)65535L)
-   {
-      png_warning(png_ptr, "zTXt chunk too large to fit in memory");
-      png_push_crc_skip(png_ptr, length);
-      return;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr, length + 1);
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_zTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_zTXt(png_structp png_ptr, png_infop info_ptr)
-{
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < (png_uint_32)png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp text;
-      png_charp key;
-      int ret;
-      png_size_t text_size, key_size;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-      key = png_ptr->current_text;
-
-      for (text = key; *text; text++)
-         /* Empty loop */ ;
-
-      /* zTXt can't have zero text */
-      if (text >= key + png_ptr->current_text_size)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      if (*text != PNG_TEXT_COMPRESSION_zTXt) /* Check compression byte */
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         return;
-      }
-
-      text++;
-
-      png_ptr->zstream.next_in = (png_bytep)text;
-      png_ptr->zstream.avail_in = (uInt)(png_ptr->current_text_size -
-          (text - key));
-      png_ptr->zstream.next_out = png_ptr->zbuf;
-      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-
-      key_size = text - key;
-      text_size = 0;
-      text = NULL;
-      ret = Z_STREAM_END;
-
-      while (png_ptr->zstream.avail_in)
-      {
-         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
-         if (ret != Z_OK && ret != Z_STREAM_END)
-         {
-            inflateReset(&png_ptr->zstream);
-            png_ptr->zstream.avail_in = 0;
-            png_ptr->current_text = NULL;
-            png_free(png_ptr, key);
-            png_free(png_ptr, text);
-            return;
-         }
-
-         if (!(png_ptr->zstream.avail_out) || ret == Z_STREAM_END)
-         {
-            if (text == NULL)
-            {
-               text = (png_charp)png_malloc(png_ptr,
-                   (png_ptr->zbuf_size
-                   - png_ptr->zstream.avail_out + key_size + 1));
-
-               png_memcpy(text + key_size, png_ptr->zbuf,
-                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-
-               png_memcpy(text, key, key_size);
-
-               text_size = key_size + png_ptr->zbuf_size -
-                   png_ptr->zstream.avail_out;
-
-               *(text + text_size) = '\0';
-            }
-
-            else
-            {
-               png_charp tmp;
-
-               tmp = text;
-               text = (png_charp)png_malloc(png_ptr, text_size +
-                   (png_ptr->zbuf_size
-                   - png_ptr->zstream.avail_out + 1));
-
-               png_memcpy(text, tmp, text_size);
-               png_free(png_ptr, tmp);
-
-               png_memcpy(text + text_size, png_ptr->zbuf,
-                   png_ptr->zbuf_size - png_ptr->zstream.avail_out);
-
-               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
-               *(text + text_size) = '\0';
-            }
-
-            if (ret != Z_STREAM_END)
-            {
-               png_ptr->zstream.next_out = png_ptr->zbuf;
-               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-            }
-         }
-         else
-         {
-            break;
-         }
-
-         if (ret == Z_STREAM_END)
-            break;
-      }
-
-      inflateReset(&png_ptr->zstream);
-      png_ptr->zstream.avail_in = 0;
-
-      if (ret != Z_STREAM_END)
-      {
-         png_ptr->current_text = NULL;
-         png_free(png_ptr, key);
-         png_free(png_ptr, text);
-         return;
-      }
-
-      png_ptr->current_text = NULL;
-      png_free(png_ptr, key);
-      key = text;
-      text += key_size;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-          png_sizeof(png_text));
-      text_ptr->compression = PNG_TEXT_COMPRESSION_zTXt;
-      text_ptr->key = key;
-      text_ptr->itxt_length = 0;
-      text_ptr->lang = NULL;
-      text_ptr->lang_key = NULL;
-      text_ptr->text = text;
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_free(png_ptr, key);
-      png_free(png_ptr, text_ptr);
-
-      if (ret)
-         png_warning(png_ptr, "Insufficient memory to store text chunk");
-   }
-}
-#endif
-
-#ifdef PNG_READ_iTXt_SUPPORTED
-void /* PRIVATE */
-png_push_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32
-    length)
-{
-   if (!(png_ptr->mode & PNG_HAVE_IHDR) || (png_ptr->mode & PNG_HAVE_IEND))
-   {
-      PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-      png_error(png_ptr, "Out of place iTXt");
-      /* NOT REACHED */
-   }
-
-#ifdef PNG_MAX_MALLOC_64K
-   png_ptr->skip_length = 0;  /* This may not be necessary */
-
-   if (length > (png_uint_32)65535L) /* Can't hold entire string in memory */
-   {
-      png_warning(png_ptr, "iTXt chunk too large to fit in memory");
-      png_ptr->skip_length = length - (png_uint_32)65535L;
-      length = (png_uint_32)65535L;
-   }
-#endif
-
-   png_ptr->current_text = (png_charp)png_malloc(png_ptr, length + 1);
-   png_ptr->current_text[length] = '\0';
-   png_ptr->current_text_ptr = png_ptr->current_text;
-   png_ptr->current_text_size = (png_size_t)length;
-   png_ptr->current_text_left = (png_size_t)length;
-   png_ptr->process_mode = PNG_READ_iTXt_MODE;
-}
-
-void /* PRIVATE */
-png_push_read_iTXt(png_structp png_ptr, png_infop info_ptr)
-{
-
-   if (png_ptr->buffer_size && png_ptr->current_text_left)
-   {
-      png_size_t text_size;
-
-      if (png_ptr->buffer_size < png_ptr->current_text_left)
-         text_size = png_ptr->buffer_size;
-
-      else
-         text_size = png_ptr->current_text_left;
-
-      png_crc_read(png_ptr, (png_bytep)png_ptr->current_text_ptr, text_size);
-      png_ptr->current_text_left -= text_size;
-      png_ptr->current_text_ptr += text_size;
-   }
-
-   if (!(png_ptr->current_text_left))
-   {
-      png_textp text_ptr;
-      png_charp key;
-      int comp_flag;
-      png_charp lang;
-      png_charp lang_key;
-      png_charp text;
-      int ret;
-
-      if (png_ptr->buffer_size < 4)
-      {
-         png_push_save_buffer(png_ptr);
-         return;
-      }
-
-      png_push_crc_finish(png_ptr);
-
-#ifdef PNG_MAX_MALLOC_64K
-      if (png_ptr->skip_length)
-         return;
-#endif
-
-      key = png_ptr->current_text;
-
-      for (lang = key; *lang; lang++)
-         /* Empty loop */ ;
-
-      if (lang < key + png_ptr->current_text_size - 3)
-         lang++;
-
-      comp_flag = *lang++;
-      lang++;     /* Skip comp_type, always zero */
-
-      for (lang_key = lang; *lang_key; lang_key++)
-         /* Empty loop */ ;
-
-      lang_key++;        /* Skip NUL separator */
-
-      text=lang_key;
-
-      if (lang_key < key + png_ptr->current_text_size - 1)
-      {
-         for (; *text; text++)
-            /* Empty loop */ ;
-      }
-
-      if (text < key + png_ptr->current_text_size)
-         text++;
-
-      text_ptr = (png_textp)png_malloc(png_ptr,
-          png_sizeof(png_text));
-
-      text_ptr->compression = comp_flag + 2;
-      text_ptr->key = key;
-      text_ptr->lang = lang;
-      text_ptr->lang_key = lang_key;
-      text_ptr->text = text;
-      text_ptr->text_length = 0;
-      text_ptr->itxt_length = png_strlen(text);
-
-      ret = png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
-
-      png_ptr->current_text = NULL;
-
-      png_free(png_ptr, text_ptr);
-      if (ret)
-         png_warning(png_ptr, "Insufficient memory to store iTXt chunk");
-   }
-}
-#endif
-
-/* This function is called when we haven't found a handler for this
- * chunk.  If there isn't a problem with the chunk itself (ie a bad chunk
- * name or a critical chunk), the chunk is (currently) silently ignored.
- */
-void /* PRIVATE */
-png_push_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32
-    length)
-{
-   png_uint_32 skip = 0;
-   png_uint_32 chunk_name = png_ptr->chunk_name;
-
-   if (PNG_CHUNK_CRITICAL(chunk_name))
-   {
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-      if (png_chunk_unknown_handling(png_ptr, chunk_name) !=
-          PNG_HANDLE_CHUNK_ALWAYS
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-          && png_ptr->read_user_chunk_fn == NULL
-#endif
-          )
-#endif
-         png_chunk_error(png_ptr, "unknown critical chunk");
-
-      PNG_UNUSED(info_ptr) /* To quiet some compiler warnings */
-   }
-
-#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
-   /* TODO: the code below is apparently just using the
-    * png_struct::unknown_chunk member as a temporarily variable, it should be
-    * possible to eliminate both it and the temporary buffer.
-    */
-   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
-   {
-#ifdef PNG_MAX_MALLOC_64K
-      if (length > 65535)
-      {
-         png_warning(png_ptr, "unknown chunk too large to fit in memory");
-         skip = length - 65535;
-         length = 65535;
-      }
-#endif
-      /* This is just a record for the user; libpng doesn't use the character
-       * form of the name.
-       */
-      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);
-
-      png_ptr->unknown_chunk.size = length;
-
-      if (length == 0)
-         png_ptr->unknown_chunk.data = NULL;
-
-      else
-      {
-         png_ptr->unknown_chunk.data = (png_bytep)png_malloc(png_ptr,
-            png_ptr->unknown_chunk.size);
-         png_crc_read(png_ptr, (png_bytep)png_ptr->unknown_chunk.data,
-            png_ptr->unknown_chunk.size);
-      }
-
-#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
-      if (png_ptr->read_user_chunk_fn != NULL)
-      {
-         /* Callback to user unknown chunk handler */
-         int ret;
-         ret = (*(png_ptr->read_user_chunk_fn))
-             (png_ptr, &png_ptr->unknown_chunk);
-
-         if (ret < 0)
-            png_chunk_error(png_ptr, "error in user chunk");
-
-         if (ret == 0)
-         {
-            if (PNG_CHUNK_CRITICAL(png_ptr->chunk_name))
-               if (png_chunk_unknown_handling(png_ptr, chunk_name) !=
-                   PNG_HANDLE_CHUNK_ALWAYS)
-                  png_chunk_error(png_ptr, "unknown critical chunk");
-            png_set_unknown_chunks(png_ptr, info_ptr,
-                &png_ptr->unknown_chunk, 1);
-         }
-      }
-
-      else
-#endif
-         png_set_unknown_chunks(png_ptr, info_ptr, &png_ptr->unknown_chunk, 1);
-      png_free(png_ptr, png_ptr->unknown_chunk.data);
-      png_ptr->unknown_chunk.data = NULL;
-   }
-
-   else
-#endif
-      skip=length;
-   png_push_crc_skip(png_ptr, skip);
-}
-
 void /* PRIVATE */
 png_push_have_info(png_structp png_ptr, png_infop info_ptr)
 {
@@ -2021,6 +1501,7 @@
 {
    png_ptr->frame_info_fn = frame_info_fn;
    png_ptr->frame_end_fn = frame_end_fn;
+   png_ptr->apng_flags |= PNG_APNG_APP;
 }
 #endif
 
diff -urN a/media/libpng/pngpriv.h b/media/libpng/pngpriv.h
--- a/media/libpng/pngpriv.h	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngpriv.h	2012-07-13 12:40:57 +0800
@@ -2,11 +2,11 @@
 /* pngpriv.h - private declarations for use inside libpng
  *
  * For conditions of distribution and use, see copyright notice in png.h
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
- * Last changed in libpng 1.5.7 [December 15, 2011]
+ * Last changed in libpng 1.5.10 [March 29, 2012]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -133,6 +133,46 @@
 #  define PNG_DLL_EXPORT
 #endif
 
+/* SECURITY and SAFETY:
+ *
+ * By default libpng is built without any internal limits on image size,
+ * individual heap (png_malloc) allocations or the total amount of memory used.
+ * If PNG_SAFE_LIMITS_SUPPORTED is defined, however, the limits below are used
+ * (unless individually overridden).  These limits are believed to be fairly
+ * safe, but builders of secure systems should verify the values against the
+ * real system capabilities.
+ */
+
+#ifdef PNG_SAFE_LIMITS_SUPPORTED
+   /* 'safe' limits */
+#  ifndef PNG_USER_WIDTH_MAX
+#     define PNG_USER_WIDTH_MAX 1000000
+#  endif
+#  ifndef PNG_USER_HEIGHT_MAX
+#     define PNG_USER_HEIGHT_MAX 1000000
+#  endif
+#  ifndef PNG_USER_CHUNK_CACHE_MAX
+#     define PNG_USER_CHUNK_CACHE_MAX 128
+#  endif
+#  ifndef PNG_USER_CHUNK_MALLOC_MAX
+#     define PNG_USER_CHUNK_MALLOC_MAX 8000000
+#  endif
+#else
+   /* values for no limits */
+#  ifndef PNG_USER_WIDTH_MAX
+#     define PNG_USER_WIDTH_MAX 0x7fffffff
+#  endif
+#  ifndef PNG_USER_HEIGHT_MAX
+#     define PNG_USER_HEIGHT_MAX 0x7fffffff
+#  endif
+#  ifndef PNG_USER_CHUNK_CACHE_MAX
+#     define PNG_USER_CHUNK_CACHE_MAX 0
+#  endif
+#  ifndef PNG_USER_CHUNK_MALLOC_MAX
+#     define PNG_USER_CHUNK_MALLOC_MAX 0
+#  endif
+#endif
+
 /* This is used for 16 bit gamma tables - only the top level pointers are const,
  * this could be changed:
  */
@@ -426,9 +466,10 @@
 #define PNG_BACKGROUND_IS_GRAY     0x800
 #define PNG_HAVE_PNG_SIGNATURE    0x1000
 #define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
+#define PNG_HAVE_iCCP             0x4000
 #ifdef PNG_APNG_SUPPORTED
-#define PNG_HAVE_acTL             0x4000
-#define PNG_HAVE_fcTL             0x8000
+#define PNG_HAVE_acTL             0x8000
+#define PNG_HAVE_fcTL            0x10000
 #endif
 
 /* Flags for the transformations the PNG library does on the image data */
@@ -632,6 +673,7 @@
 
 /* For png_struct.apng_flags: */
 #define PNG_FIRST_FRAME_HIDDEN       0x0001
+#define PNG_APNG_APP                 0x0002
 #endif
 
 /* The following will work on (signed char*) strings, whereas the get_uint_32
@@ -1231,10 +1273,8 @@
     png_uint_32 length));
 #endif
 
-#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
 PNG_EXTERN void png_handle_unknown PNGARG((png_structp png_ptr,
     png_infop info_ptr, png_uint_32 length));
-#endif
 
 PNG_EXTERN void png_check_chunk_name PNGARG((png_structp png_ptr,
     png_uint_32 chunk_name));
@@ -1407,6 +1447,13 @@
     int color_type, int interlace_type, int compression_type,
     int filter_type));
 
+/* Added at libpng version 1.5.10 */
+#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+PNG_EXTERN void png_do_check_palette_indexes PNGARG((png_structp png_ptr,
+    png_row_infop row_info));
+#endif
+
 /* Free all memory used by the read (old method - NOT DLL EXPORTED) */
 PNG_EXTERN void png_read_destroy PNGARG((png_structp png_ptr,
     png_infop info_ptr, png_infop end_info_ptr));
diff -urN a/media/libpng/pngread.c b/media/libpng/pngread.c
--- a/media/libpng/pngread.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngread.c	2012-07-13 12:40:57 +0800
@@ -1,8 +1,8 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.5.7 [December 15, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -67,15 +67,11 @@
    png_ptr->user_width_max = PNG_USER_WIDTH_MAX;
    png_ptr->user_height_max = PNG_USER_HEIGHT_MAX;
 
-#  ifdef PNG_USER_CHUNK_CACHE_MAX
    /* Added at libpng-1.2.43 and 1.4.0 */
    png_ptr->user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;
-#  endif
 
-#  ifdef PNG_SET_USER_CHUNK_MALLOC_MAX
    /* Added at libpng-1.2.43 and 1.4.1 */
    png_ptr->user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;
-#  endif
 #endif
 
 #ifdef PNG_SETJMP_SUPPORTED
@@ -922,6 +918,13 @@
 
    png_crc_finish(png_ptr, 0); /* Finish off CRC from last IDAT chunk */
 
+#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   /* Report invalid palette index; added at libng-1.5.10 */
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
+      png_ptr->num_palette_max > png_ptr->num_palette)
+     png_benign_error(png_ptr, "Read palette index exceeding num_palette");
+#endif
+
    do
    {
       png_uint_32 length = png_read_chunk_header(png_ptr);
@@ -1046,15 +1049,6 @@
          png_handle_iTXt(png_ptr, info_ptr, length);
 #endif
 
-#ifdef PNG_READ_APNG_SUPPORTED
-      else if (chunk_name == png_acTL)
-         png_handle_acTL(png_ptr, info_ptr, length);
-      else if (chunk_name == png_fcTL)
-         png_handle_fcTL(png_ptr, info_ptr, length);
-      else if (chunk_name == png_fdAT)
-         png_handle_fdAT(png_ptr, info_ptr, length);
-#endif
-
       else
          png_handle_unknown(png_ptr, info_ptr, length);
    } while (!(png_ptr->mode & PNG_HAVE_IEND));
@@ -1196,12 +1190,6 @@
    png_free(png_ptr, png_ptr->save_buffer);
 #endif
 
-#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-#ifdef PNG_TEXT_SUPPORTED
-   png_free(png_ptr, png_ptr->current_text);
-#endif /* PNG_TEXT_SUPPORTED */
-#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-
    /* Save the important info out of the png_struct, in case it is
     * being used again.
     */
diff -urN a/media/libpng/pngrio.c b/media/libpng/pngrio.c
--- a/media/libpng/pngrio.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngrio.c	2012-07-13 12:40:57 +0800
@@ -1,176 +1,176 @@
-
-/* pngrio.c - functions for data input
- *
- * Last changed in libpng 1.5.0 [January 6, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all input.  Users who need
- * special handling are expected to write a function that has the same
- * arguments as this and performs a similar function, but that possibly
- * has a different input method.  Note that you shouldn't change this
- * function, but rather write a replacement function and then make
- * libpng use it at run time with png_set_read_fn(...).
- */
-
-#include "pngpriv.h"
-
-#ifdef PNG_READ_SUPPORTED
-
-/* Read the data from whatever input you are using.  The default routine
- * reads from a file pointer.  Note that this routine sometimes gets called
- * with very small lengths, so you should implement some kind of simple
- * buffering if you are using unbuffered reads.  This should never be asked
- * to read more then 64K on a 16 bit machine.
- */
-void /* PRIVATE */
-png_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_debug1(4, "reading %d bytes", (int)length);
-
-   if (png_ptr->read_data_fn != NULL)
-      (*(png_ptr->read_data_fn))(png_ptr, data, length);
-
-   else
-      png_error(png_ptr, "Call to NULL read function");
-}
-
-#ifdef PNG_STDIO_SUPPORTED
-/* This is the function that does the actual reading of data.  If you are
- * not reading from a standard C stream, you should create a replacement
- * read_data function and use it at run time with png_set_read_fn(), rather
- * than changing the library.
- */
-#  ifndef USE_FAR_KEYWORD
-void PNGCBAPI
-png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-
-   if (png_ptr == NULL)
-      return;
-
-   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
-    * instead of an int, which is what fread() actually returns.
-    */
-   check = fread(data, 1, length, (png_FILE_p)png_ptr->io_ptr);
-
-   if (check != length)
-      png_error(png_ptr, "Read Error");
-}
-#  else
-/* This is the model-independent version. Since the standard I/O library
-   can't handle far buffers in the medium and small models, we have to copy
-   the data.
-*/
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-static void PNGCBAPI
-png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-   png_byte *n_data;
-   png_FILE_p io_ptr;
-
-   if (png_ptr == NULL)
-      return;
-
-   /* Check if data really is near. If so, use usual code. */
-   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
-
-   if ((png_bytep)n_data == data)
-   {
-      check = fread(n_data, 1, length, io_ptr);
-   }
-
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t read, remaining, err;
-      check = 0;
-      remaining = length;
-
-      do
-      {
-         read = MIN(NEAR_BUF_SIZE, remaining);
-         err = fread(buf, 1, read, io_ptr);
-         png_memcpy(data, buf, read); /* copy far buffer to near buffer */
-
-         if (err != read)
-            break;
-
-         else
-            check += err;
-
-         data += read;
-         remaining -= read;
-      }
-      while (remaining != 0);
-   }
-
-   if ((png_uint_32)check != (png_uint_32)length)
-      png_error(png_ptr, "read Error");
-}
-#  endif
-#endif
-
-/* This function allows the application to supply a new input function
- * for libpng if standard C streams aren't being used.
- *
- * This function takes as its arguments:
- *
- * png_ptr      - pointer to a png input data structure
- *
- * io_ptr       - pointer to user supplied structure containing info about
- *                the input functions.  May be NULL.
- *
- * read_data_fn - pointer to a new input function that takes as its
- *                arguments a pointer to a png_struct, a pointer to
- *                a location where input data can be stored, and a 32-bit
- *                unsigned int that is the number of bytes to be read.
- *                To exit and output any fatal error messages the new write
- *                function should call png_error(png_ptr, "Error msg").
- *                May be NULL, in which case libpng's default function will
- *                be used.
- */
-void PNGAPI
-png_set_read_fn(png_structp png_ptr, png_voidp io_ptr,
-   png_rw_ptr read_data_fn)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->io_ptr = io_ptr;
-
-#ifdef PNG_STDIO_SUPPORTED
-   if (read_data_fn != NULL)
-      png_ptr->read_data_fn = read_data_fn;
-
-   else
-      png_ptr->read_data_fn = png_default_read_data;
-#else
-   png_ptr->read_data_fn = read_data_fn;
-#endif
-
-   /* It is an error to write to a read device */
-   if (png_ptr->write_data_fn != NULL)
-   {
-      png_ptr->write_data_fn = NULL;
-      png_warning(png_ptr,
-          "Can't set both read_data_fn and write_data_fn in the"
-          " same structure");
-   }
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-   png_ptr->output_flush_fn = NULL;
-#endif
-}
-#endif /* PNG_READ_SUPPORTED */
+
+/* pngrio.c - functions for data input
+ *
+ * Last changed in libpng 1.5.0 [January 6, 2011]
+ * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
+ * This file provides a location for all input.  Users who need
+ * special handling are expected to write a function that has the same
+ * arguments as this and performs a similar function, but that possibly
+ * has a different input method.  Note that you shouldn't change this
+ * function, but rather write a replacement function and then make
+ * libpng use it at run time with png_set_read_fn(...).
+ */
+
+#include "pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+/* Read the data from whatever input you are using.  The default routine
+ * reads from a file pointer.  Note that this routine sometimes gets called
+ * with very small lengths, so you should implement some kind of simple
+ * buffering if you are using unbuffered reads.  This should never be asked
+ * to read more then 64K on a 16 bit machine.
+ */
+void /* PRIVATE */
+png_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
+{
+   png_debug1(4, "reading %d bytes", (int)length);
+
+   if (png_ptr->read_data_fn != NULL)
+      (*(png_ptr->read_data_fn))(png_ptr, data, length);
+
+   else
+      png_error(png_ptr, "Call to NULL read function");
+}
+
+#ifdef PNG_STDIO_SUPPORTED
+/* This is the function that does the actual reading of data.  If you are
+ * not reading from a standard C stream, you should create a replacement
+ * read_data function and use it at run time with png_set_read_fn(), rather
+ * than changing the library.
+ */
+#  ifndef USE_FAR_KEYWORD
+void PNGCBAPI
+png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
+{
+   png_size_t check;
+
+   if (png_ptr == NULL)
+      return;
+
+   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
+    * instead of an int, which is what fread() actually returns.
+    */
+   check = fread(data, 1, length, (png_FILE_p)png_ptr->io_ptr);
+
+   if (check != length)
+      png_error(png_ptr, "Read Error");
+}
+#  else
+/* This is the model-independent version. Since the standard I/O library
+   can't handle far buffers in the medium and small models, we have to copy
+   the data.
+*/
+
+#define NEAR_BUF_SIZE 1024
+#define MIN(a,b) (a <= b ? a : b)
+
+static void PNGCBAPI
+png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
+{
+   png_size_t check;
+   png_byte *n_data;
+   png_FILE_p io_ptr;
+
+   if (png_ptr == NULL)
+      return;
+
+   /* Check if data really is near. If so, use usual code. */
+   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
+   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
+
+   if ((png_bytep)n_data == data)
+   {
+      check = fread(n_data, 1, length, io_ptr);
+   }
+
+   else
+   {
+      png_byte buf[NEAR_BUF_SIZE];
+      png_size_t read, remaining, err;
+      check = 0;
+      remaining = length;
+
+      do
+      {
+         read = MIN(NEAR_BUF_SIZE, remaining);
+         err = fread(buf, 1, read, io_ptr);
+         png_memcpy(data, buf, read); /* copy far buffer to near buffer */
+
+         if (err != read)
+            break;
+
+         else
+            check += err;
+
+         data += read;
+         remaining -= read;
+      }
+      while (remaining != 0);
+   }
+
+   if ((png_uint_32)check != (png_uint_32)length)
+      png_error(png_ptr, "read Error");
+}
+#  endif
+#endif
+
+/* This function allows the application to supply a new input function
+ * for libpng if standard C streams aren't being used.
+ *
+ * This function takes as its arguments:
+ *
+ * png_ptr      - pointer to a png input data structure
+ *
+ * io_ptr       - pointer to user supplied structure containing info about
+ *                the input functions.  May be NULL.
+ *
+ * read_data_fn - pointer to a new input function that takes as its
+ *                arguments a pointer to a png_struct, a pointer to
+ *                a location where input data can be stored, and a 32-bit
+ *                unsigned int that is the number of bytes to be read.
+ *                To exit and output any fatal error messages the new write
+ *                function should call png_error(png_ptr, "Error msg").
+ *                May be NULL, in which case libpng's default function will
+ *                be used.
+ */
+void PNGAPI
+png_set_read_fn(png_structp png_ptr, png_voidp io_ptr,
+   png_rw_ptr read_data_fn)
+{
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->io_ptr = io_ptr;
+
+#ifdef PNG_STDIO_SUPPORTED
+   if (read_data_fn != NULL)
+      png_ptr->read_data_fn = read_data_fn;
+
+   else
+      png_ptr->read_data_fn = png_default_read_data;
+#else
+   png_ptr->read_data_fn = read_data_fn;
+#endif
+
+   /* It is an error to write to a read device */
+   if (png_ptr->write_data_fn != NULL)
+   {
+      png_ptr->write_data_fn = NULL;
+      png_warning(png_ptr,
+          "Can't set both read_data_fn and write_data_fn in the"
+          " same structure");
+   }
+
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+   png_ptr->output_flush_fn = NULL;
+#endif
+}
+#endif /* PNG_READ_SUPPORTED */
diff -urN a/media/libpng/pngrtran.c b/media/libpng/pngrtran.c
--- a/media/libpng/pngrtran.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngrtran.c	2012-07-13 12:40:57 +0800
@@ -1,5023 +1,5033 @@
-
-/* pngrtran.c - transforms the data in a row for PNG readers
- *
- * Last changed in libpng 1.5.7 [December 15, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file contains functions optionally called by an application
- * in order to tell libpng how to handle data when reading a PNG.
- * Transformations that are used in both reading and writing are
- * in pngtrans.c.
- */
-
-#include "pngpriv.h"
-
-#ifdef PNG_READ_SUPPORTED
-
-/* Set the action on getting a CRC error for an ancillary or critical chunk. */
-void PNGAPI
-png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
-{
-   png_debug(1, "in png_set_crc_action");
-
-   if (png_ptr == NULL)
-      return;
-
-   /* Tell libpng how we react to CRC errors in critical chunks */
-   switch (crit_action)
-   {
-      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
-         break;
-
-      case PNG_CRC_WARN_USE:                               /* Warn/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
-         break;
-
-      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
-                           PNG_FLAG_CRC_CRITICAL_IGNORE;
-         break;
-
-      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
-         png_warning(png_ptr,
-            "Can't discard critical data on CRC error");
-      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */
-
-      case PNG_CRC_DEFAULT:
-      default:
-         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
-         break;
-   }
-
-   /* Tell libpng how we react to CRC errors in ancillary chunks */
-   switch (ancil_action)
-   {
-      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
-         break;
-
-      case PNG_CRC_WARN_USE:                              /* Warn/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
-         break;
-
-      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
-                           PNG_FLAG_CRC_ANCILLARY_NOWARN;
-         break;
-
-      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
-         break;
-
-      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */
-
-      case PNG_CRC_DEFAULT:
-      default:
-         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
-         break;
-   }
-}
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-/* Handle alpha and tRNS via a background color */
-void PNGFAPI
-png_set_background_fixed(png_structp png_ptr,
-    png_const_color_16p background_color, int background_gamma_code,
-    int need_expand, png_fixed_point background_gamma)
-{
-   png_debug(1, "in png_set_background_fixed");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
-   {
-      png_warning(png_ptr, "Application must supply a known background gamma");
-      return;
-   }
-
-   png_ptr->transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA;
-   png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-   png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-
-   png_memcpy(&(png_ptr->background), background_color,
-      png_sizeof(png_color_16));
-   png_ptr->background_gamma = background_gamma;
-   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
-   if (need_expand)
-      png_ptr->transformations |= PNG_BACKGROUND_EXPAND;
-   else
-      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
-}
-
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-void PNGAPI
-png_set_background(png_structp png_ptr,
-    png_const_color_16p background_color, int background_gamma_code,
-    int need_expand, double background_gamma)
-{
-   png_set_background_fixed(png_ptr, background_color, background_gamma_code,
-      need_expand, png_fixed(png_ptr, background_gamma, "png_set_background"));
-}
-#  endif  /* FLOATING_POINT */
-#endif /* READ_BACKGROUND */
-
-/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the
- * one that pngrtran does first (scale) happens.  This is necessary to allow the
- * TRANSFORM and API behavior to be somewhat consistent, and it's simpler.
- */
-#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-void PNGAPI
-png_set_scale_16(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_scale_16");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_SCALE_16_TO_8;
-}
-#endif
-
-#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
-/* Chop 16-bit depth files to 8-bit depth */
-void PNGAPI
-png_set_strip_16(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_strip_16");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_16_TO_8;
-}
-#endif
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-void PNGAPI
-png_set_strip_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_strip_alpha");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_STRIP_ALPHA;
-}
-#endif
-
-#if defined(PNG_READ_ALPHA_MODE_SUPPORTED) || defined(PNG_READ_GAMMA_SUPPORTED)
-static png_fixed_point
-translate_gamma_flags(png_structp png_ptr, png_fixed_point output_gamma,
-   int is_screen)
-{
-   /* Check for flag values.  The main reason for having the old Mac value as a
-    * flag is that it is pretty near impossible to work out what the correct
-    * value is from Apple documentation - a working Mac system is needed to
-    * discover the value!
-    */
-   if (output_gamma == PNG_DEFAULT_sRGB ||
-      output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)
-   {
-      /* If there is no sRGB support this just sets the gamma to the standard
-       * sRGB value.  (This is a side effect of using this function!)
-       */
-#     ifdef PNG_READ_sRGB_SUPPORTED
-         png_ptr->flags |= PNG_FLAG_ASSUME_sRGB;
-#     endif
-      if (is_screen)
-         output_gamma = PNG_GAMMA_sRGB;
-      else
-         output_gamma = PNG_GAMMA_sRGB_INVERSE;
-   }
-
-   else if (output_gamma == PNG_GAMMA_MAC_18 ||
-      output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)
-   {
-      if (is_screen)
-         output_gamma = PNG_GAMMA_MAC_OLD;
-      else
-         output_gamma = PNG_GAMMA_MAC_INVERSE;
-   }
-
-   return output_gamma;
-}
-
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-static png_fixed_point
-convert_gamma_value(png_structp png_ptr, double output_gamma)
-{
-   /* The following silently ignores cases where fixed point (times 100,000)
-    * gamma values are passed to the floating point API.  This is safe and it
-    * means the fixed point constants work just fine with the floating point
-    * API.  The alternative would just lead to undetected errors and spurious
-    * bug reports.  Negative values fail inside the _fixed API unless they
-    * correspond to the flag values.
-    */
-   if (output_gamma > 0 && output_gamma < 128)
-      output_gamma *= PNG_FP_1;
-
-   /* This preserves -1 and -2 exactly: */
-   output_gamma = floor(output_gamma + .5);
-
-   if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)
-      png_fixed_error(png_ptr, "gamma value");
-
-   return (png_fixed_point)output_gamma;
-}
-#  endif
-#endif /* READ_ALPHA_MODE || READ_GAMMA */
-
-#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-void PNGFAPI
-png_set_alpha_mode_fixed(png_structp png_ptr, int mode,
-   png_fixed_point output_gamma)
-{
-   int compose = 0;
-   png_fixed_point file_gamma;
-
-   png_debug(1, "in png_set_alpha_mode");
-
-   if (png_ptr == NULL)
-      return;
-
-   output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1/*screen*/);
-
-   /* Validate the value to ensure it is in a reasonable range. The value
-    * is expected to be 1 or greater, but this range test allows for some
-    * viewing correction values.  The intent is to weed out users of this API
-    * who use the inverse of the gamma value accidentally!  Since some of these
-    * values are reasonable this may have to be changed.
-    */
-   if (output_gamma < 70000 || output_gamma > 300000)
-      png_error(png_ptr, "output gamma out of expected range");
-
-   /* The default file gamma is the inverse of the output gamma; the output
-    * gamma may be changed below so get the file value first:
-    */
-   file_gamma = png_reciprocal(output_gamma);
-
-   /* There are really 8 possibilities here, composed of any combination
-    * of:
-    *
-    *    premultiply the color channels
-    *    do not encode non-opaque pixels
-    *    encode the alpha as well as the color channels
-    *
-    * The differences disappear if the input/output ('screen') gamma is 1.0,
-    * because then the encoding is a no-op and there is only the choice of
-    * premultiplying the color channels or not.
-    *
-    * png_set_alpha_mode and png_set_background interact because both use
-    * png_compose to do the work.  Calling both is only useful when
-    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along
-    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.
-    */
-   switch (mode)
-   {
-      case PNG_ALPHA_PNG:        /* default: png standard */
-         /* No compose, but it may be set by png_set_background! */
-         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-         break;
-
-      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */
-         compose = 1;
-         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-         /* The output is linear: */
-         output_gamma = PNG_FP_1;
-         break;
-
-      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */
-         compose = 1;
-         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;
-         /* output_gamma records the encoding of opaque pixels! */
-         break;
-
-      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */
-         compose = 1;
-         png_ptr->transformations |= PNG_ENCODE_ALPHA;
-         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-         break;
-
-      default:
-         png_error(png_ptr, "invalid alpha mode");
-   }
-
-   /* Only set the default gamma if the file gamma has not been set (this has
-    * the side effect that the gamma in a second call to png_set_alpha_mode will
-    * be ignored.)
-    */
-   if (png_ptr->gamma == 0)
-      png_ptr->gamma = file_gamma;
-
-   /* But always set the output gamma: */
-   png_ptr->screen_gamma = output_gamma;
-
-   /* Finally, if pre-multiplying, set the background fields to achieve the
-    * desired result.
-    */
-   if (compose)
-   {
-      /* And obtain alpha pre-multiplication by composing on black: */
-      png_memset(&png_ptr->background, 0, sizeof png_ptr->background);
-      png_ptr->background_gamma = png_ptr->gamma; /* just in case */
-      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;
-      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
-
-      if (png_ptr->transformations & PNG_COMPOSE)
-         png_error(png_ptr,
-            "conflicting calls to set alpha mode and background");
-
-      png_ptr->transformations |= PNG_COMPOSE;
-   }
-
-   /* New API, make sure apps call the correct initializers: */
-   png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;
-}
-
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-void PNGAPI
-png_set_alpha_mode(png_structp png_ptr, int mode, double output_gamma)
-{
-   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
-      output_gamma));
-}
-#  endif
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-/* Dither file to 8-bit.  Supply a palette, the current number
- * of elements in the palette, the maximum number of elements
- * allowed, and a histogram if possible.  If the current number
- * of colors is greater then the maximum number, the palette will be
- * modified to fit in the maximum number.  "full_quantize" indicates
- * whether we need a quantizing cube set up for RGB images, or if we
- * simply are reducing the number of colors in a paletted image.
- */
-
-typedef struct png_dsort_struct
-{
-   struct png_dsort_struct FAR * next;
-   png_byte left;
-   png_byte right;
-} png_dsort;
-typedef png_dsort FAR *       png_dsortp;
-typedef png_dsort FAR * FAR * png_dsortpp;
-
-void PNGAPI
-png_set_quantize(png_structp png_ptr, png_colorp palette,
-    int num_palette, int maximum_colors, png_const_uint_16p histogram,
-    int full_quantize)
-{
-   png_debug(1, "in png_set_quantize");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_QUANTIZE;
-
-   if (!full_quantize)
-   {
-      int i;
-
-      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,
-          (png_uint_32)(num_palette * png_sizeof(png_byte)));
-      for (i = 0; i < num_palette; i++)
-         png_ptr->quantize_index[i] = (png_byte)i;
-   }
-
-   if (num_palette > maximum_colors)
-   {
-      if (histogram != NULL)
-      {
-         /* This is easy enough, just throw out the least used colors.
-          * Perhaps not the best solution, but good enough.
-          */
-
-         int i;
-
-         /* Initialize an array to sort colors */
-         png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,
-             (png_uint_32)(num_palette * png_sizeof(png_byte)));
-
-         /* Initialize the quantize_sort array */
-         for (i = 0; i < num_palette; i++)
-            png_ptr->quantize_sort[i] = (png_byte)i;
-
-         /* Find the least used palette entries by starting a
-          * bubble sort, and running it until we have sorted
-          * out enough colors.  Note that we don't care about
-          * sorting all the colors, just finding which are
-          * least used.
-          */
-
-         for (i = num_palette - 1; i >= maximum_colors; i--)
-         {
-            int done; /* To stop early if the list is pre-sorted */
-            int j;
-
-            done = 1;
-            for (j = 0; j < i; j++)
-            {
-               if (histogram[png_ptr->quantize_sort[j]]
-                   < histogram[png_ptr->quantize_sort[j + 1]])
-               {
-                  png_byte t;
-
-                  t = png_ptr->quantize_sort[j];
-                  png_ptr->quantize_sort[j] = png_ptr->quantize_sort[j + 1];
-                  png_ptr->quantize_sort[j + 1] = t;
-                  done = 0;
-               }
-            }
-
-            if (done)
-               break;
-         }
-
-         /* Swap the palette around, and set up a table, if necessary */
-         if (full_quantize)
-         {
-            int j = num_palette;
-
-            /* Put all the useful colors within the max, but don't
-             * move the others.
-             */
-            for (i = 0; i < maximum_colors; i++)
-            {
-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
-               {
-                  do
-                     j--;
-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
-
-                  palette[i] = palette[j];
-               }
-            }
-         }
-         else
-         {
-            int j = num_palette;
-
-            /* Move all the used colors inside the max limit, and
-             * develop a translation table.
-             */
-            for (i = 0; i < maximum_colors; i++)
-            {
-               /* Only move the colors we need to */
-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
-               {
-                  png_color tmp_color;
-
-                  do
-                     j--;
-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
-
-                  tmp_color = palette[j];
-                  palette[j] = palette[i];
-                  palette[i] = tmp_color;
-                  /* Indicate where the color went */
-                  png_ptr->quantize_index[j] = (png_byte)i;
-                  png_ptr->quantize_index[i] = (png_byte)j;
-               }
-            }
-
-            /* Find closest color for those colors we are not using */
-            for (i = 0; i < num_palette; i++)
-            {
-               if ((int)png_ptr->quantize_index[i] >= maximum_colors)
-               {
-                  int min_d, k, min_k, d_index;
-
-                  /* Find the closest color to one we threw out */
-                  d_index = png_ptr->quantize_index[i];
-                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
-                  for (k = 1, min_k = 0; k < maximum_colors; k++)
-                  {
-                     int d;
-
-                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);
-
-                     if (d < min_d)
-                     {
-                        min_d = d;
-                        min_k = k;
-                     }
-                  }
-                  /* Point to closest color */
-                  png_ptr->quantize_index[i] = (png_byte)min_k;
-               }
-            }
-         }
-         png_free(png_ptr, png_ptr->quantize_sort);
-         png_ptr->quantize_sort = NULL;
-      }
-      else
-      {
-         /* This is much harder to do simply (and quickly).  Perhaps
-          * we need to go through a median cut routine, but those
-          * don't always behave themselves with only a few colors
-          * as input.  So we will just find the closest two colors,
-          * and throw out one of them (chosen somewhat randomly).
-          * [We don't understand this at all, so if someone wants to
-          *  work on improving it, be our guest - AED, GRP]
-          */
-         int i;
-         int max_d;
-         int num_new_palette;
-         png_dsortp t;
-         png_dsortpp hash;
-
-         t = NULL;
-
-         /* Initialize palette index arrays */
-         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
-             (png_uint_32)(num_palette * png_sizeof(png_byte)));
-         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
-             (png_uint_32)(num_palette * png_sizeof(png_byte)));
-
-         /* Initialize the sort array */
-         for (i = 0; i < num_palette; i++)
-         {
-            png_ptr->index_to_palette[i] = (png_byte)i;
-            png_ptr->palette_to_index[i] = (png_byte)i;
-         }
-
-         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
-             png_sizeof(png_dsortp)));
-
-         num_new_palette = num_palette;
-
-         /* Initial wild guess at how far apart the farthest pixel
-          * pair we will be eliminating will be.  Larger
-          * numbers mean more areas will be allocated, Smaller
-          * numbers run the risk of not saving enough data, and
-          * having to do this all over again.
-          *
-          * I have not done extensive checking on this number.
-          */
-         max_d = 96;
-
-         while (num_new_palette > maximum_colors)
-         {
-            for (i = 0; i < num_new_palette - 1; i++)
-            {
-               int j;
-
-               for (j = i + 1; j < num_new_palette; j++)
-               {
-                  int d;
-
-                  d = PNG_COLOR_DIST(palette[i], palette[j]);
-
-                  if (d <= max_d)
-                  {
-
-                     t = (png_dsortp)png_malloc_warn(png_ptr,
-                         (png_uint_32)(png_sizeof(png_dsort)));
-
-                     if (t == NULL)
-                         break;
-
-                     t->next = hash[d];
-                     t->left = (png_byte)i;
-                     t->right = (png_byte)j;
-                     hash[d] = t;
-                  }
-               }
-               if (t == NULL)
-                  break;
-            }
-
-            if (t != NULL)
-            for (i = 0; i <= max_d; i++)
-            {
-               if (hash[i] != NULL)
-               {
-                  png_dsortp p;
-
-                  for (p = hash[i]; p; p = p->next)
-                  {
-                     if ((int)png_ptr->index_to_palette[p->left]
-                         < num_new_palette &&
-                         (int)png_ptr->index_to_palette[p->right]
-                         < num_new_palette)
-                     {
-                        int j, next_j;
-
-                        if (num_new_palette & 0x01)
-                        {
-                           j = p->left;
-                           next_j = p->right;
-                        }
-                        else
-                        {
-                           j = p->right;
-                           next_j = p->left;
-                        }
-
-                        num_new_palette--;
-                        palette[png_ptr->index_to_palette[j]]
-                            = palette[num_new_palette];
-                        if (!full_quantize)
-                        {
-                           int k;
-
-                           for (k = 0; k < num_palette; k++)
-                           {
-                              if (png_ptr->quantize_index[k] ==
-                                  png_ptr->index_to_palette[j])
-                                 png_ptr->quantize_index[k] =
-                                     png_ptr->index_to_palette[next_j];
-
-                              if ((int)png_ptr->quantize_index[k] ==
-                                  num_new_palette)
-                                 png_ptr->quantize_index[k] =
-                                     png_ptr->index_to_palette[j];
-                           }
-                        }
-
-                        png_ptr->index_to_palette[png_ptr->palette_to_index
-                            [num_new_palette]] = png_ptr->index_to_palette[j];
-
-                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]
-                            = png_ptr->palette_to_index[num_new_palette];
-
-                        png_ptr->index_to_palette[j] =
-                            (png_byte)num_new_palette;
-
-                        png_ptr->palette_to_index[num_new_palette] =
-                            (png_byte)j;
-                     }
-                     if (num_new_palette <= maximum_colors)
-                        break;
-                  }
-                  if (num_new_palette <= maximum_colors)
-                     break;
-               }
-            }
-
-            for (i = 0; i < 769; i++)
-            {
-               if (hash[i] != NULL)
-               {
-                  png_dsortp p = hash[i];
-                  while (p)
-                  {
-                     t = p->next;
-                     png_free(png_ptr, p);
-                     p = t;
-                  }
-               }
-               hash[i] = 0;
-            }
-            max_d += 96;
-         }
-         png_free(png_ptr, hash);
-         png_free(png_ptr, png_ptr->palette_to_index);
-         png_free(png_ptr, png_ptr->index_to_palette);
-         png_ptr->palette_to_index = NULL;
-         png_ptr->index_to_palette = NULL;
-      }
-      num_palette = maximum_colors;
-   }
-   if (png_ptr->palette == NULL)
-   {
-      png_ptr->palette = palette;
-   }
-   png_ptr->num_palette = (png_uint_16)num_palette;
-
-   if (full_quantize)
-   {
-      int i;
-      png_bytep distance;
-      int total_bits = PNG_QUANTIZE_RED_BITS + PNG_QUANTIZE_GREEN_BITS +
-          PNG_QUANTIZE_BLUE_BITS;
-      int num_red = (1 << PNG_QUANTIZE_RED_BITS);
-      int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);
-      int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);
-      png_size_t num_entries = ((png_size_t)1 << total_bits);
-
-      png_ptr->palette_lookup = (png_bytep)png_calloc(png_ptr,
-          (png_uint_32)(num_entries * png_sizeof(png_byte)));
-
-      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
-          png_sizeof(png_byte)));
-
-      png_memset(distance, 0xff, num_entries * png_sizeof(png_byte));
-
-      for (i = 0; i < num_palette; i++)
-      {
-         int ir, ig, ib;
-         int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));
-         int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));
-         int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));
-
-         for (ir = 0; ir < num_red; ir++)
-         {
-            /* int dr = abs(ir - r); */
-            int dr = ((ir > r) ? ir - r : r - ir);
-            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
-                PNG_QUANTIZE_GREEN_BITS));
-
-            for (ig = 0; ig < num_green; ig++)
-            {
-               /* int dg = abs(ig - g); */
-               int dg = ((ig > g) ? ig - g : g - ig);
-               int dt = dr + dg;
-               int dm = ((dr > dg) ? dr : dg);
-               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);
-
-               for (ib = 0; ib < num_blue; ib++)
-               {
-                  int d_index = index_g | ib;
-                  /* int db = abs(ib - b); */
-                  int db = ((ib > b) ? ib - b : b - ib);
-                  int dmax = ((dm > db) ? dm : db);
-                  int d = dmax + dt + db;
-
-                  if (d < (int)distance[d_index])
-                  {
-                     distance[d_index] = (png_byte)d;
-                     png_ptr->palette_lookup[d_index] = (png_byte)i;
-                  }
-               }
-            }
-         }
-      }
-
-      png_free(png_ptr, distance);
-   }
-}
-#endif /* PNG_READ_QUANTIZE_SUPPORTED */
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-void PNGFAPI
-png_set_gamma_fixed(png_structp png_ptr, png_fixed_point scrn_gamma,
-   png_fixed_point file_gamma)
-{
-   png_debug(1, "in png_set_gamma_fixed");
-
-   if (png_ptr == NULL)
-      return;
-
-   /* New in libpng-1.5.4 - reserve particular negative values as flags. */
-   scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1/*screen*/);
-   file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0/*file*/);
-
-#if PNG_LIBPNG_VER >= 10600
-   /* Checking the gamma values for being >0 was added in 1.5.4 along with the
-    * premultiplied alpha support; this actually hides an undocumented feature
-    * of the previous implementation which allowed gamma processing to be
-    * disabled in background handling.  There is no evidence (so far) that this
-    * was being used; however, png_set_background itself accepted and must still
-    * accept '0' for the gamma value it takes, because it isn't always used.
-    *
-    * Since this is an API change (albeit a very minor one that removes an
-    * undocumented API feature) it will not be made until libpng-1.6.0.
-    */
-   if (file_gamma <= 0)
-      png_error(png_ptr, "invalid file gamma in png_set_gamma");
-
-   if (scrn_gamma <= 0)
-      png_error(png_ptr, "invalid screen gamma in png_set_gamma");
-#endif
-
-   /* Set the gamma values unconditionally - this overrides the value in the PNG
-    * file if a gAMA chunk was present.  png_set_alpha_mode provides a
-    * different, easier, way to default the file gamma.
-    */
-   png_ptr->gamma = file_gamma;
-   png_ptr->screen_gamma = scrn_gamma;
-}
-
-#  ifdef PNG_FLOATING_POINT_SUPPORTED
-void PNGAPI
-png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
-{
-   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),
-      convert_gamma_value(png_ptr, file_gamma));
-}
-#  endif /* FLOATING_POINT_SUPPORTED */
-#endif /* READ_GAMMA */
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-/* Expand paletted images to RGB, expand grayscale images of
- * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
- * to alpha channels.
- */
-void PNGAPI
-png_set_expand(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_expand");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-
-/* GRR 19990627:  the following three functions currently are identical
- *  to png_set_expand().  However, it is entirely reasonable that someone
- *  might wish to expand an indexed image to RGB but *not* expand a single,
- *  fully transparent palette entry to a full alpha channel--perhaps instead
- *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace
- *  the transparent color with a particular RGB value, or drop tRNS entirely.
- *  IOW, a future version of the library may make the transformations flag
- *  a bit more fine-grained, with separate bits for each of these three
- *  functions.
- *
- *  More to the point, these functions make it obvious what libpng will be
- *  doing, whereas "expand" can (and does) mean any number of things.
- *
- *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified
- *  to expand only the sample depth but not to expand the tRNS to alpha
- *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
- */
-
-/* Expand paletted images to RGB. */
-void PNGAPI
-png_set_palette_to_rgb(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_palette_to_rgb");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-
-/* Expand grayscale images of less than 8-bit depth to 8 bits. */
-void PNGAPI
-png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_EXPAND;
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-
-
-
-/* Expand tRNS chunks to alpha channels. */
-void PNGAPI
-png_set_tRNS_to_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_tRNS_to_alpha");
-
-   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-}
-#endif /* defined(PNG_READ_EXPAND_SUPPORTED) */
-
-#ifdef PNG_READ_EXPAND_16_SUPPORTED
-/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise
- * it may not work correctly.)
- */
-void PNGAPI
-png_set_expand_16(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_expand_16");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= (PNG_EXPAND_16 | PNG_EXPAND | PNG_EXPAND_tRNS);
-   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-
-   /* New API, make sure apps call the correct initializers: */
-   png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;
-}
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-void PNGAPI
-png_set_gray_to_rgb(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_gray_to_rgb");
-
-   if (png_ptr != NULL)
-   {
-      /* Because rgb must be 8 bits or more: */
-      png_set_expand_gray_1_2_4_to_8(png_ptr);
-      png_ptr->transformations |= PNG_GRAY_TO_RGB;
-      png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
-   }
-}
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-void PNGFAPI
-png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
-    png_fixed_point red, png_fixed_point green)
-{
-   png_debug(1, "in png_set_rgb_to_gray");
-
-   if (png_ptr == NULL)
-      return;
-
-   switch(error_action)
-   {
-      case PNG_ERROR_ACTION_NONE:
-         png_ptr->transformations |= PNG_RGB_TO_GRAY;
-         break;
-
-      case PNG_ERROR_ACTION_WARN:
-         png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
-         break;
-
-      case PNG_ERROR_ACTION_ERROR:
-         png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
-         break;
-
-      default:
-         png_error(png_ptr, "invalid error action to rgb_to_gray");
-         break;
-   }
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-#ifdef PNG_READ_EXPAND_SUPPORTED
-      png_ptr->transformations |= PNG_EXPAND;
-#else
-   {
-      png_warning(png_ptr,
-        "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED");
-
-      png_ptr->transformations &= ~PNG_RGB_TO_GRAY;
-   }
-#endif
-   {
-      if (red >= 0 && green >= 0 && red + green <= PNG_FP_1)
-      {
-         png_uint_16 red_int, green_int;
-
-         /* NOTE: this calculation does not round, but this behavior is retained
-          * for consistency, the inaccuracy is very small.  The code here always
-          * overwrites the coefficients, regardless of whether they have been
-          * defaulted or set already.
-          */
-         red_int = (png_uint_16)(((png_uint_32)red*32768)/100000);
-         green_int = (png_uint_16)(((png_uint_32)green*32768)/100000);
-
-         png_ptr->rgb_to_gray_red_coeff   = red_int;
-         png_ptr->rgb_to_gray_green_coeff = green_int;
-         png_ptr->rgb_to_gray_coefficients_set = 1;
-      }
-
-      else
-      {
-         if (red >= 0 && green >= 0)
-            png_warning(png_ptr,
-               "ignoring out of range rgb_to_gray coefficients");
-
-         /* Use the defaults, from the cHRM chunk if set, else the historical
-          * values which are close to the sRGB/HDTV/ITU-Rec 709 values.  See
-          * png_do_rgb_to_gray for more discussion of the values.  In this case
-          * the coefficients are not marked as 'set' and are not overwritten if
-          * something has already provided a default.
-          */
-         if (png_ptr->rgb_to_gray_red_coeff == 0 &&
-            png_ptr->rgb_to_gray_green_coeff == 0)
-         {
-            png_ptr->rgb_to_gray_red_coeff   = 6968;
-            png_ptr->rgb_to_gray_green_coeff = 23434;
-            /* png_ptr->rgb_to_gray_blue_coeff  = 2366; */
-         }
-      }
-   }
-}
-
-#ifdef PNG_FLOATING_POINT_SUPPORTED
-/* Convert a RGB image to a grayscale of the same width.  This allows us,
- * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
- */
-
-void PNGAPI
-png_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,
-   double green)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_set_rgb_to_gray_fixed(png_ptr, error_action,
-      png_fixed(png_ptr, red, "rgb to gray red coefficient"),
-      png_fixed(png_ptr, green, "rgb to gray green coefficient"));
-}
-#endif /* FLOATING POINT */
-
-#endif
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-void PNGAPI
-png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
-    read_user_transform_fn)
-{
-   png_debug(1, "in png_set_read_user_transform_fn");
-
-   if (png_ptr == NULL)
-      return;
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-   png_ptr->transformations |= PNG_USER_TRANSFORM;
-   png_ptr->read_user_transform_fn = read_user_transform_fn;
-#endif
-}
-#endif
-
-#ifdef PNG_READ_TRANSFORMS_SUPPORTED
-#ifdef PNG_READ_GAMMA_SUPPORTED
-/* In the case of gamma transformations only do transformations on images where
- * the [file] gamma and screen_gamma are not close reciprocals, otherwise it
- * slows things down slightly, and also needlessly introduces small errors.
- */
-static int /* PRIVATE */
-png_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)
-{
-   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
-    * correction as a difference of the overall transform from 1.0
-    *
-    * We want to compare the threshold with s*f - 1, if we get
-    * overflow here it is because of wacky gamma values so we
-    * turn on processing anyway.
-    */
-   png_fixed_point gtest;
-   return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||
-       png_gamma_significant(gtest);
-}
-#endif
-
-/* Initialize everything needed for the read.  This includes modifying
- * the palette.
- */
-
-/*For the moment 'png_init_palette_transformations' and
- * 'png_init_rgb_transformations' only do some flag canceling optimizations.
- * The intent is that these two routines should have palette or rgb operations
- * extracted from 'png_init_read_transformations'.
- */
-static void /* PRIVATE */
-png_init_palette_transformations(png_structp png_ptr)
-{
-   /* Called to handle the (input) palette case.  In png_do_read_transformations
-    * the first step is to expand the palette if requested, so this code must
-    * take care to only make changes that are invariant with respect to the
-    * palette expansion, or only do them if there is no expansion.
-    *
-    * STRIP_ALPHA has already been handled in the caller (by setting num_trans
-    * to 0.)
-    */
-   int input_has_alpha = 0;
-   int input_has_transparency = 0;
-
-   if (png_ptr->num_trans > 0)
-   {
-      int i;
-
-      /* Ignore if all the entries are opaque (unlikely!) */
-      for (i=0; i<png_ptr->num_trans; ++i)
-         if (png_ptr->trans_alpha[i] == 255)
-            continue;
-         else if (png_ptr->trans_alpha[i] == 0)
-            input_has_transparency = 1;
-         else
-            input_has_alpha = 1;
-   }
-
-   /* If no alpha we can optimize. */
-   if (!input_has_alpha)
-   {
-      /* Any alpha means background and associative alpha processing is
-       * required, however if the alpha is 0 or 1 throughout OPTIIMIZE_ALPHA
-       * and ENCODE_ALPHA are irrelevant.
-       */
-      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-
-      if (!input_has_transparency)
-         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
-   }
-
-#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
-   /* png_set_background handling - deals with the complexity of whether the
-    * background color is in the file format or the screen format in the case
-    * where an 'expand' will happen.
-    */
-
-   /* The following code cannot be entered in the alpha pre-multiplication case
-    * because PNG_BACKGROUND_EXPAND is cancelled below.
-    */
-   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       (png_ptr->transformations & PNG_EXPAND))
-   {
-      {
-         png_ptr->background.red   =
-             png_ptr->palette[png_ptr->background.index].red;
-         png_ptr->background.green =
-             png_ptr->palette[png_ptr->background.index].green;
-         png_ptr->background.blue  =
-             png_ptr->palette[png_ptr->background.index].blue;
-
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-        if (png_ptr->transformations & PNG_INVERT_ALPHA)
-        {
-           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-           {
-              /* Invert the alpha channel (in tRNS) unless the pixels are
-               * going to be expanded, in which case leave it for later
-               */
-              int i, istop = png_ptr->num_trans;
-
-              for (i=0; i<istop; i++)
-                 png_ptr->trans_alpha[i] = (png_byte)(255 -
-                    png_ptr->trans_alpha[i]);
-           }
-        }
-#endif /* PNG_READ_INVERT_ALPHA_SUPPORTED */
-      }
-   } /* background expand and (therefore) no alpha association. */
-#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */
-}
-
-static void /* PRIVATE */
-png_init_rgb_transformations(png_structp png_ptr)
-{
-   /* Added to libpng-1.5.4: check the color type to determine whether there
-    * is any alpha or transparency in the image and simply cancel the
-    * background and alpha mode stuff if there isn't.
-    */
-   int input_has_alpha = (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0;
-   int input_has_transparency = png_ptr->num_trans > 0;
-
-   /* If no alpha we can optimize. */
-   if (!input_has_alpha)
-   {
-      /* Any alpha means background and associative alpha processing is
-       * required, however if the alpha is 0 or 1 throughout OPTIIMIZE_ALPHA
-       * and ENCODE_ALPHA are irrelevant.
-       */
-#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-#     endif
-
-      if (!input_has_transparency)
-         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
-   }
-
-#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
-   /* png_set_background handling - deals with the complexity of whether the
-    * background color is in the file format or the screen format in the case
-    * where an 'expand' will happen.
-    */
-
-   /* The following code cannot be entered in the alpha pre-multiplication case
-    * because PNG_BACKGROUND_EXPAND is cancelled below.
-    */
-   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-       (png_ptr->transformations & PNG_EXPAND) &&
-       !(png_ptr->color_type & PNG_COLOR_MASK_COLOR))
-       /* i.e., GRAY or GRAY_ALPHA */
-   {
-      {
-         /* Expand background and tRNS chunks */
-         int gray = png_ptr->background.gray;
-         int trans_gray = png_ptr->trans_color.gray;
-
-         switch (png_ptr->bit_depth)
-         {
-            case 1:
-               gray *= 0xff;
-               trans_gray *= 0xff;
-               break;
-
-            case 2:
-               gray *= 0x55;
-               trans_gray *= 0x55;
-               break;
-
-            case 4:
-               gray *= 0x11;
-               trans_gray *= 0x11;
-               break;
-
-            default:
-
-            case 8:
-               /* Already 8 bits, fall through */
-
-            case 16:
-               /* Already a full 16 bits */
-               break;
-         }
-
-         png_ptr->background.red = png_ptr->background.green =
-            png_ptr->background.blue = (png_uint_16)gray;
-
-         if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
-         {
-            png_ptr->trans_color.red = png_ptr->trans_color.green =
-               png_ptr->trans_color.blue = (png_uint_16)trans_gray;
-         }
-      }
-   } /* background expand and (therefore) no alpha association. */
-#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */
-}
-
-void /* PRIVATE */
-png_init_read_transformations(png_structp png_ptr)
-{
-   png_debug(1, "in png_init_read_transformations");
-
-   /* This internal function is called from png_read_start_row in pngrutil.c
-    * and it is called before the 'rowbytes' calculation is done, so the code
-    * in here can change or update the transformations flags.
-    *
-    * First do updates that do not depend on the details of the PNG image data
-    * being processed.
-    */
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
-    * png_set_alpha_mode and this is another source for a default file gamma so
-    * the test needs to be performed later - here.  In addition prior to 1.5.4
-    * the tests were repeated for the PALETTE color type here - this is no
-    * longer necessary (and doesn't seem to have been necessary before.)
-    */
-   {
-      /* The following temporary indicates if overall gamma correction is
-       * required.
-       */
-      int gamma_correction = 0;
-
-      if (png_ptr->gamma != 0) /* has been set */
-      {
-         if (png_ptr->screen_gamma != 0) /* screen set too */
-            gamma_correction = png_gamma_threshold(png_ptr->gamma,
-               png_ptr->screen_gamma);
-
-         else
-            /* Assume the output matches the input; a long time default behavior
-             * of libpng, although the standard has nothing to say about this.
-             */
-            png_ptr->screen_gamma = png_reciprocal(png_ptr->gamma);
-      }
-
-      else if (png_ptr->screen_gamma != 0)
-         /* The converse - assume the file matches the screen, note that this
-          * perhaps undesireable default can (from 1.5.4) be changed by calling
-          * png_set_alpha_mode (even if the alpha handling mode isn't required
-          * or isn't changed from the default.)
-          */
-         png_ptr->gamma = png_reciprocal(png_ptr->screen_gamma);
-
-      else /* neither are set */
-         /* Just in case the following prevents any processing - file and screen
-          * are both assumed to be linear and there is no way to introduce a
-          * third gamma value other than png_set_background with 'UNIQUE', and,
-          * prior to 1.5.4
-          */
-         png_ptr->screen_gamma = png_ptr->gamma = PNG_FP_1;
-
-      /* Now turn the gamma transformation on or off as appropriate.  Notice
-       * that PNG_GAMMA just refers to the file->screen correction.  Alpha
-       * composition may independently cause gamma correction because it needs
-       * linear data (e.g. if the file has a gAMA chunk but the screen gamma
-       * hasn't been specified.)  In any case this flag may get turned off in
-       * the code immediately below if the transform can be handled outside the
-       * row loop.
-       */
-      if (gamma_correction)
-         png_ptr->transformations |= PNG_GAMMA;
-
-      else
-         png_ptr->transformations &= ~PNG_GAMMA;
-   }
-#endif
-
-   /* Certain transformations have the effect of preventing other
-    * transformations that happen afterward in png_do_read_transformations,
-    * resolve the interdependencies here.  From the code of
-    * png_do_read_transformations the order is:
-    *
-    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)
-    *  2) PNG_STRIP_ALPHA (if no compose)
-    *  3) PNG_RGB_TO_GRAY
-    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY
-    *  5) PNG_COMPOSE
-    *  6) PNG_GAMMA
-    *  7) PNG_STRIP_ALPHA (if compose)
-    *  8) PNG_ENCODE_ALPHA
-    *  9) PNG_SCALE_16_TO_8
-    * 10) PNG_16_TO_8
-    * 11) PNG_QUANTIZE (converts to palette)
-    * 12) PNG_EXPAND_16
-    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY
-    * 14) PNG_INVERT_MONO
-    * 15) PNG_SHIFT
-    * 16) PNG_PACK
-    * 17) PNG_BGR
-    * 18) PNG_PACKSWAP
-    * 19) PNG_FILLER (includes PNG_ADD_ALPHA)
-    * 20) PNG_INVERT_ALPHA
-    * 21) PNG_SWAP_ALPHA
-    * 22) PNG_SWAP_BYTES
-    * 23) PNG_USER_TRANSFORM [must be last]
-    */
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
-      !(png_ptr->transformations & PNG_COMPOSE))
-   {
-      /* Stripping the alpha channel happens immediately after the 'expand'
-       * transformations, before all other transformation, so it cancels out
-       * the alpha handling.  It has the side effect negating the effect of
-       * PNG_EXPAND_tRNS too:
-       */
-      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |
-         PNG_EXPAND_tRNS);
-      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-
-      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen
-       * so transparency information would remain just so long as it wasn't
-       * expanded.  This produces unexpected API changes if the set of things
-       * that do PNG_EXPAND_tRNS changes (perfectly possible given the
-       * documentation - which says ask for what you want, accept what you
-       * get.)  This makes the behavior consistent from 1.5.4:
-       */
-      png_ptr->num_trans = 0;
-   }
-#endif /* STRIP_ALPHA supported, no COMPOSE */
-
-#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA
-    * settings will have no effect.
-    */
-   if (!png_gamma_significant(png_ptr->screen_gamma))
-   {
-      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
-      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
-   }
-#endif
-
-#if defined(PNG_READ_EXPAND_SUPPORTED) && \
-   defined(PNG_READ_BACKGROUND_SUPPORTED) && \
-   defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
-   /* Detect gray background and attempt to enable optimization for
-    * gray --> RGB case.
-    *
-    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
-    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
-    * background color might actually be gray yet not be flagged as such.
-    * This is not a problem for the current code, which uses
-    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
-    * png_do_gray_to_rgb() transformation.
-    *
-    * TODO: this code needs to be revised to avoid the complexity and
-    * interdependencies.  The color type of the background should be recorded in
-    * png_set_background, along with the bit depth, then the code has a record
-    * of exactly what color space the background is currently in.
-    */
-   if (png_ptr->transformations & PNG_BACKGROUND_EXPAND)
-   {
-      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if
-       * the file was grayscale the background value is gray.
-       */
-      if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR))
-         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-   }
-
-   else if (png_ptr->transformations & PNG_COMPOSE)
-   {
-      /* PNG_COMPOSE: png_set_background was called with need_expand false,
-       * so the color is in the color space of the output or png_set_alpha_mode
-       * was called and the color is black.  Ignore RGB_TO_GRAY because that
-       * happens before GRAY_TO_RGB.
-       */
-      if (png_ptr->transformations & PNG_GRAY_TO_RGB)
-      {
-         if (png_ptr->background.red == png_ptr->background.green &&
-             png_ptr->background.red == png_ptr->background.blue)
-         {
-            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
-            png_ptr->background.gray = png_ptr->background.red;
-         }
-      }
-   }
-#endif /* PNG_READ_GRAY_TO_RGB_SUPPORTED (etc) */
-
-   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
-    * can be performed directly on the palette, and some (such as rgb to gray)
-    * can be optimized inside the palette.  This is particularly true of the
-    * composite (background and alpha) stuff, which can be pretty much all done
-    * in the palette even if the result is expanded to RGB or gray afterward.
-    *
-    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and
-    * earlier and the palette stuff is actually handled on the first row.  This
-    * leads to the reported bug that the palette returned by png_get_PLTE is not
-    * updated.
-    */
-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      png_init_palette_transformations(png_ptr);
-
-   else
-      png_init_rgb_transformations(png_ptr);
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
-   defined(PNG_READ_EXPAND_16_SUPPORTED)
-   if ((png_ptr->transformations & PNG_EXPAND_16) &&
-      (png_ptr->transformations & PNG_COMPOSE) &&
-      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-      png_ptr->bit_depth != 16)
-   {
-      /* TODO: fix this.  Because the expand_16 operation is after the compose
-       * handling the background color must be 8, not 16, bits deep, but the
-       * application will supply a 16-bit value so reduce it here.
-       *
-       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at
-       * present, so that case is ok (until do_expand_16 is moved.)
-       *
-       * NOTE: this discards the low 16 bits of the user supplied background
-       * color, but until expand_16 works properly there is no choice!
-       */
-#     define CHOP(x) (x)=((png_uint_16)(((png_uint_32)(x)*255+32895) >> 16))
-      CHOP(png_ptr->background.red);
-      CHOP(png_ptr->background.green);
-      CHOP(png_ptr->background.blue);
-      CHOP(png_ptr->background.gray);
-#     undef CHOP
-   }
-#endif /* PNG_READ_BACKGROUND_SUPPORTED && PNG_READ_EXPAND_16_SUPPORTED */
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
-   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \
-   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))
-   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) &&
-      (png_ptr->transformations & PNG_COMPOSE) &&
-      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
-      png_ptr->bit_depth == 16)
-   {
-      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per
-       * component this will also happen after PNG_COMPOSE and so the background
-       * color must be pre-expanded here.
-       *
-       * TODO: fix this too.
-       */
-      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);
-      png_ptr->background.green =
-         (png_uint_16)(png_ptr->background.green * 257);
-      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);
-      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);
-   }
-#endif
-
-   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the
-    * background support (see the comments in scripts/pnglibconf.dfa), this
-    * allows pre-multiplication of the alpha channel to be implemented as
-    * compositing on black.  This is probably sub-optimal and has been done in
-    * 1.5.4 betas simply to enable external critique and testing (i.e. to
-    * implement the new API quickly, without lots of internal changes.)
-    */
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-#  ifdef PNG_READ_BACKGROUND_SUPPORTED
-      /* Includes ALPHA_MODE */
-      png_ptr->background_1 = png_ptr->background;
-#  endif
-
-   /* This needs to change - in the palette image case a whole set of tables are
-    * built when it would be quicker to just calculate the correct value for
-    * each palette entry directly.  Also, the test is too tricky - why check
-    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that
-    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the
-    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction
-    * the gamma tables will not be built even if composition is required on a
-    * gamma encoded value.
-    *
-    * In 1.5.4 this is addressed below by an additional check on the individual
-    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the
-    * tables.
-    */
-   if ((png_ptr->transformations & PNG_GAMMA)
-      || ((png_ptr->transformations & PNG_RGB_TO_GRAY)
-         && (png_gamma_significant(png_ptr->gamma) ||
-            png_gamma_significant(png_ptr->screen_gamma)))
-      || ((png_ptr->transformations & PNG_COMPOSE)
-         && (png_gamma_significant(png_ptr->gamma)
-            || png_gamma_significant(png_ptr->screen_gamma)
-#  ifdef PNG_READ_BACKGROUND_SUPPORTED
-            || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE
-               && png_gamma_significant(png_ptr->background_gamma))
-#  endif
-      )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA)
-         && png_gamma_significant(png_ptr->screen_gamma))
-      )
-   {
-      png_build_gamma_table(png_ptr, png_ptr->bit_depth);
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-      if (png_ptr->transformations & PNG_COMPOSE)
-      {
-         /* Issue a warning about this combination: because RGB_TO_GRAY is
-          * optimized to do the gamma transform if present yet do_background has
-          * to do the same thing if both options are set a
-          * double-gamma-correction happens.  This is true in all versions of
-          * libpng to date.
-          */
-         if (png_ptr->transformations & PNG_RGB_TO_GRAY)
-            png_warning(png_ptr,
-               "libpng does not support gamma+background+rgb_to_gray");
-
-         if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-         {
-            /* We don't get to here unless there is a tRNS chunk with non-opaque
-             * entries - see the checking code at the start of this function.
-             */
-            png_color back, back_1;
-            png_colorp palette = png_ptr->palette;
-            int num_palette = png_ptr->num_palette;
-            int i;
-            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
-            {
-
-               back.red = png_ptr->gamma_table[png_ptr->background.red];
-               back.green = png_ptr->gamma_table[png_ptr->background.green];
-               back.blue = png_ptr->gamma_table[png_ptr->background.blue];
-
-               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
-               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
-               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
-            }
-            else
-            {
-               png_fixed_point g, gs;
-
-               switch (png_ptr->background_gamma_type)
-               {
-                  case PNG_BACKGROUND_GAMMA_SCREEN:
-                     g = (png_ptr->screen_gamma);
-                     gs = PNG_FP_1;
-                     break;
-
-                  case PNG_BACKGROUND_GAMMA_FILE:
-                     g = png_reciprocal(png_ptr->gamma);
-                     gs = png_reciprocal2(png_ptr->gamma,
-                        png_ptr->screen_gamma);
-                     break;
-
-                  case PNG_BACKGROUND_GAMMA_UNIQUE:
-                     g = png_reciprocal(png_ptr->background_gamma);
-                     gs = png_reciprocal2(png_ptr->background_gamma,
-                        png_ptr->screen_gamma);
-                     break;
-                  default:
-                     g = PNG_FP_1;    /* back_1 */
-                     gs = PNG_FP_1;   /* back */
-                     break;
-               }
-
-               if (png_gamma_significant(gs))
-               {
-                  back.red = png_gamma_8bit_correct(png_ptr->background.red,
-                      gs);
-                  back.green = png_gamma_8bit_correct(png_ptr->background.green,
-                      gs);
-                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,
-                      gs);
-               }
-
-               else
-               {
-                  back.red   = (png_byte)png_ptr->background.red;
-                  back.green = (png_byte)png_ptr->background.green;
-                  back.blue  = (png_byte)png_ptr->background.blue;
-               }
-
-               if (png_gamma_significant(g))
-               {
-                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,
-                     g);
-                  back_1.green = png_gamma_8bit_correct(
-                     png_ptr->background.green, g);
-                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,
-                     g);
-               }
-
-               else
-               {
-                  back_1.red   = (png_byte)png_ptr->background.red;
-                  back_1.green = (png_byte)png_ptr->background.green;
-                  back_1.blue  = (png_byte)png_ptr->background.blue;
-               }
-            }
-
-            for (i = 0; i < num_palette; i++)
-            {
-               if (i < (int)png_ptr->num_trans &&
-                   png_ptr->trans_alpha[i] != 0xff)
-               {
-                  if (png_ptr->trans_alpha[i] == 0)
-                  {
-                     palette[i] = back;
-                  }
-                  else /* if (png_ptr->trans_alpha[i] != 0xff) */
-                  {
-                     png_byte v, w;
-
-                     v = png_ptr->gamma_to_1[palette[i].red];
-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);
-                     palette[i].red = png_ptr->gamma_from_1[w];
-
-                     v = png_ptr->gamma_to_1[palette[i].green];
-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);
-                     palette[i].green = png_ptr->gamma_from_1[w];
-
-                     v = png_ptr->gamma_to_1[palette[i].blue];
-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);
-                     palette[i].blue = png_ptr->gamma_from_1[w];
-                  }
-               }
-               else
-               {
-                  palette[i].red = png_ptr->gamma_table[palette[i].red];
-                  palette[i].green = png_ptr->gamma_table[palette[i].green];
-                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];
-               }
-            }
-
-            /* Prevent the transformations being done again.
-             *
-             * NOTE: this is highly dubious; it removes the transformations in
-             * place.  This seems inconsistent with the general treatment of the
-             * transformations elsewhere.
-             */
-            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);
-         } /* color_type == PNG_COLOR_TYPE_PALETTE */
-
-         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
-         else /* color_type != PNG_COLOR_TYPE_PALETTE */
-         {
-            int gs_sig, g_sig;
-            png_fixed_point g = PNG_FP_1;  /* Correction to linear */
-            png_fixed_point gs = PNG_FP_1; /* Correction to screen */
-
-            switch (png_ptr->background_gamma_type)
-            {
-               case PNG_BACKGROUND_GAMMA_SCREEN:
-                  g = png_ptr->screen_gamma;
-                  /* gs = PNG_FP_1; */
-                  break;
-
-               case PNG_BACKGROUND_GAMMA_FILE:
-                  g = png_reciprocal(png_ptr->gamma);
-                  gs = png_reciprocal2(png_ptr->gamma, png_ptr->screen_gamma);
-                  break;
-
-               case PNG_BACKGROUND_GAMMA_UNIQUE:
-                  g = png_reciprocal(png_ptr->background_gamma);
-                  gs = png_reciprocal2(png_ptr->background_gamma,
-                      png_ptr->screen_gamma);
-                  break;
-
-               default:
-                  png_error(png_ptr, "invalid background gamma type");
-            }
-
-            g_sig = png_gamma_significant(g);
-            gs_sig = png_gamma_significant(gs);
-
-            if (g_sig)
-               png_ptr->background_1.gray = png_gamma_correct(png_ptr,
-                   png_ptr->background.gray, g);
-
-            if (gs_sig)
-               png_ptr->background.gray = png_gamma_correct(png_ptr,
-                   png_ptr->background.gray, gs);
-
-            if ((png_ptr->background.red != png_ptr->background.green) ||
-                (png_ptr->background.red != png_ptr->background.blue) ||
-                (png_ptr->background.red != png_ptr->background.gray))
-            {
-               /* RGB or RGBA with color background */
-               if (g_sig)
-               {
-                  png_ptr->background_1.red = png_gamma_correct(png_ptr,
-                      png_ptr->background.red, g);
-
-                  png_ptr->background_1.green = png_gamma_correct(png_ptr,
-                      png_ptr->background.green, g);
-
-                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,
-                      png_ptr->background.blue, g);
-               }
-
-               if (gs_sig)
-               {
-                  png_ptr->background.red = png_gamma_correct(png_ptr,
-                      png_ptr->background.red, gs);
-
-                  png_ptr->background.green = png_gamma_correct(png_ptr,
-                      png_ptr->background.green, gs);
-
-                  png_ptr->background.blue = png_gamma_correct(png_ptr,
-                      png_ptr->background.blue, gs);
-               }
-            }
-
-            else
-            {
-               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
-               png_ptr->background_1.red = png_ptr->background_1.green
-                   = png_ptr->background_1.blue = png_ptr->background_1.gray;
-
-               png_ptr->background.red = png_ptr->background.green
-                   = png_ptr->background.blue = png_ptr->background.gray;
-            }
-
-            /* The background is now in screen gamma: */
-            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;
-         } /* color_type != PNG_COLOR_TYPE_PALETTE */
-      }/* png_ptr->transformations & PNG_BACKGROUND */
-
-      else
-      /* Transformation does not include PNG_BACKGROUND */
-#endif /* PNG_READ_BACKGROUND_SUPPORTED */
-      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */
-         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||
-         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)
-#endif
-         )
-      {
-         png_colorp palette = png_ptr->palette;
-         int num_palette = png_ptr->num_palette;
-         int i;
-
-         /*NOTE: there are other transformations that should probably be in here
-          * too.
-          */
-         for (i = 0; i < num_palette; i++)
-         {
-            palette[i].red = png_ptr->gamma_table[palette[i].red];
-            palette[i].green = png_ptr->gamma_table[palette[i].green];
-            palette[i].blue = png_ptr->gamma_table[palette[i].blue];
-         }
-
-         /* Done the gamma correction. */
-         png_ptr->transformations &= ~PNG_GAMMA;
-      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */
-   }
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   else
-#endif
-#endif /* PNG_READ_GAMMA_SUPPORTED */
-
-#ifdef PNG_READ_BACKGROUND_SUPPORTED
-   /* No GAMMA transformation (see the hanging else 4 lines above) */
-   if ((png_ptr->transformations & PNG_COMPOSE) &&
-       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
-   {
-      int i;
-      int istop = (int)png_ptr->num_trans;
-      png_color back;
-      png_colorp palette = png_ptr->palette;
-
-      back.red   = (png_byte)png_ptr->background.red;
-      back.green = (png_byte)png_ptr->background.green;
-      back.blue  = (png_byte)png_ptr->background.blue;
-
-      for (i = 0; i < istop; i++)
-      {
-         if (png_ptr->trans_alpha[i] == 0)
-         {
-            palette[i] = back;
-         }
-
-         else if (png_ptr->trans_alpha[i] != 0xff)
-         {
-            /* The png_composite() macro is defined in png.h */
-            png_composite(palette[i].red, palette[i].red,
-                png_ptr->trans_alpha[i], back.red);
-
-            png_composite(palette[i].green, palette[i].green,
-                png_ptr->trans_alpha[i], back.green);
-
-            png_composite(palette[i].blue, palette[i].blue,
-                png_ptr->trans_alpha[i], back.blue);
-         }
-      }
-
-      png_ptr->transformations &= ~PNG_COMPOSE;
-   }
-#endif /* PNG_READ_BACKGROUND_SUPPORTED */
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-   if ((png_ptr->transformations & PNG_SHIFT) &&
-       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
-   {
-      int i;
-      int istop = png_ptr->num_palette;
-      int shift = 8 - png_ptr->sig_bit.red;
-
-      /* significant bits can be in the range 1 to 7 for a meaninful result, if
-       * the number of significant bits is 0 then no shift is done (this is an
-       * error condition which is silently ignored.)
-       */
-      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
-      {
-         int component = png_ptr->palette[i].red;
-
-         component >>= shift;
-         png_ptr->palette[i].red = (png_byte)component;
-      }
-
-      shift = 8 - png_ptr->sig_bit.green;
-      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
-      {
-         int component = png_ptr->palette[i].green;
-
-         component >>= shift;
-         png_ptr->palette[i].green = (png_byte)component;
-      }
-
-      shift = 8 - png_ptr->sig_bit.blue;
-      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
-      {
-         int component = png_ptr->palette[i].blue;
-
-         component >>= shift;
-         png_ptr->palette[i].blue = (png_byte)component;
-      }
-   }
-#endif  /* PNG_READ_SHIFT_SUPPORTED */
-}
-
-/* Modify the info structure to reflect the transformations.  The
- * info should be updated so a PNG file could be written with it,
- * assuming the transformations result in valid PNG data.
- */
-void /* PRIVATE */
-png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
-{
-   png_debug(1, "in png_read_transform_info");
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-   if (png_ptr->transformations & PNG_EXPAND)
-   {
-      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         /* This check must match what actually happens in
-          * png_do_expand_palette; if it ever checks the tRNS chunk to see if
-          * it is all opaque we must do the same (at present it does not.)
-          */
-         if (png_ptr->num_trans > 0)
-            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
-
-         else
-            info_ptr->color_type = PNG_COLOR_TYPE_RGB;
-
-         info_ptr->bit_depth = 8;
-         info_ptr->num_trans = 0;
-      }
-      else
-      {
-         if (png_ptr->num_trans)
-         {
-            if (png_ptr->transformations & PNG_EXPAND_tRNS)
-               info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
-         }
-         if (info_ptr->bit_depth < 8)
-            info_ptr->bit_depth = 8;
-
-         info_ptr->num_trans = 0;
-      }
-   }
-#endif
-
-#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
-   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
-   /* The following is almost certainly wrong unless the background value is in
-    * the screen space!
-    */
-   if (png_ptr->transformations & PNG_COMPOSE)
-      info_ptr->background = png_ptr->background;
-#endif
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   /* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),
-    * however it seems that the code in png_init_read_transformations, which has
-    * been called before this from png_read_update_info->png_read_start_row
-    * sometimes does the gamma transform and cancels the flag.
-    */
-   info_ptr->gamma = png_ptr->gamma;
-#endif
-
-   if (info_ptr->bit_depth == 16)
-   {
-#  ifdef PNG_READ_16BIT_SUPPORTED
-#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-         if (png_ptr->transformations & PNG_SCALE_16_TO_8)
-            info_ptr->bit_depth = 8;
-#     endif
-
-#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
-         if (png_ptr->transformations & PNG_16_TO_8)
-            info_ptr->bit_depth = 8;
-#     endif
-
-#  else
-      /* No 16 bit support: force chopping 16-bit input down to 8, in this case
-       * the app program can chose if both APIs are available by setting the
-       * correct scaling to use.
-       */
-#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
-         /* For compatibility with previous versions use the strip method by
-          * default.  This code works because if PNG_SCALE_16_TO_8 is already
-          * set the code below will do that in preference to the chop.
-          */
-         png_ptr->transformations |= PNG_16_TO_8;
-         info_ptr->bit_depth = 8;
-#     else
-
-#        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-            png_ptr->transformations |= PNG_SCALE_16_TO_8;
-            info_ptr->bit_depth = 8;
-#        else
-
-            CONFIGURATION ERROR: you must enable at least one 16 to 8 method
-#        endif
-#    endif
-#endif /* !READ_16BIT_SUPPORTED */
-   }
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
-      info_ptr->color_type = (png_byte)(info_ptr->color_type |
-         PNG_COLOR_MASK_COLOR);
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
-      info_ptr->color_type = (png_byte)(info_ptr->color_type &
-         ~PNG_COLOR_MASK_COLOR);
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   if (png_ptr->transformations & PNG_QUANTIZE)
-   {
-      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
-          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
-          png_ptr->palette_lookup && info_ptr->bit_depth == 8)
-      {
-         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
-      }
-   }
-#endif
-
-#ifdef PNG_READ_EXPAND_16_SUPPORTED
-   if (png_ptr->transformations & PNG_EXPAND_16 && info_ptr->bit_depth == 8 &&
-      info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
-   {
-      info_ptr->bit_depth = 16;
-   }
-#endif
-
-#ifdef PNG_READ_PACK_SUPPORTED
-   if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))
-      info_ptr->bit_depth = 8;
-#endif
-
-   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
-      info_ptr->channels = 1;
-
-   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
-      info_ptr->channels = 3;
-
-   else
-      info_ptr->channels = 1;
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_STRIP_ALPHA)
-   {
-      info_ptr->color_type = (png_byte)(info_ptr->color_type &
-         ~PNG_COLOR_MASK_ALPHA);
-      info_ptr->num_trans = 0;
-   }
-#endif
-
-   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
-      info_ptr->channels++;
-
-#ifdef PNG_READ_FILLER_SUPPORTED
-   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
-   if ((png_ptr->transformations & PNG_FILLER) &&
-       ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
-       (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))
-   {
-      info_ptr->channels++;
-      /* If adding a true alpha channel not just filler */
-      if (png_ptr->transformations & PNG_ADD_ALPHA)
-         info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
-   }
-#endif
-
-#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
-defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
-   if (png_ptr->transformations & PNG_USER_TRANSFORM)
-   {
-      if (info_ptr->bit_depth < png_ptr->user_transform_depth)
-         info_ptr->bit_depth = png_ptr->user_transform_depth;
-
-      if (info_ptr->channels < png_ptr->user_transform_channels)
-         info_ptr->channels = png_ptr->user_transform_channels;
-   }
-#endif
-
-   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
-       info_ptr->bit_depth);
-
-   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
-
-   /* Adding in 1.5.4: cache the above value in png_struct so that we can later
-    * check in png_rowbytes that the user buffer won't get overwritten.  Note
-    * that the field is not always set - if png_read_update_info isn't called
-    * the application has to either not do any transforms or get the calculation
-    * right itself.
-    */
-   png_ptr->info_rowbytes = info_ptr->rowbytes;
-
-#ifndef PNG_READ_EXPAND_SUPPORTED
-   if (png_ptr)
-      return;
-#endif
-}
-
-/* Transform the row.  The order of transformations is significant,
- * and is very touchy.  If you add a transformation, take care to
- * decide how it fits in with the other transformations here.
- */
-void /* PRIVATE */
-png_do_read_transformations(png_structp png_ptr, png_row_infop row_info)
-{
-   png_debug(1, "in png_do_read_transformations");
-
-   if (png_ptr->row_buf == NULL)
-   {
-      /* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this
-       * error is incredibly rare and incredibly easy to debug without this
-       * information.
-       */
-      png_error(png_ptr, "NULL row buffer");
-   }
-
-   /* The following is debugging; prior to 1.5.4 the code was never compiled in;
-    * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro
-    * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.5 the new flag is set only for
-    * selected new APIs to ensure that there is no API change.
-    */
-   if ((png_ptr->flags & PNG_FLAG_DETECT_UNINITIALIZED) != 0 &&
-      !(png_ptr->flags & PNG_FLAG_ROW_INIT))
-   {
-      /* Application has failed to call either png_read_start_image() or
-       * png_read_update_info() after setting transforms that expand pixels.
-       * This check added to libpng-1.2.19 (but not enabled until 1.5.4).
-       */
-      png_error(png_ptr, "Uninitialized row");
-   }
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-   if (png_ptr->transformations & PNG_EXPAND)
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
-      {
-         png_do_expand_palette(row_info, png_ptr->row_buf + 1,
-             png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);
-      }
-
-      else
-      {
-         if (png_ptr->num_trans &&
-             (png_ptr->transformations & PNG_EXPAND_tRNS))
-            png_do_expand(row_info, png_ptr->row_buf + 1,
-                &(png_ptr->trans_color));
-
-         else
-            png_do_expand(row_info, png_ptr->row_buf + 1,
-                NULL);
-      }
-   }
-#endif
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
-      !(png_ptr->transformations & PNG_COMPOSE) &&
-      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
-      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
-         0 /* at_start == false, because SWAP_ALPHA happens later */);
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
-   {
-      int rgb_error =
-          png_do_rgb_to_gray(png_ptr, row_info,
-              png_ptr->row_buf + 1);
-
-      if (rgb_error)
-      {
-         png_ptr->rgb_to_gray_status=1;
-         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
-             PNG_RGB_TO_GRAY_WARN)
-            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
-
-         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
-             PNG_RGB_TO_GRAY_ERR)
-            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
-      }
-   }
-#endif
-
-/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
- *
- *   In most cases, the "simple transparency" should be done prior to doing
- *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
- *   pixel is transparent.  You would also need to make sure that the
- *   transparency information is upgraded to RGB.
- *
- *   To summarize, the current flow is:
- *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
- *                                   with background "in place" if transparent,
- *                                   convert to RGB if necessary
- *   - Gray + alpha -> composite with gray background and remove alpha bytes,
- *                                   convert to RGB if necessary
- *
- *   To support RGB backgrounds for gray images we need:
- *   - Gray + simple transparency -> convert to RGB + simple transparency,
- *                                   compare 3 or 6 bytes and composite with
- *                                   background "in place" if transparent
- *                                   (3x compare/pixel compared to doing
- *                                   composite with gray bkgrnd)
- *   - Gray + alpha -> convert to RGB + alpha, composite with background and
- *                                   remove alpha bytes (3x float
- *                                   operations/pixel compared with composite
- *                                   on gray background)
- *
- *  Greg's change will do this.  The reason it wasn't done before is for
- *  performance, as this increases the per-pixel operations.  If we would check
- *  in advance if the background was gray or RGB, and position the gray-to-RGB
- *  transform appropriately, then it would save a lot of work/time.
- */
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /* If gray -> RGB, do so now only if background is non-gray; else do later
-    * for performance reasons
-    */
-   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-       !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
-      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
-#endif
-
-#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
-   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
-   if (png_ptr->transformations & PNG_COMPOSE)
-      png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);
-#endif
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   if ((png_ptr->transformations & PNG_GAMMA) &&
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-      /* Because RGB_TO_GRAY does the gamma transform. */
-      !(png_ptr->transformations & PNG_RGB_TO_GRAY) &&
-#endif
-#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
-   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
-      /* Because PNG_COMPOSE does the gamma transform if there is something to
-       * do (if there is an alpha channel or transparency.)
-       */
-       !((png_ptr->transformations & PNG_COMPOSE) &&
-       ((png_ptr->num_trans != 0) ||
-       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
-#endif
-      /* Because png_init_read_transformations transforms the palette, unless
-       * RGB_TO_GRAY will do the transform.
-       */
-       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
-      png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);
-#endif
-
-#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
-   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
-      (png_ptr->transformations & PNG_COMPOSE) &&
-      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
-      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
-      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
-         0 /* at_start == false, because SWAP_ALPHA happens later */);
-#endif
-
-#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-   if ((png_ptr->transformations & PNG_ENCODE_ALPHA) &&
-      (row_info->color_type & PNG_COLOR_MASK_ALPHA))
-      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);
-#endif
-
-#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-   if (png_ptr->transformations & PNG_SCALE_16_TO_8)
-      png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
-   /* There is no harm in doing both of these because only one has any effect,
-    * by putting the 'scale' option first if the app asks for scale (either by
-    * calling the API or in a TRANSFORM flag) this is what happens.
-    */
-   if (png_ptr->transformations & PNG_16_TO_8)
-      png_do_chop(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-   if (png_ptr->transformations & PNG_QUANTIZE)
-   {
-      png_do_quantize(row_info, png_ptr->row_buf + 1,
-          png_ptr->palette_lookup, png_ptr->quantize_index);
-
-      if (row_info->rowbytes == 0)
-         png_error(png_ptr, "png_do_quantize returned rowbytes=0");
-   }
-#endif /* PNG_READ_QUANTIZE_SUPPORTED */
-
-#ifdef PNG_READ_EXPAND_16_SUPPORTED
-   /* Do the expansion now, after all the arithmetic has been done.  Notice
-    * that previous transformations can handle the PNG_EXPAND_16 flag if this
-    * is efficient (particularly true in the case of gamma correction, where
-    * better accuracy results faster!)
-    */
-   if (png_ptr->transformations & PNG_EXPAND_16)
-      png_do_expand_16(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-   /*NOTE: moved here in 1.5.4 (from much later in this list.) */
-   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
-       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
-      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_INVERT_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_do_invert(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-   if (png_ptr->transformations & PNG_SHIFT)
-      png_do_unshift(row_info, png_ptr->row_buf + 1,
-          &(png_ptr->shift));
-#endif
-
-#ifdef PNG_READ_PACK_SUPPORTED
-   if (png_ptr->transformations & PNG_PACK)
-      png_do_unpack(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_BGR_SUPPORTED
-   if (png_ptr->transformations & PNG_BGR)
-      png_do_bgr(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_PACKSWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_PACKSWAP)
-      png_do_packswap(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_FILLER_SUPPORTED
-   if (png_ptr->transformations & PNG_FILLER)
-      png_do_read_filler(row_info, png_ptr->row_buf + 1,
-          (png_uint_32)png_ptr->filler, png_ptr->flags);
-#endif
-
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_ALPHA)
-      png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_ALPHA)
-      png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-#ifdef PNG_READ_SWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_do_swap(row_info, png_ptr->row_buf + 1);
-#endif
-#endif
-
-#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
-   if (png_ptr->transformations & PNG_USER_TRANSFORM)
-    {
-      if (png_ptr->read_user_transform_fn != NULL)
-         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
-             (png_ptr,     /* png_ptr */
-             row_info,     /* row_info: */
-                /*  png_uint_32 width;       width of row */
-                /*  png_size_t rowbytes;     number of bytes in row */
-                /*  png_byte color_type;     color type of pixels */
-                /*  png_byte bit_depth;      bit depth of samples */
-                /*  png_byte channels;       number of channels (1-4) */
-                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
-             png_ptr->row_buf + 1);    /* start of pixel data for row */
-#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-      if (png_ptr->user_transform_depth)
-         row_info->bit_depth = png_ptr->user_transform_depth;
-
-      if (png_ptr->user_transform_channels)
-         row_info->channels = png_ptr->user_transform_channels;
-#endif
-      row_info->pixel_depth = (png_byte)(row_info->bit_depth *
-          row_info->channels);
-
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);
-   }
-#endif
-}
-
-#ifdef PNG_READ_PACK_SUPPORTED
-/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
- * without changing the actual values.  Thus, if you had a row with
- * a bit depth of 1, you would end up with bytes that only contained
- * the numbers 0 or 1.  If you would rather they contain 0 and 255, use
- * png_do_shift() after this.
- */
-void /* PRIVATE */
-png_do_unpack(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_unpack");
-
-   if (row_info->bit_depth < 8)
-   {
-      png_uint_32 i;
-      png_uint_32 row_width=row_info->width;
-
-      switch (row_info->bit_depth)
-      {
-         case 1:
-         {
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);
-            for (i = 0; i < row_width; i++)
-            {
-               *dp = (png_byte)((*sp >> shift) & 0x01);
-
-               if (shift == 7)
-               {
-                  shift = 0;
-                  sp--;
-               }
-
-               else
-                  shift++;
-
-               dp--;
-            }
-            break;
-         }
-
-         case 2:
-         {
-
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
-            for (i = 0; i < row_width; i++)
-            {
-               *dp = (png_byte)((*sp >> shift) & 0x03);
-
-               if (shift == 6)
-               {
-                  shift = 0;
-                  sp--;
-               }
-
-               else
-                  shift += 2;
-
-               dp--;
-            }
-            break;
-         }
-
-         case 4:
-         {
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
-            for (i = 0; i < row_width; i++)
-            {
-               *dp = (png_byte)((*sp >> shift) & 0x0f);
-
-               if (shift == 4)
-               {
-                  shift = 0;
-                  sp--;
-               }
-
-               else
-                  shift = 4;
-
-               dp--;
-            }
-            break;
-         }
-
-         default:
-            break;
-      }
-      row_info->bit_depth = 8;
-      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
-      row_info->rowbytes = row_width * row_info->channels;
-   }
-}
-#endif
-
-#ifdef PNG_READ_SHIFT_SUPPORTED
-/* Reverse the effects of png_do_shift.  This routine merely shifts the
- * pixels back to their significant bits values.  Thus, if you have
- * a row of bit depth 8, but only 5 are significant, this will shift
- * the values back to 0 through 31.
- */
-void /* PRIVATE */
-png_do_unshift(png_row_infop row_info, png_bytep row,
-    png_const_color_8p sig_bits)
-{
-   int color_type;
-
-   png_debug(1, "in png_do_unshift");
-
-   /* The palette case has already been handled in the _init routine. */
-   color_type = row_info->color_type;
-
-   if (color_type != PNG_COLOR_TYPE_PALETTE)
-   {
-      int shift[4];
-      int channels = 0;
-      int bit_depth = row_info->bit_depth;
-
-      if (color_type & PNG_COLOR_MASK_COLOR)
-      {
-         shift[channels++] = bit_depth - sig_bits->red;
-         shift[channels++] = bit_depth - sig_bits->green;
-         shift[channels++] = bit_depth - sig_bits->blue;
-      }
-
-      else
-      {
-         shift[channels++] = bit_depth - sig_bits->gray;
-      }
-
-      if (color_type & PNG_COLOR_MASK_ALPHA)
-      {
-         shift[channels++] = bit_depth - sig_bits->alpha;
-      }
-
-      {
-         int c, have_shift;
-
-         for (c = have_shift = 0; c < channels; ++c)
-         {
-            /* A shift of more than the bit depth is an error condition but it
-             * gets ignored here.
-             */
-            if (shift[c] <= 0 || shift[c] >= bit_depth)
-               shift[c] = 0;
-
-            else
-               have_shift = 1;
-         }
-
-         if (!have_shift)
-            return;
-      }
-
-      switch (bit_depth)
-      {
-         default:
-         /* Must be 1bpp gray: should not be here! */
-            /* NOTREACHED */
-            break;
-
-         case 2:
-         /* Must be 2bpp gray */
-         /* assert(channels == 1 && shift[0] == 1) */
-         {
-            png_bytep bp = row;
-            png_bytep bp_end = bp + row_info->rowbytes;
-
-            while (bp < bp_end)
-            {
-               int b = (*bp >> 1) & 0x55;
-               *bp++ = (png_byte)b;
-            }
-            break;
-         }
-
-         case 4:
-         /* Must be 4bpp gray */
-         /* assert(channels == 1) */
-         {
-            png_bytep bp = row;
-            png_bytep bp_end = bp + row_info->rowbytes;
-            int gray_shift = shift[0];
-            int mask =  0xf >> gray_shift;
-
-            mask |= mask << 4;
-
-            while (bp < bp_end)
-            {
-               int b = (*bp >> gray_shift) & mask;
-               *bp++ = (png_byte)b;
-            }
-            break;
-         }
-
-         case 8:
-         /* Single byte components, G, GA, RGB, RGBA */
-         {
-            png_bytep bp = row;
-            png_bytep bp_end = bp + row_info->rowbytes;
-            int channel = 0;
-
-            while (bp < bp_end)
-            {
-               int b = *bp >> shift[channel];
-               if (++channel >= channels)
-                  channel = 0;
-               *bp++ = (png_byte)b;
-            }
-            break;
-         }
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-         case 16:
-         /* Double byte components, G, GA, RGB, RGBA */
-         {
-            png_bytep bp = row;
-            png_bytep bp_end = bp + row_info->rowbytes;
-            int channel = 0;
-
-            while (bp < bp_end)
-            {
-               int value = (bp[0] << 8) + bp[1];
-
-               value >>= shift[channel];
-               if (++channel >= channels)
-                  channel = 0;
-               *bp++ = (png_byte)(value >> 8);
-               *bp++ = (png_byte)(value & 0xff);
-            }
-            break;
-         }
-#endif
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
-/* Scale rows of bit depth 16 down to 8 accurately */
-void /* PRIVATE */
-png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_scale_16_to_8");
-
-   if (row_info->bit_depth == 16)
-   {
-      png_bytep sp = row; /* source */
-      png_bytep dp = row; /* destination */
-      png_bytep ep = sp + row_info->rowbytes; /* end+1 */
-
-      while (sp < ep)
-      {
-         /* The input is an array of 16 bit components, these must be scaled to
-          * 8 bits each.  For a 16 bit value V the required value (from the PNG
-          * specification) is:
-          *
-          *    (V * 255) / 65535
-          *
-          * This reduces to round(V / 257), or floor((V + 128.5)/257)
-          *
-          * Represent V as the two byte value vhi.vlo.  Make a guess that the
-          * result is the top byte of V, vhi, then the correction to this value
-          * is:
-          *
-          *    error = floor(((V-vhi.vhi) + 128.5) / 257)
-          *          = floor(((vlo-vhi) + 128.5) / 257)
-          *
-          * This can be approximated using integer arithmetic (and a signed
-          * shift):
-          *
-          *    error = (vlo-vhi+128) >> 8;
-          *
-          * The approximate differs from the exact answer only when (vlo-vhi) is
-          * 128; it then gives a correction of +1 when the exact correction is
-          * 0.  This gives 128 errors.  The exact answer (correct for all 16 bit
-          * input values) is:
-          *
-          *    error = (vlo-vhi+128)*65535 >> 24;
-          *
-          * An alternative arithmetic calculation which also gives no errors is:
-          *
-          *    (V * 255 + 32895) >> 16
-          */
-
-         png_int_32 tmp = *sp++; /* must be signed! */
-         tmp += (((int)*sp++ - tmp + 128) * 65535) >> 24;
-         *dp++ = (png_byte)tmp;
-      }
-
-      row_info->bit_depth = 8;
-      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
-      row_info->rowbytes = row_info->width * row_info->channels;
-   }
-}
-#endif
-
-#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
-void /* PRIVATE */
-/* Simply discard the low byte.  This was the default behavior prior
- * to libpng-1.5.4.
- */
-png_do_chop(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_chop");
-
-   if (row_info->bit_depth == 16)
-   {
-      png_bytep sp = row; /* source */
-      png_bytep dp = row; /* destination */
-      png_bytep ep = sp + row_info->rowbytes; /* end+1 */
-
-      while (sp < ep)
-      {
-         *dp++ = *sp;
-         sp += 2; /* skip low byte */
-      }
-
-      row_info->bit_depth = 8;
-      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
-      row_info->rowbytes = row_info->width * row_info->channels;
-   }
-}
-#endif
-
-#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_read_swap_alpha");
-
-   {
-      png_uint_32 row_width = row_info->width;
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         /* This converts from RGBA to ARGB */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save;
-            }
-         }
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-         /* This converts from RRGGBBAA to AARRGGBB */
-         else
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save[2];
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save[0] = *(--sp);
-               save[1] = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save[0];
-               *(--dp) = save[1];
-            }
-         }
-#endif
-      }
-
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         /* This converts from GA to AG */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save;
-            }
-         }
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-         /* This converts from GGAA to AAGG */
-         else
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save[2];
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               save[0] = *(--sp);
-               save[1] = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save[0];
-               *(--dp) = save[1];
-            }
-         }
-#endif
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_uint_32 row_width;
-   png_debug(1, "in png_do_read_invert_alpha");
-
-   row_width = row_info->width;
-   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         /* This inverts the alpha channel in RGBA */
-         png_bytep sp = row + row_info->rowbytes;
-         png_bytep dp = sp;
-         png_uint_32 i;
-
-         for (i = 0; i < row_width; i++)
-         {
-            *(--dp) = (png_byte)(255 - *(--sp));
-
-/*          This does nothing:
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-            We can replace it with:
-*/
-            sp-=3;
-            dp=sp;
-         }
-      }
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-      /* This inverts the alpha channel in RRGGBBAA */
-      else
-      {
-         png_bytep sp = row + row_info->rowbytes;
-         png_bytep dp = sp;
-         png_uint_32 i;
-
-         for (i = 0; i < row_width; i++)
-         {
-            *(--dp) = (png_byte)(255 - *(--sp));
-            *(--dp) = (png_byte)(255 - *(--sp));
-
-/*          This does nothing:
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-            We can replace it with:
-*/
-            sp-=6;
-            dp=sp;
-         }
-      }
-#endif
-   }
-   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         /* This inverts the alpha channel in GA */
-         png_bytep sp = row + row_info->rowbytes;
-         png_bytep dp = sp;
-         png_uint_32 i;
-
-         for (i = 0; i < row_width; i++)
-         {
-            *(--dp) = (png_byte)(255 - *(--sp));
-            *(--dp) = *(--sp);
-         }
-      }
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-      else
-      {
-         /* This inverts the alpha channel in GGAA */
-         png_bytep sp  = row + row_info->rowbytes;
-         png_bytep dp = sp;
-         png_uint_32 i;
-
-         for (i = 0; i < row_width; i++)
-         {
-            *(--dp) = (png_byte)(255 - *(--sp));
-            *(--dp) = (png_byte)(255 - *(--sp));
-/*
-            *(--dp) = *(--sp);
-            *(--dp) = *(--sp);
-*/
-            sp-=2;
-            dp=sp;
-         }
-      }
-#endif
-   }
-}
-#endif
-
-#ifdef PNG_READ_FILLER_SUPPORTED
-/* Add filler channel if we have RGB color */
-void /* PRIVATE */
-png_do_read_filler(png_row_infop row_info, png_bytep row,
-    png_uint_32 filler, png_uint_32 flags)
-{
-   png_uint_32 i;
-   png_uint_32 row_width = row_info->width;
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-   png_byte hi_filler = (png_byte)((filler>>8) & 0xff);
-#endif
-   png_byte lo_filler = (png_byte)(filler & 0xff);
-
-   png_debug(1, "in png_do_read_filler");
-
-   if (
-       row_info->color_type == PNG_COLOR_TYPE_GRAY)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            /* This changes the data from G to GX */
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp =  sp + (png_size_t)row_width;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = lo_filler;
-            row_info->channels = 2;
-            row_info->pixel_depth = 16;
-            row_info->rowbytes = row_width * 2;
-         }
-
-         else
-         {
-            /* This changes the data from G to XG */
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp = sp  + (png_size_t)row_width;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = lo_filler;
-            }
-            row_info->channels = 2;
-            row_info->pixel_depth = 16;
-            row_info->rowbytes = row_width * 2;
-         }
-      }
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-      else if (row_info->bit_depth == 16)
-      {
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            /* This changes the data from GG to GGXX */
-            png_bytep sp = row + (png_size_t)row_width * 2;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = hi_filler;
-            *(--dp) = lo_filler;
-            row_info->channels = 2;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-
-         else
-         {
-            /* This changes the data from GG to XXGG */
-            png_bytep sp = row + (png_size_t)row_width * 2;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-            }
-            row_info->channels = 2;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-      }
-#endif
-   } /* COLOR_TYPE == GRAY */
-   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            /* This changes the data from RGB to RGBX */
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp  + (png_size_t)row_width;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = lo_filler;
-            row_info->channels = 4;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-
-         else
-         {
-            /* This changes the data from RGB to XRGB */
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp + (png_size_t)row_width;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = lo_filler;
-            }
-            row_info->channels = 4;
-            row_info->pixel_depth = 32;
-            row_info->rowbytes = row_width * 4;
-         }
-      }
-
-#ifdef PNG_READ_16BIT_SUPPORTED
-      else if (row_info->bit_depth == 16)
-      {
-         if (flags & PNG_FLAG_FILLER_AFTER)
-         {
-            /* This changes the data from RRGGBB to RRGGBBXX */
-            png_bytep sp = row + (png_size_t)row_width * 6;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 1; i < row_width; i++)
-            {
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-            }
-            *(--dp) = hi_filler;
-            *(--dp) = lo_filler;
-            row_info->channels = 4;
-            row_info->pixel_depth = 64;
-            row_info->rowbytes = row_width * 8;
-         }
-
-         else
-         {
-            /* This changes the data from RRGGBB to XXRRGGBB */
-            png_bytep sp = row + (png_size_t)row_width * 6;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = hi_filler;
-               *(--dp) = lo_filler;
-            }
-
-            row_info->channels = 4;
-            row_info->pixel_depth = 64;
-            row_info->rowbytes = row_width * 8;
-         }
-      }
-#endif
-   } /* COLOR_TYPE == RGB */
-}
-#endif
-
-#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
-/* Expand grayscale files to RGB, with or without alpha */
-void /* PRIVATE */
-png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
-{
-   png_uint_32 i;
-   png_uint_32 row_width = row_info->width;
-
-   png_debug(1, "in png_do_gray_to_rgb");
-
-   if (row_info->bit_depth >= 8 &&
-       !(row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This changes G to RGB */
-            png_bytep sp = row + (png_size_t)row_width - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *sp;
-               *(dp--) = *sp;
-               *(dp--) = *(sp--);
-            }
-         }
-
-         else
-         {
-            /* This changes GG to RRGGBB */
-            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 4;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *(sp--);
-               *(dp--) = *(sp--);
-            }
-         }
-      }
-
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This changes GA to RGBA */
-            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *(sp--);
-               *(dp--) = *sp;
-               *(dp--) = *sp;
-               *(dp--) = *(sp--);
-            }
-         }
-
-         else
-         {
-            /* This changes GGAA to RRGGBBAA */
-            png_bytep sp = row + (png_size_t)row_width * 4 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 4;
-            for (i = 0; i < row_width; i++)
-            {
-               *(dp--) = *(sp--);
-               *(dp--) = *(sp--);
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *sp;
-               *(dp--) = *(sp - 1);
-               *(dp--) = *(sp--);
-               *(dp--) = *(sp--);
-            }
-         }
-      }
-      row_info->channels = (png_byte)(row_info->channels + 2);
-      row_info->color_type |= PNG_COLOR_MASK_COLOR;
-      row_info->pixel_depth = (png_byte)(row_info->channels *
-          row_info->bit_depth);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-   }
-}
-#endif
-
-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
-/* Reduce RGB files to grayscale, with or without alpha
- * using the equation given in Poynton's ColorFAQ of 1998-01-04 at
- * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but
- * versions dated 1998 through November 2002 have been archived at
- * http://web.archive.org/web/20000816232553/http://www.inforamp.net/
- * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )
- * Charles Poynton poynton at poynton.com
- *
- *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
- *
- *  which can be expressed with integers as
- *
- *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
- *
- * Poynton's current link (as of January 2003 through July 2011):
- * <http://www.poynton.com/notes/colour_and_gamma/>
- * has changed the numbers slightly:
- *
- *     Y = 0.2126*R + 0.7152*G + 0.0722*B
- *
- *  which can be expressed with integers as
- *
- *     Y = (6966 * R + 23436 * G + 2366 * B)/32768
- *
- *  Historically, however, libpng uses numbers derived from the ITU-R Rec 709
- *  end point chromaticities and the D65 white point.  Depending on the
- *  precision used for the D65 white point this produces a variety of different
- *  numbers, however if the four decimal place value used in ITU-R Rec 709 is
- *  used (0.3127,0.3290) the Y calculation would be:
- *
- *     Y = (6968 * R + 23435 * G + 2366 * B)/32768
- *
- *  While this is correct the rounding results in an overflow for white, because
- *  the sum of the rounded coefficients is 32769, not 32768.  Consequently
- *  libpng uses, instead, the closest non-overflowing approximation:
- *
- *     Y = (6968 * R + 23434 * G + 2366 * B)/32768
- *
- *  Starting with libpng-1.5.5, if the image being converted has a cHRM chunk
- *  (including an sRGB chunk) then the chromaticities are used to calculate the
- *  coefficients.  See the chunk handling in pngrutil.c for more information.
- *
- *  In all cases the calculation is to be done in a linear colorspace.  If no
- *  gamma information is available to correct the encoding of the original RGB
- *  values this results in an implicit assumption that the original PNG RGB
- *  values were linear.
- *
- *  Other integer coefficents can be used via png_set_rgb_to_gray().  Because
- *  the API takes just red and green coefficients the blue coefficient is
- *  calculated to make the sum 32768.  This will result in different rounding
- *  to that used above.
- */
-int /* PRIVATE */
-png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)
-
-{
-   int rgb_error = 0;
-
-   png_debug(1, "in png_do_rgb_to_gray");
-
-   if (!(row_info->color_type & PNG_COLOR_MASK_PALETTE) &&
-       (row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      PNG_CONST png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
-      PNG_CONST png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
-      PNG_CONST png_uint_32 bc = 32768 - rc - gc;
-      PNG_CONST png_uint_32 row_width = row_info->width;
-      PNG_CONST int have_alpha =
-         (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;
-
-      if (row_info->bit_depth == 8)
-      {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-         /* Notice that gamma to/from 1 are not necessarily inverses (if
-          * there is an overall gamma correction).  Prior to 1.5.5 this code
-          * checked the linearized values for equality; this doesn't match
-          * the documentation, the original values must be checked.
-          */
-         if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
-         {
-            png_bytep sp = row;
-            png_bytep dp = row;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               png_byte red   = *(sp++);
-               png_byte green = *(sp++);
-               png_byte blue  = *(sp++);
-
-               if (red != green || red != blue)
-               {
-                  red = png_ptr->gamma_to_1[red];
-                  green = png_ptr->gamma_to_1[green];
-                  blue = png_ptr->gamma_to_1[blue];
-
-                  rgb_error |= 1;
-                  *(dp++) = png_ptr->gamma_from_1[
-                      (rc*red + gc*green + bc*blue + 16384)>>15];
-               }
-
-               else
-               {
-                  /* If there is no overall correction the table will not be
-                   * set.
-                   */
-                  if (png_ptr->gamma_table != NULL)
-                     red = png_ptr->gamma_table[red];
-
-                  *(dp++) = red;
-               }
-
-               if (have_alpha)
-                  *(dp++) = *(sp++);
-            }
-         }
-         else
-#endif
-         {
-            png_bytep sp = row;
-            png_bytep dp = row;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               png_byte red   = *(sp++);
-               png_byte green = *(sp++);
-               png_byte blue  = *(sp++);
-
-               if (red != green || red != blue)
-               {
-                  rgb_error |= 1;
-                  /*NOTE: this is the historical approach which simply
-                   * truncates the results.
-                   */
-                  *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
-               }
-
-               else
-                  *(dp++) = red;
-
-               if (have_alpha)
-                  *(dp++) = *(sp++);
-            }
-         }
-      }
-
-      else /* RGB bit_depth == 16 */
-      {
-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
-         if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)
-         {
-            png_bytep sp = row;
-            png_bytep dp = row;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               png_uint_16 red, green, blue, w;
-
-               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-
-               if (red == green && red == blue)
-               {
-                  if (png_ptr->gamma_16_table != NULL)
-                     w = png_ptr->gamma_16_table[(red&0xff)
-                         >> png_ptr->gamma_shift][red>>8];
-
-                  else
-                     w = red;
-               }
-
-               else
-               {
-                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)
-                      >> png_ptr->gamma_shift][red>>8];
-                  png_uint_16 green_1 =
-                      png_ptr->gamma_16_to_1[(green&0xff) >>
-                      png_ptr->gamma_shift][green>>8];
-                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)
-                      >> png_ptr->gamma_shift][blue>>8];
-                  png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
-                      + bc*blue_1 + 16384)>>15);
-                  w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
-                      png_ptr->gamma_shift][gray16 >> 8];
-                  rgb_error |= 1;
-               }
-
-               *(dp++) = (png_byte)((w>>8) & 0xff);
-               *(dp++) = (png_byte)(w & 0xff);
-
-               if (have_alpha)
-               {
-                  *(dp++) = *(sp++);
-                  *(dp++) = *(sp++);
-               }
-            }
-         }
-         else
-#endif
-         {
-            png_bytep sp = row;
-            png_bytep dp = row;
-            png_uint_32 i;
-
-            for (i = 0; i < row_width; i++)
-            {
-               png_uint_16 red, green, blue, gray16;
-
-               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
-
-               if (red != green || red != blue)
-                  rgb_error |= 1;
-
-               /* From 1.5.5 in the 16 bit case do the accurate conversion even
-                * in the 'fast' case - this is because this is where the code
-                * ends up when handling linear 16 bit data.
-                */
-               gray16  = (png_uint_16)((rc*red + gc*green + bc*blue + 16384) >>
-                  15);
-               *(dp++) = (png_byte)((gray16>>8) & 0xff);
-               *(dp++) = (png_byte)(gray16 & 0xff);
-
-               if (have_alpha)
-               {
-                  *(dp++) = *(sp++);
-                  *(dp++) = *(sp++);
-               }
-            }
-         }
-      }
-
-      row_info->channels = (png_byte)(row_info->channels - 2);
-      row_info->color_type = (png_byte)(row_info->color_type &
-          ~PNG_COLOR_MASK_COLOR);
-      row_info->pixel_depth = (png_byte)(row_info->channels *
-          row_info->bit_depth);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-   }
-   return rgb_error;
-}
-#endif
-#endif /* PNG_READ_TRANSFORMS_SUPPORTED */
-
-#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
-/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
- * large of png_color.  This lets grayscale images be treated as
- * paletted.  Most useful for gamma correction and simplification
- * of code.  This API is not used internally.
- */
-void PNGAPI
-png_build_grayscale_palette(int bit_depth, png_colorp palette)
-{
-   int num_palette;
-   int color_inc;
-   int i;
-   int v;
-
-   png_debug(1, "in png_do_build_grayscale_palette");
-
-   if (palette == NULL)
-      return;
-
-   switch (bit_depth)
-   {
-      case 1:
-         num_palette = 2;
-         color_inc = 0xff;
-         break;
-
-      case 2:
-         num_palette = 4;
-         color_inc = 0x55;
-         break;
-
-      case 4:
-         num_palette = 16;
-         color_inc = 0x11;
-         break;
-
-      case 8:
-         num_palette = 256;
-         color_inc = 1;
-         break;
-
-      default:
-         num_palette = 0;
-         color_inc = 0;
-         break;
-   }
-
-   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
-   {
-      palette[i].red = (png_byte)v;
-      palette[i].green = (png_byte)v;
-      palette[i].blue = (png_byte)v;
-   }
-}
-#endif
-
-
-#ifdef PNG_READ_TRANSFORMS_SUPPORTED
-#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
-   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
-/* Replace any alpha or transparency with the supplied background color.
- * "background" is already in the screen gamma, while "background_1" is
- * at a gamma of 1.0.  Paletted files have already been taken care of.
- */
-void /* PRIVATE */
-png_do_compose(png_row_infop row_info, png_bytep row, png_structp png_ptr)
-{
-#ifdef PNG_READ_GAMMA_SUPPORTED
-   png_const_bytep gamma_table = png_ptr->gamma_table;
-   png_const_bytep gamma_from_1 = png_ptr->gamma_from_1;
-   png_const_bytep gamma_to_1 = png_ptr->gamma_to_1;
-   png_const_uint_16pp gamma_16 = png_ptr->gamma_16_table;
-   png_const_uint_16pp gamma_16_from_1 = png_ptr->gamma_16_from_1;
-   png_const_uint_16pp gamma_16_to_1 = png_ptr->gamma_16_to_1;
-   int gamma_shift = png_ptr->gamma_shift;
-#endif
-
-   png_bytep sp;
-   png_uint_32 i;
-   png_uint_32 row_width = row_info->width;
-   int optimize = (png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0;
-   int shift;
-
-   png_debug(1, "in png_do_compose");
-
-   {
-      switch (row_info->color_type)
-      {
-         case PNG_COLOR_TYPE_GRAY:
-         {
-            switch (row_info->bit_depth)
-            {
-               case 1:
-               {
-                  sp = row;
-                  shift = 7;
-                  for (i = 0; i < row_width; i++)
-                  {
-                     if ((png_uint_16)((*sp >> shift) & 0x01)
-                        == png_ptr->trans_color.gray)
-                     {
-                        *sp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
-                        *sp |= (png_byte)(png_ptr->background.gray << shift);
-                     }
-
-                     if (!shift)
-                     {
-                        shift = 7;
-                        sp++;
-                     }
-
-                     else
-                        shift--;
-                  }
-                  break;
-               }
-
-               case 2:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     shift = 6;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == png_ptr->trans_color.gray)
-                        {
-                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(png_ptr->background.gray << shift);
-                        }
-
-                        else
-                        {
-                           png_byte p = (png_byte)((*sp >> shift) & 0x03);
-                           png_byte g = (png_byte)((gamma_table [p | (p << 2) |
-                               (p << 4) | (p << 6)] >> 6) & 0x03);
-                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(g << shift);
-                        }
-
-                        if (!shift)
-                        {
-                           shift = 6;
-                           sp++;
-                        }
-
-                        else
-                           shift -= 2;
-                     }
-                  }
-
-                  else
-#endif
-                  {
-                     sp = row;
-                     shift = 6;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == png_ptr->trans_color.gray)
-                        {
-                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
-                           *sp |= (png_byte)(png_ptr->background.gray << shift);
-                        }
-
-                        if (!shift)
-                        {
-                           shift = 6;
-                           sp++;
-                        }
-
-                        else
-                           shift -= 2;
-                     }
-                  }
-                  break;
-               }
-
-               case 4:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     shift = 4;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == png_ptr->trans_color.gray)
-                        {
-                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(png_ptr->background.gray << shift);
-                        }
-
-                        else
-                        {
-                           png_byte p = (png_byte)((*sp >> shift) & 0x0f);
-                           png_byte g = (png_byte)((gamma_table[p |
-                               (p << 4)] >> 4) & 0x0f);
-                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(g << shift);
-                        }
-
-                        if (!shift)
-                        {
-                           shift = 4;
-                           sp++;
-                        }
-
-                        else
-                           shift -= 4;
-                     }
-                  }
-
-                  else
-#endif
-                  {
-                     sp = row;
-                     shift = 4;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == png_ptr->trans_color.gray)
-                        {
-                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
-                           *sp |= (png_byte)(png_ptr->background.gray << shift);
-                        }
-
-                        if (!shift)
-                        {
-                           shift = 4;
-                           sp++;
-                        }
-
-                        else
-                           shift -= 4;
-                     }
-                  }
-                  break;
-               }
-
-               case 8:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp++)
-                     {
-                        if (*sp == png_ptr->trans_color.gray)
-                           *sp = (png_byte)png_ptr->background.gray;
-
-                        else
-                           *sp = gamma_table[*sp];
-                     }
-                  }
-                  else
-#endif
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp++)
-                     {
-                        if (*sp == png_ptr->trans_color.gray)
-                           *sp = (png_byte)png_ptr->background.gray;
-                     }
-                  }
-                  break;
-               }
-
-               case 16:
-               {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_16 != NULL)
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp += 2)
-                     {
-                        png_uint_16 v;
-
-                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-
-                        if (v == png_ptr->trans_color.gray)
-                        {
-                           /* Background is already in screen gamma */
-                           *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
-                        }
-
-                        else
-                        {
-                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                           *sp = (png_byte)((v >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(v & 0xff);
-                        }
-                     }
-                  }
-                  else
-#endif
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp += 2)
-                     {
-                        png_uint_16 v;
-
-                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-
-                        if (v == png_ptr->trans_color.gray)
-                        {
-                           *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
-                        }
-                     }
-                  }
-                  break;
-               }
-
-               default:
-                  break;
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_RGB:
-         {
-            if (row_info->bit_depth == 8)
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_table != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 3)
-                  {
-                     if (*sp == png_ptr->trans_color.red &&
-                         *(sp + 1) == png_ptr->trans_color.green &&
-                         *(sp + 2) == png_ptr->trans_color.blue)
-                     {
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
-
-                     else
-                     {
-                        *sp = gamma_table[*sp];
-                        *(sp + 1) = gamma_table[*(sp + 1)];
-                        *(sp + 2) = gamma_table[*(sp + 2)];
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 3)
-                  {
-                     if (*sp == png_ptr->trans_color.red &&
-                         *(sp + 1) == png_ptr->trans_color.green &&
-                         *(sp + 2) == png_ptr->trans_color.blue)
-                     {
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
-                  }
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 6)
-                  {
-                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-
-                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
-
-                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
-                         + *(sp + 5));
-
-                     if (r == png_ptr->trans_color.red &&
-                         g == png_ptr->trans_color.green &&
-                         b == png_ptr->trans_color.blue)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
-
-                     else
-                     {
-                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-
-                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(v & 0xff);
-
-                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
-
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 6)
-                  {
-                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-
-                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
-
-                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
-                         + *(sp + 5));
-
-                     if (r == png_ptr->trans_color.red &&
-                         g == png_ptr->trans_color.green &&
-                         b == png_ptr->trans_color.blue)
-                     {
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_GRAY_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
-                   gamma_table != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 2)
-                  {
-                     png_uint_16 a = *(sp + 1);
-
-                     if (a == 0xff)
-                        *sp = gamma_table[*sp];
-
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)png_ptr->background.gray;
-                     }
-
-                     else
-                     {
-                        png_byte v, w;
-
-                        v = gamma_to_1[*sp];
-                        png_composite(w, v, a, png_ptr->background_1.gray);
-                        if (!optimize)
-                           w = gamma_from_1[w];
-                        *sp = w;
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 2)
-                  {
-                     png_byte a = *(sp + 1);
-
-                     if (a == 0)
-                        *sp = (png_byte)png_ptr->background.gray;
-
-                     else if (a < 0xff)
-                        png_composite(*sp, *sp, a, png_ptr->background_1.gray);
-                  }
-               }
-            }
-            else /* if (png_ptr->bit_depth == 16) */
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
-                   gamma_16_to_1 != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
-
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_uint_16 v;
-
-                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-                     }
-
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
-                     }
-
-                     else
-                     {
-                        png_uint_16 g, v, w;
-
-                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(v, g, a, png_ptr->background_1.gray);
-                        if (optimize)
-                           w = v;
-                        else
-                           w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
-                        *sp = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(w & 0xff);
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
-
-                     if (a == 0)
-                     {
-                        *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
-                     }
-
-                     else if (a < 0xffff)
-                     {
-                        png_uint_16 g, v;
-
-                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_composite_16(v, g, a, png_ptr->background_1.gray);
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_RGB_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
-                   gamma_table != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_byte a = *(sp + 3);
-
-                     if (a == 0xff)
-                     {
-                        *sp = gamma_table[*sp];
-                        *(sp + 1) = gamma_table[*(sp + 1)];
-                        *(sp + 2) = gamma_table[*(sp + 2)];
-                     }
-
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
-
-                     else
-                     {
-                        png_byte v, w;
-
-                        v = gamma_to_1[*sp];
-                        png_composite(w, v, a, png_ptr->background_1.red);
-                        if (!optimize) w = gamma_from_1[w];
-                        *sp = w;
-
-                        v = gamma_to_1[*(sp + 1)];
-                        png_composite(w, v, a, png_ptr->background_1.green);
-                        if (!optimize) w = gamma_from_1[w];
-                        *(sp + 1) = w;
-
-                        v = gamma_to_1[*(sp + 2)];
-                        png_composite(w, v, a, png_ptr->background_1.blue);
-                        if (!optimize) w = gamma_from_1[w];
-                        *(sp + 2) = w;
-                     }
-                  }
-               }
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_byte a = *(sp + 3);
-
-                     if (a == 0)
-                     {
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
-
-                     else if (a < 0xff)
-                     {
-                        png_composite(*sp, *sp, a, png_ptr->background.red);
-
-                        png_composite(*(sp + 1), *(sp + 1), a,
-                            png_ptr->background.green);
-
-                        png_composite(*(sp + 2), *(sp + 2), a,
-                            png_ptr->background.blue);
-                     }
-                  }
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
-#ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
-                   gamma_16_to_1 != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 8)
-                  {
-                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
-                         << 8) + (png_uint_16)(*(sp + 7)));
-
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_uint_16 v;
-
-                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-
-                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(v & 0xff);
-
-                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(v & 0xff);
-                     }
-
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
-
-                     else
-                     {
-                        png_uint_16 v, w;
-
-                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(w, v, a, png_ptr->background_1.red);
-                        if (!optimize)
-                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
-                        *sp = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(w & 0xff);
-
-                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        png_composite_16(w, v, a, png_ptr->background_1.green);
-                        if (!optimize)
-                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
-
-                        *(sp + 2) = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(w & 0xff);
-
-                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        png_composite_16(w, v, a, png_ptr->background_1.blue);
-                        if (!optimize)
-                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
-
-                        *(sp + 4) = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(w & 0xff);
-                     }
-                  }
-               }
-
-               else
-#endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 8)
-                  {
-                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
-                         << 8) + (png_uint_16)(*(sp + 7)));
-
-                     if (a == 0)
-                     {
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
-
-                     else if (a < 0xffff)
-                     {
-                        png_uint_16 v;
-
-                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
-                            + *(sp + 3));
-                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
-                            + *(sp + 5));
-
-                        png_composite_16(v, r, a, png_ptr->background.red);
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-
-                        png_composite_16(v, g, a, png_ptr->background.green);
-                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(v & 0xff);
-
-                        png_composite_16(v, b, a, png_ptr->background.blue);
-                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
-
-         default:
-            break;
-      }
-   }
-}
-#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_READ_ALPHA_MODE_SUPPORTED */
-
-#ifdef PNG_READ_GAMMA_SUPPORTED
-/* Gamma correct the image, avoiding the alpha channel.  Make sure
- * you do this after you deal with the transparency issue on grayscale
- * or RGB images. If your bit depth is 8, use gamma_table, if it
- * is 16, use gamma_16_table and gamma_shift.  Build these with
- * build_gamma_table().
- */
-void /* PRIVATE */
-png_do_gamma(png_row_infop row_info, png_bytep row, png_structp png_ptr)
-{
-   png_const_bytep gamma_table = png_ptr->gamma_table;
-   png_const_uint_16pp gamma_16_table = png_ptr->gamma_16_table;
-   int gamma_shift = png_ptr->gamma_shift;
-
-   png_bytep sp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_gamma");
-
-   if (((row_info->bit_depth <= 8 && gamma_table != NULL) ||
-       (row_info->bit_depth == 16 && gamma_16_table != NULL)))
-   {
-      switch (row_info->color_type)
-      {
-         case PNG_COLOR_TYPE_RGB:
-         {
-            if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp++;
-                  *sp = gamma_table[*sp];
-                  sp++;
-                  *sp = gamma_table[*sp];
-                  sp++;
-               }
-            }
-
-            else /* if (row_info->bit_depth == 16) */
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v;
-
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_RGB_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp++;
-
-                  *sp = gamma_table[*sp];
-                  sp++;
-
-                  *sp = gamma_table[*sp];
-                  sp++;
-
-                  sp++;
-               }
-            }
-
-            else /* if (row_info->bit_depth == 16) */
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-
-                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 4;
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_GRAY_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp += 2;
-               }
-            }
-
-            else /* if (row_info->bit_depth == 16) */
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 4;
-               }
-            }
-            break;
-         }
-
-         case PNG_COLOR_TYPE_GRAY:
-         {
-            if (row_info->bit_depth == 2)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i += 4)
-               {
-                  int a = *sp & 0xc0;
-                  int b = *sp & 0x30;
-                  int c = *sp & 0x0c;
-                  int d = *sp & 0x03;
-
-                  *sp = (png_byte)(
-                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
-                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
-                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
-                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
-                  sp++;
-               }
-            }
-
-            if (row_info->bit_depth == 4)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i += 2)
-               {
-                  int msb = *sp & 0xf0;
-                  int lsb = *sp & 0x0f;
-
-                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
-                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
-                  sp++;
-               }
-            }
-
-            else if (row_info->bit_depth == 8)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  *sp = gamma_table[*sp];
-                  sp++;
-               }
-            }
-
-            else if (row_info->bit_depth == 16)
-            {
-               sp = row;
-               for (i = 0; i < row_width; i++)
-               {
-                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
-                  *sp = (png_byte)((v >> 8) & 0xff);
-                  *(sp + 1) = (png_byte)(v & 0xff);
-                  sp += 2;
-               }
-            }
-            break;
-         }
-
-         default:
-            break;
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
-/* Encode the alpha channel to the output gamma (the input channel is always
- * linear.)  Called only with color types that have an alpha channel.  Needs the
- * from_1 tables.
- */
-void /* PRIVATE */
-png_do_encode_alpha(png_row_infop row_info, png_bytep row, png_structp png_ptr)
-{
-   png_uint_32 row_width = row_info->width;
-
-   png_debug(1, "in png_do_encode_alpha");
-
-   if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         PNG_CONST png_bytep table = png_ptr->gamma_from_1;
-
-         if (table != NULL)
-         {
-            PNG_CONST int step =
-               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;
-
-            /* The alpha channel is the last component: */
-            row += step - 1;
-
-            for (; row_width > 0; --row_width, row += step)
-               *row = table[*row];
-
-            return;
-         }
-      }
-
-      else if (row_info->bit_depth == 16)
-      {
-         PNG_CONST png_uint_16pp table = png_ptr->gamma_16_from_1;
-         PNG_CONST int gamma_shift = png_ptr->gamma_shift;
-
-         if (table != NULL)
-         {
-            PNG_CONST int step =
-               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;
-
-            /* The alpha channel is the last component: */
-            row += step - 2;
-
-            for (; row_width > 0; --row_width, row += step)
-            {
-               png_uint_16 v;
-
-               v = table[*(row + 1) >> gamma_shift][*row];
-               *row = (png_byte)((v >> 8) & 0xff);
-               *(row + 1) = (png_byte)(v & 0xff);
-            }
-
-            return;
-         }
-      }
-   }
-
-   /* Only get to here if called with a weird row_info; no harm has been done,
-    * so just issue a warning.
-    */
-   png_warning(png_ptr, "png_do_encode_alpha: unexpected call");
-}
-#endif
-
-#ifdef PNG_READ_EXPAND_SUPPORTED
-/* Expands a palette row to an RGB or RGBA row depending
- * upon whether you supply trans and num_trans.
- */
-void /* PRIVATE */
-png_do_expand_palette(png_row_infop row_info, png_bytep row,
-   png_const_colorp palette, png_const_bytep trans_alpha, int num_trans)
-{
-   int shift, value;
-   png_bytep sp, dp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_expand_palette");
-
-   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
-   {
-      if (row_info->bit_depth < 8)
-      {
-         switch (row_info->bit_depth)
-         {
-            case 1:
-            {
-               sp = row + (png_size_t)((row_width - 1) >> 3);
-               dp = row + (png_size_t)row_width - 1;
-               shift = 7 - (int)((row_width + 7) & 0x07);
-               for (i = 0; i < row_width; i++)
-               {
-                  if ((*sp >> shift) & 0x01)
-                     *dp = 1;
-
-                  else
-                     *dp = 0;
-
-                  if (shift == 7)
-                  {
-                     shift = 0;
-                     sp--;
-                  }
-
-                  else
-                     shift++;
-
-                  dp--;
-               }
-               break;
-            }
-
-            case 2:
-            {
-               sp = row + (png_size_t)((row_width - 1) >> 2);
-               dp = row + (png_size_t)row_width - 1;
-               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
-               for (i = 0; i < row_width; i++)
-               {
-                  value = (*sp >> shift) & 0x03;
-                  *dp = (png_byte)value;
-                  if (shift == 6)
-                  {
-                     shift = 0;
-                     sp--;
-                  }
-
-                  else
-                     shift += 2;
-
-                  dp--;
-               }
-               break;
-            }
-
-            case 4:
-            {
-               sp = row + (png_size_t)((row_width - 1) >> 1);
-               dp = row + (png_size_t)row_width - 1;
-               shift = (int)((row_width & 0x01) << 2);
-               for (i = 0; i < row_width; i++)
-               {
-                  value = (*sp >> shift) & 0x0f;
-                  *dp = (png_byte)value;
-                  if (shift == 4)
-                  {
-                     shift = 0;
-                     sp--;
-                  }
-
-                  else
-                     shift += 4;
-
-                  dp--;
-               }
-               break;
-            }
-
-            default:
-               break;
-         }
-         row_info->bit_depth = 8;
-         row_info->pixel_depth = 8;
-         row_info->rowbytes = row_width;
-      }
-
-      if (row_info->bit_depth == 8)
-      {
-         {
-            if (num_trans > 0)
-            {
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width << 2) - 1;
-
-               for (i = 0; i < row_width; i++)
-               {
-                  if ((int)(*sp) >= num_trans)
-                     *dp-- = 0xff;
-
-                  else
-                     *dp-- = trans_alpha[*sp];
-
-                  *dp-- = palette[*sp].blue;
-                  *dp-- = palette[*sp].green;
-                  *dp-- = palette[*sp].red;
-                  sp--;
-               }
-               row_info->bit_depth = 8;
-               row_info->pixel_depth = 32;
-               row_info->rowbytes = row_width * 4;
-               row_info->color_type = 6;
-               row_info->channels = 4;
-            }
-
-            else
-            {
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width * 3) - 1;
-
-               for (i = 0; i < row_width; i++)
-               {
-                  *dp-- = palette[*sp].blue;
-                  *dp-- = palette[*sp].green;
-                  *dp-- = palette[*sp].red;
-                  sp--;
-               }
-
-               row_info->bit_depth = 8;
-               row_info->pixel_depth = 24;
-               row_info->rowbytes = row_width * 3;
-               row_info->color_type = 2;
-               row_info->channels = 3;
-            }
-         }
-      }
-   }
-}
-
-/* If the bit depth < 8, it is expanded to 8.  Also, if the already
- * expanded transparency value is supplied, an alpha channel is built.
- */
-void /* PRIVATE */
-png_do_expand(png_row_infop row_info, png_bytep row,
-    png_const_color_16p trans_color)
-{
-   int shift, value;
-   png_bytep sp, dp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_expand");
-
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
-      {
-         png_uint_16 gray = (png_uint_16)(trans_color ? trans_color->gray : 0);
-
-         if (row_info->bit_depth < 8)
-         {
-            switch (row_info->bit_depth)
-            {
-               case 1:
-               {
-                  gray = (png_uint_16)((gray & 0x01) * 0xff);
-                  sp = row + (png_size_t)((row_width - 1) >> 3);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = 7 - (int)((row_width + 7) & 0x07);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     if ((*sp >> shift) & 0x01)
-                        *dp = 0xff;
-
-                     else
-                        *dp = 0;
-
-                     if (shift == 7)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
-
-                     else
-                        shift++;
-
-                     dp--;
-                  }
-                  break;
-               }
-
-               case 2:
-               {
-                  gray = (png_uint_16)((gray & 0x03) * 0x55);
-                  sp = row + (png_size_t)((row_width - 1) >> 2);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     value = (*sp >> shift) & 0x03;
-                     *dp = (png_byte)(value | (value << 2) | (value << 4) |
-                        (value << 6));
-                     if (shift == 6)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
-
-                     else
-                        shift += 2;
-
-                     dp--;
-                  }
-                  break;
-               }
-
-               case 4:
-               {
-                  gray = (png_uint_16)((gray & 0x0f) * 0x11);
-                  sp = row + (png_size_t)((row_width - 1) >> 1);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     value = (*sp >> shift) & 0x0f;
-                     *dp = (png_byte)(value | (value << 4));
-                     if (shift == 4)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
-
-                     else
-                        shift = 4;
-
-                     dp--;
-                  }
-                  break;
-               }
-
-               default:
-                  break;
-            }
-
-            row_info->bit_depth = 8;
-            row_info->pixel_depth = 8;
-            row_info->rowbytes = row_width;
-         }
-
-         if (trans_color != NULL)
-         {
-            if (row_info->bit_depth == 8)
-            {
-               gray = gray & 0xff;
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width << 1) - 1;
-
-               for (i = 0; i < row_width; i++)
-               {
-                  if (*sp == gray)
-                     *dp-- = 0;
-
-                  else
-                     *dp-- = 0xff;
-
-                  *dp-- = *sp--;
-               }
-            }
-
-            else if (row_info->bit_depth == 16)
-            {
-               png_byte gray_high = (png_byte)((gray >> 8) & 0xff);
-               png_byte gray_low = (png_byte)(gray & 0xff);
-               sp = row + row_info->rowbytes - 1;
-               dp = row + (row_info->rowbytes << 1) - 1;
-               for (i = 0; i < row_width; i++)
-               {
-                  if (*(sp - 1) == gray_high && *(sp) == gray_low)
-                  {
-                     *dp-- = 0;
-                     *dp-- = 0;
-                  }
-
-                  else
-                  {
-                     *dp-- = 0xff;
-                     *dp-- = 0xff;
-                  }
-
-                  *dp-- = *sp--;
-                  *dp-- = *sp--;
-               }
-            }
-
-            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
-            row_info->channels = 2;
-            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
-            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
-               row_width);
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_color)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            png_byte red = (png_byte)(trans_color->red & 0xff);
-            png_byte green = (png_byte)(trans_color->green & 0xff);
-            png_byte blue = (png_byte)(trans_color->blue & 0xff);
-            sp = row + (png_size_t)row_info->rowbytes - 1;
-            dp = row + (png_size_t)(row_width << 2) - 1;
-            for (i = 0; i < row_width; i++)
-            {
-               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
-                  *dp-- = 0;
-
-               else
-                  *dp-- = 0xff;
-
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-            }
-         }
-         else if (row_info->bit_depth == 16)
-         {
-            png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
-            png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
-            png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
-            png_byte red_low = (png_byte)(trans_color->red & 0xff);
-            png_byte green_low = (png_byte)(trans_color->green & 0xff);
-            png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
-            sp = row + row_info->rowbytes - 1;
-            dp = row + (png_size_t)(row_width << 3) - 1;
-            for (i = 0; i < row_width; i++)
-            {
-               if (*(sp - 5) == red_high &&
-                   *(sp - 4) == red_low &&
-                   *(sp - 3) == green_high &&
-                   *(sp - 2) == green_low &&
-                   *(sp - 1) == blue_high &&
-                   *(sp    ) == blue_low)
-               {
-                  *dp-- = 0;
-                  *dp-- = 0;
-               }
-
-               else
-               {
-                  *dp-- = 0xff;
-                  *dp-- = 0xff;
-               }
-
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-            }
-         }
-         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
-         row_info->channels = 4;
-         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
-   }
-}
-#endif
-
-#ifdef PNG_READ_EXPAND_16_SUPPORTED
-/* If the bit depth is 8 and the color type is not a palette type expand the
- * whole row to 16 bits.  Has no effect otherwise.
- */
-void /* PRIVATE */
-png_do_expand_16(png_row_infop row_info, png_bytep row)
-{
-   if (row_info->bit_depth == 8 &&
-      row_info->color_type != PNG_COLOR_TYPE_PALETTE)
-   {
-      /* The row have a sequence of bytes containing [0..255] and we need
-       * to turn it into another row containing [0..65535], to do this we
-       * calculate:
-       *
-       *  (input / 255) * 65535
-       *
-       *  Which happens to be exactly input * 257 and this can be achieved
-       *  simply by byte replication in place (copying backwards).
-       */
-      png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */
-      png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */
-      while (dp > sp)
-         dp[-2] = dp[-1] = *--sp, dp -= 2;
-
-      row_info->rowbytes *= 2;
-      row_info->bit_depth = 16;
-      row_info->pixel_depth = (png_byte)(row_info->channels * 16);
-   }
-}
-#endif
-
-#ifdef PNG_READ_QUANTIZE_SUPPORTED
-void /* PRIVATE */
-png_do_quantize(png_row_infop row_info, png_bytep row,
-    png_const_bytep palette_lookup, png_const_bytep quantize_lookup)
-{
-   png_bytep sp, dp;
-   png_uint_32 i;
-   png_uint_32 row_width=row_info->width;
-
-   png_debug(1, "in png_do_quantize");
-
-   if (row_info->bit_depth == 8)
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB && palette_lookup)
-      {
-         int r, g, b, p;
-         sp = row;
-         dp = row;
-         for (i = 0; i < row_width; i++)
-         {
-            r = *sp++;
-            g = *sp++;
-            b = *sp++;
-
-            /* This looks real messy, but the compiler will reduce
-             * it down to a reasonable formula.  For example, with
-             * 5 bits per color, we get:
-             * p = (((r >> 3) & 0x1f) << 10) |
-             *    (((g >> 3) & 0x1f) << 5) |
-             *    ((b >> 3) & 0x1f);
-             */
-            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
-                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
-                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
-                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
-                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
-                (PNG_QUANTIZE_BLUE_BITS)) |
-                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
-                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));
-
-            *dp++ = palette_lookup[p];
-         }
-
-         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
-         row_info->channels = 1;
-         row_info->pixel_depth = row_info->bit_depth;
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
-
-      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
-         palette_lookup != NULL)
-      {
-         int r, g, b, p;
-         sp = row;
-         dp = row;
-         for (i = 0; i < row_width; i++)
-         {
-            r = *sp++;
-            g = *sp++;
-            b = *sp++;
-            sp++;
-
-            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
-                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
-                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
-                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
-                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
-                (PNG_QUANTIZE_BLUE_BITS)) |
-                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
-                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));
-
-            *dp++ = palette_lookup[p];
-         }
-
-         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
-         row_info->channels = 1;
-         row_info->pixel_depth = row_info->bit_depth;
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
-
-      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
-         quantize_lookup)
-      {
-         sp = row;
-
-         for (i = 0; i < row_width; i++, sp++)
-         {
-            *sp = quantize_lookup[*sp];
-         }
-      }
-   }
-}
-#endif /* PNG_READ_QUANTIZE_SUPPORTED */
-#endif /* PNG_READ_TRANSFORMS_SUPPORTED */
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-/* Undoes intrapixel differencing  */
-void /* PRIVATE */
-png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_read_intrapixel");
-
-   if (
-       (row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      int bytes_per_pixel;
-      png_uint_32 row_width = row_info->width;
-
-      if (row_info->bit_depth == 8)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 3;
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 4;
-
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            *(rp) = (png_byte)((256 + *rp + *(rp + 1)) & 0xff);
-            *(rp+2) = (png_byte)((256 + *(rp + 2) + *(rp + 1)) & 0xff);
-         }
-      }
-      else if (row_info->bit_depth == 16)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 6;
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 8;
-
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
-            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
-            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
-            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;
-            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;
-            *(rp    ) = (png_byte)((red >> 8) & 0xff);
-            *(rp + 1) = (png_byte)(red & 0xff);
-            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
-            *(rp + 5) = (png_byte)(blue & 0xff);
-         }
-      }
-   }
-}
-#endif /* PNG_MNG_FEATURES_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED */
+
+/* pngrtran.c - transforms the data in a row for PNG readers
+ *
+ * Last changed in libpng 1.5.11 [June 14, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
+ * This file contains functions optionally called by an application
+ * in order to tell libpng how to handle data when reading a PNG.
+ * Transformations that are used in both reading and writing are
+ * in pngtrans.c.
+ */
+
+#include "pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+/* Set the action on getting a CRC error for an ancillary or critical chunk. */
+void PNGAPI
+png_set_crc_action(png_structp png_ptr, int crit_action, int ancil_action)
+{
+   png_debug(1, "in png_set_crc_action");
+
+   if (png_ptr == NULL)
+      return;
+
+   /* Tell libpng how we react to CRC errors in critical chunks */
+   switch (crit_action)
+   {
+      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
+         break;
+
+      case PNG_CRC_WARN_USE:                               /* Warn/use data */
+         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
+         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
+         break;
+
+      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
+         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
+         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
+                           PNG_FLAG_CRC_CRITICAL_IGNORE;
+         break;
+
+      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
+         png_warning(png_ptr,
+            "Can't discard critical data on CRC error");
+      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */
+
+      case PNG_CRC_DEFAULT:
+      default:
+         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
+         break;
+   }
+
+   /* Tell libpng how we react to CRC errors in ancillary chunks */
+   switch (ancil_action)
+   {
+      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
+         break;
+
+      case PNG_CRC_WARN_USE:                              /* Warn/use data */
+         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
+         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
+         break;
+
+      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
+         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
+         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
+                           PNG_FLAG_CRC_ANCILLARY_NOWARN;
+         break;
+
+      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
+         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
+         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
+         break;
+
+      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */
+
+      case PNG_CRC_DEFAULT:
+      default:
+         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
+         break;
+   }
+}
+
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
+/* Handle alpha and tRNS via a background color */
+void PNGFAPI
+png_set_background_fixed(png_structp png_ptr,
+    png_const_color_16p background_color, int background_gamma_code,
+    int need_expand, png_fixed_point background_gamma)
+{
+   png_debug(1, "in png_set_background_fixed");
+
+   if (png_ptr == NULL)
+      return;
+
+   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
+   {
+      png_warning(png_ptr, "Application must supply a known background gamma");
+      return;
+   }
+
+   png_ptr->transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA;
+   png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+   png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+
+   png_memcpy(&(png_ptr->background), background_color,
+      png_sizeof(png_color_16));
+   png_ptr->background_gamma = background_gamma;
+   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
+   if (need_expand)
+      png_ptr->transformations |= PNG_BACKGROUND_EXPAND;
+   else
+      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
+}
+
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+void PNGAPI
+png_set_background(png_structp png_ptr,
+    png_const_color_16p background_color, int background_gamma_code,
+    int need_expand, double background_gamma)
+{
+   png_set_background_fixed(png_ptr, background_color, background_gamma_code,
+      need_expand, png_fixed(png_ptr, background_gamma, "png_set_background"));
+}
+#  endif  /* FLOATING_POINT */
+#endif /* READ_BACKGROUND */
+
+/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the
+ * one that pngrtran does first (scale) happens.  This is necessary to allow the
+ * TRANSFORM and API behavior to be somewhat consistent, and it's simpler.
+ */
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+void PNGAPI
+png_set_scale_16(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_scale_16");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_SCALE_16_TO_8;
+}
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+/* Chop 16-bit depth files to 8-bit depth */
+void PNGAPI
+png_set_strip_16(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_strip_16");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_16_TO_8;
+}
+#endif
+
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
+void PNGAPI
+png_set_strip_alpha(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_strip_alpha");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_STRIP_ALPHA;
+}
+#endif
+
+#if defined(PNG_READ_ALPHA_MODE_SUPPORTED) || defined(PNG_READ_GAMMA_SUPPORTED)
+static png_fixed_point
+translate_gamma_flags(png_structp png_ptr, png_fixed_point output_gamma,
+   int is_screen)
+{
+   /* Check for flag values.  The main reason for having the old Mac value as a
+    * flag is that it is pretty near impossible to work out what the correct
+    * value is from Apple documentation - a working Mac system is needed to
+    * discover the value!
+    */
+   if (output_gamma == PNG_DEFAULT_sRGB ||
+      output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)
+   {
+      /* If there is no sRGB support this just sets the gamma to the standard
+       * sRGB value.  (This is a side effect of using this function!)
+       */
+#     ifdef PNG_READ_sRGB_SUPPORTED
+         png_ptr->flags |= PNG_FLAG_ASSUME_sRGB;
+#     endif
+      if (is_screen)
+         output_gamma = PNG_GAMMA_sRGB;
+      else
+         output_gamma = PNG_GAMMA_sRGB_INVERSE;
+   }
+
+   else if (output_gamma == PNG_GAMMA_MAC_18 ||
+      output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)
+   {
+      if (is_screen)
+         output_gamma = PNG_GAMMA_MAC_OLD;
+      else
+         output_gamma = PNG_GAMMA_MAC_INVERSE;
+   }
+
+   return output_gamma;
+}
+
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+static png_fixed_point
+convert_gamma_value(png_structp png_ptr, double output_gamma)
+{
+   /* The following silently ignores cases where fixed point (times 100,000)
+    * gamma values are passed to the floating point API.  This is safe and it
+    * means the fixed point constants work just fine with the floating point
+    * API.  The alternative would just lead to undetected errors and spurious
+    * bug reports.  Negative values fail inside the _fixed API unless they
+    * correspond to the flag values.
+    */
+   if (output_gamma > 0 && output_gamma < 128)
+      output_gamma *= PNG_FP_1;
+
+   /* This preserves -1 and -2 exactly: */
+   output_gamma = floor(output_gamma + .5);
+
+   if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)
+      png_fixed_error(png_ptr, "gamma value");
+
+   return (png_fixed_point)output_gamma;
+}
+#  endif
+#endif /* READ_ALPHA_MODE || READ_GAMMA */
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+void PNGFAPI
+png_set_alpha_mode_fixed(png_structp png_ptr, int mode,
+   png_fixed_point output_gamma)
+{
+   int compose = 0;
+   png_fixed_point file_gamma;
+
+   png_debug(1, "in png_set_alpha_mode");
+
+   if (png_ptr == NULL)
+      return;
+
+   output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1/*screen*/);
+
+   /* Validate the value to ensure it is in a reasonable range. The value
+    * is expected to be 1 or greater, but this range test allows for some
+    * viewing correction values.  The intent is to weed out users of this API
+    * who use the inverse of the gamma value accidentally!  Since some of these
+    * values are reasonable this may have to be changed.
+    */
+   if (output_gamma < 70000 || output_gamma > 300000)
+      png_error(png_ptr, "output gamma out of expected range");
+
+   /* The default file gamma is the inverse of the output gamma; the output
+    * gamma may be changed below so get the file value first:
+    */
+   file_gamma = png_reciprocal(output_gamma);
+
+   /* There are really 8 possibilities here, composed of any combination
+    * of:
+    *
+    *    premultiply the color channels
+    *    do not encode non-opaque pixels
+    *    encode the alpha as well as the color channels
+    *
+    * The differences disappear if the input/output ('screen') gamma is 1.0,
+    * because then the encoding is a no-op and there is only the choice of
+    * premultiplying the color channels or not.
+    *
+    * png_set_alpha_mode and png_set_background interact because both use
+    * png_compose to do the work.  Calling both is only useful when
+    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along
+    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.
+    */
+   switch (mode)
+   {
+      case PNG_ALPHA_PNG:        /* default: png standard */
+         /* No compose, but it may be set by png_set_background! */
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+         break;
+
+      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */
+         compose = 1;
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+         /* The output is linear: */
+         output_gamma = PNG_FP_1;
+         break;
+
+      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */
+         compose = 1;
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;
+         /* output_gamma records the encoding of opaque pixels! */
+         break;
+
+      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */
+         compose = 1;
+         png_ptr->transformations |= PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+         break;
+
+      default:
+         png_error(png_ptr, "invalid alpha mode");
+   }
+
+   /* Only set the default gamma if the file gamma has not been set (this has
+    * the side effect that the gamma in a second call to png_set_alpha_mode will
+    * be ignored.)
+    */
+   if (png_ptr->gamma == 0)
+      png_ptr->gamma = file_gamma;
+
+   /* But always set the output gamma: */
+   png_ptr->screen_gamma = output_gamma;
+
+   /* Finally, if pre-multiplying, set the background fields to achieve the
+    * desired result.
+    */
+   if (compose)
+   {
+      /* And obtain alpha pre-multiplication by composing on black: */
+      png_memset(&png_ptr->background, 0, sizeof png_ptr->background);
+      png_ptr->background_gamma = png_ptr->gamma; /* just in case */
+      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;
+      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
+
+      if (png_ptr->transformations & PNG_COMPOSE)
+         png_error(png_ptr,
+            "conflicting calls to set alpha mode and background");
+
+      png_ptr->transformations |= PNG_COMPOSE;
+   }
+
+   /* New API, make sure apps call the correct initializers: */
+   png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;
+}
+
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+void PNGAPI
+png_set_alpha_mode(png_structp png_ptr, int mode, double output_gamma)
+{
+   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
+      output_gamma));
+}
+#  endif
+#endif
+
+#ifdef PNG_READ_QUANTIZE_SUPPORTED
+/* Dither file to 8-bit.  Supply a palette, the current number
+ * of elements in the palette, the maximum number of elements
+ * allowed, and a histogram if possible.  If the current number
+ * of colors is greater then the maximum number, the palette will be
+ * modified to fit in the maximum number.  "full_quantize" indicates
+ * whether we need a quantizing cube set up for RGB images, or if we
+ * simply are reducing the number of colors in a paletted image.
+ */
+
+typedef struct png_dsort_struct
+{
+   struct png_dsort_struct FAR * next;
+   png_byte left;
+   png_byte right;
+} png_dsort;
+typedef png_dsort FAR *       png_dsortp;
+typedef png_dsort FAR * FAR * png_dsortpp;
+
+void PNGAPI
+png_set_quantize(png_structp png_ptr, png_colorp palette,
+    int num_palette, int maximum_colors, png_const_uint_16p histogram,
+    int full_quantize)
+{
+   png_debug(1, "in png_set_quantize");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_QUANTIZE;
+
+   if (!full_quantize)
+   {
+      int i;
+
+      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,
+          (png_uint_32)(num_palette * png_sizeof(png_byte)));
+      for (i = 0; i < num_palette; i++)
+         png_ptr->quantize_index[i] = (png_byte)i;
+   }
+
+   if (num_palette > maximum_colors)
+   {
+      if (histogram != NULL)
+      {
+         /* This is easy enough, just throw out the least used colors.
+          * Perhaps not the best solution, but good enough.
+          */
+
+         int i;
+
+         /* Initialize an array to sort colors */
+         png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,
+             (png_uint_32)(num_palette * png_sizeof(png_byte)));
+
+         /* Initialize the quantize_sort array */
+         for (i = 0; i < num_palette; i++)
+            png_ptr->quantize_sort[i] = (png_byte)i;
+
+         /* Find the least used palette entries by starting a
+          * bubble sort, and running it until we have sorted
+          * out enough colors.  Note that we don't care about
+          * sorting all the colors, just finding which are
+          * least used.
+          */
+
+         for (i = num_palette - 1; i >= maximum_colors; i--)
+         {
+            int done; /* To stop early if the list is pre-sorted */
+            int j;
+
+            done = 1;
+            for (j = 0; j < i; j++)
+            {
+               if (histogram[png_ptr->quantize_sort[j]]
+                   < histogram[png_ptr->quantize_sort[j + 1]])
+               {
+                  png_byte t;
+
+                  t = png_ptr->quantize_sort[j];
+                  png_ptr->quantize_sort[j] = png_ptr->quantize_sort[j + 1];
+                  png_ptr->quantize_sort[j + 1] = t;
+                  done = 0;
+               }
+            }
+
+            if (done)
+               break;
+         }
+
+         /* Swap the palette around, and set up a table, if necessary */
+         if (full_quantize)
+         {
+            int j = num_palette;
+
+            /* Put all the useful colors within the max, but don't
+             * move the others.
+             */
+            for (i = 0; i < maximum_colors; i++)
+            {
+               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
+               {
+                  do
+                     j--;
+                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
+
+                  palette[i] = palette[j];
+               }
+            }
+         }
+         else
+         {
+            int j = num_palette;
+
+            /* Move all the used colors inside the max limit, and
+             * develop a translation table.
+             */
+            for (i = 0; i < maximum_colors; i++)
+            {
+               /* Only move the colors we need to */
+               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
+               {
+                  png_color tmp_color;
+
+                  do
+                     j--;
+                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
+
+                  tmp_color = palette[j];
+                  palette[j] = palette[i];
+                  palette[i] = tmp_color;
+                  /* Indicate where the color went */
+                  png_ptr->quantize_index[j] = (png_byte)i;
+                  png_ptr->quantize_index[i] = (png_byte)j;
+               }
+            }
+
+            /* Find closest color for those colors we are not using */
+            for (i = 0; i < num_palette; i++)
+            {
+               if ((int)png_ptr->quantize_index[i] >= maximum_colors)
+               {
+                  int min_d, k, min_k, d_index;
+
+                  /* Find the closest color to one we threw out */
+                  d_index = png_ptr->quantize_index[i];
+                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
+                  for (k = 1, min_k = 0; k < maximum_colors; k++)
+                  {
+                     int d;
+
+                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);
+
+                     if (d < min_d)
+                     {
+                        min_d = d;
+                        min_k = k;
+                     }
+                  }
+                  /* Point to closest color */
+                  png_ptr->quantize_index[i] = (png_byte)min_k;
+               }
+            }
+         }
+         png_free(png_ptr, png_ptr->quantize_sort);
+         png_ptr->quantize_sort = NULL;
+      }
+      else
+      {
+         /* This is much harder to do simply (and quickly).  Perhaps
+          * we need to go through a median cut routine, but those
+          * don't always behave themselves with only a few colors
+          * as input.  So we will just find the closest two colors,
+          * and throw out one of them (chosen somewhat randomly).
+          * [We don't understand this at all, so if someone wants to
+          *  work on improving it, be our guest - AED, GRP]
+          */
+         int i;
+         int max_d;
+         int num_new_palette;
+         png_dsortp t;
+         png_dsortpp hash;
+
+         t = NULL;
+
+         /* Initialize palette index arrays */
+         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
+             (png_uint_32)(num_palette * png_sizeof(png_byte)));
+         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
+             (png_uint_32)(num_palette * png_sizeof(png_byte)));
+
+         /* Initialize the sort array */
+         for (i = 0; i < num_palette; i++)
+         {
+            png_ptr->index_to_palette[i] = (png_byte)i;
+            png_ptr->palette_to_index[i] = (png_byte)i;
+         }
+
+         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
+             png_sizeof(png_dsortp)));
+
+         num_new_palette = num_palette;
+
+         /* Initial wild guess at how far apart the farthest pixel
+          * pair we will be eliminating will be.  Larger
+          * numbers mean more areas will be allocated, Smaller
+          * numbers run the risk of not saving enough data, and
+          * having to do this all over again.
+          *
+          * I have not done extensive checking on this number.
+          */
+         max_d = 96;
+
+         while (num_new_palette > maximum_colors)
+         {
+            for (i = 0; i < num_new_palette - 1; i++)
+            {
+               int j;
+
+               for (j = i + 1; j < num_new_palette; j++)
+               {
+                  int d;
+
+                  d = PNG_COLOR_DIST(palette[i], palette[j]);
+
+                  if (d <= max_d)
+                  {
+
+                     t = (png_dsortp)png_malloc_warn(png_ptr,
+                         (png_uint_32)(png_sizeof(png_dsort)));
+
+                     if (t == NULL)
+                         break;
+
+                     t->next = hash[d];
+                     t->left = (png_byte)i;
+                     t->right = (png_byte)j;
+                     hash[d] = t;
+                  }
+               }
+               if (t == NULL)
+                  break;
+            }
+
+            if (t != NULL)
+            for (i = 0; i <= max_d; i++)
+            {
+               if (hash[i] != NULL)
+               {
+                  png_dsortp p;
+
+                  for (p = hash[i]; p; p = p->next)
+                  {
+                     if ((int)png_ptr->index_to_palette[p->left]
+                         < num_new_palette &&
+                         (int)png_ptr->index_to_palette[p->right]
+                         < num_new_palette)
+                     {
+                        int j, next_j;
+
+                        if (num_new_palette & 0x01)
+                        {
+                           j = p->left;
+                           next_j = p->right;
+                        }
+                        else
+                        {
+                           j = p->right;
+                           next_j = p->left;
+                        }
+
+                        num_new_palette--;
+                        palette[png_ptr->index_to_palette[j]]
+                            = palette[num_new_palette];
+                        if (!full_quantize)
+                        {
+                           int k;
+
+                           for (k = 0; k < num_palette; k++)
+                           {
+                              if (png_ptr->quantize_index[k] ==
+                                  png_ptr->index_to_palette[j])
+                                 png_ptr->quantize_index[k] =
+                                     png_ptr->index_to_palette[next_j];
+
+                              if ((int)png_ptr->quantize_index[k] ==
+                                  num_new_palette)
+                                 png_ptr->quantize_index[k] =
+                                     png_ptr->index_to_palette[j];
+                           }
+                        }
+
+                        png_ptr->index_to_palette[png_ptr->palette_to_index
+                            [num_new_palette]] = png_ptr->index_to_palette[j];
+
+                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]
+                            = png_ptr->palette_to_index[num_new_palette];
+
+                        png_ptr->index_to_palette[j] =
+                            (png_byte)num_new_palette;
+
+                        png_ptr->palette_to_index[num_new_palette] =
+                            (png_byte)j;
+                     }
+                     if (num_new_palette <= maximum_colors)
+                        break;
+                  }
+                  if (num_new_palette <= maximum_colors)
+                     break;
+               }
+            }
+
+            for (i = 0; i < 769; i++)
+            {
+               if (hash[i] != NULL)
+               {
+                  png_dsortp p = hash[i];
+                  while (p)
+                  {
+                     t = p->next;
+                     png_free(png_ptr, p);
+                     p = t;
+                  }
+               }
+               hash[i] = 0;
+            }
+            max_d += 96;
+         }
+         png_free(png_ptr, hash);
+         png_free(png_ptr, png_ptr->palette_to_index);
+         png_free(png_ptr, png_ptr->index_to_palette);
+         png_ptr->palette_to_index = NULL;
+         png_ptr->index_to_palette = NULL;
+      }
+      num_palette = maximum_colors;
+   }
+   if (png_ptr->palette == NULL)
+   {
+      png_ptr->palette = palette;
+   }
+   png_ptr->num_palette = (png_uint_16)num_palette;
+
+   if (full_quantize)
+   {
+      int i;
+      png_bytep distance;
+      int total_bits = PNG_QUANTIZE_RED_BITS + PNG_QUANTIZE_GREEN_BITS +
+          PNG_QUANTIZE_BLUE_BITS;
+      int num_red = (1 << PNG_QUANTIZE_RED_BITS);
+      int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);
+      int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);
+      png_size_t num_entries = ((png_size_t)1 << total_bits);
+
+      png_ptr->palette_lookup = (png_bytep)png_calloc(png_ptr,
+          (png_uint_32)(num_entries * png_sizeof(png_byte)));
+
+      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
+          png_sizeof(png_byte)));
+
+      png_memset(distance, 0xff, num_entries * png_sizeof(png_byte));
+
+      for (i = 0; i < num_palette; i++)
+      {
+         int ir, ig, ib;
+         int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));
+         int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));
+         int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));
+
+         for (ir = 0; ir < num_red; ir++)
+         {
+            /* int dr = abs(ir - r); */
+            int dr = ((ir > r) ? ir - r : r - ir);
+            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
+                PNG_QUANTIZE_GREEN_BITS));
+
+            for (ig = 0; ig < num_green; ig++)
+            {
+               /* int dg = abs(ig - g); */
+               int dg = ((ig > g) ? ig - g : g - ig);
+               int dt = dr + dg;
+               int dm = ((dr > dg) ? dr : dg);
+               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);
+
+               for (ib = 0; ib < num_blue; ib++)
+               {
+                  int d_index = index_g | ib;
+                  /* int db = abs(ib - b); */
+                  int db = ((ib > b) ? ib - b : b - ib);
+                  int dmax = ((dm > db) ? dm : db);
+                  int d = dmax + dt + db;
+
+                  if (d < (int)distance[d_index])
+                  {
+                     distance[d_index] = (png_byte)d;
+                     png_ptr->palette_lookup[d_index] = (png_byte)i;
+                  }
+               }
+            }
+         }
+      }
+
+      png_free(png_ptr, distance);
+   }
+}
+#endif /* PNG_READ_QUANTIZE_SUPPORTED */
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+void PNGFAPI
+png_set_gamma_fixed(png_structp png_ptr, png_fixed_point scrn_gamma,
+   png_fixed_point file_gamma)
+{
+   png_debug(1, "in png_set_gamma_fixed");
+
+   if (png_ptr == NULL)
+      return;
+
+   /* New in libpng-1.5.4 - reserve particular negative values as flags. */
+   scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1/*screen*/);
+   file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0/*file*/);
+
+#if PNG_LIBPNG_VER >= 10600
+   /* Checking the gamma values for being >0 was added in 1.5.4 along with the
+    * premultiplied alpha support; this actually hides an undocumented feature
+    * of the previous implementation which allowed gamma processing to be
+    * disabled in background handling.  There is no evidence (so far) that this
+    * was being used; however, png_set_background itself accepted and must still
+    * accept '0' for the gamma value it takes, because it isn't always used.
+    *
+    * Since this is an API change (albeit a very minor one that removes an
+    * undocumented API feature) it will not be made until libpng-1.6.0.
+    */
+   if (file_gamma <= 0)
+      png_error(png_ptr, "invalid file gamma in png_set_gamma");
+
+   if (scrn_gamma <= 0)
+      png_error(png_ptr, "invalid screen gamma in png_set_gamma");
+#endif
+
+   /* Set the gamma values unconditionally - this overrides the value in the PNG
+    * file if a gAMA chunk was present.  png_set_alpha_mode provides a
+    * different, easier, way to default the file gamma.
+    */
+   png_ptr->gamma = file_gamma;
+   png_ptr->screen_gamma = scrn_gamma;
+}
+
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+void PNGAPI
+png_set_gamma(png_structp png_ptr, double scrn_gamma, double file_gamma)
+{
+   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),
+      convert_gamma_value(png_ptr, file_gamma));
+}
+#  endif /* FLOATING_POINT_SUPPORTED */
+#endif /* READ_GAMMA */
+
+#ifdef PNG_READ_EXPAND_SUPPORTED
+/* Expand paletted images to RGB, expand grayscale images of
+ * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
+ * to alpha channels.
+ */
+void PNGAPI
+png_set_expand(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_expand");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
+   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
+}
+
+/* GRR 19990627:  the following three functions currently are identical
+ *  to png_set_expand().  However, it is entirely reasonable that someone
+ *  might wish to expand an indexed image to RGB but *not* expand a single,
+ *  fully transparent palette entry to a full alpha channel--perhaps instead
+ *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace
+ *  the transparent color with a particular RGB value, or drop tRNS entirely.
+ *  IOW, a future version of the library may make the transformations flag
+ *  a bit more fine-grained, with separate bits for each of these three
+ *  functions.
+ *
+ *  More to the point, these functions make it obvious what libpng will be
+ *  doing, whereas "expand" can (and does) mean any number of things.
+ *
+ *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified
+ *  to expand only the sample depth but not to expand the tRNS to alpha
+ *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
+ */
+
+/* Expand paletted images to RGB. */
+void PNGAPI
+png_set_palette_to_rgb(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_palette_to_rgb");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
+   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
+}
+
+/* Expand grayscale images of less than 8-bit depth to 8 bits. */
+void PNGAPI
+png_set_expand_gray_1_2_4_to_8(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_EXPAND;
+   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
+}
+
+
+
+/* Expand tRNS chunks to alpha channels. */
+void PNGAPI
+png_set_tRNS_to_alpha(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_tRNS_to_alpha");
+
+   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
+   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
+}
+#endif /* defined(PNG_READ_EXPAND_SUPPORTED) */
+
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise
+ * it may not work correctly.)
+ */
+void PNGAPI
+png_set_expand_16(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_expand_16");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= (PNG_EXPAND_16 | PNG_EXPAND | PNG_EXPAND_tRNS);
+   png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
+
+   /* New API, make sure apps call the correct initializers: */
+   png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;
+}
+#endif
+
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+void PNGAPI
+png_set_gray_to_rgb(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_gray_to_rgb");
+
+   if (png_ptr != NULL)
+   {
+      /* Because rgb must be 8 bits or more: */
+      png_set_expand_gray_1_2_4_to_8(png_ptr);
+      png_ptr->transformations |= PNG_GRAY_TO_RGB;
+      png_ptr->flags &= ~PNG_FLAG_ROW_INIT;
+   }
+}
+#endif
+
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+void PNGFAPI
+png_set_rgb_to_gray_fixed(png_structp png_ptr, int error_action,
+    png_fixed_point red, png_fixed_point green)
+{
+   png_debug(1, "in png_set_rgb_to_gray");
+
+   if (png_ptr == NULL)
+      return;
+
+   switch(error_action)
+   {
+      case PNG_ERROR_ACTION_NONE:
+         png_ptr->transformations |= PNG_RGB_TO_GRAY;
+         break;
+
+      case PNG_ERROR_ACTION_WARN:
+         png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
+         break;
+
+      case PNG_ERROR_ACTION_ERROR:
+         png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
+         break;
+
+      default:
+         png_error(png_ptr, "invalid error action to rgb_to_gray");
+         break;
+   }
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+#ifdef PNG_READ_EXPAND_SUPPORTED
+      png_ptr->transformations |= PNG_EXPAND;
+#else
+   {
+      png_warning(png_ptr,
+        "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED");
+
+      png_ptr->transformations &= ~PNG_RGB_TO_GRAY;
+   }
+#endif
+   {
+      if (red >= 0 && green >= 0 && red + green <= PNG_FP_1)
+      {
+         png_uint_16 red_int, green_int;
+
+         /* NOTE: this calculation does not round, but this behavior is retained
+          * for consistency, the inaccuracy is very small.  The code here always
+          * overwrites the coefficients, regardless of whether they have been
+          * defaulted or set already.
+          */
+         red_int = (png_uint_16)(((png_uint_32)red*32768)/100000);
+         green_int = (png_uint_16)(((png_uint_32)green*32768)/100000);
+
+         png_ptr->rgb_to_gray_red_coeff   = red_int;
+         png_ptr->rgb_to_gray_green_coeff = green_int;
+         png_ptr->rgb_to_gray_coefficients_set = 1;
+      }
+
+      else
+      {
+         if (red >= 0 && green >= 0)
+            png_warning(png_ptr,
+               "ignoring out of range rgb_to_gray coefficients");
+
+         /* Use the defaults, from the cHRM chunk if set, else the historical
+          * values which are close to the sRGB/HDTV/ITU-Rec 709 values.  See
+          * png_do_rgb_to_gray for more discussion of the values.  In this case
+          * the coefficients are not marked as 'set' and are not overwritten if
+          * something has already provided a default.
+          */
+         if (png_ptr->rgb_to_gray_red_coeff == 0 &&
+            png_ptr->rgb_to_gray_green_coeff == 0)
+         {
+            png_ptr->rgb_to_gray_red_coeff   = 6968;
+            png_ptr->rgb_to_gray_green_coeff = 23434;
+            /* png_ptr->rgb_to_gray_blue_coeff  = 2366; */
+         }
+      }
+   }
+}
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+/* Convert a RGB image to a grayscale of the same width.  This allows us,
+ * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
+ */
+
+void PNGAPI
+png_set_rgb_to_gray(png_structp png_ptr, int error_action, double red,
+   double green)
+{
+   if (png_ptr == NULL)
+      return;
+
+   png_set_rgb_to_gray_fixed(png_ptr, error_action,
+      png_fixed(png_ptr, red, "rgb to gray red coefficient"),
+      png_fixed(png_ptr, green, "rgb to gray green coefficient"));
+}
+#endif /* FLOATING POINT */
+
+#endif
+
+#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
+    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
+void PNGAPI
+png_set_read_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
+    read_user_transform_fn)
+{
+   png_debug(1, "in png_set_read_user_transform_fn");
+
+   if (png_ptr == NULL)
+      return;
+
+#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
+   png_ptr->transformations |= PNG_USER_TRANSFORM;
+   png_ptr->read_user_transform_fn = read_user_transform_fn;
+#endif
+}
+#endif
+
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
+#ifdef PNG_READ_GAMMA_SUPPORTED
+/* In the case of gamma transformations only do transformations on images where
+ * the [file] gamma and screen_gamma are not close reciprocals, otherwise it
+ * slows things down slightly, and also needlessly introduces small errors.
+ */
+static int /* PRIVATE */
+png_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)
+{
+   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
+    * correction as a difference of the overall transform from 1.0
+    *
+    * We want to compare the threshold with s*f - 1, if we get
+    * overflow here it is because of wacky gamma values so we
+    * turn on processing anyway.
+    */
+   png_fixed_point gtest;
+   return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||
+       png_gamma_significant(gtest);
+}
+#endif
+
+/* Initialize everything needed for the read.  This includes modifying
+ * the palette.
+ */
+
+/*For the moment 'png_init_palette_transformations' and
+ * 'png_init_rgb_transformations' only do some flag canceling optimizations.
+ * The intent is that these two routines should have palette or rgb operations
+ * extracted from 'png_init_read_transformations'.
+ */
+static void /* PRIVATE */
+png_init_palette_transformations(png_structp png_ptr)
+{
+   /* Called to handle the (input) palette case.  In png_do_read_transformations
+    * the first step is to expand the palette if requested, so this code must
+    * take care to only make changes that are invariant with respect to the
+    * palette expansion, or only do them if there is no expansion.
+    *
+    * STRIP_ALPHA has already been handled in the caller (by setting num_trans
+    * to 0.)
+    */
+   int input_has_alpha = 0;
+   int input_has_transparency = 0;
+
+   if (png_ptr->num_trans > 0)
+   {
+      int i;
+
+      /* Ignore if all the entries are opaque (unlikely!) */
+      for (i=0; i<png_ptr->num_trans; ++i)
+         if (png_ptr->trans_alpha[i] == 255)
+            continue;
+         else if (png_ptr->trans_alpha[i] == 0)
+            input_has_transparency = 1;
+         else
+            input_has_alpha = 1;
+   }
+
+   /* If no alpha we can optimize. */
+   if (!input_has_alpha)
+   {
+      /* Any alpha means background and associative alpha processing is
+       * required, however if the alpha is 0 or 1 throughout OPTIIMIZE_ALPHA
+       * and ENCODE_ALPHA are irrelevant.
+       */
+      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+
+      if (!input_has_transparency)
+         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
+   }
+
+#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
+   /* png_set_background handling - deals with the complexity of whether the
+    * background color is in the file format or the screen format in the case
+    * where an 'expand' will happen.
+    */
+
+   /* The following code cannot be entered in the alpha pre-multiplication case
+    * because PNG_BACKGROUND_EXPAND is cancelled below.
+    */
+   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+       (png_ptr->transformations & PNG_EXPAND))
+   {
+      {
+         png_ptr->background.red   =
+             png_ptr->palette[png_ptr->background.index].red;
+         png_ptr->background.green =
+             png_ptr->palette[png_ptr->background.index].green;
+         png_ptr->background.blue  =
+             png_ptr->palette[png_ptr->background.index].blue;
+
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
+        if (png_ptr->transformations & PNG_INVERT_ALPHA)
+        {
+           if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
+           {
+              /* Invert the alpha channel (in tRNS) unless the pixels are
+               * going to be expanded, in which case leave it for later
+               */
+              int i, istop = png_ptr->num_trans;
+
+              for (i=0; i<istop; i++)
+                 png_ptr->trans_alpha[i] = (png_byte)(255 -
+                    png_ptr->trans_alpha[i]);
+           }
+        }
+#endif /* PNG_READ_INVERT_ALPHA_SUPPORTED */
+      }
+   } /* background expand and (therefore) no alpha association. */
+#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */
+}
+
+static void /* PRIVATE */
+png_init_rgb_transformations(png_structp png_ptr)
+{
+   /* Added to libpng-1.5.4: check the color type to determine whether there
+    * is any alpha or transparency in the image and simply cancel the
+    * background and alpha mode stuff if there isn't.
+    */
+   int input_has_alpha = (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0;
+   int input_has_transparency = png_ptr->num_trans > 0;
+
+   /* If no alpha we can optimize. */
+   if (!input_has_alpha)
+   {
+      /* Any alpha means background and associative alpha processing is
+       * required, however if the alpha is 0 or 1 throughout OPTIIMIZE_ALPHA
+       * and ENCODE_ALPHA are irrelevant.
+       */
+#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+#     endif
+
+      if (!input_has_transparency)
+         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
+   }
+
+#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
+   /* png_set_background handling - deals with the complexity of whether the
+    * background color is in the file format or the screen format in the case
+    * where an 'expand' will happen.
+    */
+
+   /* The following code cannot be entered in the alpha pre-multiplication case
+    * because PNG_BACKGROUND_EXPAND is cancelled below.
+    */
+   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+       (png_ptr->transformations & PNG_EXPAND) &&
+       !(png_ptr->color_type & PNG_COLOR_MASK_COLOR))
+       /* i.e., GRAY or GRAY_ALPHA */
+   {
+      {
+         /* Expand background and tRNS chunks */
+         int gray = png_ptr->background.gray;
+         int trans_gray = png_ptr->trans_color.gray;
+
+         switch (png_ptr->bit_depth)
+         {
+            case 1:
+               gray *= 0xff;
+               trans_gray *= 0xff;
+               break;
+
+            case 2:
+               gray *= 0x55;
+               trans_gray *= 0x55;
+               break;
+
+            case 4:
+               gray *= 0x11;
+               trans_gray *= 0x11;
+               break;
+
+            default:
+
+            case 8:
+               /* Already 8 bits, fall through */
+
+            case 16:
+               /* Already a full 16 bits */
+               break;
+         }
+
+         png_ptr->background.red = png_ptr->background.green =
+            png_ptr->background.blue = (png_uint_16)gray;
+
+         if (!(png_ptr->transformations & PNG_EXPAND_tRNS))
+         {
+            png_ptr->trans_color.red = png_ptr->trans_color.green =
+               png_ptr->trans_color.blue = (png_uint_16)trans_gray;
+         }
+      }
+   } /* background expand and (therefore) no alpha association. */
+#endif /* PNG_READ_EXPAND_SUPPORTED && PNG_READ_BACKGROUND_SUPPORTED */
+}
+
+void /* PRIVATE */
+png_init_read_transformations(png_structp png_ptr)
+{
+   png_debug(1, "in png_init_read_transformations");
+
+   /* This internal function is called from png_read_start_row in pngrutil.c
+    * and it is called before the 'rowbytes' calculation is done, so the code
+    * in here can change or update the transformations flags.
+    *
+    * First do updates that do not depend on the details of the PNG image data
+    * being processed.
+    */
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
+    * png_set_alpha_mode and this is another source for a default file gamma so
+    * the test needs to be performed later - here.  In addition prior to 1.5.4
+    * the tests were repeated for the PALETTE color type here - this is no
+    * longer necessary (and doesn't seem to have been necessary before.)
+    */
+   {
+      /* The following temporary indicates if overall gamma correction is
+       * required.
+       */
+      int gamma_correction = 0;
+
+      if (png_ptr->gamma != 0) /* has been set */
+      {
+         if (png_ptr->screen_gamma != 0) /* screen set too */
+            gamma_correction = png_gamma_threshold(png_ptr->gamma,
+               png_ptr->screen_gamma);
+
+         else
+            /* Assume the output matches the input; a long time default behavior
+             * of libpng, although the standard has nothing to say about this.
+             */
+            png_ptr->screen_gamma = png_reciprocal(png_ptr->gamma);
+      }
+
+      else if (png_ptr->screen_gamma != 0)
+         /* The converse - assume the file matches the screen, note that this
+          * perhaps undesireable default can (from 1.5.4) be changed by calling
+          * png_set_alpha_mode (even if the alpha handling mode isn't required
+          * or isn't changed from the default.)
+          */
+         png_ptr->gamma = png_reciprocal(png_ptr->screen_gamma);
+
+      else /* neither are set */
+         /* Just in case the following prevents any processing - file and screen
+          * are both assumed to be linear and there is no way to introduce a
+          * third gamma value other than png_set_background with 'UNIQUE', and,
+          * prior to 1.5.4
+          */
+         png_ptr->screen_gamma = png_ptr->gamma = PNG_FP_1;
+
+      /* Now turn the gamma transformation on or off as appropriate.  Notice
+       * that PNG_GAMMA just refers to the file->screen correction.  Alpha
+       * composition may independently cause gamma correction because it needs
+       * linear data (e.g. if the file has a gAMA chunk but the screen gamma
+       * hasn't been specified.)  In any case this flag may get turned off in
+       * the code immediately below if the transform can be handled outside the
+       * row loop.
+       */
+      if (gamma_correction)
+         png_ptr->transformations |= PNG_GAMMA;
+
+      else
+         png_ptr->transformations &= ~PNG_GAMMA;
+   }
+#endif
+
+   /* Certain transformations have the effect of preventing other
+    * transformations that happen afterward in png_do_read_transformations,
+    * resolve the interdependencies here.  From the code of
+    * png_do_read_transformations the order is:
+    *
+    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)
+    *  2) PNG_STRIP_ALPHA (if no compose)
+    *  3) PNG_RGB_TO_GRAY
+    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY
+    *  5) PNG_COMPOSE
+    *  6) PNG_GAMMA
+    *  7) PNG_STRIP_ALPHA (if compose)
+    *  8) PNG_ENCODE_ALPHA
+    *  9) PNG_SCALE_16_TO_8
+    * 10) PNG_16_TO_8
+    * 11) PNG_QUANTIZE (converts to palette)
+    * 12) PNG_EXPAND_16
+    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY
+    * 14) PNG_INVERT_MONO
+    * 15) PNG_SHIFT
+    * 16) PNG_PACK
+    * 17) PNG_BGR
+    * 18) PNG_PACKSWAP
+    * 19) PNG_FILLER (includes PNG_ADD_ALPHA)
+    * 20) PNG_INVERT_ALPHA
+    * 21) PNG_SWAP_ALPHA
+    * 22) PNG_SWAP_BYTES
+    * 23) PNG_USER_TRANSFORM [must be last]
+    */
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
+   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
+      !(png_ptr->transformations & PNG_COMPOSE))
+   {
+      /* Stripping the alpha channel happens immediately after the 'expand'
+       * transformations, before all other transformation, so it cancels out
+       * the alpha handling.  It has the side effect negating the effect of
+       * PNG_EXPAND_tRNS too:
+       */
+      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |
+         PNG_EXPAND_tRNS);
+      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+
+      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen
+       * so transparency information would remain just so long as it wasn't
+       * expanded.  This produces unexpected API changes if the set of things
+       * that do PNG_EXPAND_tRNS changes (perfectly possible given the
+       * documentation - which says ask for what you want, accept what you
+       * get.)  This makes the behavior consistent from 1.5.4:
+       */
+      png_ptr->num_trans = 0;
+   }
+#endif /* STRIP_ALPHA supported, no COMPOSE */
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA
+    * settings will have no effect.
+    */
+   if (!png_gamma_significant(png_ptr->screen_gamma))
+   {
+      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
+      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
+   }
+#endif
+
+#if defined(PNG_READ_EXPAND_SUPPORTED) && \
+   defined(PNG_READ_BACKGROUND_SUPPORTED) && \
+   defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+   /* Detect gray background and attempt to enable optimization for
+    * gray --> RGB case.
+    *
+    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
+    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
+    * background color might actually be gray yet not be flagged as such.
+    * This is not a problem for the current code, which uses
+    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
+    * png_do_gray_to_rgb() transformation.
+    *
+    * TODO: this code needs to be revised to avoid the complexity and
+    * interdependencies.  The color type of the background should be recorded in
+    * png_set_background, along with the bit depth, then the code has a record
+    * of exactly what color space the background is currently in.
+    */
+   if (png_ptr->transformations & PNG_BACKGROUND_EXPAND)
+   {
+      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if
+       * the file was grayscale the background value is gray.
+       */
+      if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR))
+         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
+   }
+
+   else if (png_ptr->transformations & PNG_COMPOSE)
+   {
+      /* PNG_COMPOSE: png_set_background was called with need_expand false,
+       * so the color is in the color space of the output or png_set_alpha_mode
+       * was called and the color is black.  Ignore RGB_TO_GRAY because that
+       * happens before GRAY_TO_RGB.
+       */
+      if (png_ptr->transformations & PNG_GRAY_TO_RGB)
+      {
+         if (png_ptr->background.red == png_ptr->background.green &&
+             png_ptr->background.red == png_ptr->background.blue)
+         {
+            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
+            png_ptr->background.gray = png_ptr->background.red;
+         }
+      }
+   }
+#endif /* PNG_READ_GRAY_TO_RGB_SUPPORTED (etc) */
+
+   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
+    * can be performed directly on the palette, and some (such as rgb to gray)
+    * can be optimized inside the palette.  This is particularly true of the
+    * composite (background and alpha) stuff, which can be pretty much all done
+    * in the palette even if the result is expanded to RGB or gray afterward.
+    *
+    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and
+    * earlier and the palette stuff is actually handled on the first row.  This
+    * leads to the reported bug that the palette returned by png_get_PLTE is not
+    * updated.
+    */
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      png_init_palette_transformations(png_ptr);
+
+   else
+      png_init_rgb_transformations(png_ptr);
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
+   defined(PNG_READ_EXPAND_16_SUPPORTED)
+   if ((png_ptr->transformations & PNG_EXPAND_16) &&
+      (png_ptr->transformations & PNG_COMPOSE) &&
+      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+      png_ptr->bit_depth != 16)
+   {
+      /* TODO: fix this.  Because the expand_16 operation is after the compose
+       * handling the background color must be 8, not 16, bits deep, but the
+       * application will supply a 16-bit value so reduce it here.
+       *
+       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at
+       * present, so that case is ok (until do_expand_16 is moved.)
+       *
+       * NOTE: this discards the low 16 bits of the user supplied background
+       * color, but until expand_16 works properly there is no choice!
+       */
+#     define CHOP(x) (x)=((png_uint_16)(((png_uint_32)(x)*255+32895) >> 16))
+      CHOP(png_ptr->background.red);
+      CHOP(png_ptr->background.green);
+      CHOP(png_ptr->background.blue);
+      CHOP(png_ptr->background.gray);
+#     undef CHOP
+   }
+#endif /* PNG_READ_BACKGROUND_SUPPORTED && PNG_READ_EXPAND_16_SUPPORTED */
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
+   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \
+   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))
+   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) &&
+      (png_ptr->transformations & PNG_COMPOSE) &&
+      !(png_ptr->transformations & PNG_BACKGROUND_EXPAND) &&
+      png_ptr->bit_depth == 16)
+   {
+      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per
+       * component this will also happen after PNG_COMPOSE and so the background
+       * color must be pre-expanded here.
+       *
+       * TODO: fix this too.
+       */
+      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);
+      png_ptr->background.green =
+         (png_uint_16)(png_ptr->background.green * 257);
+      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);
+      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);
+   }
+#endif
+
+   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the
+    * background support (see the comments in scripts/pnglibconf.dfa), this
+    * allows pre-multiplication of the alpha channel to be implemented as
+    * compositing on black.  This is probably sub-optimal and has been done in
+    * 1.5.4 betas simply to enable external critique and testing (i.e. to
+    * implement the new API quickly, without lots of internal changes.)
+    */
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+#  ifdef PNG_READ_BACKGROUND_SUPPORTED
+      /* Includes ALPHA_MODE */
+      png_ptr->background_1 = png_ptr->background;
+#  endif
+
+   /* This needs to change - in the palette image case a whole set of tables are
+    * built when it would be quicker to just calculate the correct value for
+    * each palette entry directly.  Also, the test is too tricky - why check
+    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that
+    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the
+    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction
+    * the gamma tables will not be built even if composition is required on a
+    * gamma encoded value.
+    *
+    * In 1.5.4 this is addressed below by an additional check on the individual
+    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the
+    * tables.
+    */
+   if ((png_ptr->transformations & PNG_GAMMA)
+      || ((png_ptr->transformations & PNG_RGB_TO_GRAY)
+         && (png_gamma_significant(png_ptr->gamma) ||
+            png_gamma_significant(png_ptr->screen_gamma)))
+      || ((png_ptr->transformations & PNG_COMPOSE)
+         && (png_gamma_significant(png_ptr->gamma)
+            || png_gamma_significant(png_ptr->screen_gamma)
+#  ifdef PNG_READ_BACKGROUND_SUPPORTED
+            || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE
+               && png_gamma_significant(png_ptr->background_gamma))
+#  endif
+      )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA)
+         && png_gamma_significant(png_ptr->screen_gamma))
+      )
+   {
+      png_build_gamma_table(png_ptr, png_ptr->bit_depth);
+
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
+      if (png_ptr->transformations & PNG_COMPOSE)
+      {
+         /* Issue a warning about this combination: because RGB_TO_GRAY is
+          * optimized to do the gamma transform if present yet do_background has
+          * to do the same thing if both options are set a
+          * double-gamma-correction happens.  This is true in all versions of
+          * libpng to date.
+          */
+         if (png_ptr->transformations & PNG_RGB_TO_GRAY)
+            png_warning(png_ptr,
+               "libpng does not support gamma+background+rgb_to_gray");
+
+         if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+         {
+            /* We don't get to here unless there is a tRNS chunk with non-opaque
+             * entries - see the checking code at the start of this function.
+             */
+            png_color back, back_1;
+            png_colorp palette = png_ptr->palette;
+            int num_palette = png_ptr->num_palette;
+            int i;
+            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
+            {
+
+               back.red = png_ptr->gamma_table[png_ptr->background.red];
+               back.green = png_ptr->gamma_table[png_ptr->background.green];
+               back.blue = png_ptr->gamma_table[png_ptr->background.blue];
+
+               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
+               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
+               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
+            }
+            else
+            {
+               png_fixed_point g, gs;
+
+               switch (png_ptr->background_gamma_type)
+               {
+                  case PNG_BACKGROUND_GAMMA_SCREEN:
+                     g = (png_ptr->screen_gamma);
+                     gs = PNG_FP_1;
+                     break;
+
+                  case PNG_BACKGROUND_GAMMA_FILE:
+                     g = png_reciprocal(png_ptr->gamma);
+                     gs = png_reciprocal2(png_ptr->gamma,
+                        png_ptr->screen_gamma);
+                     break;
+
+                  case PNG_BACKGROUND_GAMMA_UNIQUE:
+                     g = png_reciprocal(png_ptr->background_gamma);
+                     gs = png_reciprocal2(png_ptr->background_gamma,
+                        png_ptr->screen_gamma);
+                     break;
+                  default:
+                     g = PNG_FP_1;    /* back_1 */
+                     gs = PNG_FP_1;   /* back */
+                     break;
+               }
+
+               if (png_gamma_significant(gs))
+               {
+                  back.red = png_gamma_8bit_correct(png_ptr->background.red,
+                      gs);
+                  back.green = png_gamma_8bit_correct(png_ptr->background.green,
+                      gs);
+                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,
+                      gs);
+               }
+
+               else
+               {
+                  back.red   = (png_byte)png_ptr->background.red;
+                  back.green = (png_byte)png_ptr->background.green;
+                  back.blue  = (png_byte)png_ptr->background.blue;
+               }
+
+               if (png_gamma_significant(g))
+               {
+                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,
+                     g);
+                  back_1.green = png_gamma_8bit_correct(
+                     png_ptr->background.green, g);
+                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,
+                     g);
+               }
+
+               else
+               {
+                  back_1.red   = (png_byte)png_ptr->background.red;
+                  back_1.green = (png_byte)png_ptr->background.green;
+                  back_1.blue  = (png_byte)png_ptr->background.blue;
+               }
+            }
+
+            for (i = 0; i < num_palette; i++)
+            {
+               if (i < (int)png_ptr->num_trans &&
+                   png_ptr->trans_alpha[i] != 0xff)
+               {
+                  if (png_ptr->trans_alpha[i] == 0)
+                  {
+                     palette[i] = back;
+                  }
+                  else /* if (png_ptr->trans_alpha[i] != 0xff) */
+                  {
+                     png_byte v, w;
+
+                     v = png_ptr->gamma_to_1[palette[i].red];
+                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);
+                     palette[i].red = png_ptr->gamma_from_1[w];
+
+                     v = png_ptr->gamma_to_1[palette[i].green];
+                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);
+                     palette[i].green = png_ptr->gamma_from_1[w];
+
+                     v = png_ptr->gamma_to_1[palette[i].blue];
+                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);
+                     palette[i].blue = png_ptr->gamma_from_1[w];
+                  }
+               }
+               else
+               {
+                  palette[i].red = png_ptr->gamma_table[palette[i].red];
+                  palette[i].green = png_ptr->gamma_table[palette[i].green];
+                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];
+               }
+            }
+
+            /* Prevent the transformations being done again.
+             *
+             * NOTE: this is highly dubious; it removes the transformations in
+             * place.  This seems inconsistent with the general treatment of the
+             * transformations elsewhere.
+             */
+            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);
+         } /* color_type == PNG_COLOR_TYPE_PALETTE */
+
+         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
+         else /* color_type != PNG_COLOR_TYPE_PALETTE */
+         {
+            int gs_sig, g_sig;
+            png_fixed_point g = PNG_FP_1;  /* Correction to linear */
+            png_fixed_point gs = PNG_FP_1; /* Correction to screen */
+
+            switch (png_ptr->background_gamma_type)
+            {
+               case PNG_BACKGROUND_GAMMA_SCREEN:
+                  g = png_ptr->screen_gamma;
+                  /* gs = PNG_FP_1; */
+                  break;
+
+               case PNG_BACKGROUND_GAMMA_FILE:
+                  g = png_reciprocal(png_ptr->gamma);
+                  gs = png_reciprocal2(png_ptr->gamma, png_ptr->screen_gamma);
+                  break;
+
+               case PNG_BACKGROUND_GAMMA_UNIQUE:
+                  g = png_reciprocal(png_ptr->background_gamma);
+                  gs = png_reciprocal2(png_ptr->background_gamma,
+                      png_ptr->screen_gamma);
+                  break;
+
+               default:
+                  png_error(png_ptr, "invalid background gamma type");
+            }
+
+            g_sig = png_gamma_significant(g);
+            gs_sig = png_gamma_significant(gs);
+
+            if (g_sig)
+               png_ptr->background_1.gray = png_gamma_correct(png_ptr,
+                   png_ptr->background.gray, g);
+
+            if (gs_sig)
+               png_ptr->background.gray = png_gamma_correct(png_ptr,
+                   png_ptr->background.gray, gs);
+
+            if ((png_ptr->background.red != png_ptr->background.green) ||
+                (png_ptr->background.red != png_ptr->background.blue) ||
+                (png_ptr->background.red != png_ptr->background.gray))
+            {
+               /* RGB or RGBA with color background */
+               if (g_sig)
+               {
+                  png_ptr->background_1.red = png_gamma_correct(png_ptr,
+                      png_ptr->background.red, g);
+
+                  png_ptr->background_1.green = png_gamma_correct(png_ptr,
+                      png_ptr->background.green, g);
+
+                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,
+                      png_ptr->background.blue, g);
+               }
+
+               if (gs_sig)
+               {
+                  png_ptr->background.red = png_gamma_correct(png_ptr,
+                      png_ptr->background.red, gs);
+
+                  png_ptr->background.green = png_gamma_correct(png_ptr,
+                      png_ptr->background.green, gs);
+
+                  png_ptr->background.blue = png_gamma_correct(png_ptr,
+                      png_ptr->background.blue, gs);
+               }
+            }
+
+            else
+            {
+               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
+               png_ptr->background_1.red = png_ptr->background_1.green
+                   = png_ptr->background_1.blue = png_ptr->background_1.gray;
+
+               png_ptr->background.red = png_ptr->background.green
+                   = png_ptr->background.blue = png_ptr->background.gray;
+            }
+
+            /* The background is now in screen gamma: */
+            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;
+         } /* color_type != PNG_COLOR_TYPE_PALETTE */
+      }/* png_ptr->transformations & PNG_BACKGROUND */
+
+      else
+      /* Transformation does not include PNG_BACKGROUND */
+#endif /* PNG_READ_BACKGROUND_SUPPORTED */
+      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */
+         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||
+         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)
+#endif
+         )
+      {
+         png_colorp palette = png_ptr->palette;
+         int num_palette = png_ptr->num_palette;
+         int i;
+
+         /* NOTE: there are other transformations that should probably be in
+          * here too.
+          */
+         for (i = 0; i < num_palette; i++)
+         {
+            palette[i].red = png_ptr->gamma_table[palette[i].red];
+            palette[i].green = png_ptr->gamma_table[palette[i].green];
+            palette[i].blue = png_ptr->gamma_table[palette[i].blue];
+         }
+
+         /* Done the gamma correction. */
+         png_ptr->transformations &= ~PNG_GAMMA;
+      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */
+   }
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
+   else
+#endif
+#endif /* PNG_READ_GAMMA_SUPPORTED */
+
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
+   /* No GAMMA transformation (see the hanging else 4 lines above) */
+   if ((png_ptr->transformations & PNG_COMPOSE) &&
+       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
+   {
+      int i;
+      int istop = (int)png_ptr->num_trans;
+      png_color back;
+      png_colorp palette = png_ptr->palette;
+
+      back.red   = (png_byte)png_ptr->background.red;
+      back.green = (png_byte)png_ptr->background.green;
+      back.blue  = (png_byte)png_ptr->background.blue;
+
+      for (i = 0; i < istop; i++)
+      {
+         if (png_ptr->trans_alpha[i] == 0)
+         {
+            palette[i] = back;
+         }
+
+         else if (png_ptr->trans_alpha[i] != 0xff)
+         {
+            /* The png_composite() macro is defined in png.h */
+            png_composite(palette[i].red, palette[i].red,
+                png_ptr->trans_alpha[i], back.red);
+
+            png_composite(palette[i].green, palette[i].green,
+                png_ptr->trans_alpha[i], back.green);
+
+            png_composite(palette[i].blue, palette[i].blue,
+                png_ptr->trans_alpha[i], back.blue);
+         }
+      }
+
+      png_ptr->transformations &= ~PNG_COMPOSE;
+   }
+#endif /* PNG_READ_BACKGROUND_SUPPORTED */
+
+#ifdef PNG_READ_SHIFT_SUPPORTED
+   if ((png_ptr->transformations & PNG_SHIFT) &&
+      !(png_ptr->transformations & PNG_EXPAND) &&
+       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
+   {
+      int i;
+      int istop = png_ptr->num_palette;
+      int shift = 8 - png_ptr->sig_bit.red;
+
+      png_ptr->transformations &= ~PNG_SHIFT;
+
+      /* significant bits can be in the range 1 to 7 for a meaninful result, if
+       * the number of significant bits is 0 then no shift is done (this is an
+       * error condition which is silently ignored.)
+       */
+      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
+      {
+         int component = png_ptr->palette[i].red;
+
+         component >>= shift;
+         png_ptr->palette[i].red = (png_byte)component;
+      }
+
+      shift = 8 - png_ptr->sig_bit.green;
+      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
+      {
+         int component = png_ptr->palette[i].green;
+
+         component >>= shift;
+         png_ptr->palette[i].green = (png_byte)component;
+      }
+
+      shift = 8 - png_ptr->sig_bit.blue;
+      if (shift > 0 && shift < 8) for (i=0; i<istop; ++i)
+      {
+         int component = png_ptr->palette[i].blue;
+
+         component >>= shift;
+         png_ptr->palette[i].blue = (png_byte)component;
+      }
+   }
+#endif  /* PNG_READ_SHIFT_SUPPORTED */
+}
+
+/* Modify the info structure to reflect the transformations.  The
+ * info should be updated so a PNG file could be written with it,
+ * assuming the transformations result in valid PNG data.
+ */
+void /* PRIVATE */
+png_read_transform_info(png_structp png_ptr, png_infop info_ptr)
+{
+   png_debug(1, "in png_read_transform_info");
+
+#ifdef PNG_READ_EXPAND_SUPPORTED
+   if (png_ptr->transformations & PNG_EXPAND)
+   {
+      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      {
+         /* This check must match what actually happens in
+          * png_do_expand_palette; if it ever checks the tRNS chunk to see if
+          * it is all opaque we must do the same (at present it does not.)
+          */
+         if (png_ptr->num_trans > 0)
+            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+
+         else
+            info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+
+         info_ptr->bit_depth = 8;
+         info_ptr->num_trans = 0;
+      }
+      else
+      {
+         if (png_ptr->num_trans)
+         {
+            if (png_ptr->transformations & PNG_EXPAND_tRNS)
+               info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
+         }
+         if (info_ptr->bit_depth < 8)
+            info_ptr->bit_depth = 8;
+
+         info_ptr->num_trans = 0;
+      }
+   }
+#endif
+
+#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
+   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
+   /* The following is almost certainly wrong unless the background value is in
+    * the screen space!
+    */
+   if (png_ptr->transformations & PNG_COMPOSE)
+      info_ptr->background = png_ptr->background;
+#endif
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+   /* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),
+    * however it seems that the code in png_init_read_transformations, which has
+    * been called before this from png_read_update_info->png_read_start_row
+    * sometimes does the gamma transform and cancels the flag.
+    */
+   info_ptr->gamma = png_ptr->gamma;
+#endif
+
+   if (info_ptr->bit_depth == 16)
+   {
+#  ifdef PNG_READ_16BIT_SUPPORTED
+#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+         if (png_ptr->transformations & PNG_SCALE_16_TO_8)
+            info_ptr->bit_depth = 8;
+#     endif
+
+#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+         if (png_ptr->transformations & PNG_16_TO_8)
+            info_ptr->bit_depth = 8;
+#     endif
+
+#  else
+      /* No 16 bit support: force chopping 16-bit input down to 8, in this case
+       * the app program can chose if both APIs are available by setting the
+       * correct scaling to use.
+       */
+#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+         /* For compatibility with previous versions use the strip method by
+          * default.  This code works because if PNG_SCALE_16_TO_8 is already
+          * set the code below will do that in preference to the chop.
+          */
+         png_ptr->transformations |= PNG_16_TO_8;
+         info_ptr->bit_depth = 8;
+#     else
+
+#        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+            png_ptr->transformations |= PNG_SCALE_16_TO_8;
+            info_ptr->bit_depth = 8;
+#        else
+
+            CONFIGURATION ERROR: you must enable at least one 16 to 8 method
+#        endif
+#    endif
+#endif /* !READ_16BIT_SUPPORTED */
+   }
+
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
+      info_ptr->color_type = (png_byte)(info_ptr->color_type |
+         PNG_COLOR_MASK_COLOR);
+#endif
+
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
+      info_ptr->color_type = (png_byte)(info_ptr->color_type &
+         ~PNG_COLOR_MASK_COLOR);
+#endif
+
+#ifdef PNG_READ_QUANTIZE_SUPPORTED
+   if (png_ptr->transformations & PNG_QUANTIZE)
+   {
+      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
+          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
+          png_ptr->palette_lookup && info_ptr->bit_depth == 8)
+      {
+         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+      }
+   }
+#endif
+
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+   if (png_ptr->transformations & PNG_EXPAND_16 && info_ptr->bit_depth == 8 &&
+      info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
+   {
+      info_ptr->bit_depth = 16;
+   }
+#endif
+
+#ifdef PNG_READ_PACK_SUPPORTED
+   if ((png_ptr->transformations & PNG_PACK) && (info_ptr->bit_depth < 8))
+      info_ptr->bit_depth = 8;
+#endif
+
+   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      info_ptr->channels = 1;
+
+   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
+      info_ptr->channels = 3;
+
+   else
+      info_ptr->channels = 1;
+
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
+   if (png_ptr->transformations & PNG_STRIP_ALPHA)
+   {
+      info_ptr->color_type = (png_byte)(info_ptr->color_type &
+         ~PNG_COLOR_MASK_ALPHA);
+      info_ptr->num_trans = 0;
+   }
+#endif
+
+   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
+      info_ptr->channels++;
+
+#ifdef PNG_READ_FILLER_SUPPORTED
+   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
+   if ((png_ptr->transformations & PNG_FILLER) &&
+       ((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
+       (info_ptr->color_type == PNG_COLOR_TYPE_GRAY)))
+   {
+      info_ptr->channels++;
+      /* If adding a true alpha channel not just filler */
+      if (png_ptr->transformations & PNG_ADD_ALPHA)
+         info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
+   }
+#endif
+
+#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
+defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
+   if (png_ptr->transformations & PNG_USER_TRANSFORM)
+   {
+      if (info_ptr->bit_depth < png_ptr->user_transform_depth)
+         info_ptr->bit_depth = png_ptr->user_transform_depth;
+
+      if (info_ptr->channels < png_ptr->user_transform_channels)
+         info_ptr->channels = png_ptr->user_transform_channels;
+   }
+#endif
+
+   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
+       info_ptr->bit_depth);
+
+   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
+
+   /* Adding in 1.5.4: cache the above value in png_struct so that we can later
+    * check in png_rowbytes that the user buffer won't get overwritten.  Note
+    * that the field is not always set - if png_read_update_info isn't called
+    * the application has to either not do any transforms or get the calculation
+    * right itself.
+    */
+   png_ptr->info_rowbytes = info_ptr->rowbytes;
+
+#ifndef PNG_READ_EXPAND_SUPPORTED
+   if (png_ptr)
+      return;
+#endif
+}
+
+/* Transform the row.  The order of transformations is significant,
+ * and is very touchy.  If you add a transformation, take care to
+ * decide how it fits in with the other transformations here.
+ */
+void /* PRIVATE */
+png_do_read_transformations(png_structp png_ptr, png_row_infop row_info)
+{
+   png_debug(1, "in png_do_read_transformations");
+
+   if (png_ptr->row_buf == NULL)
+   {
+      /* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this
+       * error is incredibly rare and incredibly easy to debug without this
+       * information.
+       */
+      png_error(png_ptr, "NULL row buffer");
+   }
+
+   /* The following is debugging; prior to 1.5.4 the code was never compiled in;
+    * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro
+    * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.5 the new flag is set only for
+    * selected new APIs to ensure that there is no API change.
+    */
+   if ((png_ptr->flags & PNG_FLAG_DETECT_UNINITIALIZED) != 0 &&
+      !(png_ptr->flags & PNG_FLAG_ROW_INIT))
+   {
+      /* Application has failed to call either png_read_start_image() or
+       * png_read_update_info() after setting transforms that expand pixels.
+       * This check added to libpng-1.2.19 (but not enabled until 1.5.4).
+       */
+      png_error(png_ptr, "Uninitialized row");
+   }
+
+#ifdef PNG_READ_EXPAND_SUPPORTED
+   if (png_ptr->transformations & PNG_EXPAND)
+   {
+      if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
+      {
+         png_do_expand_palette(row_info, png_ptr->row_buf + 1,
+             png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);
+      }
+
+      else
+      {
+         if (png_ptr->num_trans &&
+             (png_ptr->transformations & PNG_EXPAND_tRNS))
+            png_do_expand(row_info, png_ptr->row_buf + 1,
+                &(png_ptr->trans_color));
+
+         else
+            png_do_expand(row_info, png_ptr->row_buf + 1,
+                NULL);
+      }
+   }
+#endif
+
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
+   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
+      !(png_ptr->transformations & PNG_COMPOSE) &&
+      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
+      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
+         0 /* at_start == false, because SWAP_ALPHA happens later */);
+#endif
+
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+   if (png_ptr->transformations & PNG_RGB_TO_GRAY)
+   {
+      int rgb_error =
+          png_do_rgb_to_gray(png_ptr, row_info,
+              png_ptr->row_buf + 1);
+
+      if (rgb_error)
+      {
+         png_ptr->rgb_to_gray_status=1;
+         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
+             PNG_RGB_TO_GRAY_WARN)
+            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
+
+         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
+             PNG_RGB_TO_GRAY_ERR)
+            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
+      }
+   }
+#endif
+
+/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
+ *
+ *   In most cases, the "simple transparency" should be done prior to doing
+ *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
+ *   pixel is transparent.  You would also need to make sure that the
+ *   transparency information is upgraded to RGB.
+ *
+ *   To summarize, the current flow is:
+ *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
+ *                                   with background "in place" if transparent,
+ *                                   convert to RGB if necessary
+ *   - Gray + alpha -> composite with gray background and remove alpha bytes,
+ *                                   convert to RGB if necessary
+ *
+ *   To support RGB backgrounds for gray images we need:
+ *   - Gray + simple transparency -> convert to RGB + simple transparency,
+ *                                   compare 3 or 6 bytes and composite with
+ *                                   background "in place" if transparent
+ *                                   (3x compare/pixel compared to doing
+ *                                   composite with gray bkgrnd)
+ *   - Gray + alpha -> convert to RGB + alpha, composite with background and
+ *                                   remove alpha bytes (3x float
+ *                                   operations/pixel compared with composite
+ *                                   on gray background)
+ *
+ *  Greg's change will do this.  The reason it wasn't done before is for
+ *  performance, as this increases the per-pixel operations.  If we would check
+ *  in advance if the background was gray or RGB, and position the gray-to-RGB
+ *  transform appropriately, then it would save a lot of work/time.
+ */
+
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+   /* If gray -> RGB, do so now only if background is non-gray; else do later
+    * for performance reasons
+    */
+   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
+       !(png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
+      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
+#endif
+
+#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
+   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
+   if (png_ptr->transformations & PNG_COMPOSE)
+      png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);
+#endif
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+   if ((png_ptr->transformations & PNG_GAMMA) &&
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+      /* Because RGB_TO_GRAY does the gamma transform. */
+      !(png_ptr->transformations & PNG_RGB_TO_GRAY) &&
+#endif
+#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
+   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
+      /* Because PNG_COMPOSE does the gamma transform if there is something to
+       * do (if there is an alpha channel or transparency.)
+       */
+       !((png_ptr->transformations & PNG_COMPOSE) &&
+       ((png_ptr->num_trans != 0) ||
+       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA))) &&
+#endif
+      /* Because png_init_read_transformations transforms the palette, unless
+       * RGB_TO_GRAY will do the transform.
+       */
+       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
+      png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);
+#endif
+
+#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
+   if ((png_ptr->transformations & PNG_STRIP_ALPHA) &&
+      (png_ptr->transformations & PNG_COMPOSE) &&
+      (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
+      row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
+      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
+         0 /* at_start == false, because SWAP_ALPHA happens later */);
+#endif
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+   if ((png_ptr->transformations & PNG_ENCODE_ALPHA) &&
+      (row_info->color_type & PNG_COLOR_MASK_ALPHA))
+      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);
+#endif
+
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+   if (png_ptr->transformations & PNG_SCALE_16_TO_8)
+      png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+   /* There is no harm in doing both of these because only one has any effect,
+    * by putting the 'scale' option first if the app asks for scale (either by
+    * calling the API or in a TRANSFORM flag) this is what happens.
+    */
+   if (png_ptr->transformations & PNG_16_TO_8)
+      png_do_chop(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_QUANTIZE_SUPPORTED
+   if (png_ptr->transformations & PNG_QUANTIZE)
+   {
+      png_do_quantize(row_info, png_ptr->row_buf + 1,
+          png_ptr->palette_lookup, png_ptr->quantize_index);
+
+      if (row_info->rowbytes == 0)
+         png_error(png_ptr, "png_do_quantize returned rowbytes=0");
+   }
+#endif /* PNG_READ_QUANTIZE_SUPPORTED */
+
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+   /* Do the expansion now, after all the arithmetic has been done.  Notice
+    * that previous transformations can handle the PNG_EXPAND_16 flag if this
+    * is efficient (particularly true in the case of gamma correction, where
+    * better accuracy results faster!)
+    */
+   if (png_ptr->transformations & PNG_EXPAND_16)
+      png_do_expand_16(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+   /* NOTE: moved here in 1.5.4 (from much later in this list.) */
+   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) &&
+       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY))
+      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_INVERT_SUPPORTED
+   if (png_ptr->transformations & PNG_INVERT_MONO)
+      png_do_invert(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_SHIFT_SUPPORTED
+   if (png_ptr->transformations & PNG_SHIFT)
+      png_do_unshift(row_info, png_ptr->row_buf + 1,
+          &(png_ptr->shift));
+#endif
+
+#ifdef PNG_READ_PACK_SUPPORTED
+   if (png_ptr->transformations & PNG_PACK)
+      png_do_unpack(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   /* Added at libpng-1.5.10 */
+   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
+       png_ptr->num_palette_max >= 0)
+      png_do_check_palette_indexes(png_ptr, row_info);
+#endif
+
+#ifdef PNG_READ_BGR_SUPPORTED
+   if (png_ptr->transformations & PNG_BGR)
+      png_do_bgr(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_PACKSWAP_SUPPORTED
+   if (png_ptr->transformations & PNG_PACKSWAP)
+      png_do_packswap(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_FILLER_SUPPORTED
+   if (png_ptr->transformations & PNG_FILLER)
+      png_do_read_filler(row_info, png_ptr->row_buf + 1,
+          (png_uint_32)png_ptr->filler, png_ptr->flags);
+#endif
+
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
+   if (png_ptr->transformations & PNG_INVERT_ALPHA)
+      png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
+   if (png_ptr->transformations & PNG_SWAP_ALPHA)
+      png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+#ifdef PNG_READ_SWAP_SUPPORTED
+   if (png_ptr->transformations & PNG_SWAP_BYTES)
+      png_do_swap(row_info, png_ptr->row_buf + 1);
+#endif
+#endif
+
+#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
+   if (png_ptr->transformations & PNG_USER_TRANSFORM)
+    {
+      if (png_ptr->read_user_transform_fn != NULL)
+         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
+             (png_ptr,     /* png_ptr */
+             row_info,     /* row_info: */
+                /*  png_uint_32 width;       width of row */
+                /*  png_size_t rowbytes;     number of bytes in row */
+                /*  png_byte color_type;     color type of pixels */
+                /*  png_byte bit_depth;      bit depth of samples */
+                /*  png_byte channels;       number of channels (1-4) */
+                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
+             png_ptr->row_buf + 1);    /* start of pixel data for row */
+#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
+      if (png_ptr->user_transform_depth)
+         row_info->bit_depth = png_ptr->user_transform_depth;
+
+      if (png_ptr->user_transform_channels)
+         row_info->channels = png_ptr->user_transform_channels;
+#endif
+      row_info->pixel_depth = (png_byte)(row_info->bit_depth *
+          row_info->channels);
+
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);
+   }
+#endif
+}
+
+#ifdef PNG_READ_PACK_SUPPORTED
+/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
+ * without changing the actual values.  Thus, if you had a row with
+ * a bit depth of 1, you would end up with bytes that only contained
+ * the numbers 0 or 1.  If you would rather they contain 0 and 255, use
+ * png_do_shift() after this.
+ */
+void /* PRIVATE */
+png_do_unpack(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_unpack");
+
+   if (row_info->bit_depth < 8)
+   {
+      png_uint_32 i;
+      png_uint_32 row_width=row_info->width;
+
+      switch (row_info->bit_depth)
+      {
+         case 1:
+         {
+            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);
+            png_bytep dp = row + (png_size_t)row_width - 1;
+            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);
+            for (i = 0; i < row_width; i++)
+            {
+               *dp = (png_byte)((*sp >> shift) & 0x01);
+
+               if (shift == 7)
+               {
+                  shift = 0;
+                  sp--;
+               }
+
+               else
+                  shift++;
+
+               dp--;
+            }
+            break;
+         }
+
+         case 2:
+         {
+
+            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);
+            png_bytep dp = row + (png_size_t)row_width - 1;
+            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
+            for (i = 0; i < row_width; i++)
+            {
+               *dp = (png_byte)((*sp >> shift) & 0x03);
+
+               if (shift == 6)
+               {
+                  shift = 0;
+                  sp--;
+               }
+
+               else
+                  shift += 2;
+
+               dp--;
+            }
+            break;
+         }
+
+         case 4:
+         {
+            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
+            png_bytep dp = row + (png_size_t)row_width - 1;
+            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
+            for (i = 0; i < row_width; i++)
+            {
+               *dp = (png_byte)((*sp >> shift) & 0x0f);
+
+               if (shift == 4)
+               {
+                  shift = 0;
+                  sp--;
+               }
+
+               else
+                  shift = 4;
+
+               dp--;
+            }
+            break;
+         }
+
+         default:
+            break;
+      }
+      row_info->bit_depth = 8;
+      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
+      row_info->rowbytes = row_width * row_info->channels;
+   }
+}
+#endif
+
+#ifdef PNG_READ_SHIFT_SUPPORTED
+/* Reverse the effects of png_do_shift.  This routine merely shifts the
+ * pixels back to their significant bits values.  Thus, if you have
+ * a row of bit depth 8, but only 5 are significant, this will shift
+ * the values back to 0 through 31.
+ */
+void /* PRIVATE */
+png_do_unshift(png_row_infop row_info, png_bytep row,
+    png_const_color_8p sig_bits)
+{
+   int color_type;
+
+   png_debug(1, "in png_do_unshift");
+
+   /* The palette case has already been handled in the _init routine. */
+   color_type = row_info->color_type;
+
+   if (color_type != PNG_COLOR_TYPE_PALETTE)
+   {
+      int shift[4];
+      int channels = 0;
+      int bit_depth = row_info->bit_depth;
+
+      if (color_type & PNG_COLOR_MASK_COLOR)
+      {
+         shift[channels++] = bit_depth - sig_bits->red;
+         shift[channels++] = bit_depth - sig_bits->green;
+         shift[channels++] = bit_depth - sig_bits->blue;
+      }
+
+      else
+      {
+         shift[channels++] = bit_depth - sig_bits->gray;
+      }
+
+      if (color_type & PNG_COLOR_MASK_ALPHA)
+      {
+         shift[channels++] = bit_depth - sig_bits->alpha;
+      }
+
+      {
+         int c, have_shift;
+
+         for (c = have_shift = 0; c < channels; ++c)
+         {
+            /* A shift of more than the bit depth is an error condition but it
+             * gets ignored here.
+             */
+            if (shift[c] <= 0 || shift[c] >= bit_depth)
+               shift[c] = 0;
+
+            else
+               have_shift = 1;
+         }
+
+         if (!have_shift)
+            return;
+      }
+
+      switch (bit_depth)
+      {
+         default:
+         /* Must be 1bpp gray: should not be here! */
+            /* NOTREACHED */
+            break;
+
+         case 2:
+         /* Must be 2bpp gray */
+         /* assert(channels == 1 && shift[0] == 1) */
+         {
+            png_bytep bp = row;
+            png_bytep bp_end = bp + row_info->rowbytes;
+
+            while (bp < bp_end)
+            {
+               int b = (*bp >> 1) & 0x55;
+               *bp++ = (png_byte)b;
+            }
+            break;
+         }
+
+         case 4:
+         /* Must be 4bpp gray */
+         /* assert(channels == 1) */
+         {
+            png_bytep bp = row;
+            png_bytep bp_end = bp + row_info->rowbytes;
+            int gray_shift = shift[0];
+            int mask =  0xf >> gray_shift;
+
+            mask |= mask << 4;
+
+            while (bp < bp_end)
+            {
+               int b = (*bp >> gray_shift) & mask;
+               *bp++ = (png_byte)b;
+            }
+            break;
+         }
+
+         case 8:
+         /* Single byte components, G, GA, RGB, RGBA */
+         {
+            png_bytep bp = row;
+            png_bytep bp_end = bp + row_info->rowbytes;
+            int channel = 0;
+
+            while (bp < bp_end)
+            {
+               int b = *bp >> shift[channel];
+               if (++channel >= channels)
+                  channel = 0;
+               *bp++ = (png_byte)b;
+            }
+            break;
+         }
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+         case 16:
+         /* Double byte components, G, GA, RGB, RGBA */
+         {
+            png_bytep bp = row;
+            png_bytep bp_end = bp + row_info->rowbytes;
+            int channel = 0;
+
+            while (bp < bp_end)
+            {
+               int value = (bp[0] << 8) + bp[1];
+
+               value >>= shift[channel];
+               if (++channel >= channels)
+                  channel = 0;
+               *bp++ = (png_byte)(value >> 8);
+               *bp++ = (png_byte)(value & 0xff);
+            }
+            break;
+         }
+#endif
+      }
+   }
+}
+#endif
+
+#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
+/* Scale rows of bit depth 16 down to 8 accurately */
+void /* PRIVATE */
+png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_scale_16_to_8");
+
+   if (row_info->bit_depth == 16)
+   {
+      png_bytep sp = row; /* source */
+      png_bytep dp = row; /* destination */
+      png_bytep ep = sp + row_info->rowbytes; /* end+1 */
+
+      while (sp < ep)
+      {
+         /* The input is an array of 16 bit components, these must be scaled to
+          * 8 bits each.  For a 16 bit value V the required value (from the PNG
+          * specification) is:
+          *
+          *    (V * 255) / 65535
+          *
+          * This reduces to round(V / 257), or floor((V + 128.5)/257)
+          *
+          * Represent V as the two byte value vhi.vlo.  Make a guess that the
+          * result is the top byte of V, vhi, then the correction to this value
+          * is:
+          *
+          *    error = floor(((V-vhi.vhi) + 128.5) / 257)
+          *          = floor(((vlo-vhi) + 128.5) / 257)
+          *
+          * This can be approximated using integer arithmetic (and a signed
+          * shift):
+          *
+          *    error = (vlo-vhi+128) >> 8;
+          *
+          * The approximate differs from the exact answer only when (vlo-vhi) is
+          * 128; it then gives a correction of +1 when the exact correction is
+          * 0.  This gives 128 errors.  The exact answer (correct for all 16 bit
+          * input values) is:
+          *
+          *    error = (vlo-vhi+128)*65535 >> 24;
+          *
+          * An alternative arithmetic calculation which also gives no errors is:
+          *
+          *    (V * 255 + 32895) >> 16
+          */
+
+         png_int_32 tmp = *sp++; /* must be signed! */
+         tmp += (((int)*sp++ - tmp + 128) * 65535) >> 24;
+         *dp++ = (png_byte)tmp;
+      }
+
+      row_info->bit_depth = 8;
+      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
+      row_info->rowbytes = row_info->width * row_info->channels;
+   }
+}
+#endif
+
+#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
+void /* PRIVATE */
+/* Simply discard the low byte.  This was the default behavior prior
+ * to libpng-1.5.4.
+ */
+png_do_chop(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_chop");
+
+   if (row_info->bit_depth == 16)
+   {
+      png_bytep sp = row; /* source */
+      png_bytep dp = row; /* destination */
+      png_bytep ep = sp + row_info->rowbytes; /* end+1 */
+
+      while (sp < ep)
+      {
+         *dp++ = *sp;
+         sp += 2; /* skip low byte */
+      }
+
+      row_info->bit_depth = 8;
+      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
+      row_info->rowbytes = row_info->width * row_info->channels;
+   }
+}
+#endif
+
+#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
+void /* PRIVATE */
+png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_read_swap_alpha");
+
+   {
+      png_uint_32 row_width = row_info->width;
+      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+      {
+         /* This converts from RGBA to ARGB */
+         if (row_info->bit_depth == 8)
+         {
+            png_bytep sp = row + row_info->rowbytes;
+            png_bytep dp = sp;
+            png_byte save;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               save = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = save;
+            }
+         }
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+         /* This converts from RRGGBBAA to AARRGGBB */
+         else
+         {
+            png_bytep sp = row + row_info->rowbytes;
+            png_bytep dp = sp;
+            png_byte save[2];
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               save[0] = *(--sp);
+               save[1] = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = save[0];
+               *(--dp) = save[1];
+            }
+         }
+#endif
+      }
+
+      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+      {
+         /* This converts from GA to AG */
+         if (row_info->bit_depth == 8)
+         {
+            png_bytep sp = row + row_info->rowbytes;
+            png_bytep dp = sp;
+            png_byte save;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               save = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = save;
+            }
+         }
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+         /* This converts from GGAA to AAGG */
+         else
+         {
+            png_bytep sp = row + row_info->rowbytes;
+            png_bytep dp = sp;
+            png_byte save[2];
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               save[0] = *(--sp);
+               save[1] = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = save[0];
+               *(--dp) = save[1];
+            }
+         }
+#endif
+      }
+   }
+}
+#endif
+
+#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
+void /* PRIVATE */
+png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
+{
+   png_uint_32 row_width;
+   png_debug(1, "in png_do_read_invert_alpha");
+
+   row_width = row_info->width;
+   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         /* This inverts the alpha channel in RGBA */
+         png_bytep sp = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_uint_32 i;
+
+         for (i = 0; i < row_width; i++)
+         {
+            *(--dp) = (png_byte)(255 - *(--sp));
+
+/*          This does nothing:
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            We can replace it with:
+*/
+            sp-=3;
+            dp=sp;
+         }
+      }
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+      /* This inverts the alpha channel in RRGGBBAA */
+      else
+      {
+         png_bytep sp = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_uint_32 i;
+
+         for (i = 0; i < row_width; i++)
+         {
+            *(--dp) = (png_byte)(255 - *(--sp));
+            *(--dp) = (png_byte)(255 - *(--sp));
+
+/*          This does nothing:
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            We can replace it with:
+*/
+            sp-=6;
+            dp=sp;
+         }
+      }
+#endif
+   }
+   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         /* This inverts the alpha channel in GA */
+         png_bytep sp = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_uint_32 i;
+
+         for (i = 0; i < row_width; i++)
+         {
+            *(--dp) = (png_byte)(255 - *(--sp));
+            *(--dp) = *(--sp);
+         }
+      }
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+      else
+      {
+         /* This inverts the alpha channel in GGAA */
+         png_bytep sp  = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_uint_32 i;
+
+         for (i = 0; i < row_width; i++)
+         {
+            *(--dp) = (png_byte)(255 - *(--sp));
+            *(--dp) = (png_byte)(255 - *(--sp));
+/*
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+*/
+            sp-=2;
+            dp=sp;
+         }
+      }
+#endif
+   }
+}
+#endif
+
+#ifdef PNG_READ_FILLER_SUPPORTED
+/* Add filler channel if we have RGB color */
+void /* PRIVATE */
+png_do_read_filler(png_row_infop row_info, png_bytep row,
+    png_uint_32 filler, png_uint_32 flags)
+{
+   png_uint_32 i;
+   png_uint_32 row_width = row_info->width;
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+   png_byte hi_filler = (png_byte)((filler>>8) & 0xff);
+#endif
+   png_byte lo_filler = (png_byte)(filler & 0xff);
+
+   png_debug(1, "in png_do_read_filler");
+
+   if (
+       row_info->color_type == PNG_COLOR_TYPE_GRAY)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         if (flags & PNG_FLAG_FILLER_AFTER)
+         {
+            /* This changes the data from G to GX */
+            png_bytep sp = row + (png_size_t)row_width;
+            png_bytep dp =  sp + (png_size_t)row_width;
+            for (i = 1; i < row_width; i++)
+            {
+               *(--dp) = lo_filler;
+               *(--dp) = *(--sp);
+            }
+            *(--dp) = lo_filler;
+            row_info->channels = 2;
+            row_info->pixel_depth = 16;
+            row_info->rowbytes = row_width * 2;
+         }
+
+         else
+         {
+            /* This changes the data from G to XG */
+            png_bytep sp = row + (png_size_t)row_width;
+            png_bytep dp = sp  + (png_size_t)row_width;
+            for (i = 0; i < row_width; i++)
+            {
+               *(--dp) = *(--sp);
+               *(--dp) = lo_filler;
+            }
+            row_info->channels = 2;
+            row_info->pixel_depth = 16;
+            row_info->rowbytes = row_width * 2;
+         }
+      }
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+      else if (row_info->bit_depth == 16)
+      {
+         if (flags & PNG_FLAG_FILLER_AFTER)
+         {
+            /* This changes the data from GG to GGXX */
+            png_bytep sp = row + (png_size_t)row_width * 2;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            for (i = 1; i < row_width; i++)
+            {
+               *(--dp) = hi_filler;
+               *(--dp) = lo_filler;
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+            }
+            *(--dp) = hi_filler;
+            *(--dp) = lo_filler;
+            row_info->channels = 2;
+            row_info->pixel_depth = 32;
+            row_info->rowbytes = row_width * 4;
+         }
+
+         else
+         {
+            /* This changes the data from GG to XXGG */
+            png_bytep sp = row + (png_size_t)row_width * 2;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            for (i = 0; i < row_width; i++)
+            {
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = hi_filler;
+               *(--dp) = lo_filler;
+            }
+            row_info->channels = 2;
+            row_info->pixel_depth = 32;
+            row_info->rowbytes = row_width * 4;
+         }
+      }
+#endif
+   } /* COLOR_TYPE == GRAY */
+   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         if (flags & PNG_FLAG_FILLER_AFTER)
+         {
+            /* This changes the data from RGB to RGBX */
+            png_bytep sp = row + (png_size_t)row_width * 3;
+            png_bytep dp = sp  + (png_size_t)row_width;
+            for (i = 1; i < row_width; i++)
+            {
+               *(--dp) = lo_filler;
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+            }
+            *(--dp) = lo_filler;
+            row_info->channels = 4;
+            row_info->pixel_depth = 32;
+            row_info->rowbytes = row_width * 4;
+         }
+
+         else
+         {
+            /* This changes the data from RGB to XRGB */
+            png_bytep sp = row + (png_size_t)row_width * 3;
+            png_bytep dp = sp + (png_size_t)row_width;
+            for (i = 0; i < row_width; i++)
+            {
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = lo_filler;
+            }
+            row_info->channels = 4;
+            row_info->pixel_depth = 32;
+            row_info->rowbytes = row_width * 4;
+         }
+      }
+
+#ifdef PNG_READ_16BIT_SUPPORTED
+      else if (row_info->bit_depth == 16)
+      {
+         if (flags & PNG_FLAG_FILLER_AFTER)
+         {
+            /* This changes the data from RRGGBB to RRGGBBXX */
+            png_bytep sp = row + (png_size_t)row_width * 6;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            for (i = 1; i < row_width; i++)
+            {
+               *(--dp) = hi_filler;
+               *(--dp) = lo_filler;
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+            }
+            *(--dp) = hi_filler;
+            *(--dp) = lo_filler;
+            row_info->channels = 4;
+            row_info->pixel_depth = 64;
+            row_info->rowbytes = row_width * 8;
+         }
+
+         else
+         {
+            /* This changes the data from RRGGBB to XXRRGGBB */
+            png_bytep sp = row + (png_size_t)row_width * 6;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            for (i = 0; i < row_width; i++)
+            {
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = *(--sp);
+               *(--dp) = hi_filler;
+               *(--dp) = lo_filler;
+            }
+
+            row_info->channels = 4;
+            row_info->pixel_depth = 64;
+            row_info->rowbytes = row_width * 8;
+         }
+      }
+#endif
+   } /* COLOR_TYPE == RGB */
+}
+#endif
+
+#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
+/* Expand grayscale files to RGB, with or without alpha */
+void /* PRIVATE */
+png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
+{
+   png_uint_32 i;
+   png_uint_32 row_width = row_info->width;
+
+   png_debug(1, "in png_do_gray_to_rgb");
+
+   if (row_info->bit_depth >= 8 &&
+       !(row_info->color_type & PNG_COLOR_MASK_COLOR))
+   {
+      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            /* This changes G to RGB */
+            png_bytep sp = row + (png_size_t)row_width - 1;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            for (i = 0; i < row_width; i++)
+            {
+               *(dp--) = *sp;
+               *(dp--) = *sp;
+               *(dp--) = *(sp--);
+            }
+         }
+
+         else
+         {
+            /* This changes GG to RRGGBB */
+            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
+            png_bytep dp = sp  + (png_size_t)row_width * 4;
+            for (i = 0; i < row_width; i++)
+            {
+               *(dp--) = *sp;
+               *(dp--) = *(sp - 1);
+               *(dp--) = *sp;
+               *(dp--) = *(sp - 1);
+               *(dp--) = *(sp--);
+               *(dp--) = *(sp--);
+            }
+         }
+      }
+
+      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            /* This changes GA to RGBA */
+            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            for (i = 0; i < row_width; i++)
+            {
+               *(dp--) = *(sp--);
+               *(dp--) = *sp;
+               *(dp--) = *sp;
+               *(dp--) = *(sp--);
+            }
+         }
+
+         else
+         {
+            /* This changes GGAA to RRGGBBAA */
+            png_bytep sp = row + (png_size_t)row_width * 4 - 1;
+            png_bytep dp = sp  + (png_size_t)row_width * 4;
+            for (i = 0; i < row_width; i++)
+            {
+               *(dp--) = *(sp--);
+               *(dp--) = *(sp--);
+               *(dp--) = *sp;
+               *(dp--) = *(sp - 1);
+               *(dp--) = *sp;
+               *(dp--) = *(sp - 1);
+               *(dp--) = *(sp--);
+               *(dp--) = *(sp--);
+            }
+         }
+      }
+      row_info->channels = (png_byte)(row_info->channels + 2);
+      row_info->color_type |= PNG_COLOR_MASK_COLOR;
+      row_info->pixel_depth = (png_byte)(row_info->channels *
+          row_info->bit_depth);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
+   }
+}
+#endif
+
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+/* Reduce RGB files to grayscale, with or without alpha
+ * using the equation given in Poynton's ColorFAQ of 1998-01-04 at
+ * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but
+ * versions dated 1998 through November 2002 have been archived at
+ * http://web.archive.org/web/20000816232553/http://www.inforamp.net/
+ * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )
+ * Charles Poynton poynton at poynton.com
+ *
+ *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
+ *
+ *  which can be expressed with integers as
+ *
+ *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
+ *
+ * Poynton's current link (as of January 2003 through July 2011):
+ * <http://www.poynton.com/notes/colour_and_gamma/>
+ * has changed the numbers slightly:
+ *
+ *     Y = 0.2126*R + 0.7152*G + 0.0722*B
+ *
+ *  which can be expressed with integers as
+ *
+ *     Y = (6966 * R + 23436 * G + 2366 * B)/32768
+ *
+ *  Historically, however, libpng uses numbers derived from the ITU-R Rec 709
+ *  end point chromaticities and the D65 white point.  Depending on the
+ *  precision used for the D65 white point this produces a variety of different
+ *  numbers, however if the four decimal place value used in ITU-R Rec 709 is
+ *  used (0.3127,0.3290) the Y calculation would be:
+ *
+ *     Y = (6968 * R + 23435 * G + 2366 * B)/32768
+ *
+ *  While this is correct the rounding results in an overflow for white, because
+ *  the sum of the rounded coefficients is 32769, not 32768.  Consequently
+ *  libpng uses, instead, the closest non-overflowing approximation:
+ *
+ *     Y = (6968 * R + 23434 * G + 2366 * B)/32768
+ *
+ *  Starting with libpng-1.5.5, if the image being converted has a cHRM chunk
+ *  (including an sRGB chunk) then the chromaticities are used to calculate the
+ *  coefficients.  See the chunk handling in pngrutil.c for more information.
+ *
+ *  In all cases the calculation is to be done in a linear colorspace.  If no
+ *  gamma information is available to correct the encoding of the original RGB
+ *  values this results in an implicit assumption that the original PNG RGB
+ *  values were linear.
+ *
+ *  Other integer coefficents can be used via png_set_rgb_to_gray().  Because
+ *  the API takes just red and green coefficients the blue coefficient is
+ *  calculated to make the sum 32768.  This will result in different rounding
+ *  to that used above.
+ */
+int /* PRIVATE */
+png_do_rgb_to_gray(png_structp png_ptr, png_row_infop row_info, png_bytep row)
+
+{
+   int rgb_error = 0;
+
+   png_debug(1, "in png_do_rgb_to_gray");
+
+   if (!(row_info->color_type & PNG_COLOR_MASK_PALETTE) &&
+       (row_info->color_type & PNG_COLOR_MASK_COLOR))
+   {
+      PNG_CONST png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
+      PNG_CONST png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
+      PNG_CONST png_uint_32 bc = 32768 - rc - gc;
+      PNG_CONST png_uint_32 row_width = row_info->width;
+      PNG_CONST int have_alpha =
+         (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;
+
+      if (row_info->bit_depth == 8)
+      {
+#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
+         /* Notice that gamma to/from 1 are not necessarily inverses (if
+          * there is an overall gamma correction).  Prior to 1.5.5 this code
+          * checked the linearized values for equality; this doesn't match
+          * the documentation, the original values must be checked.
+          */
+         if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
+         {
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               png_byte red   = *(sp++);
+               png_byte green = *(sp++);
+               png_byte blue  = *(sp++);
+
+               if (red != green || red != blue)
+               {
+                  red = png_ptr->gamma_to_1[red];
+                  green = png_ptr->gamma_to_1[green];
+                  blue = png_ptr->gamma_to_1[blue];
+
+                  rgb_error |= 1;
+                  *(dp++) = png_ptr->gamma_from_1[
+                      (rc*red + gc*green + bc*blue + 16384)>>15];
+               }
+
+               else
+               {
+                  /* If there is no overall correction the table will not be
+                   * set.
+                   */
+                  if (png_ptr->gamma_table != NULL)
+                     red = png_ptr->gamma_table[red];
+
+                  *(dp++) = red;
+               }
+
+               if (have_alpha)
+                  *(dp++) = *(sp++);
+            }
+         }
+         else
+#endif
+         {
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               png_byte red   = *(sp++);
+               png_byte green = *(sp++);
+               png_byte blue  = *(sp++);
+
+               if (red != green || red != blue)
+               {
+                  rgb_error |= 1;
+                  /* NOTE: this is the historical approach which simply
+                   * truncates the results.
+                   */
+                  *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
+               }
+
+               else
+                  *(dp++) = red;
+
+               if (have_alpha)
+                  *(dp++) = *(sp++);
+            }
+         }
+      }
+
+      else /* RGB bit_depth == 16 */
+      {
+#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
+         if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)
+         {
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               png_uint_16 red, green, blue, w;
+
+               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+
+               if (red == green && red == blue)
+               {
+                  if (png_ptr->gamma_16_table != NULL)
+                     w = png_ptr->gamma_16_table[(red&0xff)
+                         >> png_ptr->gamma_shift][red>>8];
+
+                  else
+                     w = red;
+               }
+
+               else
+               {
+                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)
+                      >> png_ptr->gamma_shift][red>>8];
+                  png_uint_16 green_1 =
+                      png_ptr->gamma_16_to_1[(green&0xff) >>
+                      png_ptr->gamma_shift][green>>8];
+                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)
+                      >> png_ptr->gamma_shift][blue>>8];
+                  png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
+                      + bc*blue_1 + 16384)>>15);
+                  w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
+                      png_ptr->gamma_shift][gray16 >> 8];
+                  rgb_error |= 1;
+               }
+
+               *(dp++) = (png_byte)((w>>8) & 0xff);
+               *(dp++) = (png_byte)(w & 0xff);
+
+               if (have_alpha)
+               {
+                  *(dp++) = *(sp++);
+                  *(dp++) = *(sp++);
+               }
+            }
+         }
+         else
+#endif
+         {
+            png_bytep sp = row;
+            png_bytep dp = row;
+            png_uint_32 i;
+
+            for (i = 0; i < row_width; i++)
+            {
+               png_uint_16 red, green, blue, gray16;
+
+               red   = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               green = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+               blue  = (png_uint_16)(((*(sp))<<8) | *(sp + 1)); sp += 2;
+
+               if (red != green || red != blue)
+                  rgb_error |= 1;
+
+               /* From 1.5.5 in the 16 bit case do the accurate conversion even
+                * in the 'fast' case - this is because this is where the code
+                * ends up when handling linear 16 bit data.
+                */
+               gray16  = (png_uint_16)((rc*red + gc*green + bc*blue + 16384) >>
+                  15);
+               *(dp++) = (png_byte)((gray16>>8) & 0xff);
+               *(dp++) = (png_byte)(gray16 & 0xff);
+
+               if (have_alpha)
+               {
+                  *(dp++) = *(sp++);
+                  *(dp++) = *(sp++);
+               }
+            }
+         }
+      }
+
+      row_info->channels = (png_byte)(row_info->channels - 2);
+      row_info->color_type = (png_byte)(row_info->color_type &
+          ~PNG_COLOR_MASK_COLOR);
+      row_info->pixel_depth = (png_byte)(row_info->channels *
+          row_info->bit_depth);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
+   }
+   return rgb_error;
+}
+#endif
+#endif /* PNG_READ_TRANSFORMS_SUPPORTED */
+
+#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
+/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
+ * large of png_color.  This lets grayscale images be treated as
+ * paletted.  Most useful for gamma correction and simplification
+ * of code.  This API is not used internally.
+ */
+void PNGAPI
+png_build_grayscale_palette(int bit_depth, png_colorp palette)
+{
+   int num_palette;
+   int color_inc;
+   int i;
+   int v;
+
+   png_debug(1, "in png_do_build_grayscale_palette");
+
+   if (palette == NULL)
+      return;
+
+   switch (bit_depth)
+   {
+      case 1:
+         num_palette = 2;
+         color_inc = 0xff;
+         break;
+
+      case 2:
+         num_palette = 4;
+         color_inc = 0x55;
+         break;
+
+      case 4:
+         num_palette = 16;
+         color_inc = 0x11;
+         break;
+
+      case 8:
+         num_palette = 256;
+         color_inc = 1;
+         break;
+
+      default:
+         num_palette = 0;
+         color_inc = 0;
+         break;
+   }
+
+   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
+   {
+      palette[i].red = (png_byte)v;
+      palette[i].green = (png_byte)v;
+      palette[i].blue = (png_byte)v;
+   }
+}
+#endif
+
+
+#ifdef PNG_READ_TRANSFORMS_SUPPORTED
+#if (defined PNG_READ_BACKGROUND_SUPPORTED) ||\
+   (defined PNG_READ_ALPHA_MODE_SUPPORTED)
+/* Replace any alpha or transparency with the supplied background color.
+ * "background" is already in the screen gamma, while "background_1" is
+ * at a gamma of 1.0.  Paletted files have already been taken care of.
+ */
+void /* PRIVATE */
+png_do_compose(png_row_infop row_info, png_bytep row, png_structp png_ptr)
+{
+#ifdef PNG_READ_GAMMA_SUPPORTED
+   png_const_bytep gamma_table = png_ptr->gamma_table;
+   png_const_bytep gamma_from_1 = png_ptr->gamma_from_1;
+   png_const_bytep gamma_to_1 = png_ptr->gamma_to_1;
+   png_const_uint_16pp gamma_16 = png_ptr->gamma_16_table;
+   png_const_uint_16pp gamma_16_from_1 = png_ptr->gamma_16_from_1;
+   png_const_uint_16pp gamma_16_to_1 = png_ptr->gamma_16_to_1;
+   int gamma_shift = png_ptr->gamma_shift;
+#endif
+
+   png_bytep sp;
+   png_uint_32 i;
+   png_uint_32 row_width = row_info->width;
+   int optimize = (png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0;
+   int shift;
+
+   png_debug(1, "in png_do_compose");
+
+   {
+      switch (row_info->color_type)
+      {
+         case PNG_COLOR_TYPE_GRAY:
+         {
+            switch (row_info->bit_depth)
+            {
+               case 1:
+               {
+                  sp = row;
+                  shift = 7;
+                  for (i = 0; i < row_width; i++)
+                  {
+                     if ((png_uint_16)((*sp >> shift) & 0x01)
+                        == png_ptr->trans_color.gray)
+                     {
+                        *sp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
+                        *sp |= (png_byte)(png_ptr->background.gray << shift);
+                     }
+
+                     if (!shift)
+                     {
+                        shift = 7;
+                        sp++;
+                     }
+
+                     else
+                        shift--;
+                  }
+                  break;
+               }
+
+               case 2:
+               {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+                  if (gamma_table != NULL)
+                  {
+                     sp = row;
+                     shift = 6;
+                     for (i = 0; i < row_width; i++)
+                     {
+                        if ((png_uint_16)((*sp >> shift) & 0x03)
+                            == png_ptr->trans_color.gray)
+                        {
+                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
+                        }
+
+                        else
+                        {
+                           png_byte p = (png_byte)((*sp >> shift) & 0x03);
+                           png_byte g = (png_byte)((gamma_table [p | (p << 2) |
+                               (p << 4) | (p << 6)] >> 6) & 0x03);
+                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
+                           *sp |= (png_byte)(g << shift);
+                        }
+
+                        if (!shift)
+                        {
+                           shift = 6;
+                           sp++;
+                        }
+
+                        else
+                           shift -= 2;
+                     }
+                  }
+
+                  else
+#endif
+                  {
+                     sp = row;
+                     shift = 6;
+                     for (i = 0; i < row_width; i++)
+                     {
+                        if ((png_uint_16)((*sp >> shift) & 0x03)
+                            == png_ptr->trans_color.gray)
+                        {
+                           *sp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
+                        }
+
+                        if (!shift)
+                        {
+                           shift = 6;
+                           sp++;
+                        }
+
+                        else
+                           shift -= 2;
+                     }
+                  }
+                  break;
+               }
+
+               case 4:
+               {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+                  if (gamma_table != NULL)
+                  {
+                     sp = row;
+                     shift = 4;
+                     for (i = 0; i < row_width; i++)
+                     {
+                        if ((png_uint_16)((*sp >> shift) & 0x0f)
+                            == png_ptr->trans_color.gray)
+                        {
+                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
+                        }
+
+                        else
+                        {
+                           png_byte p = (png_byte)((*sp >> shift) & 0x0f);
+                           png_byte g = (png_byte)((gamma_table[p |
+                               (p << 4)] >> 4) & 0x0f);
+                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
+                           *sp |= (png_byte)(g << shift);
+                        }
+
+                        if (!shift)
+                        {
+                           shift = 4;
+                           sp++;
+                        }
+
+                        else
+                           shift -= 4;
+                     }
+                  }
+
+                  else
+#endif
+                  {
+                     sp = row;
+                     shift = 4;
+                     for (i = 0; i < row_width; i++)
+                     {
+                        if ((png_uint_16)((*sp >> shift) & 0x0f)
+                            == png_ptr->trans_color.gray)
+                        {
+                           *sp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
+                           *sp |= (png_byte)(png_ptr->background.gray << shift);
+                        }
+
+                        if (!shift)
+                        {
+                           shift = 4;
+                           sp++;
+                        }
+
+                        else
+                           shift -= 4;
+                     }
+                  }
+                  break;
+               }
+
+               case 8:
+               {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+                  if (gamma_table != NULL)
+                  {
+                     sp = row;
+                     for (i = 0; i < row_width; i++, sp++)
+                     {
+                        if (*sp == png_ptr->trans_color.gray)
+                           *sp = (png_byte)png_ptr->background.gray;
+
+                        else
+                           *sp = gamma_table[*sp];
+                     }
+                  }
+                  else
+#endif
+                  {
+                     sp = row;
+                     for (i = 0; i < row_width; i++, sp++)
+                     {
+                        if (*sp == png_ptr->trans_color.gray)
+                           *sp = (png_byte)png_ptr->background.gray;
+                     }
+                  }
+                  break;
+               }
+
+               case 16:
+               {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+                  if (gamma_16 != NULL)
+                  {
+                     sp = row;
+                     for (i = 0; i < row_width; i++, sp += 2)
+                     {
+                        png_uint_16 v;
+
+                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+
+                        if (v == png_ptr->trans_color.gray)
+                        {
+                           /* Background is already in screen gamma */
+                           *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                           *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
+                        }
+
+                        else
+                        {
+                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                           *sp = (png_byte)((v >> 8) & 0xff);
+                           *(sp + 1) = (png_byte)(v & 0xff);
+                        }
+                     }
+                  }
+                  else
+#endif
+                  {
+                     sp = row;
+                     for (i = 0; i < row_width; i++, sp += 2)
+                     {
+                        png_uint_16 v;
+
+                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+
+                        if (v == png_ptr->trans_color.gray)
+                        {
+                           *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                           *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
+                        }
+                     }
+                  }
+                  break;
+               }
+
+               default:
+                  break;
+            }
+            break;
+         }
+
+         case PNG_COLOR_TYPE_RGB:
+         {
+            if (row_info->bit_depth == 8)
+            {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+               if (gamma_table != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 3)
+                  {
+                     if (*sp == png_ptr->trans_color.red &&
+                         *(sp + 1) == png_ptr->trans_color.green &&
+                         *(sp + 2) == png_ptr->trans_color.blue)
+                     {
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
+                     }
+
+                     else
+                     {
+                        *sp = gamma_table[*sp];
+                        *(sp + 1) = gamma_table[*(sp + 1)];
+                        *(sp + 2) = gamma_table[*(sp + 2)];
+                     }
+                  }
+               }
+               else
+#endif
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 3)
+                  {
+                     if (*sp == png_ptr->trans_color.red &&
+                         *(sp + 1) == png_ptr->trans_color.green &&
+                         *(sp + 2) == png_ptr->trans_color.blue)
+                     {
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
+                     }
+                  }
+               }
+            }
+            else /* if (row_info->bit_depth == 16) */
+            {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+               if (gamma_16 != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 6)
+                  {
+                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+
+                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
+                         + *(sp + 3));
+
+                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
+                         + *(sp + 5));
+
+                     if (r == png_ptr->trans_color.red &&
+                         g == png_ptr->trans_color.green &&
+                         b == png_ptr->trans_color.blue)
+                     {
+                        /* Background is already in screen gamma */
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                     }
+
+                     else
+                     {
+                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
+
+                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
+                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(v & 0xff);
+
+                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
+                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(v & 0xff);
+                     }
+                  }
+               }
+
+               else
+#endif
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 6)
+                  {
+                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+
+                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
+                         + *(sp + 3));
+
+                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
+                         + *(sp + 5));
+
+                     if (r == png_ptr->trans_color.red &&
+                         g == png_ptr->trans_color.green &&
+                         b == png_ptr->trans_color.blue)
+                     {
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                     }
+                  }
+               }
+            }
+            break;
+         }
+
+         case PNG_COLOR_TYPE_GRAY_ALPHA:
+         {
+            if (row_info->bit_depth == 8)
+            {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
+                   gamma_table != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 2)
+                  {
+                     png_uint_16 a = *(sp + 1);
+
+                     if (a == 0xff)
+                        *sp = gamma_table[*sp];
+
+                     else if (a == 0)
+                     {
+                        /* Background is already in screen gamma */
+                        *sp = (png_byte)png_ptr->background.gray;
+                     }
+
+                     else
+                     {
+                        png_byte v, w;
+
+                        v = gamma_to_1[*sp];
+                        png_composite(w, v, a, png_ptr->background_1.gray);
+                        if (!optimize)
+                           w = gamma_from_1[w];
+                        *sp = w;
+                     }
+                  }
+               }
+               else
+#endif
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 2)
+                  {
+                     png_byte a = *(sp + 1);
+
+                     if (a == 0)
+                        *sp = (png_byte)png_ptr->background.gray;
+
+                     else if (a < 0xff)
+                        png_composite(*sp, *sp, a, png_ptr->background_1.gray);
+                  }
+               }
+            }
+            else /* if (png_ptr->bit_depth == 16) */
+            {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
+                   gamma_16_to_1 != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 4)
+                  {
+                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
+                         + *(sp + 3));
+
+                     if (a == (png_uint_16)0xffff)
+                     {
+                        png_uint_16 v;
+
+                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
+                     }
+
+                     else if (a == 0)
+                     {
+                        /* Background is already in screen gamma */
+                        *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
+                     }
+
+                     else
+                     {
+                        png_uint_16 g, v, w;
+
+                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
+                        png_composite_16(v, g, a, png_ptr->background_1.gray);
+                        if (optimize)
+                           w = v;
+                        else
+                           w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
+                        *sp = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(w & 0xff);
+                     }
+                  }
+               }
+               else
+#endif
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 4)
+                  {
+                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
+                         + *(sp + 3));
+
+                     if (a == 0)
+                     {
+                        *sp = (png_byte)((png_ptr->background.gray >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
+                     }
+
+                     else if (a < 0xffff)
+                     {
+                        png_uint_16 g, v;
+
+                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+                        png_composite_16(v, g, a, png_ptr->background_1.gray);
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
+                     }
+                  }
+               }
+            }
+            break;
+         }
+
+         case PNG_COLOR_TYPE_RGB_ALPHA:
+         {
+            if (row_info->bit_depth == 8)
+            {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
+                   gamma_table != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 4)
+                  {
+                     png_byte a = *(sp + 3);
+
+                     if (a == 0xff)
+                     {
+                        *sp = gamma_table[*sp];
+                        *(sp + 1) = gamma_table[*(sp + 1)];
+                        *(sp + 2) = gamma_table[*(sp + 2)];
+                     }
+
+                     else if (a == 0)
+                     {
+                        /* Background is already in screen gamma */
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
+                     }
+
+                     else
+                     {
+                        png_byte v, w;
+
+                        v = gamma_to_1[*sp];
+                        png_composite(w, v, a, png_ptr->background_1.red);
+                        if (!optimize) w = gamma_from_1[w];
+                        *sp = w;
+
+                        v = gamma_to_1[*(sp + 1)];
+                        png_composite(w, v, a, png_ptr->background_1.green);
+                        if (!optimize) w = gamma_from_1[w];
+                        *(sp + 1) = w;
+
+                        v = gamma_to_1[*(sp + 2)];
+                        png_composite(w, v, a, png_ptr->background_1.blue);
+                        if (!optimize) w = gamma_from_1[w];
+                        *(sp + 2) = w;
+                     }
+                  }
+               }
+               else
+#endif
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 4)
+                  {
+                     png_byte a = *(sp + 3);
+
+                     if (a == 0)
+                     {
+                        *sp = (png_byte)png_ptr->background.red;
+                        *(sp + 1) = (png_byte)png_ptr->background.green;
+                        *(sp + 2) = (png_byte)png_ptr->background.blue;
+                     }
+
+                     else if (a < 0xff)
+                     {
+                        png_composite(*sp, *sp, a, png_ptr->background.red);
+
+                        png_composite(*(sp + 1), *(sp + 1), a,
+                            png_ptr->background.green);
+
+                        png_composite(*(sp + 2), *(sp + 2), a,
+                            png_ptr->background.blue);
+                     }
+                  }
+               }
+            }
+            else /* if (row_info->bit_depth == 16) */
+            {
+#ifdef PNG_READ_GAMMA_SUPPORTED
+               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
+                   gamma_16_to_1 != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 8)
+                  {
+                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
+                         << 8) + (png_uint_16)(*(sp + 7)));
+
+                     if (a == (png_uint_16)0xffff)
+                     {
+                        png_uint_16 v;
+
+                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
+
+                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
+                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(v & 0xff);
+
+                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
+                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(v & 0xff);
+                     }
+
+                     else if (a == 0)
+                     {
+                        /* Background is already in screen gamma */
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                     }
+
+                     else
+                     {
+                        png_uint_16 v, w;
+
+                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
+                        png_composite_16(w, v, a, png_ptr->background_1.red);
+                        if (!optimize)
+                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
+                        *sp = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(w & 0xff);
+
+                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
+                        png_composite_16(w, v, a, png_ptr->background_1.green);
+                        if (!optimize)
+                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
+
+                        *(sp + 2) = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(w & 0xff);
+
+                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
+                        png_composite_16(w, v, a, png_ptr->background_1.blue);
+                        if (!optimize)
+                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >> 8];
+
+                        *(sp + 4) = (png_byte)((w >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(w & 0xff);
+                     }
+                  }
+               }
+
+               else
+#endif
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 8)
+                  {
+                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
+                         << 8) + (png_uint_16)(*(sp + 7)));
+
+                     if (a == 0)
+                     {
+                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(png_ptr->background.green & 0xff);
+                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                     }
+
+                     else if (a < 0xffff)
+                     {
+                        png_uint_16 v;
+
+                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
+                            + *(sp + 3));
+                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
+                            + *(sp + 5));
+
+                        png_composite_16(v, r, a, png_ptr->background.red);
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
+
+                        png_composite_16(v, g, a, png_ptr->background.green);
+                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 3) = (png_byte)(v & 0xff);
+
+                        png_composite_16(v, b, a, png_ptr->background.blue);
+                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 5) = (png_byte)(v & 0xff);
+                     }
+                  }
+               }
+            }
+            break;
+         }
+
+         default:
+            break;
+      }
+   }
+}
+#endif /* PNG_READ_BACKGROUND_SUPPORTED || PNG_READ_ALPHA_MODE_SUPPORTED */
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+/* Gamma correct the image, avoiding the alpha channel.  Make sure
+ * you do this after you deal with the transparency issue on grayscale
+ * or RGB images. If your bit depth is 8, use gamma_table, if it
+ * is 16, use gamma_16_table and gamma_shift.  Build these with
+ * build_gamma_table().
+ */
+void /* PRIVATE */
+png_do_gamma(png_row_infop row_info, png_bytep row, png_structp png_ptr)
+{
+   png_const_bytep gamma_table = png_ptr->gamma_table;
+   png_const_uint_16pp gamma_16_table = png_ptr->gamma_16_table;
+   int gamma_shift = png_ptr->gamma_shift;
+
+   png_bytep sp;
+   png_uint_32 i;
+   png_uint_32 row_width=row_info->width;
+
+   png_debug(1, "in png_do_gamma");
+
+   if (((row_info->bit_depth <= 8 && gamma_table != NULL) ||
+       (row_info->bit_depth == 16 && gamma_16_table != NULL)))
+   {
+      switch (row_info->color_type)
+      {
+         case PNG_COLOR_TYPE_RGB:
+         {
+            if (row_info->bit_depth == 8)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  *sp = gamma_table[*sp];
+                  sp++;
+                  *sp = gamma_table[*sp];
+                  sp++;
+                  *sp = gamma_table[*sp];
+                  sp++;
+               }
+            }
+
+            else /* if (row_info->bit_depth == 16) */
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  png_uint_16 v;
+
+                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 2;
+
+                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 2;
+
+                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 2;
+               }
+            }
+            break;
+         }
+
+         case PNG_COLOR_TYPE_RGB_ALPHA:
+         {
+            if (row_info->bit_depth == 8)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  *sp = gamma_table[*sp];
+                  sp++;
+
+                  *sp = gamma_table[*sp];
+                  sp++;
+
+                  *sp = gamma_table[*sp];
+                  sp++;
+
+                  sp++;
+               }
+            }
+
+            else /* if (row_info->bit_depth == 16) */
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 2;
+
+                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 2;
+
+                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 4;
+               }
+            }
+            break;
+         }
+
+         case PNG_COLOR_TYPE_GRAY_ALPHA:
+         {
+            if (row_info->bit_depth == 8)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  *sp = gamma_table[*sp];
+                  sp += 2;
+               }
+            }
+
+            else /* if (row_info->bit_depth == 16) */
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 4;
+               }
+            }
+            break;
+         }
+
+         case PNG_COLOR_TYPE_GRAY:
+         {
+            if (row_info->bit_depth == 2)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i += 4)
+               {
+                  int a = *sp & 0xc0;
+                  int b = *sp & 0x30;
+                  int c = *sp & 0x0c;
+                  int d = *sp & 0x03;
+
+                  *sp = (png_byte)(
+                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
+                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
+                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
+                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
+                  sp++;
+               }
+            }
+
+            if (row_info->bit_depth == 4)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i += 2)
+               {
+                  int msb = *sp & 0xf0;
+                  int lsb = *sp & 0x0f;
+
+                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
+                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
+                  sp++;
+               }
+            }
+
+            else if (row_info->bit_depth == 8)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  *sp = gamma_table[*sp];
+                  sp++;
+               }
+            }
+
+            else if (row_info->bit_depth == 16)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++)
+               {
+                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
+                  *sp = (png_byte)((v >> 8) & 0xff);
+                  *(sp + 1) = (png_byte)(v & 0xff);
+                  sp += 2;
+               }
+            }
+            break;
+         }
+
+         default:
+            break;
+      }
+   }
+}
+#endif
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+/* Encode the alpha channel to the output gamma (the input channel is always
+ * linear.)  Called only with color types that have an alpha channel.  Needs the
+ * from_1 tables.
+ */
+void /* PRIVATE */
+png_do_encode_alpha(png_row_infop row_info, png_bytep row, png_structp png_ptr)
+{
+   png_uint_32 row_width = row_info->width;
+
+   png_debug(1, "in png_do_encode_alpha");
+
+   if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         PNG_CONST png_bytep table = png_ptr->gamma_from_1;
+
+         if (table != NULL)
+         {
+            PNG_CONST int step =
+               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;
+
+            /* The alpha channel is the last component: */
+            row += step - 1;
+
+            for (; row_width > 0; --row_width, row += step)
+               *row = table[*row];
+
+            return;
+         }
+      }
+
+      else if (row_info->bit_depth == 16)
+      {
+         PNG_CONST png_uint_16pp table = png_ptr->gamma_16_from_1;
+         PNG_CONST int gamma_shift = png_ptr->gamma_shift;
+
+         if (table != NULL)
+         {
+            PNG_CONST int step =
+               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;
+
+            /* The alpha channel is the last component: */
+            row += step - 2;
+
+            for (; row_width > 0; --row_width, row += step)
+            {
+               png_uint_16 v;
+
+               v = table[*(row + 1) >> gamma_shift][*row];
+               *row = (png_byte)((v >> 8) & 0xff);
+               *(row + 1) = (png_byte)(v & 0xff);
+            }
+
+            return;
+         }
+      }
+   }
+
+   /* Only get to here if called with a weird row_info; no harm has been done,
+    * so just issue a warning.
+    */
+   png_warning(png_ptr, "png_do_encode_alpha: unexpected call");
+}
+#endif
+
+#ifdef PNG_READ_EXPAND_SUPPORTED
+/* Expands a palette row to an RGB or RGBA row depending
+ * upon whether you supply trans and num_trans.
+ */
+void /* PRIVATE */
+png_do_expand_palette(png_row_infop row_info, png_bytep row,
+   png_const_colorp palette, png_const_bytep trans_alpha, int num_trans)
+{
+   int shift, value;
+   png_bytep sp, dp;
+   png_uint_32 i;
+   png_uint_32 row_width=row_info->width;
+
+   png_debug(1, "in png_do_expand_palette");
+
+   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
+   {
+      if (row_info->bit_depth < 8)
+      {
+         switch (row_info->bit_depth)
+         {
+            case 1:
+            {
+               sp = row + (png_size_t)((row_width - 1) >> 3);
+               dp = row + (png_size_t)row_width - 1;
+               shift = 7 - (int)((row_width + 7) & 0x07);
+               for (i = 0; i < row_width; i++)
+               {
+                  if ((*sp >> shift) & 0x01)
+                     *dp = 1;
+
+                  else
+                     *dp = 0;
+
+                  if (shift == 7)
+                  {
+                     shift = 0;
+                     sp--;
+                  }
+
+                  else
+                     shift++;
+
+                  dp--;
+               }
+               break;
+            }
+
+            case 2:
+            {
+               sp = row + (png_size_t)((row_width - 1) >> 2);
+               dp = row + (png_size_t)row_width - 1;
+               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
+               for (i = 0; i < row_width; i++)
+               {
+                  value = (*sp >> shift) & 0x03;
+                  *dp = (png_byte)value;
+                  if (shift == 6)
+                  {
+                     shift = 0;
+                     sp--;
+                  }
+
+                  else
+                     shift += 2;
+
+                  dp--;
+               }
+               break;
+            }
+
+            case 4:
+            {
+               sp = row + (png_size_t)((row_width - 1) >> 1);
+               dp = row + (png_size_t)row_width - 1;
+               shift = (int)((row_width & 0x01) << 2);
+               for (i = 0; i < row_width; i++)
+               {
+                  value = (*sp >> shift) & 0x0f;
+                  *dp = (png_byte)value;
+                  if (shift == 4)
+                  {
+                     shift = 0;
+                     sp--;
+                  }
+
+                  else
+                     shift += 4;
+
+                  dp--;
+               }
+               break;
+            }
+
+            default:
+               break;
+         }
+         row_info->bit_depth = 8;
+         row_info->pixel_depth = 8;
+         row_info->rowbytes = row_width;
+      }
+
+      if (row_info->bit_depth == 8)
+      {
+         {
+            if (num_trans > 0)
+            {
+               sp = row + (png_size_t)row_width - 1;
+               dp = row + (png_size_t)(row_width << 2) - 1;
+
+               for (i = 0; i < row_width; i++)
+               {
+                  if ((int)(*sp) >= num_trans)
+                     *dp-- = 0xff;
+
+                  else
+                     *dp-- = trans_alpha[*sp];
+
+                  *dp-- = palette[*sp].blue;
+                  *dp-- = palette[*sp].green;
+                  *dp-- = palette[*sp].red;
+                  sp--;
+               }
+               row_info->bit_depth = 8;
+               row_info->pixel_depth = 32;
+               row_info->rowbytes = row_width * 4;
+               row_info->color_type = 6;
+               row_info->channels = 4;
+            }
+
+            else
+            {
+               sp = row + (png_size_t)row_width - 1;
+               dp = row + (png_size_t)(row_width * 3) - 1;
+
+               for (i = 0; i < row_width; i++)
+               {
+                  *dp-- = palette[*sp].blue;
+                  *dp-- = palette[*sp].green;
+                  *dp-- = palette[*sp].red;
+                  sp--;
+               }
+
+               row_info->bit_depth = 8;
+               row_info->pixel_depth = 24;
+               row_info->rowbytes = row_width * 3;
+               row_info->color_type = 2;
+               row_info->channels = 3;
+            }
+         }
+      }
+   }
+}
+
+/* If the bit depth < 8, it is expanded to 8.  Also, if the already
+ * expanded transparency value is supplied, an alpha channel is built.
+ */
+void /* PRIVATE */
+png_do_expand(png_row_infop row_info, png_bytep row,
+    png_const_color_16p trans_color)
+{
+   int shift, value;
+   png_bytep sp, dp;
+   png_uint_32 i;
+   png_uint_32 row_width=row_info->width;
+
+   png_debug(1, "in png_do_expand");
+
+   {
+      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
+      {
+         png_uint_16 gray = (png_uint_16)(trans_color ? trans_color->gray : 0);
+
+         if (row_info->bit_depth < 8)
+         {
+            switch (row_info->bit_depth)
+            {
+               case 1:
+               {
+                  gray = (png_uint_16)((gray & 0x01) * 0xff);
+                  sp = row + (png_size_t)((row_width - 1) >> 3);
+                  dp = row + (png_size_t)row_width - 1;
+                  shift = 7 - (int)((row_width + 7) & 0x07);
+                  for (i = 0; i < row_width; i++)
+                  {
+                     if ((*sp >> shift) & 0x01)
+                        *dp = 0xff;
+
+                     else
+                        *dp = 0;
+
+                     if (shift == 7)
+                     {
+                        shift = 0;
+                        sp--;
+                     }
+
+                     else
+                        shift++;
+
+                     dp--;
+                  }
+                  break;
+               }
+
+               case 2:
+               {
+                  gray = (png_uint_16)((gray & 0x03) * 0x55);
+                  sp = row + (png_size_t)((row_width - 1) >> 2);
+                  dp = row + (png_size_t)row_width - 1;
+                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
+                  for (i = 0; i < row_width; i++)
+                  {
+                     value = (*sp >> shift) & 0x03;
+                     *dp = (png_byte)(value | (value << 2) | (value << 4) |
+                        (value << 6));
+                     if (shift == 6)
+                     {
+                        shift = 0;
+                        sp--;
+                     }
+
+                     else
+                        shift += 2;
+
+                     dp--;
+                  }
+                  break;
+               }
+
+               case 4:
+               {
+                  gray = (png_uint_16)((gray & 0x0f) * 0x11);
+                  sp = row + (png_size_t)((row_width - 1) >> 1);
+                  dp = row + (png_size_t)row_width - 1;
+                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
+                  for (i = 0; i < row_width; i++)
+                  {
+                     value = (*sp >> shift) & 0x0f;
+                     *dp = (png_byte)(value | (value << 4));
+                     if (shift == 4)
+                     {
+                        shift = 0;
+                        sp--;
+                     }
+
+                     else
+                        shift = 4;
+
+                     dp--;
+                  }
+                  break;
+               }
+
+               default:
+                  break;
+            }
+
+            row_info->bit_depth = 8;
+            row_info->pixel_depth = 8;
+            row_info->rowbytes = row_width;
+         }
+
+         if (trans_color != NULL)
+         {
+            if (row_info->bit_depth == 8)
+            {
+               gray = gray & 0xff;
+               sp = row + (png_size_t)row_width - 1;
+               dp = row + (png_size_t)(row_width << 1) - 1;
+
+               for (i = 0; i < row_width; i++)
+               {
+                  if (*sp == gray)
+                     *dp-- = 0;
+
+                  else
+                     *dp-- = 0xff;
+
+                  *dp-- = *sp--;
+               }
+            }
+
+            else if (row_info->bit_depth == 16)
+            {
+               png_byte gray_high = (png_byte)((gray >> 8) & 0xff);
+               png_byte gray_low = (png_byte)(gray & 0xff);
+               sp = row + row_info->rowbytes - 1;
+               dp = row + (row_info->rowbytes << 1) - 1;
+               for (i = 0; i < row_width; i++)
+               {
+                  if (*(sp - 1) == gray_high && *(sp) == gray_low)
+                  {
+                     *dp-- = 0;
+                     *dp-- = 0;
+                  }
+
+                  else
+                  {
+                     *dp-- = 0xff;
+                     *dp-- = 0xff;
+                  }
+
+                  *dp-- = *sp--;
+                  *dp-- = *sp--;
+               }
+            }
+
+            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
+            row_info->channels = 2;
+            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
+            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
+               row_width);
+         }
+      }
+      else if (row_info->color_type == PNG_COLOR_TYPE_RGB && trans_color)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            png_byte red = (png_byte)(trans_color->red & 0xff);
+            png_byte green = (png_byte)(trans_color->green & 0xff);
+            png_byte blue = (png_byte)(trans_color->blue & 0xff);
+            sp = row + (png_size_t)row_info->rowbytes - 1;
+            dp = row + (png_size_t)(row_width << 2) - 1;
+            for (i = 0; i < row_width; i++)
+            {
+               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
+                  *dp-- = 0;
+
+               else
+                  *dp-- = 0xff;
+
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+            }
+         }
+         else if (row_info->bit_depth == 16)
+         {
+            png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
+            png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
+            png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
+            png_byte red_low = (png_byte)(trans_color->red & 0xff);
+            png_byte green_low = (png_byte)(trans_color->green & 0xff);
+            png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
+            sp = row + row_info->rowbytes - 1;
+            dp = row + (png_size_t)(row_width << 3) - 1;
+            for (i = 0; i < row_width; i++)
+            {
+               if (*(sp - 5) == red_high &&
+                   *(sp - 4) == red_low &&
+                   *(sp - 3) == green_high &&
+                   *(sp - 2) == green_low &&
+                   *(sp - 1) == blue_high &&
+                   *(sp    ) == blue_low)
+               {
+                  *dp-- = 0;
+                  *dp-- = 0;
+               }
+
+               else
+               {
+                  *dp-- = 0xff;
+                  *dp-- = 0xff;
+               }
+
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+            }
+         }
+         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+         row_info->channels = 4;
+         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
+      }
+   }
+}
+#endif
+
+#ifdef PNG_READ_EXPAND_16_SUPPORTED
+/* If the bit depth is 8 and the color type is not a palette type expand the
+ * whole row to 16 bits.  Has no effect otherwise.
+ */
+void /* PRIVATE */
+png_do_expand_16(png_row_infop row_info, png_bytep row)
+{
+   if (row_info->bit_depth == 8 &&
+      row_info->color_type != PNG_COLOR_TYPE_PALETTE)
+   {
+      /* The row have a sequence of bytes containing [0..255] and we need
+       * to turn it into another row containing [0..65535], to do this we
+       * calculate:
+       *
+       *  (input / 255) * 65535
+       *
+       *  Which happens to be exactly input * 257 and this can be achieved
+       *  simply by byte replication in place (copying backwards).
+       */
+      png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */
+      png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */
+      while (dp > sp)
+         dp[-2] = dp[-1] = *--sp, dp -= 2;
+
+      row_info->rowbytes *= 2;
+      row_info->bit_depth = 16;
+      row_info->pixel_depth = (png_byte)(row_info->channels * 16);
+   }
+}
+#endif
+
+#ifdef PNG_READ_QUANTIZE_SUPPORTED
+void /* PRIVATE */
+png_do_quantize(png_row_infop row_info, png_bytep row,
+    png_const_bytep palette_lookup, png_const_bytep quantize_lookup)
+{
+   png_bytep sp, dp;
+   png_uint_32 i;
+   png_uint_32 row_width=row_info->width;
+
+   png_debug(1, "in png_do_quantize");
+
+   if (row_info->bit_depth == 8)
+   {
+      if (row_info->color_type == PNG_COLOR_TYPE_RGB && palette_lookup)
+      {
+         int r, g, b, p;
+         sp = row;
+         dp = row;
+         for (i = 0; i < row_width; i++)
+         {
+            r = *sp++;
+            g = *sp++;
+            b = *sp++;
+
+            /* This looks real messy, but the compiler will reduce
+             * it down to a reasonable formula.  For example, with
+             * 5 bits per color, we get:
+             * p = (((r >> 3) & 0x1f) << 10) |
+             *    (((g >> 3) & 0x1f) << 5) |
+             *    ((b >> 3) & 0x1f);
+             */
+            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
+                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
+                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
+                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
+                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
+                (PNG_QUANTIZE_BLUE_BITS)) |
+                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
+                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));
+
+            *dp++ = palette_lookup[p];
+         }
+
+         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
+         row_info->channels = 1;
+         row_info->pixel_depth = row_info->bit_depth;
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
+      }
+
+      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
+         palette_lookup != NULL)
+      {
+         int r, g, b, p;
+         sp = row;
+         dp = row;
+         for (i = 0; i < row_width; i++)
+         {
+            r = *sp++;
+            g = *sp++;
+            b = *sp++;
+            sp++;
+
+            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
+                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
+                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
+                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
+                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
+                (PNG_QUANTIZE_BLUE_BITS)) |
+                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
+                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));
+
+            *dp++ = palette_lookup[p];
+         }
+
+         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
+         row_info->channels = 1;
+         row_info->pixel_depth = row_info->bit_depth;
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
+      }
+
+      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
+         quantize_lookup)
+      {
+         sp = row;
+
+         for (i = 0; i < row_width; i++, sp++)
+         {
+            *sp = quantize_lookup[*sp];
+         }
+      }
+   }
+}
+#endif /* PNG_READ_QUANTIZE_SUPPORTED */
+#endif /* PNG_READ_TRANSFORMS_SUPPORTED */
+
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+/* Undoes intrapixel differencing  */
+void /* PRIVATE */
+png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_read_intrapixel");
+
+   if (
+       (row_info->color_type & PNG_COLOR_MASK_COLOR))
+   {
+      int bytes_per_pixel;
+      png_uint_32 row_width = row_info->width;
+
+      if (row_info->bit_depth == 8)
+      {
+         png_bytep rp;
+         png_uint_32 i;
+
+         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+            bytes_per_pixel = 3;
+
+         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+            bytes_per_pixel = 4;
+
+         else
+            return;
+
+         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
+         {
+            *(rp) = (png_byte)((256 + *rp + *(rp + 1)) & 0xff);
+            *(rp+2) = (png_byte)((256 + *(rp + 2) + *(rp + 1)) & 0xff);
+         }
+      }
+      else if (row_info->bit_depth == 16)
+      {
+         png_bytep rp;
+         png_uint_32 i;
+
+         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+            bytes_per_pixel = 6;
+
+         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+            bytes_per_pixel = 8;
+
+         else
+            return;
+
+         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
+         {
+            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
+            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
+            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
+            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;
+            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;
+            *(rp    ) = (png_byte)((red >> 8) & 0xff);
+            *(rp + 1) = (png_byte)(red & 0xff);
+            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
+            *(rp + 5) = (png_byte)(blue & 0xff);
+         }
+      }
+   }
+}
+#endif /* PNG_MNG_FEATURES_SUPPORTED */
+#endif /* PNG_READ_SUPPORTED */
diff -urN a/media/libpng/pngrutil.c b/media/libpng/pngrutil.c
--- a/media/libpng/pngrutil.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngrutil.c	2012-07-13 12:40:57 +0800
@@ -1,7 +1,7 @@
 
 /* pngrutil.c - utilities to read a PNG file
  *
- * Last changed in libpng 1.5.9 [February 18, 2012]
+ * Last changed in libpng 1.5.10 [March 8, 2012]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -434,14 +434,12 @@
        */
       if (prefix_size >= (~(png_size_t)0) - 1 ||
          expanded_size >= (~(png_size_t)0) - 1 - prefix_size
-#ifdef PNG_SET_CHUNK_MALLOC_LIMIT_SUPPORTED
+#ifdef PNG_USER_LIMITS_SUPPORTED
          || (png_ptr->user_chunk_malloc_max &&
           (prefix_size + expanded_size >= png_ptr->user_chunk_malloc_max - 1))
 #else
-#  ifdef PNG_USER_CHUNK_MALLOC_MAX
          || ((PNG_USER_CHUNK_MALLOC_MAX > 0) &&
           prefix_size + expanded_size >= PNG_USER_CHUNK_MALLOC_MAX - 1)
-#  endif
 #endif
          )
          png_warning(png_ptr, "Exceeded size limit while expanding chunk");
@@ -1264,13 +1262,16 @@
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place iCCP chunk");
 
-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
+   if ((png_ptr->mode & PNG_HAVE_iCCP) || (info_ptr != NULL &&
+      (info_ptr->valid & (PNG_INFO_iCCP|PNG_INFO_sRGB))))
    {
       png_warning(png_ptr, "Duplicate iCCP chunk");
       png_crc_finish(png_ptr, length);
       return;
    }
 
+   png_ptr->mode |= PNG_HAVE_iCCP;
+
 #ifdef PNG_MAX_MALLOC_64K
    if (length > (png_uint_32)65535L)
    {
@@ -1800,16 +1801,16 @@
       return;
    }
 
-   num = length / 2 ;
-
-   if (num != (unsigned int)png_ptr->num_palette || num >
-       (unsigned int)PNG_MAX_PALETTE_LENGTH)
+   if (length > 2*PNG_MAX_PALETTE_LENGTH ||
+       length != (unsigned int) (2*png_ptr->num_palette))
    {
       png_warning(png_ptr, "Incorrect hIST chunk length");
       png_crc_finish(png_ptr, length);
       return;
    }
 
+   num = length / 2 ;
+
    for (i = 0; i < num; i++)
    {
       png_byte buf[2];
diff -urN a/media/libpng/pngset.c b/media/libpng/pngset.c
--- a/media/libpng/pngset.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngset.c	2012-07-13 12:40:57 +0800
@@ -1,8 +1,8 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.5.7 [December 15, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.11 [June 14, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -149,7 +149,7 @@
     * possible for 1/gamma to overflow the limit of 21474 and this means the
     * gamma value must be at least 5/100000 and hence at most 20000.0.  For
     * safety the limits here are a little narrower.  The values are 0.00016 to
-    * 6250.0, which are truly ridiculous gammma values (and will produce
+    * 6250.0, which are truly ridiculous gamma values (and will produce
     * displays that are all black or all white.)
     */
    if (file_gamma < 16 || file_gamma > 625000000)
@@ -697,24 +697,28 @@
     */
    if (info_ptr->num_text + num_text > info_ptr->max_text)
    {
+      int old_max_text = info_ptr->max_text;
+      int old_num_text = info_ptr->num_text;
+
       if (info_ptr->text != NULL)
       {
          png_textp old_text;
-         int old_max;
 
-         old_max = info_ptr->max_text;
          info_ptr->max_text = info_ptr->num_text + num_text + 8;
          old_text = info_ptr->text;
+
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
             (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));
 
          if (info_ptr->text == NULL)
          {
-            png_free(png_ptr, old_text);
+            /* Restore to previous condition */
+            info_ptr->max_text = old_max_text;
+            info_ptr->text = old_text;
             return(1);
          }
 
-         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
+         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max_text *
              png_sizeof(png_text)));
          png_free(png_ptr, old_text);
       }
@@ -726,7 +730,12 @@
          info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
              (png_size_t)(info_ptr->max_text * png_sizeof(png_text)));
          if (info_ptr->text == NULL)
+         {
+            /* Restore to previous condition */
+            info_ptr->num_text = old_num_text;
+            info_ptr->max_text = old_max_text;
             return(1);
+         }
          info_ptr->free_me |= PNG_FREE_TEXT;
       }
 
@@ -1427,4 +1436,22 @@
       png_ptr->flags &= ~PNG_FLAG_BENIGN_ERRORS_WARN;
 }
 #endif /* PNG_BENIGN_ERRORS_SUPPORTED */
+
+#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
+/* Whether to report invalid palette index; added at libng-1.5.10
+ *   allowed  - one of 0: disable; 1: enable
+ */
+void PNGAPI
+png_set_check_for_invalid_index(png_structp png_ptr, int allowed)
+{
+   png_debug(1, "in png_set_check_for_invalid_index");
+
+   if (allowed)
+      png_ptr->num_palette_max = 0;
+
+   else
+      png_ptr->num_palette_max = -1;
+}
+#endif
+
 #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -urN a/media/libpng/pngstruct.h b/media/libpng/pngstruct.h
--- a/media/libpng/pngstruct.h	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngstruct.h	2012-07-13 12:40:57 +0800
@@ -1,7 +1,7 @@
 
 /* pngstruct.h - header file for PNG reference library
  *
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -121,6 +121,12 @@
    png_uint_32 crc;           /* current chunk CRC value */
    png_colorp palette;        /* palette from the input file */
    png_uint_16 num_palette;   /* number of color entries in palette */
+
+/* Added at libpng-1.5.10 */
+#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   int num_palette_max;       /* maximum palette index found in IDAT */
+#endif
+
    png_uint_16 num_trans;     /* number of transparency values */
    png_byte compression;      /* file compression type (always 0) */
    png_byte filter;           /* file filter type (always 0) */
@@ -211,13 +217,6 @@
    int process_mode;                 /* what push library is currently doing */
    int cur_palette;                  /* current push library palette index */
 
-#  ifdef PNG_TEXT_SUPPORTED
-     png_size_t current_text_size;   /* current size of text input data */
-     png_size_t current_text_left;   /* how much text left to read in input */
-     png_charp current_text;         /* current text chunk buffer */
-     png_charp current_text_ptr;     /* current location in current_text */
-#  endif /* PNG_PROGRESSIVE_READ_SUPPORTED && PNG_TEXT_SUPPORTED */
-
 #endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
 
 #if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
@@ -249,6 +248,7 @@
 #endif
 
 #ifdef PNG_TIME_RFC1123_SUPPORTED
+   /* This is going to be unused in libpng16 and removed from libpng17 */
    char time_buffer[29]; /* String to hold RFC 1123 time text */
 #endif
 
diff -urN a/media/libpng/pngtrans.c b/media/libpng/pngtrans.c
--- a/media/libpng/pngtrans.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngtrans.c	2012-07-13 12:40:57 +0800
@@ -1,678 +1,781 @@
-
-/* pngtrans.c - transforms the data in a row (used by both readers and writers)
- *
- * Last changed in libpng 1.5.4 [July 7, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#include "pngpriv.h"
-
-#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
-
-#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-/* Turn on BGR-to-RGB mapping */
-void PNGAPI
-png_set_bgr(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_bgr");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_BGR;
-}
-#endif
-
-#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-/* Turn on 16 bit byte swapping */
-void PNGAPI
-png_set_swap(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_swap");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (png_ptr->bit_depth == 16)
-      png_ptr->transformations |= PNG_SWAP_BYTES;
-}
-#endif
-
-#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
-/* Turn on pixel packing */
-void PNGAPI
-png_set_packing(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_packing");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (png_ptr->bit_depth < 8)
-   {
-      png_ptr->transformations |= PNG_PACK;
-      png_ptr->usr_bit_depth = 8;
-   }
-}
-#endif
-
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-/* Turn on packed pixel swapping */
-void PNGAPI
-png_set_packswap(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_packswap");
-
-   if (png_ptr == NULL)
-      return;
-
-   if (png_ptr->bit_depth < 8)
-      png_ptr->transformations |= PNG_PACKSWAP;
-}
-#endif
-
-#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
-void PNGAPI
-png_set_shift(png_structp png_ptr, png_const_color_8p true_bits)
-{
-   png_debug(1, "in png_set_shift");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_SHIFT;
-   png_ptr->shift = *true_bits;
-}
-#endif
-
-#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
-    defined(PNG_WRITE_INTERLACING_SUPPORTED)
-int PNGAPI
-png_set_interlace_handling(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_interlace handling");
-
-   if (png_ptr && png_ptr->interlaced)
-   {
-      png_ptr->transformations |= PNG_INTERLACE;
-      return (7);
-   }
-
-   return (1);
-}
-#endif
-
-#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
-/* Add a filler byte on read, or remove a filler or alpha byte on write.
- * The filler type has changed in v0.95 to allow future 2-byte fillers
- * for 48-bit input data, as well as to avoid problems with some compilers
- * that don't like bytes as parameters.
- */
-void PNGAPI
-png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
-{
-   png_debug(1, "in png_set_filler");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_FILLER;
-   png_ptr->filler = (png_uint_16)filler;
-
-   if (filler_loc == PNG_FILLER_AFTER)
-      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
-
-   else
-      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;
-
-   /* This should probably go in the "do_read_filler" routine.
-    * I attempted to do that in libpng-1.0.1a but that caused problems
-    * so I restored it in libpng-1.0.2a
-   */
-
-   if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
-   {
-      png_ptr->usr_channels = 4;
-   }
-
-   /* Also I added this in libpng-1.0.2a (what happens when we expand
-    * a less-than-8-bit grayscale to GA?) */
-
-   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY && png_ptr->bit_depth >= 8)
-   {
-      png_ptr->usr_channels = 2;
-   }
-}
-
-/* Added to libpng-1.2.7 */
-void PNGAPI
-png_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)
-{
-   png_debug(1, "in png_set_add_alpha");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_set_filler(png_ptr, filler, filler_loc);
-   png_ptr->transformations |= PNG_ADD_ALPHA;
-}
-
-#endif
-
-#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
-    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
-void PNGAPI
-png_set_swap_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_swap_alpha");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_SWAP_ALPHA;
-}
-#endif
-
-#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
-    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
-void PNGAPI
-png_set_invert_alpha(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_invert_alpha");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_INVERT_ALPHA;
-}
-#endif
-
-#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
-void PNGAPI
-png_set_invert_mono(png_structp png_ptr)
-{
-   png_debug(1, "in png_set_invert_mono");
-
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->transformations |= PNG_INVERT_MONO;
-}
-
-/* Invert monochrome grayscale data */
-void /* PRIVATE */
-png_do_invert(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_invert");
-
-  /* This test removed from libpng version 1.0.13 and 1.2.0:
-   *   if (row_info->bit_depth == 1 &&
-   */
-   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
-   {
-      png_bytep rp = row;
-      png_size_t i;
-      png_size_t istop = row_info->rowbytes;
-
-      for (i = 0; i < istop; i++)
-      {
-         *rp = (png_byte)(~(*rp));
-         rp++;
-      }
-   }
-
-   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
-      row_info->bit_depth == 8)
-   {
-      png_bytep rp = row;
-      png_size_t i;
-      png_size_t istop = row_info->rowbytes;
-
-      for (i = 0; i < istop; i += 2)
-      {
-         *rp = (png_byte)(~(*rp));
-         rp += 2;
-      }
-   }
-
-#ifdef PNG_16BIT_SUPPORTED
-   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
-      row_info->bit_depth == 16)
-   {
-      png_bytep rp = row;
-      png_size_t i;
-      png_size_t istop = row_info->rowbytes;
-
-      for (i = 0; i < istop; i += 4)
-      {
-         *rp = (png_byte)(~(*rp));
-         *(rp + 1) = (png_byte)(~(*(rp + 1)));
-         rp += 4;
-      }
-   }
-#endif
-}
-#endif
-
-#ifdef PNG_16BIT_SUPPORTED
-#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
-/* Swaps byte order on 16 bit depth images */
-void /* PRIVATE */
-png_do_swap(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_swap");
-
-   if (row_info->bit_depth == 16)
-   {
-      png_bytep rp = row;
-      png_uint_32 i;
-      png_uint_32 istop= row_info->width * row_info->channels;
-
-      for (i = 0; i < istop; i++, rp += 2)
-      {
-         png_byte t = *rp;
-         *rp = *(rp + 1);
-         *(rp + 1) = t;
-      }
-   }
-}
-#endif
-#endif
-
-#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-static PNG_CONST png_byte onebppswaptable[256] = {
-   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
-   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
-   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
-   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
-   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
-   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
-   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
-   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
-   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
-   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
-   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
-   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
-   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
-   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
-   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
-   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
-   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
-   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
-   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
-   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
-   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
-   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
-   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
-   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
-   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
-   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
-   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
-   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
-   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
-   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
-   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
-   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
-};
-
-static PNG_CONST png_byte twobppswaptable[256] = {
-   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
-   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
-   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
-   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,
-   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,
-   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,
-   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,
-   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,
-   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,
-   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,
-   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,
-   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,
-   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,
-   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,
-   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,
-   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,
-   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,
-   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,
-   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,
-   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,
-   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,
-   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,
-   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,
-   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,
-   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,
-   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,
-   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,
-   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,
-   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,
-   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,
-   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,
-   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
-};
-
-static PNG_CONST png_byte fourbppswaptable[256] = {
-   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
-   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
-   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
-   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
-   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
-   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,
-   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
-   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,
-   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,
-   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,
-   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
-   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,
-   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
-   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,
-   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
-   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,
-   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,
-   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,
-   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,
-   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
-   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,
-   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
-   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,
-   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,
-   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,
-   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,
-   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,
-   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,
-   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,
-   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,
-   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,
-   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
-};
-
-/* Swaps pixel packing order within bytes */
-void /* PRIVATE */
-png_do_packswap(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_packswap");
-
-   if (row_info->bit_depth < 8)
-   {
-      png_bytep rp;
-      png_const_bytep end, table;
-
-      end = row + row_info->rowbytes;
-
-      if (row_info->bit_depth == 1)
-         table = onebppswaptable;
-
-      else if (row_info->bit_depth == 2)
-         table = twobppswaptable;
-
-      else if (row_info->bit_depth == 4)
-         table = fourbppswaptable;
-
-      else
-         return;
-
-      for (rp = row; rp < end; rp++)
-         *rp = table[*rp];
-   }
-}
-#endif /* PNG_READ_PACKSWAP_SUPPORTED or PNG_WRITE_PACKSWAP_SUPPORTED */
-
-#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
-    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
-/* Remove a channel - this used to be 'png_do_strip_filler' but it used a
- * somewhat weird combination of flags to determine what to do.  All the calls
- * to png_do_strip_filler are changed in 1.5.2 to call this instead with the
- * correct arguments.
- *
- * The routine isn't general - the channel must be the channel at the start or
- * end (not in the middle) of each pixel.
- */
-void /* PRIVATE */
-png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
-{
-   png_bytep sp = row; /* source pointer */
-   png_bytep dp = row; /* destination pointer */
-   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */
-
-   /* At the start sp will point to the first byte to copy and dp to where
-    * it is copied to.  ep always points just beyond the end of the row, so
-    * the loop simply copies (channels-1) channels until sp reaches ep.
-    *
-    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.
-    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.
-    */
-
-   /* GA, GX, XG cases */
-   if (row_info->channels == 2)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         if (at_start) /* Skip initial filler */
-            ++sp;
-         else          /* Skip initial channel and, for sp, the filler */
-            sp += 2, ++dp;
-
-         /* For a 1 pixel wide image there is nothing to do */
-         while (sp < ep)
-            *dp++ = *sp, sp += 2;
-
-         row_info->pixel_depth = 8;
-      }
-
-      else if (row_info->bit_depth == 16)
-      {
-         if (at_start) /* Skip initial filler */
-            sp += 2;
-         else          /* Skip initial channel and, for sp, the filler */
-            sp += 4, dp += 2;
-
-         while (sp < ep)
-            *dp++ = *sp++, *dp++ = *sp, sp += 3;
-
-         row_info->pixel_depth = 16;
-      }
-
-      else
-         return; /* bad bit depth */
-
-      row_info->channels = 1;
-
-      /* Finally fix the color type if it records an alpha channel */
-      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-         row_info->color_type = PNG_COLOR_TYPE_GRAY;
-   }
-
-   /* RGBA, RGBX, XRGB cases */
-   else if (row_info->channels == 4)
-   {
-      if (row_info->bit_depth == 8)
-      {
-         if (at_start) /* Skip initial filler */
-            ++sp;
-         else          /* Skip initial channels and, for sp, the filler */
-            sp += 4, dp += 3;
-
-         /* Note that the loop adds 3 to dp and 4 to sp each time. */
-         while (sp < ep)
-            *dp++ = *sp++, *dp++ = *sp++, *dp++ = *sp, sp += 2;
-
-         row_info->pixel_depth = 24;
-      }
-
-      else if (row_info->bit_depth == 16)
-      {
-         if (at_start) /* Skip initial filler */
-            sp += 2;
-         else          /* Skip initial channels and, for sp, the filler */
-            sp += 8, dp += 6;
-
-         while (sp < ep)
-         {
-            /* Copy 6 bytes, skip 2 */
-            *dp++ = *sp++, *dp++ = *sp++;
-            *dp++ = *sp++, *dp++ = *sp++;
-            *dp++ = *sp++, *dp++ = *sp, sp += 3;
-         }
-
-         row_info->pixel_depth = 48;
-      }
-
-      else
-         return; /* bad bit depth */
-
-      row_info->channels = 3;
-
-      /* Finally fix the color type if it records an alpha channel */
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-         row_info->color_type = PNG_COLOR_TYPE_RGB;
-   }
-
-   else
-      return; /* The filler channel has gone already */
-
-   /* Fix the rowbytes value. */
-   row_info->rowbytes = dp-row;
-}
-#endif
-
-#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
-/* Swaps red and blue bytes within a pixel */
-void /* PRIVATE */
-png_do_bgr(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_bgr");
-
-   if ((row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      png_uint_32 row_width = row_info->width;
-      if (row_info->bit_depth == 8)
-      {
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 3)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 2);
-               *(rp + 2) = save;
-            }
-         }
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 4)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 2);
-               *(rp + 2) = save;
-            }
-         }
-      }
-
-#ifdef PNG_16BIT_SUPPORTED
-      else if (row_info->bit_depth == 16)
-      {
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 6)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 4);
-               *(rp + 4) = save;
-               save = *(rp + 1);
-               *(rp + 1) = *(rp + 5);
-               *(rp + 5) = save;
-            }
-         }
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-         {
-            png_bytep rp;
-            png_uint_32 i;
-
-            for (i = 0, rp = row; i < row_width; i++, rp += 8)
-            {
-               png_byte save = *rp;
-               *rp = *(rp + 4);
-               *(rp + 4) = save;
-               save = *(rp + 1);
-               *(rp + 1) = *(rp + 5);
-               *(rp + 5) = save;
-            }
-         }
-      }
-#endif
-   }
-}
-#endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */
-
-#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
-    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
-#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-void PNGAPI
-png_set_user_transform_info(png_structp png_ptr, png_voidp
-   user_transform_ptr, int user_transform_depth, int user_transform_channels)
-{
-   png_debug(1, "in png_set_user_transform_info");
-
-   if (png_ptr == NULL)
-      return;
-   png_ptr->user_transform_ptr = user_transform_ptr;
-   png_ptr->user_transform_depth = (png_byte)user_transform_depth;
-   png_ptr->user_transform_channels = (png_byte)user_transform_channels;
-}
-#endif
-
-/* This function returns a pointer to the user_transform_ptr associated with
- * the user transform functions.  The application should free any memory
- * associated with this pointer before png_write_destroy and png_read_destroy
- * are called.
- */
-#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
-png_voidp PNGAPI
-png_get_user_transform_ptr(png_const_structp png_ptr)
-{
-   if (png_ptr == NULL)
-      return (NULL);
-
-   return ((png_voidp)png_ptr->user_transform_ptr);
-}
-#endif
-
-#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
-png_uint_32 PNGAPI
-png_get_current_row_number(png_const_structp png_ptr)
-{
-   /* See the comments in png.h - this is the sub-image row when reading and
-    * interlaced image.
-    */
-   if (png_ptr != NULL)
-      return png_ptr->row_number;
-
-   return PNG_UINT_32_MAX; /* help the app not to fail silently */
-}
-
-png_byte PNGAPI
-png_get_current_pass_number(png_const_structp png_ptr)
-{
-   if (png_ptr != NULL)
-      return png_ptr->pass;
-   return 8; /* invalid */
-}
-#endif /* PNG_USER_TRANSFORM_INFO_SUPPORTED */
-#endif /* PNG_READ_USER_TRANSFORM_SUPPORTED ||
-          PNG_WRITE_USER_TRANSFORM_SUPPORTED */
-#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
+
+/* pngtrans.c - transforms the data in a row (used by both readers and writers)
+ *
+ * Last changed in libpng 1.5.11 [June 14, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#include "pngpriv.h"
+
+#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
+
+#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
+/* Turn on BGR-to-RGB mapping */
+void PNGAPI
+png_set_bgr(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_bgr");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_BGR;
+}
+#endif
+
+#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
+/* Turn on 16 bit byte swapping */
+void PNGAPI
+png_set_swap(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_swap");
+
+   if (png_ptr == NULL)
+      return;
+
+   if (png_ptr->bit_depth == 16)
+      png_ptr->transformations |= PNG_SWAP_BYTES;
+}
+#endif
+
+#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
+/* Turn on pixel packing */
+void PNGAPI
+png_set_packing(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_packing");
+
+   if (png_ptr == NULL)
+      return;
+
+   if (png_ptr->bit_depth < 8)
+   {
+      png_ptr->transformations |= PNG_PACK;
+      png_ptr->usr_bit_depth = 8;
+   }
+}
+#endif
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
+/* Turn on packed pixel swapping */
+void PNGAPI
+png_set_packswap(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_packswap");
+
+   if (png_ptr == NULL)
+      return;
+
+   if (png_ptr->bit_depth < 8)
+      png_ptr->transformations |= PNG_PACKSWAP;
+}
+#endif
+
+#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
+void PNGAPI
+png_set_shift(png_structp png_ptr, png_const_color_8p true_bits)
+{
+   png_debug(1, "in png_set_shift");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_SHIFT;
+   png_ptr->shift = *true_bits;
+}
+#endif
+
+#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
+    defined(PNG_WRITE_INTERLACING_SUPPORTED)
+int PNGAPI
+png_set_interlace_handling(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_interlace handling");
+
+   if (png_ptr && png_ptr->interlaced)
+   {
+      png_ptr->transformations |= PNG_INTERLACE;
+      return (7);
+   }
+
+   return (1);
+}
+#endif
+
+#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
+/* Add a filler byte on read, or remove a filler or alpha byte on write.
+ * The filler type has changed in v0.95 to allow future 2-byte fillers
+ * for 48-bit input data, as well as to avoid problems with some compilers
+ * that don't like bytes as parameters.
+ */
+void PNGAPI
+png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
+{
+   png_debug(1, "in png_set_filler");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_FILLER;
+   png_ptr->filler = (png_uint_16)filler;
+
+   if (filler_loc == PNG_FILLER_AFTER)
+      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
+
+   else
+      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;
+
+   /* This should probably go in the "do_read_filler" routine.
+    * I attempted to do that in libpng-1.0.1a but that caused problems
+    * so I restored it in libpng-1.0.2a
+   */
+
+   if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
+   {
+      png_ptr->usr_channels = 4;
+   }
+
+   /* Also I added this in libpng-1.0.2a (what happens when we expand
+    * a less-than-8-bit grayscale to GA?) */
+
+   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY && png_ptr->bit_depth >= 8)
+   {
+      png_ptr->usr_channels = 2;
+   }
+}
+
+/* Added to libpng-1.2.7 */
+void PNGAPI
+png_set_add_alpha(png_structp png_ptr, png_uint_32 filler, int filler_loc)
+{
+   png_debug(1, "in png_set_add_alpha");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_set_filler(png_ptr, filler, filler_loc);
+   png_ptr->transformations |= PNG_ADD_ALPHA;
+}
+
+#endif
+
+#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
+    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
+void PNGAPI
+png_set_swap_alpha(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_swap_alpha");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_SWAP_ALPHA;
+}
+#endif
+
+#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
+    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
+void PNGAPI
+png_set_invert_alpha(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_invert_alpha");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_INVERT_ALPHA;
+}
+#endif
+
+#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
+void PNGAPI
+png_set_invert_mono(png_structp png_ptr)
+{
+   png_debug(1, "in png_set_invert_mono");
+
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->transformations |= PNG_INVERT_MONO;
+}
+
+/* Invert monochrome grayscale data */
+void /* PRIVATE */
+png_do_invert(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_invert");
+
+  /* This test removed from libpng version 1.0.13 and 1.2.0:
+   *   if (row_info->bit_depth == 1 &&
+   */
+   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
+   {
+      png_bytep rp = row;
+      png_size_t i;
+      png_size_t istop = row_info->rowbytes;
+
+      for (i = 0; i < istop; i++)
+      {
+         *rp = (png_byte)(~(*rp));
+         rp++;
+      }
+   }
+
+   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
+      row_info->bit_depth == 8)
+   {
+      png_bytep rp = row;
+      png_size_t i;
+      png_size_t istop = row_info->rowbytes;
+
+      for (i = 0; i < istop; i += 2)
+      {
+         *rp = (png_byte)(~(*rp));
+         rp += 2;
+      }
+   }
+
+#ifdef PNG_16BIT_SUPPORTED
+   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
+      row_info->bit_depth == 16)
+   {
+      png_bytep rp = row;
+      png_size_t i;
+      png_size_t istop = row_info->rowbytes;
+
+      for (i = 0; i < istop; i += 4)
+      {
+         *rp = (png_byte)(~(*rp));
+         *(rp + 1) = (png_byte)(~(*(rp + 1)));
+         rp += 4;
+      }
+   }
+#endif
+}
+#endif
+
+#ifdef PNG_16BIT_SUPPORTED
+#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
+/* Swaps byte order on 16 bit depth images */
+void /* PRIVATE */
+png_do_swap(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_swap");
+
+   if (row_info->bit_depth == 16)
+   {
+      png_bytep rp = row;
+      png_uint_32 i;
+      png_uint_32 istop= row_info->width * row_info->channels;
+
+      for (i = 0; i < istop; i++, rp += 2)
+      {
+         png_byte t = *rp;
+         *rp = *(rp + 1);
+         *(rp + 1) = t;
+      }
+   }
+}
+#endif
+#endif
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
+static PNG_CONST png_byte onebppswaptable[256] = {
+   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
+   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
+   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
+   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
+   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
+   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
+   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
+   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
+   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
+   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
+   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
+   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
+   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
+   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
+   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
+   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
+   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
+   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
+   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
+   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
+   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
+   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
+   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
+   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
+   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
+   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
+   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
+   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
+   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
+   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
+   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
+   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
+};
+
+static PNG_CONST png_byte twobppswaptable[256] = {
+   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
+   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
+   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
+   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,
+   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,
+   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,
+   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,
+   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,
+   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,
+   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,
+   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,
+   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,
+   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,
+   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,
+   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,
+   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,
+   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,
+   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,
+   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,
+   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,
+   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,
+   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,
+   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,
+   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,
+   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,
+   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,
+   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,
+   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,
+   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,
+   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,
+   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,
+   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
+};
+
+static PNG_CONST png_byte fourbppswaptable[256] = {
+   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
+   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
+   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
+   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
+   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
+   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,
+   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
+   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,
+   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,
+   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,
+   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
+   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,
+   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
+   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,
+   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
+   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,
+   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,
+   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,
+   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,
+   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
+   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,
+   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
+   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,
+   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,
+   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,
+   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,
+   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,
+   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,
+   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,
+   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,
+   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,
+   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
+};
+
+/* Swaps pixel packing order within bytes */
+void /* PRIVATE */
+png_do_packswap(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_packswap");
+
+   if (row_info->bit_depth < 8)
+   {
+      png_bytep rp;
+      png_const_bytep end, table;
+
+      end = row + row_info->rowbytes;
+
+      if (row_info->bit_depth == 1)
+         table = onebppswaptable;
+
+      else if (row_info->bit_depth == 2)
+         table = twobppswaptable;
+
+      else if (row_info->bit_depth == 4)
+         table = fourbppswaptable;
+
+      else
+         return;
+
+      for (rp = row; rp < end; rp++)
+         *rp = table[*rp];
+   }
+}
+#endif /* PNG_READ_PACKSWAP_SUPPORTED or PNG_WRITE_PACKSWAP_SUPPORTED */
+
+#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
+    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
+/* Remove a channel - this used to be 'png_do_strip_filler' but it used a
+ * somewhat weird combination of flags to determine what to do.  All the calls
+ * to png_do_strip_filler are changed in 1.5.2 to call this instead with the
+ * correct arguments.
+ *
+ * The routine isn't general - the channel must be the channel at the start or
+ * end (not in the middle) of each pixel.
+ */
+void /* PRIVATE */
+png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
+{
+   png_bytep sp = row; /* source pointer */
+   png_bytep dp = row; /* destination pointer */
+   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */
+
+   /* At the start sp will point to the first byte to copy and dp to where
+    * it is copied to.  ep always points just beyond the end of the row, so
+    * the loop simply copies (channels-1) channels until sp reaches ep.
+    *
+    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.
+    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.
+    */
+
+   /* GA, GX, XG cases */
+   if (row_info->channels == 2)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         if (at_start) /* Skip initial filler */
+            ++sp;
+         else          /* Skip initial channel and, for sp, the filler */
+            sp += 2, ++dp;
+
+         /* For a 1 pixel wide image there is nothing to do */
+         while (sp < ep)
+            *dp++ = *sp, sp += 2;
+
+         row_info->pixel_depth = 8;
+      }
+
+      else if (row_info->bit_depth == 16)
+      {
+         if (at_start) /* Skip initial filler */
+            sp += 2;
+         else          /* Skip initial channel and, for sp, the filler */
+            sp += 4, dp += 2;
+
+         while (sp < ep)
+            *dp++ = *sp++, *dp++ = *sp, sp += 3;
+
+         row_info->pixel_depth = 16;
+      }
+
+      else
+         return; /* bad bit depth */
+
+      row_info->channels = 1;
+
+      /* Finally fix the color type if it records an alpha channel */
+      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+         row_info->color_type = PNG_COLOR_TYPE_GRAY;
+   }
+
+   /* RGBA, RGBX, XRGB cases */
+   else if (row_info->channels == 4)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         if (at_start) /* Skip initial filler */
+            ++sp;
+         else          /* Skip initial channels and, for sp, the filler */
+            sp += 4, dp += 3;
+
+         /* Note that the loop adds 3 to dp and 4 to sp each time. */
+         while (sp < ep)
+            *dp++ = *sp++, *dp++ = *sp++, *dp++ = *sp, sp += 2;
+
+         row_info->pixel_depth = 24;
+      }
+
+      else if (row_info->bit_depth == 16)
+      {
+         if (at_start) /* Skip initial filler */
+            sp += 2;
+         else          /* Skip initial channels and, for sp, the filler */
+            sp += 8, dp += 6;
+
+         while (sp < ep)
+         {
+            /* Copy 6 bytes, skip 2 */
+            *dp++ = *sp++, *dp++ = *sp++;
+            *dp++ = *sp++, *dp++ = *sp++;
+            *dp++ = *sp++, *dp++ = *sp, sp += 3;
+         }
+
+         row_info->pixel_depth = 48;
+      }
+
+      else
+         return; /* bad bit depth */
+
+      row_info->channels = 3;
+
+      /* Finally fix the color type if it records an alpha channel */
+      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+         row_info->color_type = PNG_COLOR_TYPE_RGB;
+   }
+
+   else
+      return; /* The filler channel has gone already */
+
+   /* Fix the rowbytes value. */
+   row_info->rowbytes = dp-row;
+}
+#endif
+
+#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
+/* Swaps red and blue bytes within a pixel */
+void /* PRIVATE */
+png_do_bgr(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_bgr");
+
+   if ((row_info->color_type & PNG_COLOR_MASK_COLOR))
+   {
+      png_uint_32 row_width = row_info->width;
+      if (row_info->bit_depth == 8)
+      {
+         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+         {
+            png_bytep rp;
+            png_uint_32 i;
+
+            for (i = 0, rp = row; i < row_width; i++, rp += 3)
+            {
+               png_byte save = *rp;
+               *rp = *(rp + 2);
+               *(rp + 2) = save;
+            }
+         }
+
+         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+         {
+            png_bytep rp;
+            png_uint_32 i;
+
+            for (i = 0, rp = row; i < row_width; i++, rp += 4)
+            {
+               png_byte save = *rp;
+               *rp = *(rp + 2);
+               *(rp + 2) = save;
+            }
+         }
+      }
+
+#ifdef PNG_16BIT_SUPPORTED
+      else if (row_info->bit_depth == 16)
+      {
+         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+         {
+            png_bytep rp;
+            png_uint_32 i;
+
+            for (i = 0, rp = row; i < row_width; i++, rp += 6)
+            {
+               png_byte save = *rp;
+               *rp = *(rp + 4);
+               *(rp + 4) = save;
+               save = *(rp + 1);
+               *(rp + 1) = *(rp + 5);
+               *(rp + 5) = save;
+            }
+         }
+
+         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+         {
+            png_bytep rp;
+            png_uint_32 i;
+
+            for (i = 0, rp = row; i < row_width; i++, rp += 8)
+            {
+               png_byte save = *rp;
+               *rp = *(rp + 4);
+               *(rp + 4) = save;
+               save = *(rp + 1);
+               *(rp + 1) = *(rp + 5);
+               *(rp + 5) = save;
+            }
+         }
+      }
+#endif
+   }
+}
+#endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */
+
+#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+/* Added at libpng-1.5.10 */
+void /* PRIVATE */
+png_do_check_palette_indexes(png_structp png_ptr, png_row_infop row_info)
+{
+   if (png_ptr->num_palette < (1 << row_info->bit_depth) &&
+      png_ptr->num_palette > 0) /* num_palette can be 0 in MNG files */
+   {
+      /* Calculations moved outside switch in an attempt to stop different
+       * compiler warnings.  'padding' is in *bits* within the last byte, it is
+       * an 'int' because pixel_depth becomes an 'int' in the expression below,
+       * and this calculation is used because it avoids warnings that other
+       * forms produced on either GCC or MSVC.
+       */
+      int padding = (-row_info->pixel_depth * row_info->width) & 7;
+      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;
+
+      switch (row_info->bit_depth)
+      {
+         case 1:
+         {
+            /* in this case, all bytes must be 0 so we don't need
+             * to unpack the pixels except for the rightmost one.
+             */
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+              if (*rp >> padding != 0)
+                 png_ptr->num_palette_max = 1;
+              padding = 0;
+            }
+
+            break;
+         }
+
+         case 2:
+         {
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+              int i = ((*rp >> padding) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 2) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 4) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 6) & 0x03);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              padding = 0;
+            }
+
+            break;
+         }
+
+         case 4:
+         {
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+              int i = ((*rp >> padding) & 0x0f);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              i = (((*rp >> padding) >> 4) & 0x0f);
+
+              if (i > png_ptr->num_palette_max)
+                 png_ptr->num_palette_max = i;
+
+              padding = 0;
+            }
+
+            break;
+         }
+
+         case 8:
+         {
+            for (; rp > png_ptr->row_buf; rp--)
+            {
+               if (*rp > png_ptr->num_palette_max)
+                  png_ptr->num_palette_max = (int) *rp;
+            }
+
+            break;
+         }
+
+         default:
+            break;
+      }
+   }
+}
+#endif /* PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED */
+
+#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
+    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
+#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
+void PNGAPI
+png_set_user_transform_info(png_structp png_ptr, png_voidp
+   user_transform_ptr, int user_transform_depth, int user_transform_channels)
+{
+   png_debug(1, "in png_set_user_transform_info");
+
+   if (png_ptr == NULL)
+      return;
+   png_ptr->user_transform_ptr = user_transform_ptr;
+   png_ptr->user_transform_depth = (png_byte)user_transform_depth;
+   png_ptr->user_transform_channels = (png_byte)user_transform_channels;
+}
+#endif
+
+/* This function returns a pointer to the user_transform_ptr associated with
+ * the user transform functions.  The application should free any memory
+ * associated with this pointer before png_write_destroy and png_read_destroy
+ * are called.
+ */
+#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
+png_voidp PNGAPI
+png_get_user_transform_ptr(png_const_structp png_ptr)
+{
+   if (png_ptr == NULL)
+      return (NULL);
+
+   return ((png_voidp)png_ptr->user_transform_ptr);
+}
+#endif
+
+#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
+png_uint_32 PNGAPI
+png_get_current_row_number(png_const_structp png_ptr)
+{
+   /* See the comments in png.h - this is the sub-image row when reading and
+    * interlaced image.
+    */
+   if (png_ptr != NULL)
+      return png_ptr->row_number;
+
+   return PNG_UINT_32_MAX; /* help the app not to fail silently */
+}
+
+png_byte PNGAPI
+png_get_current_pass_number(png_const_structp png_ptr)
+{
+   if (png_ptr != NULL)
+      return png_ptr->pass;
+   return 8; /* invalid */
+}
+#endif /* PNG_USER_TRANSFORM_INFO_SUPPORTED */
+#endif /* PNG_READ_USER_TRANSFORM_SUPPORTED ||
+          PNG_WRITE_USER_TRANSFORM_SUPPORTED */
+#endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
diff -urN a/media/libpng/pngwio.c b/media/libpng/pngwio.c
--- a/media/libpng/pngwio.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngwio.c	2012-07-13 12:40:57 +0800
@@ -1,254 +1,254 @@
-
-/* pngwio.c - functions for data output
- *
- * Last changed in libpng 1.5.0 [January 6, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- *
- * This file provides a location for all output.  Users who need
- * special handling are expected to write functions that have the same
- * arguments as these and perform similar functions, but that possibly
- * use different output methods.  Note that you shouldn't change these
- * functions, but rather write replacement functions and then change
- * them at run time with png_set_write_fn(...).
- */
-
-#include "pngpriv.h"
-
-#ifdef PNG_WRITE_SUPPORTED
-
-/* Write the data to whatever output you are using.  The default routine
- * writes to a file pointer.  Note that this routine sometimes gets called
- * with very small lengths, so you should implement some kind of simple
- * buffering if you are using unbuffered writes.  This should never be asked
- * to write more than 64K on a 16 bit machine.
- */
-
-void /* PRIVATE */
-png_write_data(png_structp png_ptr, png_const_bytep data, png_size_t length)
-{
-   /* NOTE: write_data_fn must not change the buffer! */
-   if (png_ptr->write_data_fn != NULL )
-      (*(png_ptr->write_data_fn))(png_ptr, (png_bytep)data, length);
-
-   else
-      png_error(png_ptr, "Call to NULL write function");
-}
-
-#ifdef PNG_STDIO_SUPPORTED
-/* This is the function that does the actual writing of data.  If you are
- * not writing to a standard C stream, you should create a replacement
- * write_data function and use it at run time with png_set_write_fn(), rather
- * than changing the library.
- */
-#ifndef USE_FAR_KEYWORD
-void PNGCBAPI
-png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_size_t check;
-
-   if (png_ptr == NULL)
-      return;
-
-   check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
-
-   if (check != length)
-      png_error(png_ptr, "Write Error");
-}
-#else
-/* This is the model-independent version. Since the standard I/O library
- * can't handle far buffers in the medium and small models, we have to copy
- * the data.
- */
-
-#define NEAR_BUF_SIZE 1024
-#define MIN(a,b) (a <= b ? a : b)
-
-void PNGCBAPI
-png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-   png_uint_32 check;
-   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
-   png_FILE_p io_ptr;
-
-   if (png_ptr == NULL)
-      return;
-
-   /* Check if data really is near. If so, use usual code. */
-   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
-   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
-
-   if ((png_bytep)near_data == data)
-   {
-      check = fwrite(near_data, 1, length, io_ptr);
-   }
-
-   else
-   {
-      png_byte buf[NEAR_BUF_SIZE];
-      png_size_t written, remaining, err;
-      check = 0;
-      remaining = length;
-
-      do
-      {
-         written = MIN(NEAR_BUF_SIZE, remaining);
-         png_memcpy(buf, data, written); /* Copy far buffer to near buffer */
-         err = fwrite(buf, 1, written, io_ptr);
-
-         if (err != written)
-            break;
-
-         else
-            check += err;
-
-         data += written;
-         remaining -= written;
-      }
-      while (remaining != 0);
-   }
-
-   if (check != length)
-      png_error(png_ptr, "Write Error");
-}
-
-#endif
-#endif
-
-/* This function is called to output any data pending writing (normally
- * to disk).  After png_flush is called, there should be no data pending
- * writing in any buffers.
- */
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-void /* PRIVATE */
-png_flush(png_structp png_ptr)
-{
-   if (png_ptr->output_flush_fn != NULL)
-      (*(png_ptr->output_flush_fn))(png_ptr);
-}
-
-#  ifdef PNG_STDIO_SUPPORTED
-void PNGCBAPI
-png_default_flush(png_structp png_ptr)
-{
-   png_FILE_p io_ptr;
-
-   if (png_ptr == NULL)
-      return;
-
-   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
-   fflush(io_ptr);
-}
-#  endif
-#endif
-
-/* This function allows the application to supply new output functions for
- * libpng if standard C streams aren't being used.
- *
- * This function takes as its arguments:
- * png_ptr       - pointer to a png output data structure
- * io_ptr        - pointer to user supplied structure containing info about
- *                 the output functions.  May be NULL.
- * write_data_fn - pointer to a new output function that takes as its
- *                 arguments a pointer to a png_struct, a pointer to
- *                 data to be written, and a 32-bit unsigned int that is
- *                 the number of bytes to be written.  The new write
- *                 function should call png_error(png_ptr, "Error msg")
- *                 to exit and output any fatal error messages.  May be
- *                 NULL, in which case libpng's default function will
- *                 be used.
- * flush_data_fn - pointer to a new flush function that takes as its
- *                 arguments a pointer to a png_struct.  After a call to
- *                 the flush function, there should be no data in any buffers
- *                 or pending transmission.  If the output method doesn't do
- *                 any buffering of output, a function prototype must still be
- *                 supplied although it doesn't have to do anything.  If
- *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
- *                 time, output_flush_fn will be ignored, although it must be
- *                 supplied for compatibility.  May be NULL, in which case
- *                 libpng's default function will be used, if
- *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
- *                 a good idea if io_ptr does not point to a standard
- *                 *FILE structure.
- */
-void PNGAPI
-png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
-    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
-{
-   if (png_ptr == NULL)
-      return;
-
-   png_ptr->io_ptr = io_ptr;
-
-#ifdef PNG_STDIO_SUPPORTED
-   if (write_data_fn != NULL)
-      png_ptr->write_data_fn = write_data_fn;
-
-   else
-      png_ptr->write_data_fn = png_default_write_data;
-#else
-   png_ptr->write_data_fn = write_data_fn;
-#endif
-
-#ifdef PNG_WRITE_FLUSH_SUPPORTED
-#  ifdef PNG_STDIO_SUPPORTED
-
-   if (output_flush_fn != NULL)
-      png_ptr->output_flush_fn = output_flush_fn;
-
-   else
-      png_ptr->output_flush_fn = png_default_flush;
-
-#  else
-   png_ptr->output_flush_fn = output_flush_fn;
-#  endif
-#endif /* PNG_WRITE_FLUSH_SUPPORTED */
-
-   /* It is an error to read while writing a png file */
-   if (png_ptr->read_data_fn != NULL)
-   {
-      png_ptr->read_data_fn = NULL;
-
-      png_warning(png_ptr,
-          "Can't set both read_data_fn and write_data_fn in the"
-          " same structure");
-   }
-}
-
-#ifdef USE_FAR_KEYWORD
-#  ifdef _MSC_VER
-void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
-{
-   void *near_ptr;
-   void FAR *far_ptr;
-   FP_OFF(near_ptr) = FP_OFF(ptr);
-   far_ptr = (void FAR *)near_ptr;
-
-   if (check != 0)
-      if (FP_SEG(ptr) != FP_SEG(far_ptr))
-         png_error(png_ptr, "segment lost in conversion");
-
-   return(near_ptr);
-}
-#  else
-void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
-{
-   void *near_ptr;
-   void FAR *far_ptr;
-   near_ptr = (void FAR *)ptr;
-   far_ptr = (void FAR *)near_ptr;
-
-   if (check != 0)
-      if (far_ptr != ptr)
-         png_error(png_ptr, "segment lost in conversion");
-
-   return(near_ptr);
-}
-#  endif
-#endif
-#endif /* PNG_WRITE_SUPPORTED */
+
+/* pngwio.c - functions for data output
+ *
+ * Last changed in libpng 1.5.0 [January 6, 2011]
+ * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ *
+ * This file provides a location for all output.  Users who need
+ * special handling are expected to write functions that have the same
+ * arguments as these and perform similar functions, but that possibly
+ * use different output methods.  Note that you shouldn't change these
+ * functions, but rather write replacement functions and then change
+ * them at run time with png_set_write_fn(...).
+ */
+
+#include "pngpriv.h"
+
+#ifdef PNG_WRITE_SUPPORTED
+
+/* Write the data to whatever output you are using.  The default routine
+ * writes to a file pointer.  Note that this routine sometimes gets called
+ * with very small lengths, so you should implement some kind of simple
+ * buffering if you are using unbuffered writes.  This should never be asked
+ * to write more than 64K on a 16 bit machine.
+ */
+
+void /* PRIVATE */
+png_write_data(png_structp png_ptr, png_const_bytep data, png_size_t length)
+{
+   /* NOTE: write_data_fn must not change the buffer! */
+   if (png_ptr->write_data_fn != NULL )
+      (*(png_ptr->write_data_fn))(png_ptr, (png_bytep)data, length);
+
+   else
+      png_error(png_ptr, "Call to NULL write function");
+}
+
+#ifdef PNG_STDIO_SUPPORTED
+/* This is the function that does the actual writing of data.  If you are
+ * not writing to a standard C stream, you should create a replacement
+ * write_data function and use it at run time with png_set_write_fn(), rather
+ * than changing the library.
+ */
+#ifndef USE_FAR_KEYWORD
+void PNGCBAPI
+png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
+{
+   png_size_t check;
+
+   if (png_ptr == NULL)
+      return;
+
+   check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
+
+   if (check != length)
+      png_error(png_ptr, "Write Error");
+}
+#else
+/* This is the model-independent version. Since the standard I/O library
+ * can't handle far buffers in the medium and small models, we have to copy
+ * the data.
+ */
+
+#define NEAR_BUF_SIZE 1024
+#define MIN(a,b) (a <= b ? a : b)
+
+void PNGCBAPI
+png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
+{
+   png_uint_32 check;
+   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
+   png_FILE_p io_ptr;
+
+   if (png_ptr == NULL)
+      return;
+
+   /* Check if data really is near. If so, use usual code. */
+   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
+   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
+
+   if ((png_bytep)near_data == data)
+   {
+      check = fwrite(near_data, 1, length, io_ptr);
+   }
+
+   else
+   {
+      png_byte buf[NEAR_BUF_SIZE];
+      png_size_t written, remaining, err;
+      check = 0;
+      remaining = length;
+
+      do
+      {
+         written = MIN(NEAR_BUF_SIZE, remaining);
+         png_memcpy(buf, data, written); /* Copy far buffer to near buffer */
+         err = fwrite(buf, 1, written, io_ptr);
+
+         if (err != written)
+            break;
+
+         else
+            check += err;
+
+         data += written;
+         remaining -= written;
+      }
+      while (remaining != 0);
+   }
+
+   if (check != length)
+      png_error(png_ptr, "Write Error");
+}
+
+#endif
+#endif
+
+/* This function is called to output any data pending writing (normally
+ * to disk).  After png_flush is called, there should be no data pending
+ * writing in any buffers.
+ */
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+void /* PRIVATE */
+png_flush(png_structp png_ptr)
+{
+   if (png_ptr->output_flush_fn != NULL)
+      (*(png_ptr->output_flush_fn))(png_ptr);
+}
+
+#  ifdef PNG_STDIO_SUPPORTED
+void PNGCBAPI
+png_default_flush(png_structp png_ptr)
+{
+   png_FILE_p io_ptr;
+
+   if (png_ptr == NULL)
+      return;
+
+   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
+   fflush(io_ptr);
+}
+#  endif
+#endif
+
+/* This function allows the application to supply new output functions for
+ * libpng if standard C streams aren't being used.
+ *
+ * This function takes as its arguments:
+ * png_ptr       - pointer to a png output data structure
+ * io_ptr        - pointer to user supplied structure containing info about
+ *                 the output functions.  May be NULL.
+ * write_data_fn - pointer to a new output function that takes as its
+ *                 arguments a pointer to a png_struct, a pointer to
+ *                 data to be written, and a 32-bit unsigned int that is
+ *                 the number of bytes to be written.  The new write
+ *                 function should call png_error(png_ptr, "Error msg")
+ *                 to exit and output any fatal error messages.  May be
+ *                 NULL, in which case libpng's default function will
+ *                 be used.
+ * flush_data_fn - pointer to a new flush function that takes as its
+ *                 arguments a pointer to a png_struct.  After a call to
+ *                 the flush function, there should be no data in any buffers
+ *                 or pending transmission.  If the output method doesn't do
+ *                 any buffering of output, a function prototype must still be
+ *                 supplied although it doesn't have to do anything.  If
+ *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
+ *                 time, output_flush_fn will be ignored, although it must be
+ *                 supplied for compatibility.  May be NULL, in which case
+ *                 libpng's default function will be used, if
+ *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
+ *                 a good idea if io_ptr does not point to a standard
+ *                 *FILE structure.
+ */
+void PNGAPI
+png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
+    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
+{
+   if (png_ptr == NULL)
+      return;
+
+   png_ptr->io_ptr = io_ptr;
+
+#ifdef PNG_STDIO_SUPPORTED
+   if (write_data_fn != NULL)
+      png_ptr->write_data_fn = write_data_fn;
+
+   else
+      png_ptr->write_data_fn = png_default_write_data;
+#else
+   png_ptr->write_data_fn = write_data_fn;
+#endif
+
+#ifdef PNG_WRITE_FLUSH_SUPPORTED
+#  ifdef PNG_STDIO_SUPPORTED
+
+   if (output_flush_fn != NULL)
+      png_ptr->output_flush_fn = output_flush_fn;
+
+   else
+      png_ptr->output_flush_fn = png_default_flush;
+
+#  else
+   png_ptr->output_flush_fn = output_flush_fn;
+#  endif
+#endif /* PNG_WRITE_FLUSH_SUPPORTED */
+
+   /* It is an error to read while writing a png file */
+   if (png_ptr->read_data_fn != NULL)
+   {
+      png_ptr->read_data_fn = NULL;
+
+      png_warning(png_ptr,
+          "Can't set both read_data_fn and write_data_fn in the"
+          " same structure");
+   }
+}
+
+#ifdef USE_FAR_KEYWORD
+#  ifdef _MSC_VER
+void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
+{
+   void *near_ptr;
+   void FAR *far_ptr;
+   FP_OFF(near_ptr) = FP_OFF(ptr);
+   far_ptr = (void FAR *)near_ptr;
+
+   if (check != 0)
+      if (FP_SEG(ptr) != FP_SEG(far_ptr))
+         png_error(png_ptr, "segment lost in conversion");
+
+   return(near_ptr);
+}
+#  else
+void *png_far_to_near(png_structp png_ptr, png_voidp ptr, int check)
+{
+   void *near_ptr;
+   void FAR *far_ptr;
+   near_ptr = (void FAR *)ptr;
+   far_ptr = (void FAR *)near_ptr;
+
+   if (check != 0)
+      if (far_ptr != ptr)
+         png_error(png_ptr, "segment lost in conversion");
+
+   return(near_ptr);
+}
+#  endif
+#endif
+#endif /* PNG_WRITE_SUPPORTED */
diff -urN a/media/libpng/pngwrite.c b/media/libpng/pngwrite.c
--- a/media/libpng/pngwrite.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngwrite.c	2012-07-13 12:40:57 +0800
@@ -1,8 +1,8 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.5.7 [December 15, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.11 [June 14, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -309,6 +309,11 @@
    if (!(png_ptr->mode & PNG_HAVE_IDAT))
       png_error(png_ptr, "No IDATs written into file");
 
+#ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   if (png_ptr->num_palette_max > png_ptr->num_palette)
+      png_benign_error(png_ptr, "Wrote palette index exceeding num_palette");
+#endif
+
 #ifdef PNG_WRITE_APNG_SUPPORTED
    if (png_ptr->num_frames_written != png_ptr->num_frames_to_write)
       png_error(png_ptr, "Not enough frames written");
@@ -807,6 +812,14 @@
    }
 #endif
 
+/* Added at libpng-1.5.10 */
+#ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
+   /* Check for out-of-range palette index */
+   if (row_info.color_type == PNG_COLOR_TYPE_PALETTE &&
+       png_ptr->num_palette_max >= 0)
+      png_do_check_palette_indexes(png_ptr, &row_info);
+#endif
+
    /* Find a filter if necessary, filter the row and write it out. */
    png_write_find_filter(png_ptr, &row_info);
 
diff -urN a/media/libpng/pngwtran.c b/media/libpng/pngwtran.c
--- a/media/libpng/pngwtran.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngwtran.c	2012-07-13 12:40:57 +0800
@@ -1,633 +1,633 @@
-
-/* pngwtran.c - transforms the data in a row for PNG writers
- *
- * Last changed in libpng 1.5.6 [November 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
- *
- * This code is released under the libpng license.
- * For conditions of distribution and use, see the disclaimer
- * and license in png.h
- */
-
-#include "pngpriv.h"
-
-#ifdef PNG_WRITE_SUPPORTED
-
-#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
-/* Transform the data according to the user's wishes.  The order of
- * transformations is significant.
- */
-void /* PRIVATE */
-png_do_write_transformations(png_structp png_ptr, png_row_infop row_info)
-{
-   png_debug(1, "in png_do_write_transformations");
-
-   if (png_ptr == NULL)
-      return;
-
-#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
-   if (png_ptr->transformations & PNG_USER_TRANSFORM)
-      if (png_ptr->write_user_transform_fn != NULL)
-         (*(png_ptr->write_user_transform_fn)) /* User write transform
-                                                 function */
-             (png_ptr,  /* png_ptr */
-             row_info,  /* row_info: */
-                /*  png_uint_32 width;       width of row */
-                /*  png_size_t rowbytes;     number of bytes in row */
-                /*  png_byte color_type;     color type of pixels */
-                /*  png_byte bit_depth;      bit depth of samples */
-                /*  png_byte channels;       number of channels (1-4) */
-                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
-             png_ptr->row_buf + 1);      /* start of pixel data for row */
-#endif
-
-#ifdef PNG_WRITE_FILLER_SUPPORTED
-   if (png_ptr->transformations & PNG_FILLER)
-      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
-         !(png_ptr->flags & PNG_FLAG_FILLER_AFTER));
-#endif
-
-#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_PACKSWAP)
-      png_do_packswap(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_WRITE_PACK_SUPPORTED
-   if (png_ptr->transformations & PNG_PACK)
-      png_do_pack(row_info, png_ptr->row_buf + 1,
-          (png_uint_32)png_ptr->bit_depth);
-#endif
-
-#ifdef PNG_WRITE_SWAP_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_BYTES)
-      png_do_swap(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_WRITE_SHIFT_SUPPORTED
-   if (png_ptr->transformations & PNG_SHIFT)
-      png_do_shift(row_info, png_ptr->row_buf + 1,
-          &(png_ptr->shift));
-#endif
-
-#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_SWAP_ALPHA)
-      png_do_write_swap_alpha(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_ALPHA)
-      png_do_write_invert_alpha(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_WRITE_BGR_SUPPORTED
-   if (png_ptr->transformations & PNG_BGR)
-      png_do_bgr(row_info, png_ptr->row_buf + 1);
-#endif
-
-#ifdef PNG_WRITE_INVERT_SUPPORTED
-   if (png_ptr->transformations & PNG_INVERT_MONO)
-      png_do_invert(row_info, png_ptr->row_buf + 1);
-#endif
-}
-
-#ifdef PNG_WRITE_PACK_SUPPORTED
-/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
- * row_info bit depth should be 8 (one pixel per byte).  The channels
- * should be 1 (this only happens on grayscale and paletted images).
- */
-void /* PRIVATE */
-png_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)
-{
-   png_debug(1, "in png_do_pack");
-
-   if (row_info->bit_depth == 8 &&
-      row_info->channels == 1)
-   {
-      switch ((int)bit_depth)
-      {
-         case 1:
-         {
-            png_bytep sp, dp;
-            int mask, v;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            sp = row;
-            dp = row;
-            mask = 0x80;
-            v = 0;
-
-            for (i = 0; i < row_width; i++)
-            {
-               if (*sp != 0)
-                  v |= mask;
-
-               sp++;
-
-               if (mask > 1)
-                  mask >>= 1;
-
-               else
-               {
-                  mask = 0x80;
-                  *dp = (png_byte)v;
-                  dp++;
-                  v = 0;
-               }
-            }
-
-            if (mask != 0x80)
-               *dp = (png_byte)v;
-
-            break;
-         }
-
-         case 2:
-         {
-            png_bytep sp, dp;
-            int shift, v;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            sp = row;
-            dp = row;
-            shift = 6;
-            v = 0;
-
-            for (i = 0; i < row_width; i++)
-            {
-               png_byte value;
-
-               value = (png_byte)(*sp & 0x03);
-               v |= (value << shift);
-
-               if (shift == 0)
-               {
-                  shift = 6;
-                  *dp = (png_byte)v;
-                  dp++;
-                  v = 0;
-               }
-
-               else
-                  shift -= 2;
-
-               sp++;
-            }
-
-            if (shift != 6)
-               *dp = (png_byte)v;
-
-            break;
-         }
-
-         case 4:
-         {
-            png_bytep sp, dp;
-            int shift, v;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            sp = row;
-            dp = row;
-            shift = 4;
-            v = 0;
-
-            for (i = 0; i < row_width; i++)
-            {
-               png_byte value;
-
-               value = (png_byte)(*sp & 0x0f);
-               v |= (value << shift);
-
-               if (shift == 0)
-               {
-                  shift = 4;
-                  *dp = (png_byte)v;
-                  dp++;
-                  v = 0;
-               }
-
-               else
-                  shift -= 4;
-
-               sp++;
-            }
-
-            if (shift != 4)
-               *dp = (png_byte)v;
-
-            break;
-         }
-
-         default:
-            break;
-      }
-
-      row_info->bit_depth = (png_byte)bit_depth;
-      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
-      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
-          row_info->width);
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_SHIFT_SUPPORTED
-/* Shift pixel values to take advantage of whole range.  Pass the
- * true number of bits in bit_depth.  The row should be packed
- * according to row_info->bit_depth.  Thus, if you had a row of
- * bit depth 4, but the pixels only had values from 0 to 7, you
- * would pass 3 as bit_depth, and this routine would translate the
- * data to 0 to 15.
- */
-void /* PRIVATE */
-png_do_shift(png_row_infop row_info, png_bytep row,
-    png_const_color_8p bit_depth)
-{
-   png_debug(1, "in png_do_shift");
-
-   if (row_info->color_type != PNG_COLOR_TYPE_PALETTE)
-   {
-      int shift_start[4], shift_dec[4];
-      int channels = 0;
-
-      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
-      {
-         shift_start[channels] = row_info->bit_depth - bit_depth->red;
-         shift_dec[channels] = bit_depth->red;
-         channels++;
-
-         shift_start[channels] = row_info->bit_depth - bit_depth->green;
-         shift_dec[channels] = bit_depth->green;
-         channels++;
-
-         shift_start[channels] = row_info->bit_depth - bit_depth->blue;
-         shift_dec[channels] = bit_depth->blue;
-         channels++;
-      }
-
-      else
-      {
-         shift_start[channels] = row_info->bit_depth - bit_depth->gray;
-         shift_dec[channels] = bit_depth->gray;
-         channels++;
-      }
-
-      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
-      {
-         shift_start[channels] = row_info->bit_depth - bit_depth->alpha;
-         shift_dec[channels] = bit_depth->alpha;
-         channels++;
-      }
-
-      /* With low row depths, could only be grayscale, so one channel */
-      if (row_info->bit_depth < 8)
-      {
-         png_bytep bp = row;
-         png_size_t i;
-         png_byte mask;
-         png_size_t row_bytes = row_info->rowbytes;
-
-         if (bit_depth->gray == 1 && row_info->bit_depth == 2)
-            mask = 0x55;
-
-         else if (row_info->bit_depth == 4 && bit_depth->gray == 3)
-            mask = 0x11;
-
-         else
-            mask = 0xff;
-
-         for (i = 0; i < row_bytes; i++, bp++)
-         {
-            png_uint_16 v;
-            int j;
-
-            v = *bp;
-            *bp = 0;
-
-            for (j = shift_start[0]; j > -shift_dec[0]; j -= shift_dec[0])
-            {
-               if (j > 0)
-                  *bp |= (png_byte)((v << j) & 0xff);
-
-               else
-                  *bp |= (png_byte)((v >> (-j)) & mask);
-            }
-         }
-      }
-
-      else if (row_info->bit_depth == 8)
-      {
-         png_bytep bp = row;
-         png_uint_32 i;
-         png_uint_32 istop = channels * row_info->width;
-
-         for (i = 0; i < istop; i++, bp++)
-         {
-
-            png_uint_16 v;
-            int j;
-            int c = (int)(i%channels);
-
-            v = *bp;
-            *bp = 0;
-
-            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
-            {
-               if (j > 0)
-                  *bp |= (png_byte)((v << j) & 0xff);
-
-               else
-                  *bp |= (png_byte)((v >> (-j)) & 0xff);
-            }
-         }
-      }
-
-      else
-      {
-         png_bytep bp;
-         png_uint_32 i;
-         png_uint_32 istop = channels * row_info->width;
-
-         for (bp = row, i = 0; i < istop; i++)
-         {
-            int c = (int)(i%channels);
-            png_uint_16 value, v;
-            int j;
-
-            v = (png_uint_16)(((png_uint_16)(*bp) << 8) + *(bp + 1));
-            value = 0;
-
-            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
-            {
-               if (j > 0)
-                  value |= (png_uint_16)((v << j) & (png_uint_16)0xffff);
-
-               else
-                  value |= (png_uint_16)((v >> (-j)) & (png_uint_16)0xffff);
-            }
-            *bp++ = (png_byte)(value >> 8);
-            *bp++ = (png_byte)(value & 0xff);
-         }
-      }
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_write_swap_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_write_swap_alpha");
-
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This converts from ARGB to RGBA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save;
-            }
-         }
-
-#ifdef PNG_WRITE_16BIT_SUPPORTED
-         else
-         {
-            /* This converts from AARRGGBB to RRGGBBAA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save[2];
-               save[0] = *(sp++);
-               save[1] = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save[0];
-               *(dp++) = save[1];
-            }
-         }
-#endif /* PNG_WRITE_16BIT_SUPPORTED */
-      }
-
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This converts from AG to GA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save;
-            }
-         }
-
-#ifdef PNG_WRITE_16BIT_SUPPORTED
-         else
-         {
-            /* This converts from AAGG to GGAA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               png_byte save[2];
-               save[0] = *(sp++);
-               save[1] = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = save[0];
-               *(dp++) = save[1];
-            }
-         }
-#endif /* PNG_WRITE_16BIT_SUPPORTED */
-      }
-   }
-}
-#endif
-
-#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
-void /* PRIVATE */
-png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_write_invert_alpha");
-
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This inverts the alpha channel in RGBA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               /* Does nothing
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               */
-               sp+=3; dp = sp;
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-
-#ifdef PNG_WRITE_16BIT_SUPPORTED
-         else
-         {
-            /* This inverts the alpha channel in RRGGBBAA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               /* Does nothing
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               */
-               sp+=6; dp = sp;
-               *(dp++) = (png_byte)(255 - *(sp++));
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-#endif /* PNG_WRITE_16BIT_SUPPORTED */
-      }
-
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            /* This inverts the alpha channel in GA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               *(dp++) = *(sp++);
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-
-#ifdef PNG_WRITE_16BIT_SUPPORTED
-         else
-         {
-            /* This inverts the alpha channel in GGAA */
-            png_bytep sp, dp;
-            png_uint_32 i;
-            png_uint_32 row_width = row_info->width;
-
-            for (i = 0, sp = dp = row; i < row_width; i++)
-            {
-               /* Does nothing
-               *(dp++) = *(sp++);
-               *(dp++) = *(sp++);
-               */
-               sp+=2; dp = sp;
-               *(dp++) = (png_byte)(255 - *(sp++));
-               *(dp++) = (png_byte)(255 - *(sp++));
-            }
-         }
-#endif /* PNG_WRITE_16BIT_SUPPORTED */
-      }
-   }
-}
-#endif
-#endif /* PNG_WRITE_TRANSFORMS_SUPPORTED */
-
-#ifdef PNG_MNG_FEATURES_SUPPORTED
-/* Undoes intrapixel differencing  */
-void /* PRIVATE */
-png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
-{
-   png_debug(1, "in png_do_write_intrapixel");
-
-   if ((row_info->color_type & PNG_COLOR_MASK_COLOR))
-   {
-      int bytes_per_pixel;
-      png_uint_32 row_width = row_info->width;
-      if (row_info->bit_depth == 8)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 3;
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 4;
-
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            *(rp)     = (png_byte)((*rp       - *(rp + 1)) & 0xff);
-            *(rp + 2) = (png_byte)((*(rp + 2) - *(rp + 1)) & 0xff);
-         }
-      }
-
-#ifdef PNG_WRITE_16BIT_SUPPORTED
-      else if (row_info->bit_depth == 16)
-      {
-         png_bytep rp;
-         png_uint_32 i;
-
-         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
-            bytes_per_pixel = 6;
-
-         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-            bytes_per_pixel = 8;
-
-         else
-            return;
-
-         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
-         {
-            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
-            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
-            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
-            png_uint_32 red  = (png_uint_32)((s0 - s1) & 0xffffL);
-            png_uint_32 blue = (png_uint_32)((s2 - s1) & 0xffffL);
-            *(rp    ) = (png_byte)((red >> 8) & 0xff);
-            *(rp + 1) = (png_byte)(red & 0xff);
-            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
-            *(rp + 5) = (png_byte)(blue & 0xff);
-         }
-      }
-#endif /* PNG_WRITE_16BIT_SUPPORTED */
-   }
-}
-#endif /* PNG_MNG_FEATURES_SUPPORTED */
-#endif /* PNG_WRITE_SUPPORTED */
+
+/* pngwtran.c - transforms the data in a row for PNG writers
+ *
+ * Last changed in libpng 1.5.6 [November 3, 2011]
+ * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#include "pngpriv.h"
+
+#ifdef PNG_WRITE_SUPPORTED
+
+#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
+/* Transform the data according to the user's wishes.  The order of
+ * transformations is significant.
+ */
+void /* PRIVATE */
+png_do_write_transformations(png_structp png_ptr, png_row_infop row_info)
+{
+   png_debug(1, "in png_do_write_transformations");
+
+   if (png_ptr == NULL)
+      return;
+
+#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
+   if (png_ptr->transformations & PNG_USER_TRANSFORM)
+      if (png_ptr->write_user_transform_fn != NULL)
+         (*(png_ptr->write_user_transform_fn)) /* User write transform
+                                                 function */
+             (png_ptr,  /* png_ptr */
+             row_info,  /* row_info: */
+                /*  png_uint_32 width;       width of row */
+                /*  png_size_t rowbytes;     number of bytes in row */
+                /*  png_byte color_type;     color type of pixels */
+                /*  png_byte bit_depth;      bit depth of samples */
+                /*  png_byte channels;       number of channels (1-4) */
+                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
+             png_ptr->row_buf + 1);      /* start of pixel data for row */
+#endif
+
+#ifdef PNG_WRITE_FILLER_SUPPORTED
+   if (png_ptr->transformations & PNG_FILLER)
+      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
+         !(png_ptr->flags & PNG_FLAG_FILLER_AFTER));
+#endif
+
+#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
+   if (png_ptr->transformations & PNG_PACKSWAP)
+      png_do_packswap(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_WRITE_PACK_SUPPORTED
+   if (png_ptr->transformations & PNG_PACK)
+      png_do_pack(row_info, png_ptr->row_buf + 1,
+          (png_uint_32)png_ptr->bit_depth);
+#endif
+
+#ifdef PNG_WRITE_SWAP_SUPPORTED
+   if (png_ptr->transformations & PNG_SWAP_BYTES)
+      png_do_swap(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_WRITE_SHIFT_SUPPORTED
+   if (png_ptr->transformations & PNG_SHIFT)
+      png_do_shift(row_info, png_ptr->row_buf + 1,
+          &(png_ptr->shift));
+#endif
+
+#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
+   if (png_ptr->transformations & PNG_SWAP_ALPHA)
+      png_do_write_swap_alpha(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
+   if (png_ptr->transformations & PNG_INVERT_ALPHA)
+      png_do_write_invert_alpha(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_WRITE_BGR_SUPPORTED
+   if (png_ptr->transformations & PNG_BGR)
+      png_do_bgr(row_info, png_ptr->row_buf + 1);
+#endif
+
+#ifdef PNG_WRITE_INVERT_SUPPORTED
+   if (png_ptr->transformations & PNG_INVERT_MONO)
+      png_do_invert(row_info, png_ptr->row_buf + 1);
+#endif
+}
+
+#ifdef PNG_WRITE_PACK_SUPPORTED
+/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
+ * row_info bit depth should be 8 (one pixel per byte).  The channels
+ * should be 1 (this only happens on grayscale and paletted images).
+ */
+void /* PRIVATE */
+png_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)
+{
+   png_debug(1, "in png_do_pack");
+
+   if (row_info->bit_depth == 8 &&
+      row_info->channels == 1)
+   {
+      switch ((int)bit_depth)
+      {
+         case 1:
+         {
+            png_bytep sp, dp;
+            int mask, v;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            sp = row;
+            dp = row;
+            mask = 0x80;
+            v = 0;
+
+            for (i = 0; i < row_width; i++)
+            {
+               if (*sp != 0)
+                  v |= mask;
+
+               sp++;
+
+               if (mask > 1)
+                  mask >>= 1;
+
+               else
+               {
+                  mask = 0x80;
+                  *dp = (png_byte)v;
+                  dp++;
+                  v = 0;
+               }
+            }
+
+            if (mask != 0x80)
+               *dp = (png_byte)v;
+
+            break;
+         }
+
+         case 2:
+         {
+            png_bytep sp, dp;
+            int shift, v;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            sp = row;
+            dp = row;
+            shift = 6;
+            v = 0;
+
+            for (i = 0; i < row_width; i++)
+            {
+               png_byte value;
+
+               value = (png_byte)(*sp & 0x03);
+               v |= (value << shift);
+
+               if (shift == 0)
+               {
+                  shift = 6;
+                  *dp = (png_byte)v;
+                  dp++;
+                  v = 0;
+               }
+
+               else
+                  shift -= 2;
+
+               sp++;
+            }
+
+            if (shift != 6)
+               *dp = (png_byte)v;
+
+            break;
+         }
+
+         case 4:
+         {
+            png_bytep sp, dp;
+            int shift, v;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            sp = row;
+            dp = row;
+            shift = 4;
+            v = 0;
+
+            for (i = 0; i < row_width; i++)
+            {
+               png_byte value;
+
+               value = (png_byte)(*sp & 0x0f);
+               v |= (value << shift);
+
+               if (shift == 0)
+               {
+                  shift = 4;
+                  *dp = (png_byte)v;
+                  dp++;
+                  v = 0;
+               }
+
+               else
+                  shift -= 4;
+
+               sp++;
+            }
+
+            if (shift != 4)
+               *dp = (png_byte)v;
+
+            break;
+         }
+
+         default:
+            break;
+      }
+
+      row_info->bit_depth = (png_byte)bit_depth;
+      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
+          row_info->width);
+   }
+}
+#endif
+
+#ifdef PNG_WRITE_SHIFT_SUPPORTED
+/* Shift pixel values to take advantage of whole range.  Pass the
+ * true number of bits in bit_depth.  The row should be packed
+ * according to row_info->bit_depth.  Thus, if you had a row of
+ * bit depth 4, but the pixels only had values from 0 to 7, you
+ * would pass 3 as bit_depth, and this routine would translate the
+ * data to 0 to 15.
+ */
+void /* PRIVATE */
+png_do_shift(png_row_infop row_info, png_bytep row,
+    png_const_color_8p bit_depth)
+{
+   png_debug(1, "in png_do_shift");
+
+   if (row_info->color_type != PNG_COLOR_TYPE_PALETTE)
+   {
+      int shift_start[4], shift_dec[4];
+      int channels = 0;
+
+      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
+      {
+         shift_start[channels] = row_info->bit_depth - bit_depth->red;
+         shift_dec[channels] = bit_depth->red;
+         channels++;
+
+         shift_start[channels] = row_info->bit_depth - bit_depth->green;
+         shift_dec[channels] = bit_depth->green;
+         channels++;
+
+         shift_start[channels] = row_info->bit_depth - bit_depth->blue;
+         shift_dec[channels] = bit_depth->blue;
+         channels++;
+      }
+
+      else
+      {
+         shift_start[channels] = row_info->bit_depth - bit_depth->gray;
+         shift_dec[channels] = bit_depth->gray;
+         channels++;
+      }
+
+      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
+      {
+         shift_start[channels] = row_info->bit_depth - bit_depth->alpha;
+         shift_dec[channels] = bit_depth->alpha;
+         channels++;
+      }
+
+      /* With low row depths, could only be grayscale, so one channel */
+      if (row_info->bit_depth < 8)
+      {
+         png_bytep bp = row;
+         png_size_t i;
+         png_byte mask;
+         png_size_t row_bytes = row_info->rowbytes;
+
+         if (bit_depth->gray == 1 && row_info->bit_depth == 2)
+            mask = 0x55;
+
+         else if (row_info->bit_depth == 4 && bit_depth->gray == 3)
+            mask = 0x11;
+
+         else
+            mask = 0xff;
+
+         for (i = 0; i < row_bytes; i++, bp++)
+         {
+            png_uint_16 v;
+            int j;
+
+            v = *bp;
+            *bp = 0;
+
+            for (j = shift_start[0]; j > -shift_dec[0]; j -= shift_dec[0])
+            {
+               if (j > 0)
+                  *bp |= (png_byte)((v << j) & 0xff);
+
+               else
+                  *bp |= (png_byte)((v >> (-j)) & mask);
+            }
+         }
+      }
+
+      else if (row_info->bit_depth == 8)
+      {
+         png_bytep bp = row;
+         png_uint_32 i;
+         png_uint_32 istop = channels * row_info->width;
+
+         for (i = 0; i < istop; i++, bp++)
+         {
+
+            png_uint_16 v;
+            int j;
+            int c = (int)(i%channels);
+
+            v = *bp;
+            *bp = 0;
+
+            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
+            {
+               if (j > 0)
+                  *bp |= (png_byte)((v << j) & 0xff);
+
+               else
+                  *bp |= (png_byte)((v >> (-j)) & 0xff);
+            }
+         }
+      }
+
+      else
+      {
+         png_bytep bp;
+         png_uint_32 i;
+         png_uint_32 istop = channels * row_info->width;
+
+         for (bp = row, i = 0; i < istop; i++)
+         {
+            int c = (int)(i%channels);
+            png_uint_16 value, v;
+            int j;
+
+            v = (png_uint_16)(((png_uint_16)(*bp) << 8) + *(bp + 1));
+            value = 0;
+
+            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
+            {
+               if (j > 0)
+                  value |= (png_uint_16)((v << j) & (png_uint_16)0xffff);
+
+               else
+                  value |= (png_uint_16)((v >> (-j)) & (png_uint_16)0xffff);
+            }
+            *bp++ = (png_byte)(value >> 8);
+            *bp++ = (png_byte)(value & 0xff);
+         }
+      }
+   }
+}
+#endif
+
+#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
+void /* PRIVATE */
+png_do_write_swap_alpha(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_write_swap_alpha");
+
+   {
+      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            /* This converts from ARGB to RGBA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               png_byte save = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = save;
+            }
+         }
+
+#ifdef PNG_WRITE_16BIT_SUPPORTED
+         else
+         {
+            /* This converts from AARRGGBB to RRGGBBAA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               png_byte save[2];
+               save[0] = *(sp++);
+               save[1] = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = save[0];
+               *(dp++) = save[1];
+            }
+         }
+#endif /* PNG_WRITE_16BIT_SUPPORTED */
+      }
+
+      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            /* This converts from AG to GA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               png_byte save = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = save;
+            }
+         }
+
+#ifdef PNG_WRITE_16BIT_SUPPORTED
+         else
+         {
+            /* This converts from AAGG to GGAA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               png_byte save[2];
+               save[0] = *(sp++);
+               save[1] = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = save[0];
+               *(dp++) = save[1];
+            }
+         }
+#endif /* PNG_WRITE_16BIT_SUPPORTED */
+      }
+   }
+}
+#endif
+
+#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
+void /* PRIVATE */
+png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_write_invert_alpha");
+
+   {
+      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            /* This inverts the alpha channel in RGBA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               /* Does nothing
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               */
+               sp+=3; dp = sp;
+               *(dp++) = (png_byte)(255 - *(sp++));
+            }
+         }
+
+#ifdef PNG_WRITE_16BIT_SUPPORTED
+         else
+         {
+            /* This inverts the alpha channel in RRGGBBAA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               /* Does nothing
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               */
+               sp+=6; dp = sp;
+               *(dp++) = (png_byte)(255 - *(sp++));
+               *(dp++) = (png_byte)(255 - *(sp++));
+            }
+         }
+#endif /* PNG_WRITE_16BIT_SUPPORTED */
+      }
+
+      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            /* This inverts the alpha channel in GA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               *(dp++) = *(sp++);
+               *(dp++) = (png_byte)(255 - *(sp++));
+            }
+         }
+
+#ifdef PNG_WRITE_16BIT_SUPPORTED
+         else
+         {
+            /* This inverts the alpha channel in GGAA */
+            png_bytep sp, dp;
+            png_uint_32 i;
+            png_uint_32 row_width = row_info->width;
+
+            for (i = 0, sp = dp = row; i < row_width; i++)
+            {
+               /* Does nothing
+               *(dp++) = *(sp++);
+               *(dp++) = *(sp++);
+               */
+               sp+=2; dp = sp;
+               *(dp++) = (png_byte)(255 - *(sp++));
+               *(dp++) = (png_byte)(255 - *(sp++));
+            }
+         }
+#endif /* PNG_WRITE_16BIT_SUPPORTED */
+      }
+   }
+}
+#endif
+#endif /* PNG_WRITE_TRANSFORMS_SUPPORTED */
+
+#ifdef PNG_MNG_FEATURES_SUPPORTED
+/* Undoes intrapixel differencing  */
+void /* PRIVATE */
+png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
+{
+   png_debug(1, "in png_do_write_intrapixel");
+
+   if ((row_info->color_type & PNG_COLOR_MASK_COLOR))
+   {
+      int bytes_per_pixel;
+      png_uint_32 row_width = row_info->width;
+      if (row_info->bit_depth == 8)
+      {
+         png_bytep rp;
+         png_uint_32 i;
+
+         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+            bytes_per_pixel = 3;
+
+         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+            bytes_per_pixel = 4;
+
+         else
+            return;
+
+         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
+         {
+            *(rp)     = (png_byte)((*rp       - *(rp + 1)) & 0xff);
+            *(rp + 2) = (png_byte)((*(rp + 2) - *(rp + 1)) & 0xff);
+         }
+      }
+
+#ifdef PNG_WRITE_16BIT_SUPPORTED
+      else if (row_info->bit_depth == 16)
+      {
+         png_bytep rp;
+         png_uint_32 i;
+
+         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
+            bytes_per_pixel = 6;
+
+         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+            bytes_per_pixel = 8;
+
+         else
+            return;
+
+         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
+         {
+            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
+            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
+            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
+            png_uint_32 red  = (png_uint_32)((s0 - s1) & 0xffffL);
+            png_uint_32 blue = (png_uint_32)((s2 - s1) & 0xffffL);
+            *(rp    ) = (png_byte)((red >> 8) & 0xff);
+            *(rp + 1) = (png_byte)(red & 0xff);
+            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
+            *(rp + 5) = (png_byte)(blue & 0xff);
+         }
+      }
+#endif /* PNG_WRITE_16BIT_SUPPORTED */
+   }
+}
+#endif /* PNG_MNG_FEATURES_SUPPORTED */
+#endif /* PNG_WRITE_SUPPORTED */
diff -urN a/media/libpng/pngwutil.c b/media/libpng/pngwutil.c
--- a/media/libpng/pngwutil.c	2012-07-11 03:33:19 +0800
+++ b/media/libpng/pngwutil.c	2012-07-13 12:40:57 +0800
@@ -1,8 +1,8 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.5.6 [November 3, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -569,14 +569,15 @@
 
 /* Ship the compressed text out via chunk writes */
 static void /* PRIVATE */
-png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
+png_write_compressed_data_out(png_structp png_ptr, compression_state *comp,
+   png_size_t data_len)
 {
    int i;
 
    /* Handle the no-compression case */
    if (comp->input)
    {
-      png_write_chunk_data(png_ptr, comp->input, comp->input_len);
+      png_write_chunk_data(png_ptr, comp->input, data_len);
 
       return;
    }
@@ -585,7 +586,7 @@
    /* The zbuf_size test is because the code below doesn't work if zbuf_size is
     * '1'; simply skip it to avoid memory overwrite.
     */
-   if (comp->input_len >= 2 && comp->input_len < 16384 && png_ptr->zbuf_size > 1)
+   if (data_len >= 2 && comp->input_len < 16384 && png_ptr->zbuf_size > 1)
    {
       unsigned int z_cmf;  /* zlib compression method and flags */
 
@@ -1190,8 +1191,7 @@
 
    if (profile_len)
    {
-      comp.input_len = profile_len;
-      png_write_compressed_data_out(png_ptr, &comp);
+      png_write_compressed_data_out(png_ptr, &comp, profile_len);
    }
 
    png_write_chunk_end(png_ptr);
@@ -1761,8 +1761,7 @@
    png_write_chunk_data(png_ptr, &buf, (png_size_t)1);
 
    /* Write the compressed data */
-   comp.input_len = text_len;
-   png_write_compressed_data_out(png_ptr, &comp);
+   png_write_compressed_data_out(png_ptr, &comp, text_len);
 
    /* Close the chunk */
    png_write_chunk_end(png_ptr);
@@ -1853,7 +1852,7 @@
    png_write_chunk_data(png_ptr, (lang_key ? (png_const_bytep)lang_key : cbuf),
        (png_size_t)(lang_key_len + 1));
 
-   png_write_compressed_data_out(png_ptr, &comp);
+   png_write_compressed_data_out(png_ptr, &comp, text_len);
 
    png_write_chunk_end(png_ptr);
 
