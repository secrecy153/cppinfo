diff -r 284837bbf631 js/src/jsdhash.cpp
--- a/js/src/jsdhash.cpp	Sat Aug 25 07:23:12 2012 +0900
+++ b/js/src/jsdhash.cpp	Sat Aug 25 09:58:19 2012 +0900
@@ -3,16 +3,19 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 /*
  * Double hashing implementation.
  *
  * Try to keep this file in sync with xpcom/glue/pldhash.cpp.
  */
+#if _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include "jsdhash.h"
 #include "jsutil.h"
 
 using namespace js;
 
@@ -128,23 +131,39 @@ JS_DHashMatchStringKey(JSDHashTable *tab
             strcmp((const char *) stub->key, (const char *) key) == 0);
 }
 
 JS_PUBLIC_API(void)
 JS_DHashMoveEntryStub(JSDHashTable *table,
                       const JSDHashEntryHdr *from,
                       JSDHashEntryHdr *to)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __movsd((unsigned long*)to, (unsigned long*)from, table->entrySize >> 2);
+    } else {
+        js_memcpy(to, from, table->entrySize);
+    }
+#else
     js_memcpy(to, from, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
 JS_DHashClearEntryStub(JSDHashTable *table, JSDHashEntryHdr *entry)
 {
+#if _MSC_VER >= 1400
+    if ((table->entrySize & 3) == 0) {
+        __stosd((unsigned long*)entry, 0, table->entrySize >> 2);
+    } else {
+        memset(entry, 0, table->entrySize);
+    }
+#else
     memset(entry, 0, table->entrySize);
+#endif
 }
 
 JS_PUBLIC_API(void)
 JS_DHashFreeStringKey(JSDHashTable *table, JSDHashEntryHdr *entry)
 {
     const JSDHashEntryStub *stub = (const JSDHashEntryStub *)entry;
 
     UnwantedForeground::free_((void *) stub->key);
@@ -529,17 +548,39 @@ ChangeTable(JSDHashTable *table, int del
 #ifdef DEBUG
     recursionLevel = RECURSION_LEVEL(table);
 #endif
     table->hashShift = JS_DHASH_BITS - newLog2;
     table->removedCount = 0;
     table->generation++;
 
     /* Assign the new entry store to table. */
+#ifdef TT_MEMUTIL
+    {
+        static JSBool initialized = JS_FALSE;
+        static uint32_t dwNonTemporalDataSizeMin = NON_TEMPORAL_STORES_NOT_SUPPORTED;
+
+        if (!initialized) {
+            dwNonTemporalDataSizeMin = GetNonTemporalDataSizeMin_tt();
+            initialized = JS_TRUE;
+        }
+
+        if (nbytes < dwNonTemporalDataSizeMin ||
+            NON_TEMPORAL_STORES_NOT_SUPPORTED == dwNonTemporalDataSizeMin)
+        {
+            memset(newEntryStore, 0, nbytes);
+        }
+        else
+        {
+            memset_nontemporal_tt(newEntryStore, 0, nbytes);
+        }
+    }
+#else
     memset(newEntryStore, 0, nbytes);
+#endif
     oldEntryAddr = oldEntryStore = table->entryStore;
     table->entryStore = newEntryStore;
     moveEntry = table->ops->moveEntry;
 #ifdef DEBUG
     RECURSION_LEVEL(table) = recursionLevel;
 #endif
 
     /* Copy only live entries, leaving removed ones behind. */
