diff --git a/image/src/imgFrame.cpp b/image/src/imgFrame.cpp
--- a/image/src/imgFrame.cpp
+++ b/image/src/imgFrame.cpp
@@ -437,16 +437,19 @@ void imgFrame::Draw(gfxContext *aContext
                     const nsIntMargin &aPadding, const nsIntRect &aSubimage,
                     uint32_t aImageFlags)
 {
   SAMPLE_LABEL("image", "imgFrame::Draw");
   NS_ASSERTION(!aFill.IsEmpty(), "zero dest size --- fix caller");
   NS_ASSERTION(!aSubimage.IsEmpty(), "zero source size --- fix caller");
   NS_ASSERTION(!mPalettedImageData, "Directly drawing a paletted image!");
 
+  bool drawSingleImage = (aContext->GetFlags() & gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+  aContext->ClearFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+
   bool doPadding = aPadding != nsIntMargin(0,0,0,0);
   bool doPartialDecode = !ImageComplete();
 
   if (mSinglePixel && !doPadding && !doPartialDecode) {
     DoSingleColorFastPath(aContext, mSinglePixelColor, aFill);
     return;
   }
 
@@ -455,24 +458,27 @@ void imgFrame::Draw(gfxContext *aContext
   gfxRect imageRect(0, 0, mSize.width + aPadding.LeftRight(),
                     mSize.height + aPadding.TopBottom());
   gfxRect subimage(aSubimage.x, aSubimage.y, aSubimage.width, aSubimage.height);
   gfxRect fill = aFill;
 
   NS_ASSERTION(!sourceRect.Intersect(subimage).IsEmpty(),
                "We must be allowed to sample *some* source pixels!");
 
-  bool doTile = !imageRect.Contains(sourceRect) &&
-                !(aImageFlags & imgIContainer::FLAG_CLAMP);
+  bool doTile = (drawSingleImage ? false : (!imageRect.Contains(sourceRect) &&
+                !(aImageFlags & imgIContainer::FLAG_CLAMP)));
   SurfaceWithFormat surfaceResult =
     SurfaceForDrawing(doPadding, doPartialDecode, doTile, aPadding,
                       userSpaceToImageSpace, fill, subimage, sourceRect,
                       imageRect);
 
   if (surfaceResult.IsValid()) {
+    if (drawSingleImage) {
+      aContext->SetFlag(gfxContext::FLAG_DRAW_SINGLE_IMAGE_TT);
+    }
     gfxUtils::DrawPixelSnapped(aContext, surfaceResult.mDrawable,
                                userSpaceToImageSpace,
                                subimage, sourceRect, imageRect, fill,
                                surfaceResult.mFormat, aFilter, aImageFlags);
   }
 }
 
 nsresult imgFrame::Extract(const nsIntRect& aRegion, imgFrame** aResult)
