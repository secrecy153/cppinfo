diff --git a/content/svg/content/src/nsSVGFilters.cpp b/content/svg/content/src/nsSVGFilters.cpp
--- a/content/svg/content/src/nsSVGFilters.cpp
+++ b/content/svg/content/src/nsSVGFilters.cpp
@@ -1,13 +1,17 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+#include <omp.h>
+#endif
+
 #include "mozilla/Util.h"
 
 #include "nsSVGElement.h"
 #include "nsGkAtoms.h"
 #include "nsSVGNumber2.h"
 #include "nsSVGNumberPair.h"
 #include "nsSVGInteger.h"
 #include "nsSVGIntegerPair.h"
@@ -935,16 +939,36 @@ nsSVGFEBlendElement::Filter(nsSVGFilterI
   CopyRect(aTarget, aSources[0], rect);
 
   uint8_t* sourceData = aSources[1]->mImage->Data();
   uint8_t* targetData = aTarget->mImage->Data();
   uint32_t stride = aTarget->mImage->Stride();
 
   uint16_t mode = mEnumAttributes[MODE].GetAnimValue();
 
+  switch (mode) {
+    case nsSVGFEBlendElement::SVG_MODE_NORMAL:
+    case nsSVGFEBlendElement::SVG_MODE_MULTIPLY:
+    case nsSVGFEBlendElement::SVG_MODE_SCREEN:
+    case nsSVGFEBlendElement::SVG_MODE_DARKEN:
+    case nsSVGFEBlendElement::SVG_MODE_LIGHTEN:
+      break;
+    default:
+      return NS_ERROR_FAILURE;
+      break;
+  }
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, targetData, sourceData, mode) \
+if (omp_thread_counts >= 2 && \
+   (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 7000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t x = rect.x; x < rect.XMost(); x++) {
     for (int32_t y = rect.y; y < rect.YMost(); y++) {
       uint32_t targIndex = y * stride + 4 * x;
       uint32_t qa = targetData[targIndex + GFX_ARGB32_OFFSET_A];
       uint32_t qb = sourceData[targIndex + GFX_ARGB32_OFFSET_A];
       for (int32_t i = NS_MIN(GFX_ARGB32_OFFSET_B, GFX_ARGB32_OFFSET_R);
            i <= NS_MAX(GFX_ARGB32_OFFSET_B, GFX_ARGB32_OFFSET_R); i++) {
         uint32_t ca = targetData[targIndex + i];
@@ -963,21 +987,19 @@ nsSVGFEBlendElement::Filter(nsSVGFilterI
           case nsSVGFEBlendElement::SVG_MODE_DARKEN:
             val = NS_MIN((255 - qa) * cb + 255 * ca,
                          (255 - qb) * ca + 255 * cb);
             break;
           case nsSVGFEBlendElement::SVG_MODE_LIGHTEN:
             val = NS_MAX((255 - qa) * cb + 255 * ca,
                          (255 - qb) * ca + 255 * cb);
             break;
-          default:
-            return NS_ERROR_FAILURE;
-            break;
         }
-        val = NS_MIN(val / 255, 255U);
+        FAST_DIVIDE_BY_255(val, val);
+        val = NS_MIN(val, 255U);
         targetData[targIndex + i] =  static_cast<uint8_t>(val);
       }
       uint32_t alpha = 255 * 255 - (255 - qa) * (255 - qb);
       FAST_DIVIDE_BY_255(targetData[targIndex + GFX_ARGB32_OFFSET_A], alpha);
     }
   }
   return NS_OK;
 }
@@ -1268,16 +1290,24 @@ nsSVGFEColorMatrixElement::Filter(nsSVGF
 
     memcpy(colorMatrix, luminanceToAlphaMatrix, sizeof(colorMatrix));
     break;
 
   default:
     return NS_ERROR_FAILURE;
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, sourceData, colorMatrix, targetData) \
+if (omp_thread_counts >= 2 && \
+   (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 2300)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t x = rect.x; x < rect.XMost(); x++) {
     for (int32_t y = rect.y; y < rect.YMost(); y++) {
       uint32_t targIndex = y * stride + 4 * x;
 
       float col[4];
       for (int i = 0, row = 0; i < 4; i++, row += 5) {
         col[i] =
           sourceData[targIndex + GFX_ARGB32_OFFSET_R] * colorMatrix[row + 0] +
@@ -1529,16 +1559,25 @@ nsSVGFECompositeElement::Filter(nsSVGFil
 
     uint8_t* sourceData = aSources[1]->mImage->Data();
     uint8_t* targetData = aTarget->mImage->Data();
     uint32_t stride = aTarget->mImage->Stride();
 
     // Blend in the second source image
     float k1Scaled = k1 / 255.0f;
     float k4Scaled = k4*255.0f;
+
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+    int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, targetData, sourceData, stride, k1Scaled, k2, k3, k4Scaled) \
+if (omp_thread_counts >= 2 && \
+    (rect.XMost() - rect.x) >= (uint32_t)omp_thread_counts && \
+    (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       for (int32_t y = rect.y; y < rect.YMost(); y++) {
         uint32_t targIndex = y * stride + 4 * x;
         for (int32_t i = 0; i < 4; i++) {
           uint8_t i1 = targetData[targIndex + i];
           uint8_t i2 = sourceData[targIndex + i];
           float result = k1Scaled*i1*i2 + k2*i1 + k3*i2 + k4Scaled;
           targetData[targIndex + i] =
@@ -1820,16 +1859,24 @@ nsSVGFEComponentTransferElement::Filter(
     nsRefPtr<nsSVGComponentTransferFunctionElement> child;
     CallQueryInterface(childContent,
             (nsSVGComponentTransferFunctionElement**)getter_AddRefs(child));
     if (child) {
       child->GenerateLookupTable(tables[child->GetChannel()]);
     }
   }
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, targetData, sourceData, tableB, tableG, tableR, tableA) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t targIndex = y * stride + x * 4;
       targetData[targIndex + GFX_ARGB32_OFFSET_B] =
         tableB[sourceData[targIndex + GFX_ARGB32_OFFSET_B]];
       targetData[targIndex + GFX_ARGB32_OFFSET_G] =
         tableG[sourceData[targIndex + GFX_ARGB32_OFFSET_G]];
       targetData[targIndex + GFX_ARGB32_OFFSET_R] =
@@ -1990,17 +2037,18 @@ nsSVGComponentTransferFunctionElement::G
 
   switch (type) {
   case nsIDOMSVGComponentTransferFunctionElement::SVG_FECOMPONENTTRANSFER_TYPE_TABLE:
   {
     if (tableValues.Length() <= 1)
       break;
 
     for (i = 0; i < 256; i++) {
-      uint32_t k = (i * (tvLength - 1)) / 255;
+      uint32_t k;
+      FAST_DIVIDE_BY_255(k, (i * (tvLength - 1)));
       float v1 = tableValues[k];
       float v2 = tableValues[NS_MIN(k + 1, tvLength - 1)];
       int32_t val =
         int32_t(255 * (v1 + (i/255.0f - k/float(tvLength-1))*(tvLength - 1)*(v2 - v1)));
       val = NS_MIN(255, val);
       val = NS_MAX(0, val);
       aTable[i] = val;
     }
@@ -2008,17 +2056,18 @@ nsSVGComponentTransferFunctionElement::G
   }
 
   case nsIDOMSVGComponentTransferFunctionElement::SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE:
   {
     if (tableValues.Length() <= 1)
       break;
 
     for (i = 0; i < 256; i++) {
-      uint32_t k = (i * tvLength) / 255;
+      uint32_t k;
+      FAST_DIVIDE_BY_255(k, (i * tvLength));
       k = NS_MIN(k, tvLength - 1);
       float v = tableValues[k];
       int32_t val = int32_t(255 * v);
       val = NS_MIN(255, val);
       val = NS_MAX(0, val);
       aTable[i] = val;
     }
     break;
@@ -3003,16 +3052,24 @@ nsSVGFETileElement::Filter(nsSVGFilterIn
   uint8_t* sourceData = aSources[0]->mImage->Data();
   uint8_t* targetData = aTarget->mImage->Data();
   uint32_t stride = aTarget->mImage->Stride();
 
   // the offset to add to our x/y coordinates (which are relative to the
   // temporary surface data) to get coordinates relative to the origin
   // of the tile
   nsIntPoint offset(-tile.x + tile.width, -tile.y + tile.height);
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, tile, surfaceRect, sourceData, targetData, stride, offset) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts  && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 10000)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     uint32_t tileY = tile.y + WrapInterval(y + offset.y, tile.height);
     if (tileY < (uint32_t)surfaceRect.height) {
       for (int32_t x = rect.x; x < rect.XMost(); x++) {
         uint32_t tileX = tile.x + WrapInterval(x + offset.x, tile.width);
         if (tileX < (uint32_t)surfaceRect.width) {
           *(uint32_t*)(targetData + y * stride + 4 * x) =
             *(uint32_t*)(sourceData + tileY * stride + 4 * tileX);
@@ -3333,16 +3390,25 @@ nsSVGFETurbulenceElement::Filter(nsSVGFi
 
     lowFreq = floor(filterHeight * fY) / filterHeight;
     hiFreq = ceil(filterHeight * fY) / filterHeight;
     if (fY / lowFreq < hiFreq / fY)
       fY = lowFreq;
     else
       fY = hiFreq;
   }
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, instance, filterSubregion, type, doStitch, \
+  filterX, filterY, filterWidth, filterHeight, fX, fY, octaves, targetData) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 130)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t targIndex = y * stride + x * 4;
       double point[2];
       point[0] = filterX + (filterWidth * (x + instance->GetSurfaceRect().x)) / (filterSubregion.width - 1);
       point[1] = filterY + (filterHeight * (y + instance->GetSurfaceRect().y)) / (filterSubregion.height - 1);
 
       float col[4];
@@ -3356,17 +3422,17 @@ nsSVGFETurbulenceElement::Filter(nsSVGFi
                                doStitch, filterX, filterY, filterWidth, filterHeight) * 255 + 255) / 2;
       }
       for (int i = 0; i < 4; i++) {
         col[i] = NS_MIN(col[i], 255.f);
         col[i] = NS_MAX(col[i], 0.f);
       }
 
       uint8_t r, g, b, a;
-      a = uint8_t(col[3]);
+      a = (uint8_t)(col[3]);
       FAST_DIVIDE_BY_255(r, unsigned(col[0]) * a);
       FAST_DIVIDE_BY_255(g, unsigned(col[1]) * a);
       FAST_DIVIDE_BY_255(b, unsigned(col[2]) * a);
 
       targetData[targIndex + GFX_ARGB32_OFFSET_B] = b;
       targetData[targIndex + GFX_ARGB32_OFFSET_G] = g;
       targetData[targIndex + GFX_ARGB32_OFFSET_R] = r;
       targetData[targIndex + GFX_ARGB32_OFFSET_A] = a;
@@ -3821,21 +3887,29 @@ nsSVGFEMorphologyElement::Filter(nsSVGFi
 
   // Clamp radii to prevent completely insane values:
   rx = NS_MIN(rx, 100000);
   ry = NS_MIN(ry, 100000);
 
   uint8_t* sourceData = aSources[0]->mImage->Data();
   uint8_t* targetData = aTarget->mImage->Data();
   int32_t stride = aTarget->mImage->Stride();
-  uint8_t extrema[4];         // RGBA magnitude of extrema
   uint16_t op = mEnumAttributes[OPERATOR].GetAnimValue();
 
   // Scan the kernel for each pixel to determine max/min RGBA values.
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, rx, ry, instance, sourceData, targetData, stride, op) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts &&\
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1800)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
+    uint8_t extrema[4];         // RGBA magnitude of extrema
     int32_t startY = NS_MAX(0, y - ry);
     // We need to read pixels not just in 'rect', which is limited to
     // the dirty part of our filter primitive subregion, but all pixels in
     // the given radii from the source surface, so use the surface size here.
     int32_t endY = NS_MIN(y + ry, instance->GetSurfaceHeight() - 1);
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       int32_t startX = NS_MAX(0, x - rx);
       int32_t endX = NS_MIN(x + rx, instance->GetSurfaceWidth() - 1);
@@ -4319,16 +4393,25 @@ nsSVGFEConvolveMatrixElement::Filter(nsS
 
   const nsIntRect& dataRect = info.mDataRect;
   int32_t stride = info.mSource->Stride();
   int32_t width = info.mSource->GetSize().width;
   int32_t height = info.mSource->GetSize().height;
   uint8_t *sourceData = info.mSource->Data();
   uint8_t *targetData = info.mTarget->Data();
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(dataRect, sourceData, targetData, width, height, stride, edgeMode, \
+  kernel, divisor, bias, preserveAlpha, orderX, orderY, targetX, targetY) \
+if (omp_thread_counts >= 2 && \
+   (dataRect.YMost() - dataRect.y) >= (uint32_t)omp_thread_counts && \
+   (dataRect.YMost() - dataRect.y) * (dataRect.XMost() - dataRect.x) >= 200)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = dataRect.y; y < dataRect.YMost(); y++) {
     for (int32_t x = dataRect.x; x < dataRect.XMost(); x++) {
       ConvolvePixel(sourceData, targetData,
                     width, height, stride,
                     x, y,
                     edgeMode, kernel, divisor, bias, preserveAlpha,
                     orderX, orderY, targetX, targetY);
     }
@@ -5039,26 +5122,26 @@ nsSVGFELightingElement::Filter(nsSVGFilt
       break;
   }
 
   if (!distantLight && !pointLight && !spotLight)
     return NS_ERROR_FAILURE;
 
   const float radPerDeg = M_PI/180.0;
 
-  float L[3];
+  float L_orig[3];
   if (distantLight) {
     float azimuth, elevation;
     static_cast<nsSVGFEDistantLightElement*>
       (distantLight.get())->GetAnimatedNumberValues(&azimuth,
                                                     &elevation,
                                                     nullptr);
-    L[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
-    L[2] = sin(elevation * radPerDeg);
+    L_orig[0] = cos(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[1] = sin(azimuth * radPerDeg) * cos(elevation * radPerDeg);
+    L_orig[2] = sin(elevation * radPerDeg);
   }
   float lightPos[3], pointsAt[3], specularExponent;
   float cosConeAngle = 0;
   if (pointLight) {
     static_cast<nsSVGFEPointLightElement*>
       (pointLight.get())->GetAnimatedNumberValues(lightPos,
                                                   lightPos + 1,
                                                   lightPos + 2,
@@ -5091,21 +5174,31 @@ nsSVGFELightingElement::Filter(nsSVGFilt
 
   const nsIntRect& dataRect = info.mDataRect;
   int32_t stride = info.mSource->Stride();
   uint8_t *sourceData = info.mSource->Data();
   uint8_t *targetData = info.mTarget->Data();
   int32_t surfaceWidth = info.mSource->Width();
   int32_t surfaceHeight = info.mSource->Height();
   
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(dataRect, stride, sourceData, surfaceWidth, surfaceHeight, surfaceScale, pointLight, spotLight, lightPos, L_orig, pointsAt, lightColor, targetData, cosConeAngle, specularExponent, instance) \
+if (omp_thread_counts >= 2 && \
+   (dataRect.YMost() - dataRect.y) >= (uint32_t)omp_thread_counts && \
+   (dataRect.XMost() - dataRect.x) * (dataRect.YMost() - dataRect.y) >= 200)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = dataRect.y; y < dataRect.YMost(); y++) {
     for (int32_t x = dataRect.x; x < dataRect.XMost(); x++) {
       int32_t index = y * stride + x * 4;
 
       float N[3];
+      float L[3];
+      memcpy(L, L_orig, sizeof(L));
       GenerateNormal(N, sourceData, stride, surfaceWidth, surfaceHeight,
                      x, y, surfaceScale);
 
       if (pointLight || spotLight) {
         gfxPoint pt = instance->FilterSpaceToUserSpace(
                 gfxPoint(x + instance->GetSurfaceRect().x,
                          y + instance->GetSurfaceRect().y));
         float Z = surfaceScale * sourceData[index + GFX_ARGB32_OFFSET_A] / 255;
@@ -6010,16 +6103,25 @@ nsSVGFEDisplacementMapElement::Filter(ns
                              GFX_ARGB32_OFFSET_B,
                              GFX_ARGB32_OFFSET_A };
   uint16_t xChannel = channelMap[mEnumAttributes[CHANNEL_X].GetAnimValue()];
   uint16_t yChannel = channelMap[mEnumAttributes[CHANNEL_Y].GetAnimValue()];
 
   double scaleOver255 = scale / 255.0;
   double scaleAdjustment = 0.5 - 0.5 * scale;
 
+#if defined(TT_MEMUTIL) && defined(_MSC_VER)
+  int omp_thread_counts = omp_get_max_threads();
+#pragma omp parallel for schedule(guided) default(none) \
+shared(rect, stride, scaleOver255, displacementData, xChannel, yChannel, \
+  scaleAdjustment, width, height, targetData, sourceData, dummyData) \
+if (omp_thread_counts >= 2 && \
+   (rect.YMost() - rect.y) >= (uint32_t)omp_thread_counts && \
+   (rect.XMost() - rect.x) * (rect.YMost() - rect.y) >= 1500)
+#endif // defined(TT_MEMUTIL) && defined(_MSC_VER)
   for (int32_t y = rect.y; y < rect.YMost(); y++) {
     for (int32_t x = rect.x; x < rect.XMost(); x++) {
       uint32_t targIndex = y * stride + 4 * x;
       // At some point we might want to replace this with a bilinear sample.
       int32_t sourceX = x +
         NSToIntFloor(scaleOver255 * displacementData[targIndex + xChannel] +
                 scaleAdjustment);
       int32_t sourceY = y +
