diff -r 7e511b8473ff media/libpng/CHANGES
--- a/media/libpng/CHANGES	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/CHANGES	Tue Jan 29 22:34:41 2013 +0900
@@ -3919,6 +3919,76 @@
 Version 1.5.13 [September 27, 2012]
   No changes.
 
+Version 1.5.14beta01 [October 24, 2012]
+  Added -DZ_SOLO to contrib/pngminim/*/makefile to work with zlib-1.2.7
+  Warn about the incorrect runtime library setting for VS2010 debug DLL builds.
+  Fixed build when using #define PNG_NO_READ_GAMMA in png_do_compose() in
+    pngrtran.c (Domani Hannes).
+
+Version 1.5.14beta02 [omitted]
+
+Version 1.5.14beta03 [December 15, 2012]
+  Added missing "-" in front of DNO_GZIP in contrib/pngminim/*/makefile.
+  Check for png_ptr==NULL earlier in png_zalloc().
+  Ignore, with a warning, out-of-range value of num_trans in png_set_tRNS().
+  Rearranged building of ARM NEON optimizations. The ARM specific code is
+    split out entirely to the arm subdirectory and changes to configure.ac and
+    Makefile.am to add new stuff are reduced.  Now material code changes,
+    although for build test purposes, --enable-arm-neon now builds on non-ARM
+    systems.
+  Rebuilt Makefile.in, configure, etc., with autoconf-2.69 and automake-1.12.5.
+  Fixed cases of unquoted DESTDIR in Makefile.am
+  Fixed a minor bug in types to malloc and major bug in handling compressed
+    iTXt. Compressed iTXt could not be handled.
+
+Version 1.5.14beta04 [December 19, 2012]
+  Cleaned up whitespace in the synopsis portion of the manpage "libpng.3"
+  Disassembled the version number in scripts/options.awk (necessary for
+    building on SunOs).
+
+Version 1.5.14beta05 [December 23, 2012]
+  Fixed Windows build issues, enabled ARM compilation. Various warnings issued
+    by earlier versions of GCC fixed for Cygwin and Min/GW (which both use old
+    GCCs.) ARM support is enabled by default in zlib.props (unsupported by
+    Microsoft) and ARM compilation is made possible by deleting the check for
+    x86. The test programs cannot be run because they are not signed.
+
+Version 1.5.14beta06 [January 1, 2013]
+  Discontinued distributing libpng-1.5.14-1.5.13-diff.txt and similar.
+  Fixed 'make distcheck' on SUN OS - libpng.so was not being removed
+
+Version 1.5.14beta07 [January 6, 2012]
+  Replaced AM_CONFIG_HEADER(config.h) with AC_CONFIG_HEADERS([config.h])
+    in configure.ac
+  De-configured build fixes to make a range of deconfiguration options (such
+    as switching off read or write support) work in more cases.  Also upgraded
+    pngtest and pngvalid to the libpng 1.6 versions (with some modifications)
+    which provide more extensive testing.  Replaced pngtest.png because pngtest
+    writes the ancillary chunks in a different order.
+
+Version 1.5.14beta08 [January 10, 2013]
+  Check validity of "num_unknowns" parameter of png_set_unknown_chunks()
+    (Bug report from yuris).
+
+Version 1.5.14rc01 [January 17, 2013]
+  No changes.
+
+Version 1.5.14rc02 [January 17, 2013]
+  Revised test for validity of "num_unknowns" to eliminate compiler warnings.
+
+Version 1.5.14rc03 [January 18, 2013]
+  Check the validity of the "nentries" parameter of png_set_sPLT() and the
+  "num_text" parameter of png_set_text_2().
+
+Version 1.5.14 [January 24, 2013]
+  Removed an obsolete line from the manual.
+
+  ===========================================================================
+                       NOTICE November 17, 2012:
+     The location of the git repository at SourceForge has changed.
+               Visit http://libpng.sf.net/ for details.
+  ===========================================================================
+
 Send comments/corrections/commendations to png-mng-implement at lists.sf.net
 (subscription required; visit
 https://lists.sourceforge.net/lists/listinfo/png-mng-implement
diff -r 7e511b8473ff media/libpng/LICENSE
--- a/media/libpng/LICENSE	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/LICENSE	Tue Jan 29 22:34:41 2013 +0900
@@ -10,7 +10,7 @@
 
 This code is released under the libpng license.
 
-libpng versions 1.2.6, August 15, 2004, through 1.5.13, September 27, 2012, are
+libpng versions 1.2.6, August 15, 2004, through 1.5.14, January 24, 2013, are
 Copyright (c) 2004, 2006-2012 Glenn Randers-Pehrson, and are
 distributed according to the same disclaimer and license as libpng-1.2.5
 with the following individual added to the list of Contributing Authors
@@ -108,4 +108,4 @@
 
 Glenn Randers-Pehrson
 glennrp at users.sourceforge.net
-September 27, 2012
+January 24, 2013
diff -r 7e511b8473ff media/libpng/MOZCHANGES
--- a/media/libpng/MOZCHANGES	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/MOZCHANGES	Tue Jan 29 22:34:41 2013 +0900
@@ -1,6 +1,12 @@
 
 Changes made to pristine png source by mozilla.org developers.
 
+2013/01/24  -- Synced with libpng-1.5.14 (bug #832487).
+
+2013/01/23  -- Disabled TEXT support in mozpngconf.h (bug #833594).
+
+2012/10/02  -- Synced with libpng-1.5.13 (bug #775662).
+
 2012/07/16  -- Add an "APNG-aware app" flag (bug #759067).
 
 2012/07/04  -- Synced with libpng-1.5.11 (bug #771394).
diff -r 7e511b8473ff media/libpng/README
--- a/media/libpng/README	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/README	Tue Jan 29 22:34:41 2013 +0900
@@ -1,4 +1,4 @@
-README for libpng version 1.5.13 - September 27, 2012 (shared library 15.0)
+README for libpng version 1.5.14 - January 24, 2013 (shared library 15.0)
 See the note about version numbers near the top of png.h
 
 See INSTALL for instructions on how to install libpng.
diff -r 7e511b8473ff media/libpng/apng.patch
--- a/media/libpng/apng.patch	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/apng.patch	Tue Jan 29 22:34:41 2013 +0900
@@ -1,207 +1,7 @@
-diff -up8 png.h png.h
---- png.h	2012-09-27 07:21:20 -0400
-+++ png.h	2012-09-29 11:47:33 -0400
-@@ -427,24 +427,18 @@
- /* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
-  * We must not include leading zeros.
-  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
-  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
-  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
-  */
- #define PNG_LIBPNG_VER 10513 /* 1.5.13 */
- 
--/* Library configuration: these options cannot be changed after
-- * the library has been built.
-- */
--#ifndef PNGLCONF_H
--    /* If pnglibconf.h is missing, you can
--     * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
--     */
--#   include "pnglibconf.h"
-+#ifndef MOZPNGCONF_H
-+#   include "mozpngconf.h"
- #endif
- 
- #ifndef PNG_VERSION_INFO_ONLY
- #  ifndef PNG_BUILDING_SYMBOL_TABLE
-   /*
-    *   Standard header files (not needed for the version info or while
-    *   building symbol table -- see scripts/pnglibconf.dfa)
-    */
-@@ -544,16 +538,27 @@ extern "C" {
-  * Otherwise the calls are mapped to png_error.
-  */
- 
- /* Section 2: type definitions, including structures and compile time
-  * constants.
-  * See pngconf.h for base types that vary by machine/system
-  */
- 
-+#ifdef PNG_APNG_SUPPORTED
-+/* dispose_op flags from inside fcTL */
-+#define PNG_DISPOSE_OP_NONE        0x00
-+#define PNG_DISPOSE_OP_BACKGROUND  0x01
-+#define PNG_DISPOSE_OP_PREVIOUS    0x02
-+
-+/* blend_op flags from inside fcTL */
-+#define PNG_BLEND_OP_SOURCE        0x00
-+#define PNG_BLEND_OP_OVER          0x01
-+#endif /* PNG_APNG_SUPPORTED */
-+
- /* This triggers a compiler error in png.c, if png.c and png.h
-  * do not agree upon the version number.
-  */
- typedef char* png_libpng_version_1_5_13;
- 
- /* Three color definitions.  The order of the red, green, and blue, (and the
-  * exact size) is not important, although the size of the fields need to
-  * be png_byte or png_uint_16 (as defined below).
-@@ -827,16 +832,20 @@ typedef png_info FAR * FAR * png_infopp;
- #define PNG_INFO_oFFs 0x0100
- #define PNG_INFO_tIME 0x0200
- #define PNG_INFO_pCAL 0x0400
- #define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
- #define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
- #define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
- #define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
- #define PNG_INFO_IDAT 0x8000   /* ESR, 1.0.6 */
-+#ifdef PNG_APNG_SUPPORTED
-+#define PNG_INFO_acTL 0x10000
-+#define PNG_INFO_fcTL 0x20000
-+#endif
- 
- /* This is used for the transformation routines, as some of them
-  * change these values for the row.  It also should enable using
-  * the routines for other purposes.
-  */
- typedef struct png_row_info_struct
- {
-    png_uint_32 width;    /* width of row */
-@@ -872,16 +881,20 @@ typedef PNG_CALLBACK(void, *png_flush_pt
- typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
-     int));
- typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
-     int));
- 
- #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
- typedef PNG_CALLBACK(void, *png_progressive_info_ptr, (png_structp, png_infop));
- typedef PNG_CALLBACK(void, *png_progressive_end_ptr, (png_structp, png_infop));
-+#ifdef PNG_APNG_SUPPORTED
-+typedef PNG_CALLBACK(void, *png_progressive_frame_ptr, (png_structp,
-+    png_uint_32));
-+#endif
- 
- /* The following callback receives png_uint_32 row_number, int pass for the
-  * png_bytep data of the row.  When transforming an interlaced image the
-  * row number is the row number within the sub-image of the interlace pass, so
-  * the value will increase to the height of the sub-image (not the full image)
-  * then reset to 0 for the next pass.
-  *
-  * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
-@@ -2648,26 +2661,99 @@ PNG_EXPORT(207, void, png_save_uint_16, 
- #endif
- 
- #if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
-     defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
- PNG_EXPORT(234, void, png_set_check_for_invalid_index, (png_structp png_ptr,
-     int allowed));
- #endif
- 
-+#ifdef PNG_APNG_SUPPORTED
-+PNG_EXPORT(235, png_uint_32, png_get_acTL, (png_structp png_ptr,
-+   png_infop info_ptr, png_uint_32 *num_frames, png_uint_32 *num_plays));
-+
-+PNG_EXPORT(236, png_uint_32, png_set_acTL, (png_structp png_ptr,
-+   png_infop info_ptr, png_uint_32 num_frames, png_uint_32 num_plays));
-+
-+PNG_EXPORT(237, png_uint_32, png_get_num_frames, (png_structp png_ptr,
-+   png_infop info_ptr));
-+
-+PNG_EXPORT(238, png_uint_32, png_get_num_plays, (png_structp png_ptr,
-+   png_infop info_ptr));
-+
-+PNG_EXPORT(239, png_uint_32, png_get_next_frame_fcTL,
-+   (png_structp png_ptr, png_infop info_ptr, png_uint_32 *width,
-+   png_uint_32 *height, png_uint_32 *x_offset, png_uint_32 *y_offset,
-+   png_uint_16 *delay_num, png_uint_16 *delay_den, png_byte *dispose_op,
-+   png_byte *blend_op));
-+
-+PNG_EXPORT(240, png_uint_32, png_set_next_frame_fcTL,
-+   (png_structp png_ptr, png_infop info_ptr, png_uint_32 width,
-+   png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset,
-+   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
-+   png_byte blend_op));
-+
-+PNG_EXPORT(241, png_uint_32, png_get_next_frame_width,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(242, png_uint_32, png_get_next_frame_height,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(243, png_uint_32, png_get_next_frame_x_offset,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(244, png_uint_32, png_get_next_frame_y_offset,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_num,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(246, png_uint_16, png_get_next_frame_delay_den,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(247, png_byte, png_get_next_frame_dispose_op,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(248, png_byte, png_get_next_frame_blend_op,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(249, png_byte, png_get_first_frame_is_hidden,
-+   (png_structp png_ptr, png_infop info_ptr));
-+PNG_EXPORT(250, png_uint_32, png_set_first_frame_is_hidden,
-+   (png_structp png_ptr, png_infop info_ptr, png_byte is_hidden));
-+
-+#ifdef PNG_READ_APNG_SUPPORTED
-+PNG_EXPORT(251, void, png_read_frame_head, (png_structp png_ptr,
-+   png_infop info_ptr));
-+#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
-+PNG_EXPORT(252, void, png_set_progressive_frame_fn, (png_structp png_ptr,
-+   png_progressive_frame_ptr frame_info_fn,
-+   png_progressive_frame_ptr frame_end_fn));
-+#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
-+#endif /* PNG_READ_APNG_SUPPORTED */
-+
-+#ifdef PNG_WRITE_APNG_SUPPORTED
-+PNG_EXPORT(253, void, png_write_frame_head, (png_structp png_ptr,
-+   png_infop info_ptr, png_bytepp row_pointers,
-+   png_uint_32 width, png_uint_32 height,
-+   png_uint_32 x_offset, png_uint_32 y_offset,
-+   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
-+   png_byte blend_op));
-+
-+PNG_EXPORT(254, void, png_write_frame_tail, (png_structp png_ptr,
-+   png_infop info_ptr));
-+#endif /* PNG_WRITE_APNG_SUPPORTED */
-+#endif /* PNG_APNG_SUPPORTED */
-+
- /* Maintainer: Put new public prototypes here ^, in libpng.3, and project
-  * defs
-  */
- 
- /* The last ordinal number (this is the *last* one already used; the next
-  * one to use is one more than this.)  Maintainer, remember to add an entry to
-  * scripts/symbols.def as well.
-  */
- #ifdef PNG_EXPORT_LAST_ORDINAL
-+#ifdef PNG_APNG_SUPPORTED
-+  PNG_EXPORT_LAST_ORDINAL(254);
-+#else
-   PNG_EXPORT_LAST_ORDINAL(234);
-+#endif /* PNG_APNG_SUPPORTED */
- #endif
- 
- #ifdef __cplusplus
- }
- #endif
- 
- #endif /* PNG_VERSION_INFO_ONLY */
- /* Do not put anything past this line */
 diff -up8 pngget.c pngget.c
---- pngget.c	2012-09-27 07:21:20 -0400
-+++ pngget.c	2012-07-04 16:27:29 -0400
-@@ -1116,9 +1116,171 @@ png_get_io_chunk_type (png_const_structp
+--- pngget.c	2013-01-23 20:59:04.248740505 -0600
++++ pngget.c	2013-01-23 23:45:07.921684477 -0600
+@@ -1122,9 +1122,171 @@ png_get_io_chunk_type (png_const_structp
  png_const_bytep PNGAPI
  png_get_io_chunk_name (png_structp png_ptr)
  {
@@ -373,9 +173,209 @@
 +}
 +#endif /* PNG_APNG_SUPPORTED */
  #endif /* PNG_READ_SUPPORTED || PNG_WRITE_SUPPORTED */
+diff -up8 png.h png.h
+--- png.h	2013-01-23 20:59:04.140980775 -0600
++++ png.h	2013-01-23 23:46:23.693288001 -0600
+@@ -430,24 +430,18 @@
+ /* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
+  * We must not include leading zeros.
+  * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
+  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
+  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
+  */
+ #define PNG_LIBPNG_VER 10514 /* 1.5.14 */
+ 
+-/* Library configuration: these options cannot be changed after
+- * the library has been built.
+- */
+-#ifndef PNGLCONF_H
+-    /* If pnglibconf.h is missing, you can
+-     * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
+-     */
+-#   include "pnglibconf.h"
++#ifndef MOZPNGCONF_H
++#   include "mozpngconf.h"
+ #endif
+ 
+ #ifndef PNG_VERSION_INFO_ONLY
+ #  ifndef PNG_BUILDING_SYMBOL_TABLE
+   /*
+    *   Standard header files (not needed for the version info or while
+    *   building symbol table -- see scripts/pnglibconf.dfa)
+    */
+@@ -547,16 +541,27 @@ extern "C" {
+  * Otherwise the calls are mapped to png_error.
+  */
+ 
+ /* Section 2: type definitions, including structures and compile time
+  * constants.
+  * See pngconf.h for base types that vary by machine/system
+  */
+ 
++#ifdef PNG_APNG_SUPPORTED
++/* dispose_op flags from inside fcTL */
++#define PNG_DISPOSE_OP_NONE        0x00
++#define PNG_DISPOSE_OP_BACKGROUND  0x01
++#define PNG_DISPOSE_OP_PREVIOUS    0x02
++
++/* blend_op flags from inside fcTL */
++#define PNG_BLEND_OP_SOURCE        0x00
++#define PNG_BLEND_OP_OVER          0x01
++#endif /* PNG_APNG_SUPPORTED */
++
+ /* This triggers a compiler error in png.c, if png.c and png.h
+  * do not agree upon the version number.
+  */
+ typedef char* png_libpng_version_1_5_14;
+ 
+ /* Three color definitions.  The order of the red, green, and blue, (and the
+  * exact size) is not important, although the size of the fields need to
+  * be png_byte or png_uint_16 (as defined below).
+@@ -830,16 +835,20 @@ typedef png_info FAR * FAR * png_infopp;
+ #define PNG_INFO_oFFs 0x0100
+ #define PNG_INFO_tIME 0x0200
+ #define PNG_INFO_pCAL 0x0400
+ #define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
+ #define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
+ #define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
+ #define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
+ #define PNG_INFO_IDAT 0x8000   /* ESR, 1.0.6 */
++#ifdef PNG_APNG_SUPPORTED
++#define PNG_INFO_acTL 0x10000
++#define PNG_INFO_fcTL 0x20000
++#endif
+ 
+ /* This is used for the transformation routines, as some of them
+  * change these values for the row.  It also should enable using
+  * the routines for other purposes.
+  */
+ typedef struct png_row_info_struct
+ {
+    png_uint_32 width;    /* width of row */
+@@ -875,16 +884,20 @@ typedef PNG_CALLBACK(void, *png_flush_pt
+ typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
+     int));
+ typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
+     int));
+ 
+ #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
+ typedef PNG_CALLBACK(void, *png_progressive_info_ptr, (png_structp, png_infop));
+ typedef PNG_CALLBACK(void, *png_progressive_end_ptr, (png_structp, png_infop));
++#ifdef PNG_APNG_SUPPORTED
++typedef PNG_CALLBACK(void, *png_progressive_frame_ptr, (png_structp,
++    png_uint_32));
++#endif
+ 
+ /* The following callback receives png_uint_32 row_number, int pass for the
+  * png_bytep data of the row.  When transforming an interlaced image the
+  * row number is the row number within the sub-image of the interlace pass, so
+  * the value will increase to the height of the sub-image (not the full image)
+  * then reset to 0 for the next pass.
+  *
+  * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
+@@ -2651,26 +2664,99 @@ PNG_EXPORT(207, void, png_save_uint_16,
+ #endif
+ 
+ #if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
+     defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
+ PNG_EXPORT(234, void, png_set_check_for_invalid_index, (png_structp png_ptr,
+     int allowed));
+ #endif
+ 
++#ifdef PNG_APNG_SUPPORTED
++PNG_EXPORT(235, png_uint_32, png_get_acTL, (png_structp png_ptr,
++   png_infop info_ptr, png_uint_32 *num_frames, png_uint_32 *num_plays));
++
++PNG_EXPORT(236, png_uint_32, png_set_acTL, (png_structp png_ptr,
++   png_infop info_ptr, png_uint_32 num_frames, png_uint_32 num_plays));
++
++PNG_EXPORT(237, png_uint_32, png_get_num_frames, (png_structp png_ptr,
++   png_infop info_ptr));
++
++PNG_EXPORT(238, png_uint_32, png_get_num_plays, (png_structp png_ptr,
++   png_infop info_ptr));
++
++PNG_EXPORT(239, png_uint_32, png_get_next_frame_fcTL,
++   (png_structp png_ptr, png_infop info_ptr, png_uint_32 *width,
++   png_uint_32 *height, png_uint_32 *x_offset, png_uint_32 *y_offset,
++   png_uint_16 *delay_num, png_uint_16 *delay_den, png_byte *dispose_op,
++   png_byte *blend_op));
++
++PNG_EXPORT(240, png_uint_32, png_set_next_frame_fcTL,
++   (png_structp png_ptr, png_infop info_ptr, png_uint_32 width,
++   png_uint_32 height, png_uint_32 x_offset, png_uint_32 y_offset,
++   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
++   png_byte blend_op));
++
++PNG_EXPORT(241, png_uint_32, png_get_next_frame_width,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(242, png_uint_32, png_get_next_frame_height,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(243, png_uint_32, png_get_next_frame_x_offset,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(244, png_uint_32, png_get_next_frame_y_offset,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(245, png_uint_16, png_get_next_frame_delay_num,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(246, png_uint_16, png_get_next_frame_delay_den,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(247, png_byte, png_get_next_frame_dispose_op,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(248, png_byte, png_get_next_frame_blend_op,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(249, png_byte, png_get_first_frame_is_hidden,
++   (png_structp png_ptr, png_infop info_ptr));
++PNG_EXPORT(250, png_uint_32, png_set_first_frame_is_hidden,
++   (png_structp png_ptr, png_infop info_ptr, png_byte is_hidden));
++
++#ifdef PNG_READ_APNG_SUPPORTED
++PNG_EXPORT(251, void, png_read_frame_head, (png_structp png_ptr,
++   png_infop info_ptr));
++#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
++PNG_EXPORT(252, void, png_set_progressive_frame_fn, (png_structp png_ptr,
++   png_progressive_frame_ptr frame_info_fn,
++   png_progressive_frame_ptr frame_end_fn));
++#endif /* PNG_PROGRESSIVE_READ_SUPPORTED */
++#endif /* PNG_READ_APNG_SUPPORTED */
++
++#ifdef PNG_WRITE_APNG_SUPPORTED
++PNG_EXPORT(253, void, png_write_frame_head, (png_structp png_ptr,
++   png_infop info_ptr, png_bytepp row_pointers,
++   png_uint_32 width, png_uint_32 height,
++   png_uint_32 x_offset, png_uint_32 y_offset,
++   png_uint_16 delay_num, png_uint_16 delay_den, png_byte dispose_op,
++   png_byte blend_op));
++
++PNG_EXPORT(254, void, png_write_frame_tail, (png_structp png_ptr,
++   png_infop info_ptr));
++#endif /* PNG_WRITE_APNG_SUPPORTED */
++#endif /* PNG_APNG_SUPPORTED */
++
+ /* Maintainer: Put new public prototypes here ^, in libpng.3, and project
+  * defs
+  */
+ 
+ /* The last ordinal number (this is the *last* one already used; the next
+  * one to use is one more than this.)  Maintainer, remember to add an entry to
+  * scripts/symbols.def as well.
+  */
+ #ifdef PNG_EXPORT_LAST_ORDINAL
++#ifdef PNG_APNG_SUPPORTED
++  PNG_EXPORT_LAST_ORDINAL(254);
++#else
+   PNG_EXPORT_LAST_ORDINAL(234);
++#endif /* PNG_APNG_SUPPORTED */
+ #endif
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+ 
+ #endif /* PNG_VERSION_INFO_ONLY */
+ /* Do not put anything past this line */
 diff -up8 pnginfo.h pnginfo.h
---- pnginfo.h	2012-09-27 07:21:20 -0400
-+++ pnginfo.h	2012-07-04 16:27:29 -0400
+--- pnginfo.h	2013-01-23 20:59:04.182337078 -0600
++++ pnginfo.h	2013-01-23 23:45:07.928511742 -0600
 @@ -260,10 +260,23 @@ defined(PNG_READ_BACKGROUND_SUPPORTED)
  
  #ifdef PNG_INFO_IMAGE_SUPPORTED
@@ -401,8 +401,8 @@
  };
  #endif /* PNGINFO_H */
 diff -up8 pngpread.c pngpread.c
---- pngpread.c	2012-09-27 07:21:20 -0400
-+++ pngpread.c	2012-07-17 19:54:14 -0400
+--- pngpread.c	2013-01-23 20:59:04.270422980 -0600
++++ pngpread.c	2013-01-23 23:45:07.934228351 -0600
 @@ -210,16 +210,119 @@ png_push_read_chunk(png_structp png_ptr,
        png_crc_read(png_ptr, chunk_tag, 4);
        png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
@@ -701,7 +701,7 @@
     png_ptr->zstream.avail_in = (uInt)buffer_length;
  
     /* Keep going until the decompressed data is all processed
-@@ -1299,16 +1488,28 @@ png_set_progressive_read_fn(png_structp 
+@@ -1299,16 +1488,28 @@ png_set_progressive_read_fn(png_structp
  
     png_ptr->info_fn = info_fn;
     png_ptr->row_fn = row_fn;
@@ -731,8 +731,8 @@
     return png_ptr->io_ptr;
  }
 diff -up8 pngpriv.h pngpriv.h
---- pngpriv.h	2012-09-27 07:21:20 -0400
-+++ pngpriv.h	2012-09-29 11:36:24 -0400
+--- pngpriv.h	2013-01-23 20:59:04.166577343 -0600
++++ pngpriv.h	2013-01-23 23:45:07.940481520 -0600
 @@ -462,16 +462,20 @@ typedef PNG_CONST png_uint_16p FAR * png
  #define PNG_HAVE_sRGB               0x80
  #define PNG_HAVE_CHUNK_HEADER      0x100
@@ -781,7 +781,7 @@
  
  /* This uses (char), not (png_byte) to avoid warnings on systems where (char) is
   * signed and the argument is a (char[])  This macro will fail miserably on
-@@ -1338,16 +1352,55 @@ PNG_EXTERN void png_push_read_iTXt PNGAR
+@@ -1336,16 +1350,55 @@ PNG_EXTERN void png_push_read_iTXt PNGAR
  
  #ifdef PNG_MNG_FEATURES_SUPPORTED
  PNG_EXTERN void png_do_read_intrapixel PNGARG((png_row_infop row_info,
@@ -838,8 +838,8 @@
      png_fixed_point int_blue_y));
  #endif
 diff -up8 pngread.c pngread.c
---- pngread.c	2012-09-27 07:21:20 -0400
-+++ pngread.c	2012-07-17 19:54:14 -0400
+--- pngread.c	2013-01-23 20:59:04.282855271 -0600
++++ pngread.c	2013-01-23 23:45:07.948798424 -0600
 @@ -235,16 +235,19 @@ png_read_info(png_structp png_ptr, png_i
        {
           if (!(png_ptr->mode & PNG_HAVE_IHDR))
@@ -1040,8 +1040,8 @@
  
     } while (png_ptr->zstream.avail_out);
 diff -up8 pngrutil.c pngrutil.c
---- pngrutil.c	2012-09-27 07:21:20 -0400
-+++ pngrutil.c	2012-09-29 11:36:24 -0400
+--- pngrutil.c	2013-01-23 20:59:04.350499933 -0600
++++ pngrutil.c	2013-01-23 23:45:07.955605241 -0600
 @@ -542,16 +542,21 @@ png_handle_IHDR(png_structp png_ptr, png
     width = png_get_uint_31(png_ptr, buf);
     height = png_get_uint_31(png_ptr, buf + 4);
@@ -1064,7 +1064,7 @@
     png_ptr->color_type = (png_byte)color_type;
  #ifdef PNG_MNG_FEATURES_SUPPORTED
     png_ptr->filter_type = (png_byte)filter_type;
-@@ -2609,16 +2614,189 @@ png_handle_iTXt(png_structp png_ptr, png
+@@ -2619,16 +2624,189 @@ png_handle_iTXt(png_structp png_ptr, png
     png_free(png_ptr, png_ptr->chunkdata);
     png_ptr->chunkdata = NULL;
  
@@ -1254,7 +1254,7 @@
   */
  void /* PRIVATE */
  png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
-@@ -4151,9 +4329,86 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
+@@ -4109,9 +4287,86 @@ defined(PNG_USER_TRANSFORM_PTR_SUPPORTED
     png_debug1(3, "iwidth = %u,", png_ptr->iwidth);
     png_debug1(3, "num_rows = %u,", png_ptr->num_rows);
     png_debug1(3, "rowbytes = %lu,", (unsigned long)png_ptr->rowbytes);
@@ -1342,8 +1342,8 @@
 +#endif /* PNG_READ_APNG_SUPPORTED */
  #endif /* PNG_READ_SUPPORTED */
 diff -up8 pngset.c pngset.c
---- pngset.c	2012-09-27 07:21:20 -0400
-+++ pngset.c	2012-07-07 14:54:14 -0400
+--- pngset.c	2013-01-23 20:59:04.363117910 -0600
++++ pngset.c	2013-01-23 23:45:07.963968924 -0600
 @@ -257,16 +257,21 @@ png_set_IHDR(png_structp png_ptr, png_in
         (PNG_UINT_32_MAX >> 3)      /* 8-byte RRGGBBAA pixels */
         - 48       /* bigrowbuf hack */
@@ -1366,7 +1366,7 @@
      png_int_32 offset_x, png_int_32 offset_y, int unit_type)
  {
     png_debug1(1, "in %s storage function", "oFFs");
-@@ -1017,16 +1022,157 @@ png_set_sPLT(png_structp png_ptr,
+@@ -1043,16 +1048,157 @@ png_set_sPLT(png_structp png_ptr,
  
     info_ptr->splt_palettes = np;
     info_ptr->splt_palettes_num += nentries;
@@ -1525,8 +1525,8 @@
     int i;
  
 diff -up8 pngstruct.h pngstruct.h
---- pngstruct.h	2012-09-27 07:21:20 -0400
-+++ pngstruct.h	2012-07-07 14:54:14 -0400
+--- pngstruct.h	2013-01-23 20:59:04.174748840 -0600
++++ pngstruct.h	2013-01-23 23:45:07.971386461 -0600
 @@ -288,16 +288,37 @@ struct png_struct_def
     png_uint_32 mng_features_permitted;
  #endif
@@ -1566,8 +1566,8 @@
     png_free_ptr free_fn;          /* function for freeing memory */
  #endif
 diff -up8 pngwrite.c pngwrite.c
---- pngwrite.c	2012-09-27 07:21:20 -0400
-+++ pngwrite.c	2012-07-07 14:54:14 -0400
+--- pngwrite.c	2013-01-23 20:59:04.424809701 -0600
++++ pngwrite.c	2013-01-23 23:45:07.977302033 -0600
 @@ -53,16 +53,20 @@ png_write_info_before_PLTE(png_structp p
  #ifdef PNG_WRITE_INTERLACING_SUPPORTED
         info_ptr->interlace_type);
@@ -1661,9 +1661,9 @@
 +#endif /* PNG_WRITE_APNG_SUPPORTED */
  #endif /* PNG_WRITE_SUPPORTED */
 diff -up8 pngwutil.c pngwutil.c
---- pngwutil.c	2012-09-27 07:21:20 -0400
-+++ pngwutil.c	2012-09-29 11:36:24 -0400
-@@ -816,16 +816,21 @@ png_write_IHDR(png_structp png_ptr, png_
+--- pngwutil.c	2013-01-23 20:59:04.456429005 -0600
++++ pngwutil.c	2013-01-23 23:45:07.984682857 -0600
+@@ -813,16 +813,21 @@ png_write_IHDR(png_structp png_ptr, png_
     buf[9] = (png_byte)color_type;
     buf[10] = (png_byte)compression_type;
     buf[11] = (png_byte)filter_type;
@@ -1685,7 +1685,7 @@
     if (!(png_ptr->do_filter))
     {
        if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
-@@ -1030,17 +1035,38 @@ png_write_IDAT(png_structp png_ptr, png_
+@@ -1027,17 +1032,38 @@ png_write_IDAT(png_structp png_ptr, png_
        }
  
        else
@@ -1724,7 +1724,7 @@
      */
     png_ptr->zstream.next_out = png_ptr->zbuf;
     png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
-@@ -1993,16 +2019,74 @@ png_write_tIME(png_structp png_ptr, png_
+@@ -1990,16 +2016,74 @@ png_write_tIME(png_structp png_ptr, png_
     buf[4] = mod_time->hour;
     buf[5] = mod_time->minute;
     buf[6] = mod_time->second;
@@ -1799,7 +1799,7 @@
     /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
  
     /* Start of interlace block */
-@@ -3172,9 +3256,44 @@ png_write_filtered_row(png_structp png_p
+@@ -3169,9 +3253,44 @@ png_write_filtered_row(png_structp png_p
  
     if (png_ptr->flush_dist > 0 &&
         png_ptr->flush_rows >= png_ptr->flush_dist)
diff -r 7e511b8473ff media/libpng/arm/arm_init.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libpng/arm/arm_init.c	Tue Jan 29 22:34:41 2013 +0900
@@ -0,0 +1,86 @@
+
+/* arm_init.c - NEON optimised filter functions
+ *
+ * Copyright (c) 2013 Glenn Randers-Pehrson
+ * Written by Mans Rullgard, 2011.
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+#include "../pngpriv.h"
+
+/* __arm__ is defined by GCC, MSVC defines _M_ARM to the ARM version number */
+#if defined __linux__ && defined __arm__
+#include <stdio.h>
+#include <elf.h>
+#include <asm/hwcap.h>
+
+static int png_have_hwcap(unsigned cap)
+{
+   FILE *f = fopen("/proc/self/auxv", "r");
+   Elf32_auxv_t aux;
+   int have_cap = 0;
+
+   if (!f)
+      return 0;
+
+   while (fread(&aux, sizeof(aux), 1, f) > 0)
+   {
+      if (aux.a_type == AT_HWCAP &&
+          aux.a_un.a_val & cap)
+      {
+         have_cap = 1;
+         break;
+      }
+   }
+
+   fclose(f);
+
+   return have_cap;
+}
+#endif /* __linux__ && __arm__ */
+
+void
+png_init_filter_functions_neon(png_structp pp, unsigned int bpp)
+{
+#ifdef __arm__
+#ifdef __linux__
+   if (!png_have_hwcap(HWCAP_NEON))
+      return;
+#endif
+
+   /* IMPORTANT: any new external functions used here must be declared using
+    * PNG_INTERNAL_FUNCTION in ../pngpriv.h.  This is required so that the
+    * 'prefix' option to configure works:
+    *
+    *    ./configure --with-libpng-prefix=foobar_
+    *
+    * Verify you have got this right by running the above command, doing a build
+    * and examining pngprefix.h; it must contain a #define for every external
+    * function you add.  (Notice that this happens automatically for the
+    * initialization function.)
+    */
+   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_neon;
+
+   if (bpp == 3)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_neon;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_neon;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
+         png_read_filter_row_paeth3_neon;
+   }
+
+   else if (bpp == 4)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_neon;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_neon;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
+          png_read_filter_row_paeth4_neon;
+   }
+#else
+   PNG_UNUSED(pp)
+   PNG_UNUSED(bpp)
+#endif
+}
diff -r 7e511b8473ff media/libpng/arm/filter_neon.S
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/media/libpng/arm/filter_neon.S	Tue Jan 29 22:34:41 2013 +0900
@@ -0,0 +1,228 @@
+
+/* filter_neon.S - NEON optimised filter functions
+ *
+ * Copyright (c) 2011 Glenn Randers-Pehrson
+ * Written by Mans Rullgard, 2011.
+ * Last changed in libpng 1.5.7 [December 15, 2011]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#ifdef __arm__
+#if defined(__linux__) && defined(__ELF__)
+.section .note.GNU-stack,"",%progbits /* mark stack as non-executable */
+#endif
+
+#ifdef __ELF__
+#   define ELF
+#else
+#   define ELF @
+#endif
+
+        .arch armv7-a
+        .fpu  neon
+
+.macro  func    name, export=0
+    .macro endfunc
+ELF     .size   \name, . - \name
+        .endfunc
+        .purgem endfunc
+    .endm
+        .text
+    .if \export
+        .global \name
+    .endif
+ELF     .type   \name, STT_FUNC
+        .func   \name
+\name:
+.endm
+
+func    png_read_filter_row_sub4_neon, export=1
+        ldr             r3,  [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+1:
+        vld4.32         {d4[],d5[],d6[],d7[]},    [r1,:128]
+        vadd.u8         d0,  d3,  d4
+        vadd.u8         d1,  d0,  d5
+        vadd.u8         d2,  d1,  d6
+        vadd.u8         d3,  d2,  d7
+        vst4.32         {d0[0],d1[0],d2[0],d3[0]},[r1,:128]!
+        subs            r3,  r3,  #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_sub3_neon, export=1
+        ldr             r3,  [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        mov             r0,  r1
+        mov             r2,  #3
+        mov             r12, #12
+        vld1.8          {q11},    [r0], r12
+1:
+        vext.8          d5,  d22, d23, #3
+        vadd.u8         d0,  d3,  d22
+        vext.8          d6,  d22, d23, #6
+        vadd.u8         d1,  d0,  d5
+        vext.8          d7,  d23, d23, #1
+        vld1.8          {q11},    [r0], r12
+        vst1.32         {d0[0]},  [r1,:32], r2
+        vadd.u8         d2,  d1,  d6
+        vst1.32         {d1[0]},  [r1], r2
+        vadd.u8         d3,  d2,  d7
+        vst1.32         {d2[0]},  [r1], r2
+        vst1.32         {d3[0]},  [r1], r2
+        subs            r3,  r3,  #12
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_up_neon, export=1
+        ldr             r3,  [r0, #4]           @ rowbytes
+1:
+        vld1.8          {q0}, [r1,:128]
+        vld1.8          {q1}, [r2,:128]!
+        vadd.u8         q0,  q0,  q1
+        vst1.8          {q0}, [r1,:128]!
+        subs            r3,  r3,  #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_avg4_neon, export=1
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+1:
+        vld4.32         {d4[],d5[],d6[],d7[]},    [r1,:128]
+        vld4.32         {d16[],d17[],d18[],d19[]},[r2,:128]!
+        vhadd.u8        d0,  d3,  d16
+        vadd.u8         d0,  d0,  d4
+        vhadd.u8        d1,  d0,  d17
+        vadd.u8         d1,  d1,  d5
+        vhadd.u8        d2,  d1,  d18
+        vadd.u8         d2,  d2,  d6
+        vhadd.u8        d3,  d2,  d19
+        vadd.u8         d3,  d3,  d7
+        vst4.32         {d0[0],d1[0],d2[0],d3[0]},[r1,:128]!
+        subs            r12, r12, #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_avg3_neon, export=1
+        push            {r4,lr}
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        mov             r0,  r1
+        mov             r4,  #3
+        mov             lr,  #12
+        vld1.8          {q11},    [r0], lr
+1:
+        vld1.8          {q10},    [r2], lr
+        vext.8          d5,  d22, d23, #3
+        vhadd.u8        d0,  d3,  d20
+        vext.8          d17, d20, d21, #3
+        vadd.u8         d0,  d0,  d22
+        vext.8          d6,  d22, d23, #6
+        vhadd.u8        d1,  d0,  d17
+        vext.8          d18, d20, d21, #6
+        vadd.u8         d1,  d1,  d5
+        vext.8          d7,  d23, d23, #1
+        vld1.8          {q11},    [r0], lr
+        vst1.32         {d0[0]},  [r1,:32], r4
+        vhadd.u8        d2,  d1,  d18
+        vst1.32         {d1[0]},  [r1], r4
+        vext.8          d19, d21, d21, #1
+        vadd.u8         d2,  d2,  d6
+        vhadd.u8        d3,  d2,  d19
+        vst1.32         {d2[0]},  [r1], r4
+        vadd.u8         d3,  d3,  d7
+        vst1.32         {d3[0]},  [r1], r4
+        subs            r12, r12, #12
+        bgt             1b
+
+        pop             {r4,pc}
+endfunc
+
+.macro  paeth           rx,  ra,  rb,  rc
+        vaddl.u8        q12, \ra, \rb           @ a + b
+        vaddl.u8        q15, \rc, \rc           @ 2*c
+        vabdl.u8        q13, \rb, \rc           @ pa
+        vabdl.u8        q14, \ra, \rc           @ pb
+        vabd.u16        q15, q12, q15           @ pc
+        vcle.u16        q12, q13, q14           @ pa <= pb
+        vcle.u16        q13, q13, q15           @ pa <= pc
+        vcle.u16        q14, q14, q15           @ pb <= pc
+        vand            q12, q12, q13           @ pa <= pb && pa <= pc
+        vmovn.u16       d28, q14
+        vmovn.u16       \rx, q12
+        vbsl            d28, \rb, \rc
+        vbsl            \rx, \ra, d28
+.endm
+
+func    png_read_filter_row_paeth4_neon, export=1
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        vmov.i8         d20, #0
+1:
+        vld4.32         {d4[],d5[],d6[],d7[]},    [r1,:128]
+        vld4.32         {d16[],d17[],d18[],d19[]},[r2,:128]!
+        paeth           d0,  d3,  d16, d20
+        vadd.u8         d0,  d0,  d4
+        paeth           d1,  d0,  d17, d16
+        vadd.u8         d1,  d1,  d5
+        paeth           d2,  d1,  d18, d17
+        vadd.u8         d2,  d2,  d6
+        paeth           d3,  d2,  d19, d18
+        vmov            d20, d19
+        vadd.u8         d3,  d3,  d7
+        vst4.32         {d0[0],d1[0],d2[0],d3[0]},[r1,:128]!
+        subs            r12, r12, #16
+        bgt             1b
+
+        bx              lr
+endfunc
+
+func    png_read_filter_row_paeth3_neon, export=1
+        push            {r4,lr}
+        ldr             r12, [r0, #4]           @ rowbytes
+        vmov.i8         d3,  #0
+        vmov.i8         d4,  #0
+        mov             r0,  r1
+        mov             r4,  #3
+        mov             lr,  #12
+        vld1.8          {q11},    [r0], lr
+1:
+        vld1.8          {q10},    [r2], lr
+        paeth           d0,  d3,  d20, d4
+        vext.8          d5,  d22, d23, #3
+        vadd.u8         d0,  d0,  d22
+        vext.8          d17, d20, d21, #3
+        paeth           d1,  d0,  d17, d20
+        vst1.32         {d0[0]},  [r1,:32], r4
+        vext.8          d6,  d22, d23, #6
+        vadd.u8         d1,  d1,  d5
+        vext.8          d18, d20, d21, #6
+        paeth           d2,  d1,  d18, d17
+        vext.8          d7,  d23, d23, #1
+        vld1.8          {q11},    [r0], lr
+        vst1.32         {d1[0]},  [r1], r4
+        vadd.u8         d2,  d2,  d6
+        vext.8          d19, d21, d21, #1
+        paeth           d3,  d2,  d19, d18
+        vst1.32         {d2[0]},  [r1], r4
+        vmov            d4,  d19
+        vadd.u8         d3,  d3,  d7
+        vst1.32         {d3[0]},  [r1], r4
+        subs            r12, r12, #12
+        bgt             1b
+
+        pop             {r4,pc}
+endfunc
+#endif
diff -r 7e511b8473ff media/libpng/libpng-manual.txt
--- a/media/libpng/libpng-manual.txt	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/libpng-manual.txt	Tue Jan 29 22:34:41 2013 +0900
@@ -1,6 +1,6 @@
 Libpng-manual.txt - A description on how to use and modify libpng
 
- libpng version 1.5.13 - September 27, 2012
+ libpng version 1.5.14 - January 24, 2013
  Updated and distributed by Glenn Randers-Pehrson
  <glennrp at users.sourceforge.net>
  Copyright (c) 1998-2012 Glenn Randers-Pehrson
@@ -11,7 +11,7 @@
 
  Based on:
 
- libpng versions 0.97, January 1998, through 1.5.13 - September 27, 2012
+ libpng versions 0.97, January 1998, through 1.5.14 - January 24, 2013
  Updated and distributed by Glenn Randers-Pehrson
  Copyright (c) 1998-2012 Glenn Randers-Pehrson
 
@@ -650,9 +650,6 @@
 
    chunk_cache_max = png_get_chunk_cache_max(png_ptr);
 
-This limit also applies to the number of buffers that can be allocated
-by png_decompress_chunk() while decompressing iTXt, zTXt, and iCCP chunks.
-
 You can also set a limit on the amount of memory that a compressed chunk
 other than IDAT can occupy, with
 
@@ -4612,13 +4609,13 @@
 
 XIV. Y2K Compliance in libpng
 
-September 27, 2012
+January 24, 2013
 
 Since the PNG Development group is an ad-hoc body, we can't make
 an official declaration.
 
 This is your unofficial assurance that libpng from version 0.71 and
-upward through 1.5.13 are Y2K compliant.  It is my belief that earlier
+upward through 1.5.14 are Y2K compliant.  It is my belief that earlier
 versions were also Y2K compliant.
 
 Libpng only has two year fields.  One is a 2-byte unsigned integer that
diff -r 7e511b8473ff media/libpng/mozpngconf.h
--- a/media/libpng/mozpngconf.h	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/mozpngconf.h	Tue Jan 29 22:34:41 2013 +0900
@@ -9,6 +9,7 @@
 #define PNG_COST_SHIFT 3
 #define PNG_GAMMA_THRESHOLD_FIXED 5000
 #define PNG_MAX_GAMMA_8 11
+#define PNG_USER_CHUNK_CACHE_MAX 128
 #define PNG_USER_CHUNK_MALLOC_MAX 4000000L
 #define PNG_USER_HEIGHT_MAX 1000000
 #define PNG_USER_WIDTH_MAX 1000000
@@ -39,15 +40,20 @@
 #define PNG_READ_GRAY_TO_RGB_SUPPORTED
 #define PNG_READ_INTERLACING_SUPPORTED
 #define PNG_READ_SCALE_16_TO_8_SUPPORTED
-#define PNG_READ_TEXT_SUPPORTED
 #define PNG_READ_TRANSFORMS_SUPPORTED
 #endif
 
 /* necessary for boot animation code */
 #ifdef MOZ_WIDGET_GONK
+#define PNG_EASY_ACCESS_SUPPORTED
+#define PNG_READ_BGR_SUPPORTED
+#define PNG_READ_EXPAND_SUPPORTED
+#define PNG_READ_FILLER_SUPPORTED
+#define PNG_READ_GRAY_TO_RGB_SUPPORTED
+#define PNG_READ_STRIP_16_TO_8_SUPPORTED
+#define PNG_READ_STRIP_ALPHA_SUPPORTED
+#define PNG_READ_USER_TRANSFORM_SUPPORTED
 #define PNG_SEQUENTIAL_READ_SUPPORTED
-#define PNG_EASY_ACCESS_SUPPORTED
-#define PNG_READ_EXPAND_SUPPORTED
 #endif
 
 #ifdef MOZ_PNG_WRITE
diff -r 7e511b8473ff media/libpng/png.c
--- a/media/libpng/png.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/png.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* png.c - location for general purpose libpng functions
  *
- * Last changed in libpng 1.5.11 [June 14, 2012]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -14,7 +14,7 @@
 #include "pngpriv.h"
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef png_libpng_version_1_5_13 Your_png_h_is_not_version_1_5_13;
+typedef png_libpng_version_1_5_14 Your_png_h_is_not_version_1_5_14;
 
 /* Tells libpng that we have already handled the first "num_bytes" bytes
  * of the PNG file signature.  If the PNG data is embedded into another
@@ -73,13 +73,16 @@
 png_zalloc,(voidpf png_ptr, uInt items, uInt size),PNG_ALLOCATED)
 {
    png_voidp ptr;
-   png_structp p=(png_structp)png_ptr;
-   png_uint_32 save_flags=p->flags;
+   png_structp p;
+   png_uint_32 save_flags;
    png_alloc_size_t num_bytes;
 
    if (png_ptr == NULL)
       return (NULL);
 
+   p=(png_structp)png_ptr;
+   save_flags=p->flags;
+
    if (items > PNG_UINT_32_MAX/size)
    {
      png_warning (p, "Potential overflow in png_zalloc()");
@@ -655,14 +658,14 @@
 #else
 #  ifdef __STDC__
    return PNG_STRING_NEWLINE \
-     "libpng version 1.5.13 - September 27, 2012" PNG_STRING_NEWLINE \
-     "Copyright (c) 1998-2012 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
+     "libpng version 1.5.14 - January 24, 2013" PNG_STRING_NEWLINE \
+     "Copyright (c) 1998-2013 Glenn Randers-Pehrson" PNG_STRING_NEWLINE \
      "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
      "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
      PNG_STRING_NEWLINE;
 #  else
-      return "libpng version 1.5.13 - September 27, 2012\
-      Copyright (c) 1998-2012 Glenn Randers-Pehrson\
+      return "libpng version 1.5.14 - January 24, 2013\
+      Copyright (c) 1998-2013 Glenn Randers-Pehrson\
       Copyright (c) 1996-1997 Andreas Dilger\
       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.";
 #  endif
@@ -1458,7 +1461,7 @@
 }
 #endif /* pCAL or sCAL */
 
-#ifdef PNG_READ_sCAL_SUPPORTED
+#ifdef PNG_sCAL_SUPPORTED
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
 /* Utility used below - a simple accurate power of ten from an integral
  * exponent.
@@ -2044,7 +2047,8 @@
 }
 #endif
 
-#ifdef PNG_READ_GAMMA_SUPPORTED /* more fixed point functions for gamma */
+#if (defined PNG_READ_GAMMA_SUPPORTED) || (defined PNG_cHRM_SUPPORTED)
+/* more fixed point functions for gamma and cHRM (xy/XYZ) suport. */
 /* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
 png_fixed_point
 png_reciprocal(png_fixed_point a)
@@ -2064,6 +2068,7 @@
    return 0; /* error/overflow */
 }
 
+#ifdef PNG_READ_GAMMA_SUPPORTED
 /* A local convenience routine. */
 static png_fixed_point
 png_product2(png_fixed_point a, png_fixed_point b)
@@ -2085,6 +2090,7 @@
 
    return 0; /* overflow */
 }
+#endif /* READ_GAMMA */
 
 /* The inverse of the above. */
 png_fixed_point
@@ -2112,7 +2118,7 @@
 
    return 0; /* overflow */
 }
-#endif /* READ_GAMMA */
+#endif /* READ_GAMMA || cHRM */
 
 #ifdef PNG_CHECK_cHRM_SUPPORTED
 /* Added at libpng version 1.2.34 (Dec 8, 2008) and 1.4.0 (Jan 2,
diff -r 7e511b8473ff media/libpng/png.h
--- a/media/libpng/png.h	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/png.h	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.5.13 - September 27, 2012
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * libpng version 1.5.14 - January 24, 2013
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -11,7 +11,7 @@
  * Authors and maintainers:
  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *   libpng versions 0.89c, June 1996, through 0.96, May 1997: Andreas Dilger
- *   libpng versions 0.97, January 1998, through 1.5.13 - September 27, 2012: Glenn
+ *   libpng versions 0.97, January 1998, through 1.5.14 - January 24, 2013: Glenn
  *   See also "Contributing Authors", below.
  *
  * Note about libpng version numbers:
@@ -181,6 +181,9 @@
  *    1.5.13beta01-02         15    10513  15.so.15.13[.0]
  *    1.5.13rc01              15    10513  15.so.15.13[.0]
  *    1.5.13                  15    10513  15.so.15.13[.0]
+ *    1.5.14beta01-08         15    10514  15.so.15.14[.0]
+ *    1.5.14rc01-03           15    10514  15.so.15.14[.0]
+ *    1.5.14                  15    10514  15.so.15.14[.0]
  *
  *   Henceforth the source version will match the shared-library major
  *   and minor numbers; the shared-library major version number will be
@@ -212,8 +215,8 @@
  *
  * This code is released under the libpng license.
  *
- * libpng versions 1.2.6, August 15, 2004, through 1.5.13, September 27, 2012, are
- * Copyright (c) 2004, 2006-2012 Glenn Randers-Pehrson, and are
+ * libpng versions 1.2.6, August 15, 2004, through 1.5.14, January 24, 2013, are
+ * Copyright (c) 2004, 2006-2013 Glenn Randers-Pehrson, and are
  * distributed according to the same disclaimer and license as libpng-1.2.5
  * with the following individual added to the list of Contributing Authors:
  *
@@ -324,13 +327,13 @@
  * Y2K compliance in libpng:
  * =========================
  *
- *    September 27, 2012
+ *    January 24, 2013
  *
  *    Since the PNG Development group is an ad-hoc body, we can't make
  *    an official declaration.
  *
  *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.5.13 are Y2K compliant.  It is my belief that
+ *    upward through 1.5.14 are Y2K compliant.  It is my belief that
  *    earlier versions were also Y2K compliant.
  *
  *    Libpng only has two year fields.  One is a 2-byte unsigned integer
@@ -389,9 +392,9 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.5.13"
+#define PNG_LIBPNG_VER_STRING "1.5.14"
 #define PNG_HEADER_VERSION_STRING \
-     " libpng version 1.5.13 - September 27, 2012\n"
+     " libpng version 1.5.14 - January 24, 2013\n"
 
 #define PNG_LIBPNG_VER_SONUM   15
 #define PNG_LIBPNG_VER_DLLNUM  15
@@ -399,7 +402,7 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   5
-#define PNG_LIBPNG_VER_RELEASE 13
+#define PNG_LIBPNG_VER_RELEASE 14
 
 /* This should match the numeric part of the final component of
  * PNG_LIBPNG_VER_STRING, omitting any leading zero:
@@ -430,7 +433,7 @@
  * version 1.0.0 was mis-numbered 100 instead of 10000).  From
  * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
  */
-#define PNG_LIBPNG_VER 10513 /* 1.5.13 */
+#define PNG_LIBPNG_VER 10514 /* 1.5.14 */
 
 #ifndef MOZPNGCONF_H
 #   include "mozpngconf.h"
@@ -557,7 +560,7 @@
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef char* png_libpng_version_1_5_13;
+typedef char* png_libpng_version_1_5_14;
 
 /* Three color definitions.  The order of the red, green, and blue, (and the
  * exact size) is not important, although the size of the fields need to
diff -r 7e511b8473ff media/libpng/pngconf.h
--- a/media/libpng/pngconf.h	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngconf.h	Tue Jan 29 22:34:41 2013 +0900
@@ -1,9 +1,9 @@
 
 /* pngconf.h - machine configurable file for libpng
  *
- * libpng version 1.5.13 - September 27, 2012
+ * libpng version 1.5.14 - January 24, 2013
  *
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -177,18 +177,16 @@
  * ==========================
  * This code is used at build time to find PNG_IMPEXP, the API settings
  * and PNG_EXPORT_TYPE(), it may also set a macro to indicate the DLL
- * import processing is possible.  On Windows/x86 systems it also sets
+ * import processing is possible.  On Windows systems it also sets
  * compiler-specific macros to the values required to change the calling
  * conventions of the various functions.
  */
-#if ( defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
-      defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__) ) &&\
-    ( defined(_X86_) || defined(_X64_) || defined(_M_IX86) ||\
-      defined(_M_X64) || defined(_M_IA64) )
-  /* Windows system (DOS doesn't support DLLs) running on x86/x64.  Includes
-   * builds under Cygwin or MinGW.  Also includes Watcom builds but these need
-   * special treatment because they are not compatible with GCC or Visual C
-   * because of different calling conventions.
+#if defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
+    defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+  /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
+   * MinGW on any architecture currently supported by Windows.  Also includes
+   * Watcom builds but these need special treatment because they are not
+   * compatible with GCC or Visual C because of different calling conventions.
    */
 #  if PNG_API_RULE == 2
     /* If this line results in an error, either because __watcall is not
@@ -202,6 +200,9 @@
 #  if defined(__GNUC__) || (defined (_MSC_VER) && (_MSC_VER >= 800))
 #    define PNGCAPI __cdecl
 #    if PNG_API_RULE == 1
+       /* If this line results in an error __stdcall is not understood and
+        * PNG_API_RULE should not have been set to '1'.
+        */
 #      define PNGAPI __stdcall
 #    endif
 #  else
@@ -239,7 +240,7 @@
 #    endif
 #  endif /* compiler */
 
-#else /* !Windows/x86 */
+#else /* !Windows */
 #  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
 #    define PNGAPI _System
 #  else /* !Windows/x86 && !OS/2 */
diff -r 7e511b8473ff media/libpng/pngerror.c
--- a/media/libpng/pngerror.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngerror.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* pngerror.c - stub functions for i/o and memory allocation
  *
- * Last changed in libpng 1.5.8 [February 1, 2011]
- * Copyright (c) 1998-2011 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -161,7 +161,7 @@
          case PNG_NUMBER_FORMAT_02u:
             /* Expects at least 2 digits. */
             mincount = 2;
-            /* fall through */
+            /* FALL THROUGH */
 
          case PNG_NUMBER_FORMAT_u:
             *--end = digits[number % 10];
@@ -171,7 +171,7 @@
          case PNG_NUMBER_FORMAT_02x:
             /* This format expects at least two digits */
             mincount = 2;
-            /* fall through */
+            /* FALL THROUGH */
 
          case PNG_NUMBER_FORMAT_x:
             *--end = digits[number & 0xf];
diff -r 7e511b8473ff media/libpng/pngget.c
--- a/media/libpng/pngget.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngget.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,7 +1,7 @@
 
 /* pngget.c - retrieval of values from info struct
  *
- * Last changed in libpng 1.5.7 [December 15, 2011]
+ * Last changed in libpng 1.5.14 [January 24, 2013]
  * Copyright (c) 1998-2011 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
@@ -175,6 +175,9 @@
          return ((float)((float)info_ptr->y_pixels_per_unit
              /(float)info_ptr->x_pixels_per_unit));
    }
+#else
+   PNG_UNUSED(png_ptr)
+   PNG_UNUSED(info_ptr)
 #endif
 
    return ((float)0.0);
@@ -203,6 +206,9 @@
           (png_int_32)info_ptr->x_pixels_per_unit))
          return res;
    }
+#else
+   PNG_UNUSED(png_ptr)
+   PNG_UNUSED(info_ptr)
 #endif
 
    return 0;
diff -r 7e511b8473ff media/libpng/pnginfo.h
--- a/media/libpng/pnginfo.h	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pnginfo.h	Tue Jan 29 22:34:41 2013 +0900
@@ -242,7 +242,7 @@
 #ifdef PNG_sPLT_SUPPORTED
    /* Data on sPLT chunks (there may be more than one). */
    png_sPLT_tp splt_palettes;
-   png_uint_32 splt_palettes_num;
+   int splt_palettes_num;
 #endif
 
 #ifdef PNG_sCAL_SUPPORTED
diff -r 7e511b8473ff media/libpng/pngpriv.h
--- a/media/libpng/pngpriv.h	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngpriv.h	Tue Jan 29 22:34:41 2013 +0900
@@ -416,7 +416,7 @@
 #if PNG_ALIGN_TYPE == PNG_ALIGN_SIZE
    /* This is used because in some compiler implementations non-aligned
     * structure members are supported, so the offsetof approach below fails.
-    * Set PNG_ALIGN_TO_SIZE=0 for compiler combinations where unaligned access
+    * Set PNG_ALIGN_SIZE=0 for compiler combinations where unaligned access
     * is good for performance.  Do not do this unless you have tested the result
     * and understand it.
     */
@@ -837,10 +837,8 @@
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
 PNG_EXTERN void png_write_gAMA PNGARG((png_structp png_ptr, double file_gamma));
 #  endif
-#  ifdef PNG_FIXED_POINT_SUPPORTED
 PNG_EXTERN void png_write_gAMA_fixed PNGARG((png_structp png_ptr,
     png_fixed_point file_gamma));
-#  endif
 #endif
 
 #ifdef PNG_WRITE_sBIT_SUPPORTED
@@ -1544,14 +1542,16 @@
 /* ASCII to FP interfaces, currently only implemented if sCAL
  * support is required.
  */
-#if defined(PNG_READ_sCAL_SUPPORTED)
+#ifdef PNG_sCAL_SUPPORTED
 /* MAX_DIGITS is actually the maximum number of characters in an sCAL
  * width or height, derived from the precision (number of significant
  * digits - a build time settable option) and assumpitions about the
  * maximum ridiculous exponent.
  */
 #define PNG_sCAL_MAX_DIGITS (PNG_sCAL_PRECISION+1/*.*/+1/*E*/+10/*exponent*/)
+#endif
 
+#ifdef PNG_sCAL_SUPPORTED
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 PNG_EXTERN void png_ascii_from_fp PNGARG((png_structp png_ptr, png_charp ascii,
     png_size_t size, double fp, unsigned int precision));
@@ -1636,14 +1636,14 @@
 #define PNG_FP_IS_POSITIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
 #define PNG_FP_IS_NEGATIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_NZ_MASK)
 
-/* The actual parser.  This can be called repeatedly, it updates
+/* The actual parser.  This can be called repeatedly. It updates
  * the index into the string and the state variable (which must
- * be initialzed to 0).  It returns a result code, as above.  There
+ * be initialized to 0).  It returns a result code, as above.  There
  * is no point calling the parser any more if it fails to advance to
  * the end of the string - it is stuck on an invalid character (or
  * terminated by '\0').
  *
- * Note that the pointer will consume an E or even an E+ then leave
+ * Note that the pointer will consume an E or even an E+ and then leave
  * a 'maybe' state even though a preceding integer.fraction is valid.
  * The PNG_FP_WAS_VALID flag indicates that a preceding substring was
  * a valid number.  It's possible to recover from this by calling
@@ -1682,7 +1682,7 @@
     png_fixed_point a, png_int_32 multiplied_by, png_int_32 divided_by));
 #endif
 
-#ifdef PNG_READ_GAMMA_SUPPORTED
+#if (defined PNG_READ_GAMMA_SUPPORTED) || (defined PNG_cHRM_SUPPORTED)
 /* Calculate a reciprocal - used for gamma values.  This returns
  * 0 if the argument is 0 in order to maintain an undefined value,
  * there are no warnings.
@@ -1717,7 +1717,72 @@
     int bit_depth));
 #endif
 
-/* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */
+/* Missing declarations if FIXED_POINT is *not* supported - fixed properly
+ * in libpng 1.6
+ */
+#ifndef PNG_FIXED_POINT_SUPPORTED
+#ifdef PNG_cHRM_SUPPORTED
+PNG_EXTERN png_uint_32 png_get_cHRM_XYZ_fixed PNGARG(
+    (png_structp png_ptr, png_const_infop info_ptr,
+    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
+    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
+    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
+    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
+    png_fixed_point *int_blue_Z));
+PNG_EXTERN void png_set_cHRM_XYZ_fixed PNGARG((png_structp png_ptr,
+    png_infop info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
+    png_fixed_point int_red_Z, png_fixed_point int_green_X,
+    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
+    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
+    png_fixed_point int_blue_Z));
+PNG_EXTERN void png_set_cHRM_fixed PNGARG((png_structp png_ptr,
+    png_infop info_ptr, png_fixed_point int_white_x,
+    png_fixed_point int_white_y, png_fixed_point int_red_x,
+    png_fixed_point int_red_y, png_fixed_point int_green_x,
+    png_fixed_point int_green_y, png_fixed_point int_blue_x,
+    png_fixed_point int_blue_y));
+#endif
+
+#ifdef PNG_gAMA_SUPPORTED
+PNG_EXTERN png_uint_32 png_get_gAMA_fixed PNGARG(
+    (png_const_structp png_ptr, png_const_infop info_ptr,
+    png_fixed_point *int_file_gamma));
+PNG_EXTERN void png_set_gAMA_fixed PNGARG((png_structp png_ptr,
+    png_infop info_ptr, png_fixed_point int_file_gamma));
+#endif
+
+#ifdef PNG_READ_BACKGROUND_SUPPORTED
+PNG_EXTERN void png_set_background_fixed PNGARG((png_structp png_ptr,
+    png_const_color_16p background_color, int background_gamma_code,
+    int need_expand, png_fixed_point background_gamma));
+#endif
+
+#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
+PNG_EXTERN void png_set_alpha_mode_fixed PNGARG((png_structp png_ptr,
+    int mode, png_fixed_point output_gamma));
+#endif
+
+#ifdef PNG_READ_GAMMA_SUPPORTED
+PNG_EXTERN void png_set_gamma_fixed PNGARG((png_structp png_ptr,
+    png_fixed_point screen_gamma, png_fixed_point override_file_gamma));
+#endif
+
+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
+PNG_EXTERN void png_set_rgb_to_gray_fixed PNGARG((png_structp png_ptr,
+    int error_action, png_fixed_point red, png_fixed_point green));
+#endif
+#endif /* FIX MISSING !FIXED_POINT DECLARATIONS */
+
+#ifdef PNG_FILTER_OPTIMIZATIONS
+PNG_EXTERN void PNG_FILTER_OPTIMIZATIONS(png_structp png_ptr, unsigned int bpp);
+   /* This is the initialization function for hardware specific optimizations,
+    * one implementation (for ARM NEON machines) is contained in
+    * arm/filter_neon.c.  It need not be defined - the generic code will be used
+    * if not.
+    */
+#endif
+
+/* Maintainer: Put new private prototypes here ^ */
 
 #include "pngdebug.h"
 
diff -r 7e511b8473ff media/libpng/pngread.c
--- a/media/libpng/pngread.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngread.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,7 +1,7 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.5.10 [March 8, 2012]
+ * Last changed in libpng 1.5.14 [January 24, 2013]
  * Copyright (c) 1998-2012 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
diff -r 7e511b8473ff media/libpng/pngrtran.c
--- a/media/libpng/pngrtran.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngrtran.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.5.11 [June 14, 2012]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -1221,7 +1221,7 @@
             default:
 
             case 8:
-               /* Already 8 bits, fall through */
+               /* FALL THROUGH (already 8 bits) */
 
             case 16:
                /* Already a full 16 bits */
@@ -3920,7 +3920,7 @@
                         *sp = (png_byte)png_ptr->background.gray;
 
                      else if (a < 0xff)
-                        png_composite(*sp, *sp, a, png_ptr->background_1.gray);
+                        png_composite(*sp, *sp, a, png_ptr->background.gray);
                   }
                }
             }
@@ -3989,7 +3989,7 @@
                         png_uint_16 g, v;
 
                         g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_composite_16(v, g, a, png_ptr->background_1.gray);
+                        png_composite_16(v, g, a, png_ptr->background.gray);
                         *sp = (png_byte)((v >> 8) & 0xff);
                         *(sp + 1) = (png_byte)(v & 0xff);
                      }
@@ -4746,7 +4746,9 @@
          {
             if (row_info->bit_depth == 8)
             {
-               gray = gray & 0xff;
+               /* NOTE: prior to libpng 1.5.14 this cleared out the top bits of
+                * 'gray', however if those are set it is an error.
+                */
                sp = row + (png_size_t)row_width - 1;
                dp = row + (png_size_t)(row_width << 1) - 1;
 
diff -r 7e511b8473ff media/libpng/pngrutil.c
--- a/media/libpng/pngrutil.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngrutil.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* pngrutil.c - utilities to read a PNG file
  *
- * Last changed in libpng 1.5.10 [March 8, 2012]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -2457,7 +2457,7 @@
    png_textp text_ptr;
    png_charp key, lang, text, lang_key;
    int comp_flag;
-   int comp_type = 0;
+   int comp_type;
    int ret;
    png_size_t slength, prefix_len, data_len;
 
@@ -2538,15 +2538,24 @@
       return;
    }
 
-   else
+   comp_flag = *lang++;
+   comp_type = *lang++;
+
+   /* 1.5.14: The spec says "for uncompressed text decoders shall ignore [the
+    * compression type]".  The compression flag shall be 0 (no compression) or
+    * 1 (compressed with method 0 - deflate.)
+    */
+   if (comp_flag != 0 && comp_flag != 1)
    {
-      comp_flag = *lang++;
-      comp_type = *lang++;
+      png_warning(png_ptr, "invalid iTXt compression flag");
+      png_free(png_ptr, png_ptr->chunkdata);
+      png_ptr->chunkdata = NULL;
+      return;
    }
 
-   if (comp_type || (comp_flag && comp_flag != PNG_TEXT_COMPRESSION_zTXt))
+   if (comp_flag/*compressed*/ && comp_type != 0)
    {
-      png_warning(png_ptr, "Unknown iTXt compression type or method");
+      png_warning(png_ptr, "unknown iTXt compression type");
       png_free(png_ptr, png_ptr->chunkdata);
       png_ptr->chunkdata = NULL;
       return;
@@ -2582,7 +2591,7 @@
 
    key=png_ptr->chunkdata;
 
-   if (comp_flag)
+   if (comp_flag/*compressed*/)
       png_decompress_chunk(png_ptr, comp_type,
           (size_t)length, prefix_len, &data_len);
 
@@ -2600,7 +2609,8 @@
       return;
    }
 
-   text_ptr->compression = (int)comp_flag + 1;
+   text_ptr->compression =
+      (comp_flag ? PNG_ITXT_COMPRESSION_zTXt : PNG_ITXT_COMPRESSION_NONE);
    text_ptr->lang_key = png_ptr->chunkdata + (lang_key - key);
    text_ptr->lang = png_ptr->chunkdata + (lang - key);
    text_ptr->itxt_length = data_len;
@@ -3838,66 +3848,6 @@
    }
 }
 
-#ifdef PNG_ARM_NEON
-
-#ifdef __linux__
-#include <stdio.h>
-#include <elf.h>
-#include <asm/hwcap.h>
-
-static int png_have_hwcap(unsigned cap)
-{
-   FILE *f = fopen("/proc/self/auxv", "r");
-   Elf32_auxv_t aux;
-   int have_cap = 0;
-
-   if (!f)
-      return 0;
-
-   while (fread(&aux, sizeof(aux), 1, f) > 0)
-   {
-      if (aux.a_type == AT_HWCAP &&
-          aux.a_un.a_val & cap)
-      {
-         have_cap = 1;
-         break;
-      }
-   }
-
-   fclose(f);
-
-   return have_cap;
-}
-#endif /* __linux__ */
-
-static void
-png_init_filter_functions_neon(png_structp pp, unsigned int bpp)
-{
-#ifdef __linux__
-   if (!png_have_hwcap(HWCAP_NEON))
-      return;
-#endif
-
-   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_neon;
-
-   if (bpp == 3)
-   {
-      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_neon;
-      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_neon;
-      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
-         png_read_filter_row_paeth3_neon;
-   }
-
-   else if (bpp == 4)
-   {
-      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_neon;
-      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_neon;
-      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
-          png_read_filter_row_paeth4_neon;
-   }
-}
-#endif /* PNG_ARM_NEON */
-
 static void
 png_init_filter_functions(png_structp pp)
 {
@@ -3913,8 +3863,16 @@
       pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
          png_read_filter_row_paeth_multibyte_pixel;
 
-#ifdef PNG_ARM_NEON
-   png_init_filter_functions_neon(pp, bpp);
+#ifdef PNG_FILTER_OPTIMIZATIONS
+   /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to
+    * call to install hardware optimizations for the above functions; simply
+    * replace whatever elements of the pp->read_filter[] array with a hardware
+    * specific (or, for that matter, generic) optimization.
+    *
+    * To see an example of this examine what configure.ac does when
+    * --enable-arm-neon is specified on the command line.
+    */
+   PNG_FILTER_OPTIMIZATIONS(pp, bpp);
 #endif
 }
 
diff -r 7e511b8473ff media/libpng/pngset.c
--- a/media/libpng/pngset.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngset.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.5.11 [June 14, 2012]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -695,6 +695,17 @@
    /* Make sure we have enough space in the "text" array in info_struct
     * to hold all of the incoming text_ptr objects.
     */
+
+   if (num_text < 0 ||
+       num_text > INT_MAX - info_ptr->num_text - 8 ||
+       (unsigned int)/*SAFE*/(num_text +/*SAFE*/
+       info_ptr->num_text + 8) >=
+       PNG_SIZE_MAX/png_sizeof(png_text))
+   {
+      png_warning(png_ptr, "too many text chunks");
+      return(0);
+   }
+
    if (info_ptr->num_text + num_text > info_ptr->max_text)
    {
       int old_max_text = info_ptr->max_text;
@@ -902,6 +913,12 @@
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
+   if (num_trans < 0 || num_trans > PNG_MAX_PALETTE_LENGTH)
+      {
+        png_warning(png_ptr, "Ignoring invalid num_trans value");
+        return;
+      }
+
    if (trans_alpha != NULL)
    {
        /* It may not actually be necessary to set png_ptr->trans_alpha here;
@@ -968,9 +985,18 @@
    if (png_ptr == NULL || info_ptr == NULL)
       return;
 
-   np = (png_sPLT_tp)png_malloc_warn(png_ptr,
-       (info_ptr->splt_palettes_num + nentries) *
-       (png_size_t)png_sizeof(png_sPLT_t));
+   if (nentries < 0 ||
+       nentries > INT_MAX-info_ptr->splt_palettes_num ||
+       (unsigned int)/*SAFE*/(nentries +/*SAFE*/
+       info_ptr->splt_palettes_num) >=
+       PNG_SIZE_MAX/png_sizeof(png_sPLT_t))
+      np=NULL;
+
+   else
+
+      np = (png_sPLT_tp)png_malloc_warn(png_ptr,
+          (info_ptr->splt_palettes_num + nentries) *
+          (png_size_t)png_sizeof(png_sPLT_t));
 
    if (np == NULL)
    {
@@ -1179,9 +1205,17 @@
    if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
       return;
 
-   np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
-       (png_size_t)(info_ptr->unknown_chunks_num + num_unknowns) *
-       png_sizeof(png_unknown_chunk));
+   if (num_unknowns < 0 ||
+       num_unknowns > INT_MAX-info_ptr->unknown_chunks_num ||
+       (unsigned int)/*SAFE*/(num_unknowns +/*SAFE*/
+       info_ptr->unknown_chunks_num) >=
+       PNG_SIZE_MAX/png_sizeof(png_unknown_chunk))
+      np=NULL;
+
+   else
+      np = (png_unknown_chunkp)png_malloc_warn(png_ptr,
+          (png_size_t)(info_ptr->unknown_chunks_num + num_unknowns) *
+          png_sizeof(png_unknown_chunk));
 
    if (np == NULL)
    {
diff -r 7e511b8473ff media/libpng/pngwrite.c
--- a/media/libpng/pngwrite.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngwrite.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.5.11 [June 14, 2012]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -314,7 +314,6 @@
       png_benign_error(png_ptr, "Wrote palette index exceeding num_palette");
 #endif
 
-    /* See if user wants us to write information chunks */
 #ifdef PNG_WRITE_APNG_SUPPORTED
    if (png_ptr->num_frames_written != png_ptr->num_frames_to_write)
       png_error(png_ptr, "Not enough frames written");
@@ -430,7 +429,6 @@
 }
 
 #ifdef PNG_CONVERT_tIME_SUPPORTED
-/* "tm" structure is not supported on WindowsCE */
 void PNGAPI
 png_convert_from_struct_tm(png_timep ptime, PNG_CONST struct tm FAR * ttime)
 {
@@ -1052,6 +1050,7 @@
          case 5:
          case 6:
          case 7: png_warning(png_ptr, "Unknown row filter for method 0");
+             /* FALL THROUGH */
 #endif /* PNG_WRITE_FILTER_SUPPORTED */
          case PNG_FILTER_VALUE_NONE:
             png_ptr->do_filter = PNG_FILTER_NONE; break;
diff -r 7e511b8473ff media/libpng/pngwutil.c
--- a/media/libpng/pngwutil.c	Fri Jan 25 13:40:38 2013 -0500
+++ b/media/libpng/pngwutil.c	Tue Jan 29 22:34:41 2013 +0900
@@ -1,8 +1,8 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.5.10 [March 8, 2012]
- * Copyright (c) 1998-2012 Glenn Randers-Pehrson
+ * Last changed in libpng 1.5.14 [January 24, 2013]
+ * Copyright (c) 1998-2013 Glenn Randers-Pehrson
  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
  *
@@ -460,24 +460,21 @@
                old_ptr = comp->output_ptr;
 
                comp->output_ptr = (png_bytepp)png_malloc(png_ptr,
-                   (png_alloc_size_t)
-                   (comp->max_output_ptr * png_sizeof(png_charpp)));
+                   (comp->max_output_ptr * png_sizeof(png_bytep)));
 
                png_memcpy(comp->output_ptr, old_ptr, old_max
-                   * png_sizeof(png_charp));
+                   * png_sizeof(png_bytep));
 
                png_free(png_ptr, old_ptr);
             }
             else
                comp->output_ptr = (png_bytepp)png_malloc(png_ptr,
-                   (png_alloc_size_t)
-                   (comp->max_output_ptr * png_sizeof(png_charp)));
+                   (comp->max_output_ptr * png_sizeof(png_bytep)));
          }
 
          /* Save the data */
          comp->output_ptr[comp->num_output_ptr] =
-             (png_bytep)png_malloc(png_ptr,
-             (png_alloc_size_t)png_ptr->zbuf_size);
+             (png_bytep)png_malloc(png_ptr, png_ptr->zbuf_size);
 
          png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
              png_ptr->zbuf_size);
@@ -1049,7 +1046,7 @@
    {
       png_byte buf[4];
 
-      png_write_chunk_header(png_ptr, png_fdAT, 4 + length);
+      png_write_chunk_header(png_ptr, png_fdAT, (png_uint_32)(4 + length));
 
       png_save_uint_32(buf, png_ptr->next_seq_num);
       png_write_chunk_data(png_ptr, buf, 4);
