# HG changeset patch
# Parent 17a7e2d5950573c5b3ed86a7245f6ff03ab36db0
# User hua.andy <hua.andy@gmail.com>
"Certain valid WebGL drawing"


diff --git a/content/canvas/src/WebGLElementArrayCache.cpp b/content/canvas/src/WebGLElementArrayCache.cpp
--- a/content/canvas/src/WebGLElementArrayCache.cpp
+++ b/content/canvas/src/WebGLElementArrayCache.cpp
@@ -5,16 +5,17 @@
 
 #include "WebGLElementArrayCache.h"
 
 #include "nsTArray.h"
 #include "mozilla/Assertions.h"
 
 #include <cstdlib>
 #include <cstring>
+#include <limits>
 
 namespace mozilla {
 
 /*
  * WebGLElementArrayCacheTree contains most of the implementation of WebGLElementArrayCache,
  * which performs WebGL element array buffer validation for drawElements.
  *
  * Attention: Here lie nontrivial data structures, bug-prone algorithms, and non-canonical tweaks!
@@ -465,70 +466,80 @@ void WebGLElementArrayCache::InvalidateT
 {
   if (mUint8Tree)
     mUint8Tree->Invalidate(firstByte, lastByte);
   if (mUint16Tree)
     mUint16Tree->Invalidate(firstByte, lastByte);
 }
 
 template<typename T>
-bool WebGLElementArrayCache::Validate(T maxAllowed, size_t firstElement, size_t countElements) {
+bool WebGLElementArrayCache::Validate(uint32_t maxAllowed, size_t firstElement, size_t countElements) {
+  // if maxAllowed is >= the max T value, then there is no way that a T index could be invalid
+  if (maxAllowed >= std::numeric_limits<T>::max())
+    return true;
+
+  T maxAllowedT(maxAllowed);
+
+  // integer overflow must have been handled earlier, so we assert that maxAllowedT
+  // is exactly the max allowed value.
+  MOZ_ASSERT(uint32_t(maxAllowedT) == maxAllowed);
+
   if (!mByteSize || !countElements)
     return true;
 
   WebGLElementArrayCacheTree<T>*& tree = TreeForType<T>::Run(this);
   if (!tree) {
     tree = new WebGLElementArrayCacheTree<T>(*this);
   }
 
   size_t lastElement = firstElement + countElements - 1;
 
   tree->Update();
 
   // fast exit path when the global maximum for the whole element array buffer
   // falls in the allowed range
-  if (tree->GlobalMaximum() <= maxAllowed)
+  if (tree->GlobalMaximum() <= maxAllowedT)
   {
     return true;
   }
 
   const T* elements = Elements<T>();
 
   // before calling tree->Validate, we have to validate ourselves the boundaries of the elements span,
   // to round them to the nearest multiple of sElementsPerLeaf.
   size_t firstElementAdjustmentEnd = NS_MIN(lastElement,
                                             tree->LastElementUnderSameLeaf(firstElement));
   while (firstElement <= firstElementAdjustmentEnd) {
-    if (elements[firstElement] > maxAllowed)
+    if (elements[firstElement] > maxAllowedT)
       return false;
     firstElement++;
   }
   size_t lastElementAdjustmentEnd = NS_MAX(firstElement,
                                            tree->FirstElementUnderSameLeaf(lastElement));
   while (lastElement >= lastElementAdjustmentEnd) {
-    if (elements[lastElement] > maxAllowed)
+    if (elements[lastElement] > maxAllowedT)
       return false;
     lastElement--;
   }
 
   // at this point, for many tiny validations, we're already done.
   if (firstElement > lastElement)
     return true;
 
   // general case
-  return tree->Validate(maxAllowed,
+  return tree->Validate(maxAllowedT,
                         tree->LeafForElement(firstElement),
                         tree->LeafForElement(lastElement));
 }
 
 bool WebGLElementArrayCache::Validate(GLenum type, uint32_t maxAllowed, size_t firstElement, size_t countElements) {
   if (type == LOCAL_GL_UNSIGNED_BYTE)
-    return Validate<uint8_t>(uint8_t(maxAllowed), firstElement, countElements);
+    return Validate<uint8_t>(maxAllowed, firstElement, countElements);
   if (type == LOCAL_GL_UNSIGNED_SHORT)
-    return Validate<uint16_t>(uint16_t(maxAllowed), firstElement, countElements);
+    return Validate<uint16_t>(maxAllowed, firstElement, countElements);
   return false;
 }
 
 size_t WebGLElementArrayCache::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const {
   size_t uint8TreeSize  = mUint8Tree  ? mUint8Tree->SizeOfIncludingThis(aMallocSizeOf) : 0;
   size_t uint16TreeSize = mUint16Tree ? mUint16Tree->SizeOfIncludingThis(aMallocSizeOf) : 0;
   return aMallocSizeOf(this) +
           mByteSize +
diff --git a/content/canvas/src/WebGLElementArrayCache.h b/content/canvas/src/WebGLElementArrayCache.h
--- a/content/canvas/src/WebGLElementArrayCache.h
+++ b/content/canvas/src/WebGLElementArrayCache.h
@@ -46,17 +46,17 @@ public:
 
   ~WebGLElementArrayCache();
 
   size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const;
 
 private:
 
   template<typename T>
-  bool Validate(T maxAllowed, size_t first, size_t count);
+  bool Validate(uint32_t maxAllowed, size_t first, size_t count);
 
   size_t ByteSize() const {
     return mByteSize;
   }
 
   template<typename T>
   const T* Elements() const { return static_cast<const T*>(mUntypedData); }
   template<typename T>
diff --git a/content/canvas/test/compiled/TestWebGLElementArrayCache.cpp b/content/canvas/test/compiled/TestWebGLElementArrayCache.cpp
--- a/content/canvas/test/compiled/TestWebGLElementArrayCache.cpp
+++ b/content/canvas/test/compiled/TestWebGLElementArrayCache.cpp
@@ -113,16 +113,23 @@ void CheckSanity()
     data[i] = numElems - i;
   c.BufferData(data, numBytes);
   VERIFY( c.Validate(type, numElems,     0, numElems));
   VERIFY(!c.Validate(type, numElems - 1, 0, numElems));
 
   MOZ_ASSERT(numElems > 10);
   VERIFY( c.Validate(type, numElems - 10, 10, numElems - 10));
   VERIFY(!c.Validate(type, numElems - 11, 10, numElems - 10));
+
+  // bug 825205
+  if (sizeof(T) < sizeof(uint32_t)) {
+    uint32_t bigValWrappingToZero = uint32_t(T(-1)) + 1;
+    VERIFY(c.Validate(type, bigValWrappingToZero,     0, numElems));
+    VERIFY(c.Validate(type, bigValWrappingToZero - 1, 0, numElems));
+  }
 }
 
 int main(int argc, char *argv[])
 {
   srand(0); // do not want a random seed here.
 
   CheckSanity<uint8_t>();
   CheckSanity<uint16_t>();
